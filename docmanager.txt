=== DocumentManager/Controllers/SignatureController.php ===
<?php

namespace DocumentManager\Controllers;

use DocumentManager\Services\SignatureService;
use App\Services\Validator;
use Psr\Log\LoggerInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

/**
 * Signature Controller
 *
 * Handles the management of user signatures, including uploading,
 * verifying, and retrieving signatures for documents.
 */
class SignatureController
{
    private SignatureService $signatureService;
    private Validator $validator;
    private LoggerInterface $logger;

    public function __construct(
        SignatureService $signatureService,
        Validator $validator,
        LoggerInterface $logger
    ) {
        $this->signatureService = $signatureService;
        $this->validator = $validator;
        $this->logger = $logger;
    }

    /**
     * Upload a signature.
     *
     * @param array $data The uploaded signature file and associated metadata.
     * @return array Response indicating success or failure.
     */
    public function uploadSignature(array $data): array
    {
        $rules = [
            'user_id' => 'required|integer',
            'file' => 'required|file|mimes:png,jpg,jpeg|max:2048', // Max 2MB
        ];

        if (!$this->validator->validate($data, $rules)) {
            $this->logger->warning('Signature validation failed', ['data' => $data]);
            return ['status' => 'error', 'message' => 'Validation failed', 'errors' => $this->validator->errors()];
        }

        try {
            $signaturePath = $this->signatureService->uploadSignature($data['user_id'], $data['file']);
            $this->logger->info('Signature uploaded successfully', ['user_id' => $data['user_id']]);

            return ['status' => 'success', 'message' => 'Signature uploaded successfully', 'signature_path' => $signaturePath];
        } catch (\Exception $e) {
            $this->logger->error('Failed to upload signature', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to upload signature'];
        }
    }

    /**
     * Verify a signature.
     *
     * @param int $userId The ID of the user whose signature is to be verified.
     * @param string $documentHash The hash of the document to verify against the signature.
     * @return array Verification result.
     */
    public function verifySignature(int $userId, string $documentHash): array
    {
        try {
            $isValid = $this->signatureService->verifySignature($userId, $documentHash);

            if ($isValid) {
                $this->logger->info('Signature verified successfully', ['user_id' => $userId]);
                return ['status' => 'success', 'message' => 'Signature verified successfully'];
            }

            return ['status' => 'error', 'message' => 'Signature verification failed'];
        } catch (\Exception $e) {
            $this->logger->error('Failed to verify signature', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to verify signature'];
        }
    }

    /**
     * Retrieve a user's signature.
     *
     * @param int $userId The ID of the user.
     * @return array Response containing the signature path or error message.
     */
    public function getSignature(int $userId): array
    {
        try {
            $signaturePath = $this->signatureService->getSignature($userId);

            if ($signaturePath) {
                $this->logger->info('Signature retrieved successfully', ['user_id' => $userId]);
                return ['status' => 'success', 'signature_path' => $signaturePath];
            }

            return ['status' => 'error', 'message' => 'Signature not found'];
        } catch (\Exception $e) {
            $this->logger->error('Failed to retrieve signature', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to retrieve signature'];
        }
    }
}
=== DocumentManager/Controllers/DocumentController.php ===
<?php

namespace DocumentManager\Controllers;

use DocumentManager\Services\DocumentService;
use App\Services\EncryptionService;
use DocumentManager\Services\FileStorage;
use App\Services\Validator;
use AuditManager\Services\AuditService;
use Psr\Log\LoggerInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

class DocumentController
{
    private DocumentService $documentService;
    private Validator $validator;
    private AuditService $auditService;
    private LoggerInterface $logger;

    public function __construct(
        DocumentService $documentService,
        Validator $validator,
        AuditService $auditService,
        LoggerInterface $logger
    ) {
        $this->documentService = $documentService;
        $this->validator = $validator;
        $this->auditService = $auditService;
        $this->logger = $logger;
    }
    
    /**
     * Upload a document template.
     */
    public function uploadTemplate(array $data): array
    {
        $rules = [
            'name' => 'required|string|max:255',
            'file' => 'required|file|mimes:pdf,docx|max:10240', // Max 10MB
        ];

        if (!$this->validator->validate($data, $rules)) {
            return ['status' => 'error', 'message' => 'Validation failed', 'errors' => $this->validator->errors()];
        }

        try {
            $templateId = $this->documentService->uploadTemplate($data['name'], $data['file']);
            $this->auditService->log(
                'template_uploaded',
                'Template uploaded successfully.',
                null,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            return ['status' => 'success', 'message' => 'Template uploaded successfully', 'template_id' => $templateId];
        } catch (\Exception $e) {
            $this->logger->error('Failed to upload template', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to upload template'];
        }
    }

    /**
     * Generate a contract for a booking.
     */
    public function generateContract(int $bookingId, int $userId): array
    {
        try {
            $contractPath = $this->documentService->generateContract($bookingId, $userId);
            $this->auditService->log(
                'contract_generated',
                'Contract generated successfully.',
                $userId,
                $bookingId,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            return ['status' => 'success', 'message' => 'Contract generated successfully', 'contract_path' => $contractPath];
        } catch (\Exception $e) {
            $this->logger->error('Failed to generate contract', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to generate contract'];
        }
    }

    /**
     * Upload and manage the Terms & Conditions document.
     */
    public function uploadTerms(array $data): array
    {
        $rules = [
            'file' => 'required|file|mimes:pdf|max:5120', // Max 5MB
        ];

        if (!$this->validator->validate($data, $rules)) {
            return ['status' => 'error', 'message' => 'Validation failed', 'errors' => $this->validator->errors()];
        }

        try {
            $path = $this->documentService->uploadTerms($data['file']);
            $this->auditService->log(
                'terms_uploaded',
                'Terms and Conditions document uploaded.',
                null,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            return ['status' => 'success', 'message' => 'T&C document uploaded successfully'];
        } catch (\Exception $e) {
            $this->logger->error('Failed to upload T&C document', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to upload T&C document'];
        }
    }

    /**
     * Generate an invoice for a booking.
     */
    public function generateInvoice(int $bookingId): array
    {
        try {
            $invoicePath = $this->documentService->generateInvoice($bookingId);
            $this->auditService->log(
                'invoice_generated',
                'Invoice generated successfully.',
                null,
                $bookingId,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            return ['status' => 'success', 'message' => 'Invoice generated successfully', 'invoice_path' => $invoicePath];
        } catch (\Exception $e) {
            $this->logger->error('Failed to generate invoice', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to generate invoice'];
        }
    }

    /**
     * Delete a document (template or user-specific).
     */
    public function deleteDocument(int $documentId): array
    {
        try {
            $this->documentService->deleteDocument($documentId);
            $this->auditService->log(
                'document_deleted',
                'Document deleted successfully.',
                null,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            return ['status' => 'success', 'message' => 'Document deleted successfully'];
        } catch (\Exception $e) {
            $this->logger->error('Failed to delete document', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to delete document'];
        }
    }
}
=== DocumentManager/Views/signing_page.php ===
=== DocumentManager/Views/user_documents.php ===
=== DocumentManager/Views/admin_documents.php ===
=== DocumentManager/Models/Document.php ===
<?php

namespace DocumentManager\Models;

use PDO;
use Exception;

/**
 * Document Model
 *
 * Represents documents stored in the system and provides methods
 * for managing and querying them.
 */
class Document
{
    private PDO $db;

    public function __construct(PDO $db)
    {
        $this->db = $db;
    }

    /**
     * Create a new document record.
     *
     * @param string $name The name of the document.
     * @param string $filePath The file path of the stored document.
     * @param int|null $userId The ID of the user associated with the document (if applicable).
     * @param string|null $type The type of document (e.g., 'contract', 'terms').
     * @return int The ID of the newly created document.
     * @throws Exception If the document creation fails.
     */
    public function create(string $name, string $filePath, ?int $userId = null, ?string $type = null): int
    {
        $query = "
            INSERT INTO documents (name, file_path, user_id, type, created_at)
            VALUES (:name, :file_path, :user_id, :type, NOW())
        ";

        $stmt = $this->db->prepare($query);

        if (!$stmt->execute([
            ':name' => $name,
            ':file_path' => $filePath,
            ':user_id' => $userId,
            ':type' => $type,
        ])) {
            throw new Exception('Failed to create document.');
        }

        return (int)$this->db->lastInsertId();
    }

    /**
     * Retrieve a document by its ID.
     *
     * @param int $id The ID of the document.
     * @return array|null The document record or null if not found.
     */
    public function getById(int $id): ?array
    {
        $query = "SELECT * FROM documents WHERE id = :id";
        $stmt = $this->db->prepare($query);
        $stmt->execute([':id' => $id]);

        $document = $stmt->fetch(PDO::FETCH_ASSOC);
        return $document ?: null;
    }

    /**
     * Retrieve documents associated with a user.
     *
     * @param int $userId The ID of the user.
     * @return array A list of documents associated with the user.
     */
    public function getByUserId(int $userId): array
    {
        $query = "SELECT * FROM documents WHERE user_id = :user_id ORDER BY created_at DESC";
        $stmt = $this->db->prepare($query);
        $stmt->execute([':user_id' => $userId]);

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Retrieve documents by type.
     *
     * @param string $type The type of document (e.g., 'contract', 'terms').
     * @return array A list of documents matching the specified type.
     */
    public function getByType(string $type): array
    {
        $query = "SELECT * FROM documents WHERE type = :type ORDER BY created_at DESC";
        $stmt = $this->db->prepare($query);
        $stmt->execute([':type' => $type]);

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Delete a document by its ID.
     *
     * @param int $id The ID of the document to delete.
     * @return bool True on success, false otherwise.
     */
    public function deleteById(int $id): bool
    {
        $query = "DELETE FROM documents WHERE id = :id";
        $stmt = $this->db->prepare($query);

        return $stmt->execute([':id' => $id]);
    }
}
=== DocumentManager/Models/DocumentTemplate.php ===
<?php

namespace DocumentManager\Models;

use PDO;
use Exception;

/**
 * DocumentTemplate Model
 *
 * Manages templates for documents such as contracts, invoices, and Terms & Conditions.
 */
class DocumentTemplate
{
    private PDO $db;

    public function __construct(PDO $db)
    {
        $this->db = $db;
    }

    /**
     * Create a new document template.
     *
     * @param string $name The name of the template.
     * @param string $filePath The file path of the template.
     * @return int The ID of the newly created template.
     * @throws Exception If the template creation fails.
     */
    public function create(string $name, string $filePath): int
    {
        $query = "
            INSERT INTO document_templates (name, file_path, created_at)
            VALUES (:name, :file_path, NOW())
        ";

        $stmt = $this->db->prepare($query);

        if (!$stmt->execute([
            ':name' => $name,
            ':file_path' => $filePath,
        ])) {
            throw new Exception('Failed to create document template.');
        }

        return (int)$this->db->lastInsertId();
    }

    /**
     * Retrieve a template by its ID.
     *
     * @param int $id The ID of the template.
     * @return array|null The template record or null if not found.
     */
    public function getById(int $id): ?array
    {
        $query = "SELECT * FROM document_templates WHERE id = :id";
        $stmt = $this->db->prepare($query);
        $stmt->execute([':id' => $id]);

        $template = $stmt->fetch(PDO::FETCH_ASSOC);
        return $template ?: null;
    }

    /**
     * Retrieve a template by its name.
     *
     * @param string $name The name of the template.
     * @return array|null The template record or null if not found.
     */
    public function getByName(string $name): ?array
    {
        $query = "SELECT * FROM document_templates WHERE name = :name";
        $stmt = $this->db->prepare($query);
        $stmt->execute([':name' => $name]);

        $template = $stmt->fetch(PDO::FETCH_ASSOC);
        return $template ?: null;
    }

    /**
     * Retrieve all templates.
     *
     * @return array A list of all document templates.
     */
    public function getAll(): array
    {
        $query = "SELECT * FROM document_templates ORDER BY created_at DESC";
        $stmt = $this->db->query($query);

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Delete a template by its ID.
     *
     * @param int $id The ID of the template to delete.
     * @return bool True on success, false otherwise.
     */
    public function deleteById(int $id): bool
    {
        $query = "DELETE FROM document_templates WHERE id = :id";
        $stmt = $this->db->prepare($query);

        return $stmt->execute([':id' => $id]);
    }
}
=== DocumentManager/Models/AuditTrail.php ===
<?php

namespace AuditManager\Models;

use PDO;

/**
 * AuditTrail Model
 *
 * Represents the audit trails stored in the database and provides methods
 * for accessing and filtering the logs.
 */
class AuditTrail
{
    private PDO $db;

    public function __construct(PDO $db)
    {
        $this->db = $db;
    }

    /**
     * Create a new audit trail record.
     *
     * @param string $action The action performed (e.g., 'user_registered').
     * @param string $details Additional details about the action.
     * @param int|null $userId The ID of the user performing the action.
     * @param int|null $bookingId The ID of the related booking (if applicable).
     * @param string|null $ipAddress The IP address of the user.
     * @return bool True on success, false otherwise.
     */
    public function create(
        string $action,
        string $details,
        ?int $userId = null,
        ?int $bookingId = null,
        ?string $ipAddress = null
    ): bool {
        $query = "
            INSERT INTO audit_trails (action, details, user_id, booking_id, ip_address, created_at)
            VALUES (:action, :details, :user_id, :booking_id, :ip_address, NOW())
        ";

        $stmt = $this->db->prepare($query);

        return $stmt->execute([
            ':action' => $action,
            ':details' => $details,
            ':user_id' => $userId,
            ':booking_id' => $bookingId,
            ':ip_address' => $ipAddress,
        ]);
    }

    /**
     * Retrieve audit trail records based on filters.
     *
     * @param array $filters An associative array of filters:
     *                       - 'user_id' (int): Filter by user ID.
     *                       - 'booking_id' (int): Filter by booking ID.
     *                       - 'action' (string): Filter by action type.
     *                       - 'start_date' (string): Filter by start date (YYYY-MM-DD).
     *                       - 'end_date' (string): Filter by end date (YYYY-MM-DD).
     * @return array An array of matching audit trail records.
     */
    public function getLogs(array $filters = []): array
    {
        $query = "SELECT * FROM audit_trails WHERE 1=1";
        $params = [];

        if (!empty($filters['user_id'])) {
            $query .= " AND user_id = :user_id";
            $params[':user_id'] = $filters['user_id'];
        }

        if (!empty($filters['booking_id'])) {
            $query .= " AND booking_id = :booking_id";
            $params[':booking_id'] = $filters['booking_id'];
        }

        if (!empty($filters['action'])) {
            $query .= " AND action = :action";
            $params[':action'] = $filters['action'];
        }

        if (!empty($filters['start_date'])) {
            $query .= " AND created_at >= :start_date";
            $params[':start_date'] = $filters['start_date'];
        }

        if (!empty($filters['end_date'])) {
            $query .= " AND created_at <= :end_date";
            $params[':end_date'] = $filters['end_date'];
        }

        $query .= " ORDER BY created_at DESC";

        $stmt = $this->db->prepare($query);
        $stmt->execute($params);

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Delete an audit trail record by ID.
     *
     * @param int $id The ID of the audit trail record to delete.
     * @return bool True on success, false otherwise.
     */
    public function deleteById(int $id): bool
    {
        $query = "DELETE FROM audit_trails WHERE id = :id";
        $stmt = $this->db->prepare($query);

        return $stmt->execute([':id' => $id]);
    }
}
=== DocumentManager/config/filestorage.php ===
<?php
/**
 * File: filestorage.php
 * Purpose: Configuration file for the FileStorage service in DocumentManager.
 * Path: DocumentManager/config/filestorage.php
 *
 * Changelog:
 * - [2025-01-28] Initial creation of the file.
 */

return [
    // General file storage settings
    'base_directory' => __DIR__ . '/../Storage', // Base directory for storing files

    // Storage structure
    'directories' => [
        'templates' => 'Templates', // Directory for storing document templates
        'users' => 'Users', // Directory for user-specific documents
        'logs' => '../logs', // Directory for storing logs (relative to base)
    ],

    // File security settings
    'security' => [
        'allowed_extensions' => ['pdf', 'docx', 'html'], // Allowed file extensions
        'max_file_size' => 10 * 1024 * 1024, // Max file size (10 MB in bytes)
        'encryption' => [
            'enabled' => true, // Enable encryption for stored files
        ],
        'permissions' => [
            'default' => 0640, // Default file permissions (read/write for owner, read for group)
        ],
    ],

    // Temporary storage settings
    'temporary' => [
        'enabled' => true, // Enable temporary storage
        'directory' => __DIR__ . '/../Storage/Temp', // Temp directory path
        'cleanup_interval' => 86400, // Time in seconds to clean up old temp files (24 hours)
    ],

    // Error handling and logging
    'error_handling' => [
        'log_errors' => true, // Log errors related to file storage
        'log_file' => __DIR__ . '/../logs/filestorage.log', // Log file for file storage errors
    ],
];
=== DocumentManager/config/encryption.php ===
<?php

return [
    'encryption_key' => 'your-secure-encryption-key', // Replace with a secure, randomly generated key
    'cipher' => 'AES-256-CBC',                       // Encryption cipher
    'iv_length' => 16,                               // Initialization vector length
];
=== DocumentManager/config/database.php ===
<?php
return [
    'host' => 'carfuse.pl',
        'port' => 3306,
        'database' => 'u122931475_secure',
        'username' => 'u122931475_admin',
        'password' => 'Japierdole1876',
        'charset' => 'utf8mb4',
];
=== DocumentManager/config/signature.php ===
return [
    'api_endpoint' => 'https://api.signatureprovider.com',
    'api_key' => 'your-api-key',
];
=== DocumentManager/config/documents.php ===
<?php
/**
 * File: config/documents.php
 * Purpose: Configuration for the Document Management System.
 */

return [
    // Storage Paths
    'storage' => [
        'user_documents' => __DIR__ . '/../../storage/documents/users/', // Path for user-specific documents
        'templates' => __DIR__ . '/../../storage/documents/templates/', // Path for document templates
        'terms_and_conditions' => __DIR__ . '/../../storage/documents/terms/', // Path for T&C documents
    ],

    // Encryption Settings
    'encryption' => [
        'aes_key' => getenv('DOCUMENT_AES_KEY') ?: 'default_secure_key', // AES Encryption Key
    ],

    // Document Types
    'allowed_types' => ['pdf', 'docx'], // Allowed document file types

    // Naming Conventions
    'naming' => [
        'contract_format' => 'contract_booking_{booking_id}_{timestamp}.pdf', // Format for contract names
        'invoice_format' => 'invoice_booking_{booking_id}_{timestamp}.pdf',  // Format for invoice names
    ],

    // Retention Policy
    'retention_policy' => [
        'contracts' => '10 years', // Retention period for contracts
        'invoices' => '7 years',   // Retention period for invoices
    ],
];
=== DocumentManager/Services/TemplateService.php ===
<?php

namespace DocumentManager\Services;

use Exception;

/**
 * Template Service
 *
 * Provides functionality for managing and rendering document templates.
 * Templates support placeholders for dynamic data injection.
 */
class TemplateService
{
    private string $templateDirectory;

    /**
     * Constructor
     *
     * @param string $templateDirectory The directory where templates are stored.
     * @throws Exception If the directory is invalid or not readable.
     */
    public function __construct(string $templateDirectory)
    {
        if (!is_dir($templateDirectory) || !is_readable($templateDirectory)) {
            throw new \InvalidArgumentException("Invalid template directory: $templateDirectory");
        }

        $this->templateDirectory = rtrim($templateDirectory, DIRECTORY_SEPARATOR);
    }

    /**
     * List all available templates in the directory.
     *
     * @return array List of template filenames with '.html' extension.
     */
    public function listTemplates(): array
    {
        $files = scandir($this->templateDirectory);
        return array_values(array_filter($files, fn($file) => pathinfo($file, PATHINFO_EXTENSION) === 'html'));
    }

    /**
     * Load the content of a template.
     *
     * @param string $templateName The name of the template file.
     * @return string The template content.
     * @throws Exception If the template cannot be found or read.
     */
    public function loadTemplate(string $templateName): string
    {
        $filePath = $this->getTemplatePath($templateName);

        if (!file_exists($filePath) || !is_readable($filePath)) {
            throw new Exception("Template not found or unreadable: $templateName");
        }

        return file_get_contents($filePath);
    }

    /**
     * Render a template by replacing placeholders with data.
     *
     * @param string $templateName The name of the template file.
     * @param array $data Key-value pairs to replace placeholders.
     * @return string Rendered template with placeholders replaced.
     * @throws Exception If the template cannot be loaded.
     */
    public function renderTemplate(string $templateName, array $data): string
    {
        $template = $this->loadTemplate($templateName);

        foreach ($data as $key => $value) {
            $placeholder = '{{' . $key . '}}';
            $template = str_replace($placeholder, htmlspecialchars((string)$value, ENT_QUOTES, 'UTF-8'), $template);
        }

        return $template;
    }

    /**
     * Save a new or updated template file.
     *
     * @param string $templateName The name of the template file.
     * @param string $content The template content to save.
     * @return bool True if saved successfully, false otherwise.
     * @throws Exception If saving fails.
     */
    public function saveTemplate(string $templateName, string $content): bool
    {
        $filePath = $this->getTemplatePath($templateName);

        if (file_put_contents($filePath, $content) === false) {
            throw new Exception("Failed to save template: $templateName");
        }

        return true;
    }

    /**
     * Delete a template file.
     *
     * @param string $templateName The name of the template file to delete.
     * @return bool True if deleted successfully, false otherwise.
     * @throws Exception If the template cannot be found or deleted.
     */
    public function deleteTemplate(string $templateName): bool
    {
        $filePath = $this->getTemplatePath($templateName);

        if (!file_exists($filePath)) {
            throw new Exception("Template not found: $templateName");
        }

        if (!unlink($filePath)) {
            throw new Exception("Failed to delete template: $templateName");
        }

        return true;
    }

    /**
     * Validate and sanitize template filename.
     *
     * @param string $templateName The name of the template file.
     * @return string Sanitized template file path.
     */
    private function getTemplatePath(string $templateName): string
    {
        $sanitizedFileName = preg_replace('/[^a-zA-Z0-9_\.-]/', '_', $templateName);

        if (pathinfo($sanitizedFileName, PATHINFO_EXTENSION) !== 'html') {
            $sanitizedFileName .= '.html';
        }

        return $this->templateDirectory . DIRECTORY_SEPARATOR . $sanitizedFileName;
    }
}
=== DocumentManager/Services/DocumentService.php ===
<?php

namespace DocumentManager\Services;

use PDO;
use Exception;
use AuditManager\Services\AuditService;
use DocumentManager\Services\FileStorage;
use DocumentManager\Services\TemplateService;
use App\Services\EncryptionService;
use Psr\Log\LoggerInterface;

/**
 * Document Service
 *
 * Manages documents including templates, contracts, and Terms & Conditions (T&C).
 * Supports encryption, secure storage, logging, and dynamic document generation.
 */
class DocumentService
{
    private PDO $db;
    private AuditService $auditService;
    private FileStorage $fileStorage;
    private EncryptionService $encryptionService;
    private TemplateService $templateService;
    private LoggerInterface $logger;

    public function __construct(
        PDO $db,
        AuditService $auditService,
        FileStorage $fileStorage,
        EncryptionService $encryptionService,
        TemplateService $templateService,
        LoggerInterface $logger
    ) {
        $this->db = $db;
        $this->auditService = $auditService;
        $this->fileStorage = $fileStorage;
        $this->encryptionService = $encryptionService;
        $this->templateService = $templateService;
        $this->logger = $logger;
    }

    /**
     * Upload a document template.
     */
    public function uploadTemplate(string $name, string $content): void
    {
        $this->processTemplate($name, $content, 'template_uploaded');
    }

    /**
     * Upload the Terms & Conditions document.
     */
    public function uploadTerms(string $content): void
    {
        $this->processTemplate('terms_and_conditions', $content, 'terms_uploaded');
    }

    /**
     * Process template storage and logging.
     */
    private function processTemplate(string $name, string $content, string $logAction): void
    {
        try {
            $this->logger->info("Uploading template: {$name}");
            $encryptedContent = $this->encryptionService->encrypt($content);
            $this->templateService->saveTemplate("{$name}.html", $encryptedContent);
            $this->auditService->log($logAction, ['name' => $name]);
        } catch (Exception $e) {
            $this->handleException("Failed to upload template: {$name}", $e);
        }
    }

    /**
     * Generate a rental contract document dynamically.
     */
    public function generateContract(int $bookingId, int $userId): string
    {
        try {
            $this->logger->info("Generating contract", ['bookingId' => $bookingId, 'userId' => $userId]);

            $templateContent = $this->templateService->loadTemplate('rental_contract.html');
            $data = array_merge($this->fetchUserData($userId), $this->fetchBookingData($bookingId));
            $renderedContent = $this->templateService->renderTemplate('rental_contract.html', $data);

            $encryptedContract = $this->encryptionService->encrypt($renderedContent);
            $filePath = $this->fileStorage->storeFile("contracts", "contract_{$bookingId}.pdf", $encryptedContract);

            $this->db->prepare("
                INSERT INTO contracts (booking_id, user_id, contract_pdf, created_at) 
                VALUES (:booking_id, :user_id, :contract_pdf, NOW())
            ")->execute(['booking_id' => $bookingId, 'user_id' => $userId, 'contract_pdf' => $filePath]);

            $this->auditService->log('contract_generated', ['booking_id' => $bookingId, 'user_id' => $userId]);

            return $filePath;
        } catch (Exception $e) {
            $this->handleException("Failed to generate contract", $e);
        }
    }

    /**
     * Retrieve and decrypt a document.
     */
    public function retrieveDocument(string $filePath): string
    {
        try {
            $this->logger->info("Retrieving document", ['filePath' => $filePath]);

            $encryptedContent = $this->fileStorage->retrieveFile($filePath);
            $decryptedContent = $this->encryptionService->decrypt($encryptedContent);

            $this->auditService->log('document_retrieved', ['file_path' => $filePath]);

            return $decryptedContent;
        } catch (Exception $e) {
            $this->handleException("Failed to retrieve document", $e);
        }
    }

    /**
     * Delete a document.
     */
    public function deleteDocument(int $documentId): void
    {
        try {
            $this->logger->info("Deleting document", ['documentId' => $documentId]);

            $stmt = $this->db->prepare("SELECT file_path FROM documents WHERE id = :document_id");
            $stmt->execute(['document_id' => $documentId]);
            $document = $stmt->fetch(PDO::FETCH_ASSOC);

            if (!$document) {
                throw new Exception("Document not found.");
            }

            $this->fileStorage->deleteFile($document['file_path']);
            $this->db->prepare("DELETE FROM documents WHERE id = :document_id")
                ->execute(['document_id' => $documentId]);

            $this->auditService->log('document_deleted', ['document_id' => $documentId]);
        } catch (Exception $e) {
            $this->handleException("Failed to delete document", $e);
        }
    }

    /**
     * Fetch user data.
     */
    private function fetchUserData(int $userId): array
    {
        return $this->fetchRecord("SELECT * FROM users WHERE id = :id", ['id' => $userId], "User not found.");
    }

    /**
     * Fetch booking data.
     */
    private function fetchBookingData(int $bookingId): array
    {
        return $this->fetchRecord("SELECT * FROM bookings WHERE id = :id", ['id' => $bookingId], "Booking not found.");
    }

    /**
     * Fetch a record from the database.
     */
    private function fetchRecord(string $query, array $params, string $errorMessage): array
    {
        $stmt = $this->db->prepare($query);
        $stmt->execute($params);
        $record = $stmt->fetch(PDO::FETCH_ASSOC);

        if (!$record) {
            throw new Exception($errorMessage);
        }

        return $record;
    }

    /**
     * Handle exceptions and log errors.
     */
    private function handleException(string $message, Exception $e): void
    {
        $this->logger->error($message, ['error' => $e->getMessage()]);
        throw new Exception($message . " " . $e->getMessage());
    }
}
=== DocumentManager/Services/FileStorage.php ===
<?php

namespace DocumentManager\Services;

use Exception;
use Psr\Log\LoggerInterface;
use App\Services\EncryptionService;

/**
 * FileStorage Service
 *
 * Handles secure storage, retrieval, and deletion of files with support for encryption,
 * logging, and temporary file management.
 */
class FileStorage
{
    private string $basePath;
    private array $config;
    private LoggerInterface $logger;
    private EncryptionService $encryptionService;

    /**
     * Constructor
     *
     * @param array $config Configuration for the FileStorage service.
     * @param LoggerInterface $logger Logger instance for logging file operations.
     * @param EncryptionService $encryptionService Service for encrypting file contents.
     */
    public function __construct(array $config, LoggerInterface $logger, EncryptionService $encryptionService)
    {
        $this->config = $config;
        $this->logger = $logger;
        $this->encryptionService = $encryptionService;

        $this->basePath = rtrim($config['base_directory'], DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;

        if (!is_dir($this->basePath) || !is_writable($this->basePath)) {
            throw new Exception("Invalid storage base path or insufficient permissions: {$this->basePath}");
        }
    }

    /**
     * Store a file securely with optional encryption.
     */
    public function storeFile(string $directory, string $fileName, string $content, bool $encrypt = false): string
    {
        $safeDirectory = $this->getDirectoryPath($directory);
        $safeFileName = $this->sanitizeFileName($fileName);
        $filePath = $safeDirectory . $safeFileName;

        if ($encrypt) {
            $content = $this->encryptionService->encrypt($content);
        }

        if (file_put_contents($filePath, $content) === false) {
            $this->logger->error("Failed to store file", ['file' => $fileName, 'path' => $filePath]);
            throw new Exception("Failed to store file: $fileName");
        }

        chmod($filePath, $this->config['security']['permissions']['default']);
        $this->logger->info("File stored successfully", ['file' => $fileName, 'path' => $filePath]);

        return $filePath;
    }

    /**
     * Retrieve a file's content with optional decryption.
     */
    public function retrieveFile(string $filePath, bool $decrypt = false): string
    {
        if (!file_exists($filePath) || !is_readable($filePath)) {
            $this->logger->error("File not found or not readable", ['path' => $filePath]);
            throw new Exception("File not found or not readable: $filePath");
        }

        $content = file_get_contents($filePath);
        if ($content === false) {
            $this->logger->error("Failed to retrieve file", ['path' => $filePath]);
            throw new Exception("Failed to retrieve file: $filePath");
        }

        if ($decrypt) {
            $content = $this->encryptionService->decrypt($content);
            if ($content === null) {
                throw new Exception("Failed to decrypt file: $filePath");
            }
        }

        $this->logger->info("File retrieved successfully", ['path' => $filePath]);
        return $content;
    }

    /**
     * Delete a file securely.
     */
    public function deleteFile(string $filePath): void
    {
        if (!file_exists($filePath)) {
            $this->logger->error("File not found", ['path' => $filePath]);
            throw new Exception("File not found: $filePath");
        }

        if (!unlink($filePath)) {
            $this->logger->error("Failed to delete file", ['path' => $filePath]);
            throw new Exception("Failed to delete file: $filePath");
        }

        $this->logger->info("File deleted successfully", ['path' => $filePath]);
    }

    /**
     * Sanitize the file name to prevent directory traversal attacks.
     */
    private function sanitizeFileName(string $fileName): string
    {
        return preg_replace('/[^a-zA-Z0-9_\.-]/', '_', $fileName);
    }

    /**
     * Get the full directory path, creating it if it doesn't exist.
     */
    private function getDirectoryPath(string $directory): string
    {
        $path = $this->basePath . trim($directory, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;

        if (!is_dir($path) && !mkdir($path, 0755, true)) {
            $this->logger->error("Failed to create directory", ['path' => $path]);
            throw new Exception("Failed to create directory: $path");
        }

        if (!is_writable($path)) {
            $this->logger->error("Directory is not writable", ['path' => $path]);
            throw new Exception("Directory is not writable: $path");
        }

        return $path;
    }
}
=== DocumentManager/Services/SignatureService.php ===
<?php

namespace DocumentManager\Services;

use Exception;
use GuzzleHttp\Client;
use Psr\Log\LoggerInterface;
use DocumentManager\Services\FileStorage;
use App\Services\EncryptionService;

/**
 * Signature Service
 *
 * Manages electronic signatures both locally and via an external AES API.
 */
class SignatureService
{
    private Client $httpClient;
    private string $apiEndpoint;
    private string $apiKey;
    private FileStorage $fileStorage;
    private EncryptionService $encryptionService;
    private LoggerInterface $logger;

    public function __construct(
        Client $httpClient,
        array $config,
        FileStorage $fileStorage,
        EncryptionService $encryptionService,
        LoggerInterface $logger
    ) {
        if (empty($config['api_endpoint']) || empty($config['api_key'])) {
            throw new Exception('AES API configuration is incomplete.');
        }

        $this->httpClient = $httpClient;
        $this->apiEndpoint = $config['api_endpoint'];
        $this->apiKey = $config['api_key'];
        $this->fileStorage = $fileStorage;
        $this->encryptionService = $encryptionService;
        $this->logger = $logger;
    }

    /**
     * Upload a local signature.
     */
    public function uploadSignature(string $filePath, int $userId): string
    {
        $this->validateFileType($filePath);

        $encryptedContent = $this->encryptionService->encrypt(file_get_contents($filePath));
        $fileName = uniqid() . '.' . pathinfo($filePath, PATHINFO_EXTENSION);
        $storagePath = $this->fileStorage->storeFile("signatures/{$userId}", $fileName, $encryptedContent, false);

        $this->logger->info("Signature uploaded", ['user_id' => $userId, 'path' => $storagePath]);
        return $storagePath;
    }

    /**
     * Send a document for AES signature.
     */
    public function sendForAdvancedSignature(string $filePath, int $userId, string $callbackUrl): array
    {
        try {
            $documentHash = hash_file('sha256', $filePath);

            $response = $this->httpClient->post("{$this->apiEndpoint}/sign-aes", [
                'headers' => $this->getAuthHeaders(),
                'multipart' => [
                    ['name' => 'file', 'contents' => fopen($filePath, 'r')],
                    ['name' => 'user_id', 'contents' => $userId],
                    ['name' => 'document_hash', 'contents' => $documentHash],
                    ['name' => 'callback_url', 'contents' => $callbackUrl],
                ],
            ]);

            return json_decode($response->getBody(), true);
        } catch (Exception $e) {
            $this->logAndThrow("Failed to send document for AES signing", $e);
        }
    }

    /**
     * Verify an AES signature.
     */
    public function verifyAdvancedSignature(string $signedFilePath, string $originalFilePath): bool
    {
        try {
            $response = $this->httpClient->post("{$this->apiEndpoint}/verify-aes", [
                'headers' => $this->getAuthHeaders(),
                'json' => [
                    'original_hash' => hash_file('sha256', $originalFilePath),
                    'signed_hash' => hash_file('sha256', $signedFilePath),
                ],
            ]);

            return json_decode($response->getBody(), true)['verified'] ?? false;
        } catch (Exception $e) {
            $this->logAndThrow("Failed to verify AES signature", $e);
        }
    }

    /**
     * Retrieve stored local signatures for a user.
     */
    public function getSignatures(int $userId): array
    {
        $storedSignatures = $this->fileStorage->retrieveFiles("signatures/{$userId}");

        if (empty($storedSignatures)) {
            throw new Exception('No signatures found.');
        }

        return array_map(fn($path) => $this->encryptionService->decrypt($this->fileStorage->retrieveFile($path, false)), $storedSignatures);
    }

    /**
     * Check the status of an AES signature request.
     */
    public function checkAdvancedSignatureStatus(string $requestId): array
    {
        try {
            $response = $this->httpClient->get("{$this->apiEndpoint}/status/{$requestId}", [
                'headers' => $this->getAuthHeaders(),
            ]);

            return json_decode($response->getBody(), true);
        } catch (Exception $e) {
            $this->logAndThrow("Failed to check AES signature status", $e);
        }
    }

    /**
     * Download a signed AES document.
     */
    public function downloadSignedDocument(string $requestId, string $outputPath): bool
    {
        try {
            $response = $this->httpClient->get("{$this->apiEndpoint}/download/{$requestId}", [
                'headers' => $this->getAuthHeaders(),
                'sink' => $outputPath,
            ]);

            return $response->getStatusCode() === 200;
        } catch (Exception $e) {
            $this->logAndThrow("Failed to download AES signed document", $e);
        }
    }

    /**
     * Get authentication headers for API requests.
     */
    private function getAuthHeaders(): array
    {
        return [
            'Authorization' => "Bearer {$this->apiKey}",
            'Content-Type'  => 'application/json',
        ];
    }

    /**
     * Validate allowed file types.
     */
    private function validateFileType(string $filePath): void
    {
        $allowedExtensions = ['png', 'jpg', 'svg'];
        if (!in_array(pathinfo($filePath, PATHINFO_EXTENSION), $allowedExtensions)) {
            throw new Exception('Invalid file type.');
        }
    }

    /**
     * Log error and throw exception.
     */
    private function logAndThrow(string $message, Exception $e): void
    {
        $this->logger->error($message, ['error' => $e->getMessage()]);
        throw new Exception("$message: " . $e->getMessage());
    }
}
=== DocumentManager/templates/invoice.template.html ===
=== DocumentManager/templates/terms_and_conditions.html ===
=== DocumentManager/templates/rental_contract.html ===
=== DocumentManager/migrations/create_documents_table.php ===
=== DocumentManager/migrations/signature_queue_table.php ===
CREATE TABLE signature_requests (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    request_id VARCHAR(255) NOT NULL,
    document_path VARCHAR(255) NOT NULL,
    user_id INT NOT NULL,
    status ENUM('pending', 'completed', 'failed') DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
=== DocumentManager/migrations/create_templates_table.php ===
