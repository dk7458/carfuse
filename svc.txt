=== App/Services/TemplateService.php ===
<?php

namespace App\Services;

use Exception;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use App\Models\DocumentTemplate;
use App\Services\AuditService;

/**
 * Template Service
 *
 * Provides functionality for managing and rendering document templates.
 * Templates support placeholders for dynamic data injection.
 */
class TemplateService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private AuditService $auditService;

    /**
     * Constructor
     *
     * @param LoggerInterface $logger The logger instance.
     * @param ExceptionHandler $exceptionHandler The exception handler instance.
     * @param AuditService $auditService The audit service instance.
     */
    public function __construct(
        LoggerInterface $logger, 
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    /**
     * List all available templates.
     *
     * @return array List of templates.
     */
    public function listTemplates(): array
    {
        return DocumentTemplate::all()->toArray();
    }

    /**
     * Load the content of a template.
     *
     * @param int|string $templateId The ID or name of the template.
     * @return DocumentTemplate The template.
     * @throws Exception If the template cannot be found.
     */
    public function loadTemplate($templateId): DocumentTemplate
    {
        try {
            $template = is_numeric($templateId) 
                ? DocumentTemplate::findOrFail($templateId)
                : DocumentTemplate::where('name', $templateId)->firstOrFail();
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[system] Loaded template", ['template' => $template->name]);
            }
            
            $this->auditService->logEvent('template_loaded', [
                'template_id' => $template->id,
                'template_name' => $template->name
            ]);
            
            return $template;
        } catch (\Exception $e) {
            $this->logger->error("[system] ❌ Error loading template: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Render a template by replacing placeholders with data.
     *
     * @param int|string $templateId The ID or name of the template.
     * @param array $data Key-value pairs to replace placeholders.
     * @return string Rendered template with placeholders replaced.
     * @throws Exception If the template cannot be loaded.
     */
    public function renderTemplate($templateId, array $data): string
    {
        $template = $this->loadTemplate($templateId);
        $content = $template->content;

        foreach ($data as $key => $value) {
            $placeholder = '{{' . $key . '}}';
            $content = str_replace($placeholder, htmlspecialchars((string)$value, ENT_QUOTES, 'UTF-8'), $content);
        }

        $this->auditService->logEvent('template_rendered', [
            'template_id' => $template->id,
            'template_name' => $template->name
        ]);
        
        return $content;
    }

    /**
     * Save a new or updated template.
     *
     * @param string $templateName The name of the template.
     * @param string $content The template content to save.
     * @param int|null $templateId The template ID for updates (null for new templates).
     * @return DocumentTemplate The saved template.
     * @throws Exception If saving fails.
     */
    public function saveTemplate(string $templateName, string $content, ?int $templateId = null): DocumentTemplate
    {
        try {
            if ($templateId) {
                $template = DocumentTemplate::findOrFail($templateId);
                $template->name = $templateName;
                $template->content = $content;
                $template->save();
            } else {
                $template = DocumentTemplate::create([
                    'name' => $templateName,
                    'content' => $content
                ]);
            }
            
            return $template;
        } catch (\Exception $e) {
            $this->logger->error("Error saving template", ['template' => $templateName, 'error' => $e->getMessage()]);
            throw $e;
        }
    }

    /**
     * Delete a template.
     *
     * @param int $templateId The ID of the template to delete.
     * @return bool True if deleted successfully.
     * @throws Exception If the template cannot be found or deleted.
     */
    public function deleteTemplate(int $templateId): bool
    {
        try {
            $template = DocumentTemplate::findOrFail($templateId);
            $template->delete();
            
            return true;
        } catch (\Exception $e) {
            $this->logger->error("Error deleting template", ['template_id' => $templateId, 'error' => $e->getMessage()]);
            throw $e;
        }
    }
}
=== App/Services/MetricsService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use Exception;

class MetricsService
{
    public const DEBUG_MODE = true;
    private DatabaseHelper $db;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        DatabaseHelper $db
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->db = $db;
    }

    public function getDashboardMetrics(): array
    {
        try {
            $totalUsers        = $this->db->table('users')->count();
            $activeUsers       = $this->db->table('users')->where('active', true)->count();
            $totalBookings     = $this->db->table('bookings')->count();
            $completedBookings = $this->db->table('bookings')->where('status', 'completed')->count();
            $canceledBookings  = $this->db->table('bookings')->where('status', 'canceled')->count();
            $totalRevenue      = $this->db->table('payments')->where('status', 'completed')->sum('amount');
            $totalRefunds      = $this->db->table('payments')
                                          ->where('status', 'completed')
                                          ->where('type', 'refund')
                                          ->sum('amount');
            
            $metrics = [
                'total_users'         => $totalUsers,
                'active_users'        => $activeUsers,
                'total_bookings'      => $totalBookings,
                'completed_bookings'  => $completedBookings,
                'canceled_bookings'   => $canceledBookings,
                'total_revenue'       => $totalRevenue,
                'total_refunds'       => $totalRefunds,
            ];
            $metrics['net_revenue'] = $totalRevenue - $totalRefunds;
            if (self::DEBUG_MODE) {
                $this->logger->info("[Metrics] Dashboard metrics retrieved successfully");
            }
            return $metrics;
        } catch (Exception $e) {
            $this->logger->error("[DB] ❌ MetricsService error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return [];
        }
    }
}
=== App/Services/UserService.php ===
<?php

namespace App\Services;

use Psr\Log\LoggerInterface;
use Firebase\JWT\JWT;
use Exception;
use App\Helpers\DatabaseHelper;
use App\Helpers\ApiHelper;
use App\Helpers\ExceptionHandler;
use App\Models\User;

class UserService
{
    public const DEBUG_MODE = true;

    private DatabaseHelper $db;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private AuditService $auditService;
    private User $userModel;
    private string $jwtSecret;

    public function __construct(
        LoggerInterface $logger,
        DatabaseHelper $db,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService,
        User $userModel,
        string $jwtSecret = 'default_secret'
    ) {
        $this->logger = $logger;
        $this->db = $db;
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
        $this->userModel = $userModel;
        $this->jwtSecret = $jwtSecret;
        
        if (self::DEBUG_MODE) {
            $this->logger->info("[auth] UserService initialized", ['service' => 'UserService']);
        }
    }

    public function createUser(array $data): array
    {
        $rules = User::$rules;

        try {
            Validator::validate($data, $rules);
        } catch (Exception $e) {
            return ['status' => 'error', 'message' => $e->getMessage()];
        }

        try {
            // Use User model to create the user
            $userId = $this->userModel->create($data);
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[auth] ✅ User registered.", ['userId' => $userId]);
            }
            
            return ['status' => 'success', 'message' => 'User created successfully', 'data' => ['user_id' => $userId]];
        } catch (Exception $e) {
            $this->logger->error("[auth] ❌ User creation failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'User creation failed'];
        }
    }

    public function updateUser(int $id, array $data): array
    {
        try {
            // First check if user exists
            $user = $this->userModel->find($id);
            if (!$user) {
                $this->logger->error("User not found", ['userId' => $id]);
                return ['status' => 'error', 'message' => 'User not found', 'code' => 404];
            }
            
            // Use User model to update the user
            $result = $this->userModel->updateProfile($id, $data);
            
            if ($result) {
                // Changed from audit service to logger for profile updates
                $this->logger->info("✅ User profile updated", [
                    'userId' => $id,
                    'fields' => array_keys($data)
                ]);
                return ['status' => 'success', 'message' => 'User updated successfully', 'data' => ['user_id' => $id]];
            } else {
                return ['status' => 'error', 'message' => 'User update failed'];
            }
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'User update failed: ' . $e->getMessage()];
        }
    }

    public function updateUserRole(int $id, string $role): array
    {
        try {
            // First check if user exists
            $user = $this->userModel->find($id);
            if (!$user) {
                $this->logger->error("User not found", ['userId' => $id]);
                return ['status' => 'error', 'message' => 'User not found', 'code' => 404];
            }
            
            // Use User model to update role
            $result = $this->userModel->updateUserRole($id, $role);
            
            if ($result) {
                $this->logger->info("✅ User role updated.", ['userId' => $id, 'role' => $role]);
                
                // Keep audit logging for admin role updates
                $this->auditService->logEvent(
                    'user',
                    'Role changed',
                    [
                        'user_id' => $id, 
                        'previous_role' => $user['role'] ?? 'unknown',
                        'new_role' => $role
                    ],
                    $id,
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
                
                return ['status' => 'success', 'message' => 'User role updated successfully'];
            } else {
                return ['status' => 'error', 'message' => 'User role update failed'];
            }
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'Role update failed: ' . $e->getMessage()];
        }
    }

    public function deleteUser(int $id): array
    {
        try {
            // First check if user exists
            $user = $this->userModel->find($id);
            if (!$user) {
                $this->logger->error("User not found", ['userId' => $id]);
                return ['status' => 'error', 'message' => 'User not found', 'code' => 404];
            }
            
            // Check if user is a super admin (this prevents super admin deletion)
            if (isset($user['role']) && $user['role'] === 'super_admin') {
                $this->logger->warning("Attempted to delete super admin account", ['userId' => $id]);
                return ['status' => 'error', 'message' => 'Super admin accounts cannot be deleted', 'code' => 403];
            }
            
            // Use User model to delete user
            $result = $this->userModel->deleteUser($id);
            
            if ($result) {
                $this->logger->info("✅ User deleted.", ['userId' => $id]);
                
                // Keep audit log for user deletions
                $this->auditService->logEvent(
                    'user',
                    'User deleted',
                    [
                        'user_id' => $id,
                        'user_email' => $user['email'] ?? 'unknown',
                        'user_role' => $user['role'] ?? 'unknown'
                    ],
                    null,
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
                
                return ['status' => 'success', 'message' => 'User deleted successfully'];
            } else {
                return ['status' => 'error', 'message' => 'User deletion failed'];
            }
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'User deletion failed: ' . $e->getMessage()];
        }
    }

    public function changePassword(int $id, string $currentPassword, string $newPassword): array
    {
        try {
            // Use User model to change password
            $result = $this->userModel->changePassword($id, $currentPassword, $newPassword);
            
            if ($result) {
                $this->logger->info("✅ Password changed.", ['userId' => $id]);
                
                // Log password change through audit service
                $this->auditService->logEvent(
                    'user',
                    'Password changed',
                    ['user_id' => $id],
                    $id,
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
                
                return ['status' => 'success', 'message' => 'Password changed successfully'];
            } else {
                return ['status' => 'error', 'message' => 'Password change failed'];
            }
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'Password change failed: ' . $e->getMessage()];
        }
    }

    public function authenticate(string $email, string $password): array
    {
        try {
            $user = $this->userModel->getUserByEmail($email);
            
            if (!$user || !$this->userModel->verifyPassword($password, $user['password_hash'])) {
                $this->logger->error("Authentication failed", ['email' => $email]);
                
                // Use logger instead of audit service for failed authentication
                $this->logger->warning("Failed authentication attempt", [
                    'email' => $email,
                    'ip' => $_SERVER['REMOTE_ADDR'] ?? null
                ]);
                
                return ['status' => 'error', 'message' => 'Authentication failed', 'code' => 401];
            }
            
            $this->logger->info("✅ Authentication successful.", ['userId' => $user['id']]);
            
            // Use logger instead of audit service for successful authentication
            $this->logger->info("User authenticated successfully", [
                'userId' => $user['id'],
                'email' => $email,
                'ip' => $_SERVER['REMOTE_ADDR'] ?? null
            ]);
            
            $jwt = $this->generateJWT($user);
            return ['status' => 'success', 'message' => 'Authentication successful', 'data' => ['token' => $jwt]];
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'Authentication error: ' . $e->getMessage()];
        }
    }

    private function generateJWT($user): string
    {
        $payload = [
            'sub' => $user['id'],
            'email' => $user['email'],
            'role' => $user['role'],
            'iat' => time(),
            'exp' => time() + 3600,
        ];

        return JWT::encode($payload, $this->jwtSecret, 'HS256');
    }

    public function requestPasswordReset(string $email): array
    {
        try {
            $user = $this->userModel->getUserByEmail($email);
            
            if (!$user) {
                $this->logger->error("Password reset request failed", ['email' => $email]);
                return ['status' => 'error', 'message' => 'User not found', 'code' => 404];
            }
            
            $token = bin2hex(random_bytes(32));
            $expiresAt = date('Y-m-d H:i:s', strtotime('+1 hour'));
            
            // Use User model's createPasswordReset method
            $result = $this->userModel->createPasswordReset($email, $token, $_SERVER['REMOTE_ADDR'] ?? null, $expiresAt);
            
            if ($result) {
                $this->logger->info("✅ Password reset requested.", [
                    'userId' => $user['id'],
                    'email' => $email,
                    'ip' => $_SERVER['REMOTE_ADDR'] ?? null
                ]);
                
                // Keep audit logging for password reset requests
                $this->auditService->logEvent(
                    'auth',
                    'Password reset requested',
                    ['email' => $email],
                    $user['id'],
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
                
                return [
                    'status' => 'success',
                    'message' => 'Password reset requested',
                    'data' => ['reset_token' => $token]
                ];
            } else {
                return ['status' => 'error', 'message' => 'Password reset request failed'];
            }
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'Password reset request error: ' . $e->getMessage()];
        }
    }
}
=== App/Services/Validator.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

/**
 * Validator Service
 *
 * Validates input data against defined rules.
 */
class Validator
{
    public const DEBUG_MODE = true;
    private array $errors = [];
    private LoggerInterface $logger;
    private DatabaseHelper $db;
    private ExceptionHandler $exceptionHandler;

    // Updated constructor for Dependency Injection
    public function __construct(LoggerInterface $logger, DatabaseHelper $db, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->db = $db;
        $this->exceptionHandler = $exceptionHandler;
        $this->logger->debug("Validator initialized with database connection");
    }

    /**
     * Validate data against rules.
     */
    public function validate(array $data, array $rules): bool
    {
        $this->logger->debug("Starting validation with rules", ['rules' => $rules]);
        $this->errors = [];
        
        foreach ($rules as $field => $ruleSet) {
            $rulesArray = explode('|', $ruleSet);
            foreach ($rulesArray as $rule) {
                $this->applyRule($field, $data[$field] ?? null, $rule, $data);
            }
        }

        if (!empty($this->errors)) {
            if (self::DEBUG_MODE) {
                $this->logger->warning("Validation failed", ['errors' => $this->errors]);
            }

            // Throw an exception to prevent further execution
            throw new \InvalidArgumentException(json_encode(['errors' => $this->errors]));
        }

        $this->logger->debug("Validation successful");
        return true;
    }

    /**
     * Get validation errors.
     */
    public function errors(): array
    {
        return $this->errors;
    }

    /**
     * Apply a validation rule to a field.
     */
    private function applyRule(string $field, $value, string $rule, array $data): void
    {
        try {
            if ($rule === 'required' && empty($value)) {
                $this->errors[$field][] = "The {$field} field is required.";
            } elseif (strpos($rule, 'max:') === 0) {
                $maxLength = (int)explode(':', $rule)[1];
                if (!empty($value) && strlen($value) > $maxLength) {
                    $this->errors[$field][] = "The {$field} must not exceed {$maxLength} characters.";
                }
            } elseif (strpos($rule, 'min:') === 0) {
                $minLength = (int)explode(':', $rule)[1];
                if (!empty($value) && strlen($value) < $minLength) {
                    $this->errors[$field][] = "The {$field} must be at least {$minLength} characters.";
                }
            } elseif ($rule === 'email' && !empty($value) && !filter_var($value, FILTER_VALIDATE_EMAIL)) {
                $this->errors[$field][] = "The {$field} must be a valid email address.";
            } elseif (strpos($rule, 'regex:') === 0) {
                $pattern = substr($rule, 6);
                if (!empty($value) && !preg_match($pattern, $value)) {
                    $this->errors[$field][] = "The {$field} format is invalid.";
                }
            } elseif (strpos($rule, 'same:') === 0) {
                $otherField = substr($rule, 5);
                if (!empty($value) && isset($data[$otherField]) && $value !== $data[$otherField]) {
                    $this->errors[$field][] = "The {$field} and {$otherField} must match.";
                }
            } elseif (strpos($rule, 'unique:') === 0) {
                [$table, $column] = explode(',', substr($rule, 7));
                
                $this->logger->debug("Checking uniqueness", [
                    'field' => $field,
                    'table' => $table,
                    'column' => $column,
                    'value' => $value
                ]);
                
                if (!empty($value)) {
                    $pdo = $this->db->getPdo(); // Get PDO instance from DatabaseHelper
                    $stmt = $pdo->prepare("SELECT COUNT(*) FROM {$table} WHERE {$column} = ?");
                    $stmt->execute([$value]);
                    $count = (int)$stmt->fetchColumn();
                    
                    if ($count > 0) {
                        $this->errors[$field][] = "The {$field} has already been taken.";
                    }
                }
            }
        } catch (\Exception $e) {
            $this->logger->error("Validation error: " . $e->getMessage(), [
                'field' => $field,
                'rule' => $rule
            ]);
            
            // Add a generic error and continue validation
            $this->errors[$field][] = "An error occurred while validating {$field}.";
        }
    }
}=== App/Services/AdminService.php ===
<?php

namespace App\Services;

use App\Models\Admin;
use App\Services\Auth\TokenService;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class AdminService
{
    private Admin $adminModel;
    private AuditService $auditService;
    private LoggerInterface $logger;
    private TokenService $tokenService;
    private ExceptionHandler $exceptionHandler;

    public function __construct(
        Admin $adminModel,
        AuditService $auditService,
        LoggerInterface $logger,
        TokenService $tokenService,
        ExceptionHandler $exceptionHandler
    ) {
        $this->adminModel = $adminModel;
        $this->auditService = $auditService;
        $this->logger = $logger;
        $this->tokenService = $tokenService;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Validate admin token and return admin data
     */
    public function validateAdmin(ServerRequestInterface $request): ?array
    {
        $this->logger->debug("Validating admin token using secure database");
        
        // Use TokenService to extract the token
        $token = $this->tokenService->extractToken($request);
        
        if (empty($token)) {
            $this->logger->info("No authorization token provided");
            return null;
        }
        
        // Validate token and fetch admin details
        $admin = $this->adminModel->findByToken($token);
            
        if (empty($admin) || $admin['role'] !== 'admin') {
            $this->logger->info("Invalid admin token or insufficient permissions");
            return null;
        }
        
        $this->logger->info("Admin validated successfully", ['admin_id' => $admin['id']]);
        return $admin;
    }

    /**
     * Get all users with pagination
     */
    public function getAllUsers(int $page, int $adminId): array
    {
        try {
            $perPage = 10;
            
            $this->logger->debug("Fetching users with pagination");
            
            $users = $this->adminModel->getPaginatedUsers($page, $perPage);
            $totalUsers = $this->adminModel->getTotalUserCount();
            
            $this->auditService->logEvent(
                'user_list_viewed',
                'Admin viewed user list',
                ['admin_id' => $adminId, 'page' => $page],
                $adminId,
                null,
                'admin'
            );
            
            return [
                'users' => $users,
                'pagination' => [
                    'total' => $totalUsers,
                    'per_page' => $perPage,
                    'current_page' => $page,
                    'last_page' => ceil($totalUsers / $perPage)
                ]
            ];
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            throw $e; // Re-throw so controller can handle response
        }
    }

    /**
     * Update a user's role
     */
    public function updateUserRole(int $userId, string $role, int $adminId): bool
    {
        try {
            $this->logger->debug("Fetching user data for role update", [
                'user_id' => $userId
            ]);
            
            // Get user and their current role
            $user = $this->adminModel->getUserById($userId);
            
            if (empty($user)) {
                return false;
            }
            
            $oldRole = $user['role'];
            
            $this->logger->debug("Updating user role", [
                'user_id' => $userId,
                'old_role' => $oldRole,
                'new_role' => $role
            ]);
            
            // Update role
            $result = $this->adminModel->updateUserRole($userId, $role);
            
            if ($result) {
                $this->auditService->logEvent(
                    'user_role_updated',
                    "User role updated from {$oldRole} to {$role}",
                    [
                        'user_id' => $userId,
                        'old_role' => $oldRole,
                        'new_role' => $role,
                        'admin_id' => $adminId
                    ],
                    $adminId,
                    null,
                    'admin'
                );
            }
            
            return $result;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Delete a user (Soft delete)
     */
    public function deleteUser(int $userId, int $adminId): ?array
    {
        try {
            $this->logger->debug("Fetching user data for deletion", [
                'user_id' => $userId
            ]);
            
            // Get user data for audit log
            $user = $this->adminModel->getUserById($userId);
            
            if (empty($user)) {
                return null;
            }
            
            $userEmail = $user['email'];
            $userRole = $user['role'];
            
            // Check if user is a super admin
            if ($userRole === 'super_admin') {
                $this->logger->info("Attempted to delete a super_admin account", [
                    'user_id' => $userId,
                    'admin_id' => $adminId
                ]);
                return ['error' => 'Super admins cannot be deleted'];
            }
            
            $this->logger->debug("Soft deleting user", [
                'user_id' => $userId,
                'user_email' => $userEmail
            ]);
            
            // Soft delete by setting deleted_at timestamp
            $result = $this->adminModel->softDeleteUser($userId);
            
            if ($result) {
                $this->auditService->logEvent(
                    'user_deleted',
                    "User {$userEmail} was deleted",
                    [
                        'user_id' => $userId,
                        'user_email' => $userEmail,
                        'admin_id' => $adminId
                    ],
                    $adminId,
                    null,
                    'admin'
                );
            }
            
            return $result ? $user : null;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get dashboard statistics
     */
    public function getDashboardData(int $adminId): array
    {
        try {
            $this->logger->debug("Fetching dashboard statistics");
            
            $dashboardData = $this->adminModel->getDashboardStatistics();
            
            $this->auditService->logEvent(
                'dashboard_viewed',
                'Admin viewed dashboard',
                ['admin_id' => $adminId],
                $adminId,
                null,
                'admin'
            );
            
            return $dashboardData;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Create a new admin user
     */
    public function createAdmin(array $data, int $adminId): ?array
    {
        try {
            $this->logger->debug("Checking for existing admin email", [
                'email' => $data['email']
            ]);
            
            // Check if email already exists
            $existingAdmin = $this->adminModel->findByEmail($data['email']);
            
            if ($existingAdmin) {
                return null;
            }
            
            // Create new admin
            $hashedPassword = password_hash($data['password'], PASSWORD_DEFAULT);
            
            $this->logger->debug("Creating new admin user");
            
            // Insert new admin record
            $newAdminId = $this->adminModel->create([
                "name" => $data['name'],
                "email" => $data['email'],
                "password" => $hashedPassword,
                "role" => 'admin',
                "created_at" => date('Y-m-d H:i:s')
            ]);
            
            if (!$newAdminId) {
                return null;
            }
            
            $this->logger->debug("Fetching created admin details", [
                'new_admin_id' => $newAdminId
            ]);
            
            // Get created admin details for response
            $newAdmin = $this->adminModel->findById($newAdminId);
            
            $this->auditService->logEvent(
                'admin_created',
                "New admin user created: {$data['email']}",
                [
                    'created_by' => $adminId,
                    'new_admin_id' => $newAdminId,
                    'new_admin_email' => $data['email']
                ],
                $adminId,
                null,
                'admin'
            );
            
            return $newAdmin;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
}
=== App/Services/BookingService.php ===
<?php

namespace App\Services;

use App\Models\Booking;
use Exception;
use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class BookingService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private DatabaseHelper $db;
    private Booking $bookingModel;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        DatabaseHelper $db,
        Booking $bookingModel
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->db = $db;
        $this->bookingModel = $bookingModel;
    }

    /**
     * Get booking details by ID
     */
    public function getBookingById(int $id): array
    {
        try {
            $booking = $this->bookingModel->find($id);
            if (!$booking) {
                throw new Exception("Booking not found.");
            }
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved booking id: {$id}");
            }
            return (array)$booking;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getBookingById error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Reschedule a booking
     */
    public function rescheduleBooking(int $id, string $pickupDate, string $dropoffDate): void
    {
        try {
            $booking = $this->bookingModel->find($id);
            if (!$booking) {
                throw new Exception("Booking not found.");
            }

            $updated = $this->bookingModel->update($id, [
                'pickup_date'  => $pickupDate,
                'dropoff_date' => $dropoffDate,
                'status'       => 'rescheduled'
            ]);

            if (!$updated) {
                throw new Exception("Failed to update booking.");
            }
            
            // Business-level logging (keep it as it's not just a record change)
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Rescheduled booking id: {$id}");
            }
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ rescheduleBooking error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Cancel a booking and calculate refund amount
     */
    public function cancelBooking(int $id): float
    {
        try {
            $booking = $this->bookingModel->find($id);
            if (!$booking) {
                throw new Exception("Booking not found.");
            }

            $updated = $this->bookingModel->update($id, ['status' => 'canceled']);

            if (!$updated) {
                throw new Exception("Failed to update booking status.");
            }
            
            // Business-level logging (keep it as it's not just a record change)
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Canceled booking id: {$id}");
            }
            
            return isset($booking['refund_amount']) ? (float)$booking['refund_amount'] : 0.0;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ cancelBooking error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get user ID associated with a booking
     */
    public function getUserIdByBooking(int $id): int
    {
        try {
            $booking = $this->bookingModel->find($id);
            if (!$booking) {
                throw new Exception("Booking not found.");
            }
            
            $userId = $this->bookingModel->getUserId($id);
            
            if (!$userId) {
                throw new Exception("User not found for booking.");
            }
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved user id for booking id: {$id}");
            }
            
            return (int)$userId;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getUserIdByBooking error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get monthly booking trends for the current year
     */
    public function getMonthlyBookingTrends(): array
    {
        try {
            $trends = $this->bookingModel->getMonthlyTrends();
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved monthly booking trends.");
            }
            
            return $trends;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getMonthlyBookingTrends error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get total number of bookings
     */
    public function getTotalBookings(): int
    {
        try {
            $total = $this->bookingModel->getTotalBookings();
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved total bookings.");
            }
            
            return $total;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getTotalBookings error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get the number of completed bookings
     */
    public function getCompletedBookings(): int
    {
        try {
            $completed = $this->bookingModel->getCompletedBookings();
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved completed bookings.");
            }
            
            return $completed;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getCompletedBookings error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get the number of canceled bookings
     */
    public function getCanceledBookings(): int
    {
        try {
            $canceled = $this->bookingModel->getCanceledBookings();
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved canceled bookings.");
            }
            
            return $canceled;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getCanceledBookings error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get booking logs for a specific booking ID
     */
    public function getBookingLogs(int $bookingId): array
    {
        try {
            $logs = $this->bookingModel->getLogs($bookingId);
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved logs for booking id: {$bookingId}");
            }
            
            return $logs;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getBookingLogs error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Check booking availability
     */
    private function isBookingAvailable(int $vehicleId, string $pickupDate, string $dropoffDate): bool
    {
        try {
            $available = $this->bookingModel->isAvailable($vehicleId, $pickupDate, $dropoffDate);
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Checked availability for vehicle id: {$vehicleId}");
            }
            
            return $available;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ isBookingAvailable error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Create a new booking
     */
    public function createBooking(int $userId, int $vehicleId, string $pickupDate, string $dropoffDate): array
    {
        if (!$this->isBookingAvailable($vehicleId, $pickupDate, $dropoffDate)) {
            $this->logger->error("[Booking] ❌ Vehicle not available for booking (vehicle id: {$vehicleId})");
            return ['status' => 'error', 'message' => 'Vehicle not available for the selected dates'];
        }

        try {
            $bookingData = [
                'user_id'     => $userId,
                'vehicle_id'  => $vehicleId,
                'pickup_date' => $pickupDate,
                'dropoff_date'=> $dropoffDate,
                'status'      => 'booked',
                'created_at'  => date('Y-m-d H:i:s'),
                'updated_at'  => date('Y-m-d H:i:s')
            ];
            
            $booking = $this->bookingModel->create($bookingData);

            // Business-level logging (keep it as it's not just a record change)
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Booking created for user {$userId}");
            }

            return ['status' => 'success', 'message' => 'Booking created successfully'];
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ createBooking error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'Failed to create booking'];
        }
    }
    
    /**
     * Get all bookings for a user
     */
    public function getUserBookings(int $userId): array
    {
        try {
            $bookings = $this->bookingModel->getByUser($userId);
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved bookings for user id: {$userId}");
            }
            
            return $bookings;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getUserBookings error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
    
    /**
     * Delete a booking (soft delete if model supports it)
     */
    public function deleteBooking(int $id): bool
    {
        try {
            $deleted = $this->bookingModel->delete($id);
            
            if (!$deleted) {
                throw new Exception("Failed to delete booking.");
            }
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Deleted booking id: {$id}");
            }
            
            return true;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ deleteBooking error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
}
=== App/Services/Auth/TokenService.php ===
<?php

namespace App\Services\Auth;

use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use App\Helpers\DatabaseHelper;
use App\Services\AuditService;
use App\Models\RefreshToken;
use App\Models\User;
use Exception;

class TokenService
{
    public const DEBUG_MODE = true;

    private string $jwtSecret;
    private string $jwtRefreshSecret;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private DatabaseHelper $db;
    private AuditService $auditService;
    private array $encryptionConfig;
    private RefreshToken $refreshTokenModel;
    private User $userModel;

    public function __construct(
        string $jwtSecret,
        string $jwtRefreshSecret,
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        DatabaseHelper $appDb,
        AuditService $auditService,
        array $encryptionConfig,
        RefreshToken $refreshTokenModel,
        User $userModel
    ) {
        $this->jwtSecret = $jwtSecret;
        $this->jwtRefreshSecret = $jwtRefreshSecret;
        if (empty($this->jwtSecret) || empty($this->jwtRefreshSecret)) {
            throw new \RuntimeException('❌ JWT secrets are missing.');
        }
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->db = $appDb;
        $this->auditService = $auditService;
        $this->encryptionConfig = $encryptionConfig;
        $this->refreshTokenModel = $refreshTokenModel;
        $this->userModel = $userModel;
        
        if (self::DEBUG_MODE) {
            $this->logger->info("[auth] TokenService initialized.");
        }
    }

    /**
     * Generate a JWT token for a user
     */
    public function generateToken($user): string
    {
        // Extract user ID safely from either array or object
        $userId = is_array($user) ? $user['id'] : $user->id;

        $payload = [
            'iss' => $this->encryptionConfig['issuer'],
            'aud' => $this->encryptionConfig['audience'],
            'iat' => time(),
            'exp' => time() + 3600, // 1 hour
            'sub' => $userId,
            'data' => [
                'id' => $userId,
                'email' => is_array($user) ? $user['email'] : $user->email,
                'role' => is_array($user) ? ($user['role'] ?? 'user') : ($user->role ?? 'user')
            ]
        ];
        
        try {
            $token = JWT::encode($payload, $this->jwtSecret, 'HS256');
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[auth] ✅ Token generated.", ['userId' => $userId]);
            }
            
            // Log JWT creation as a business-level event in audit trail
            $this->auditService->logEvent(
                'auth',
                'jwt_created',
                ['user_id' => $userId],
                $userId,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return $token;
        } catch (Exception $e) {
            $this->logger->error("[auth] ❌ Token generation failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Generate a refresh token for a user
     */
    public function generateRefreshToken($user): string
    {
        // Extract user ID safely from either array or object
        $userId = is_array($user) ? $user['id'] : $user->id;

        $payload = [
            'iss' => $this->encryptionConfig['issuer'],
            'aud' => $this->encryptionConfig['audience'],
            'iat' => time(),
            'exp' => time() + 604800, // 7 days
            'sub' => $userId,
        ];
        
        try {
            $refreshToken = JWT::encode($payload, $this->jwtRefreshSecret, 'HS256');
            
            // Store the refresh token using the RefreshToken model
            $this->refreshTokenModel->store($userId, $refreshToken, 604800);
            
            // Log refresh token creation
            $this->auditService->logEvent(
                'auth',
                'refresh_token_created',
                ['user_id' => $userId],
                $userId,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return $refreshToken;
        } catch (Exception $e) {
            $this->logger->error("[auth] ❌ Refresh token generation failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Verify/decode a JWT token
     */
    public function verifyToken(string $token): array
    {
        try {
            $decoded = JWT::decode($token, new Key($this->jwtSecret, 'HS256'));
            
            if ($decoded->exp < time()) {
                // Log token expiration
                $this->auditService->logEvent(
                    'auth',
                    'token_expired',
                    ['sub' => $decoded->sub],
                    $decoded->sub,
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
                
                throw new Exception("Token has expired.");
            }
            
            $this->logger->info("✅ Token verified.", ['userId' => $decoded->sub]);
            
            // Log successful verification
            $this->auditService->logEvent(
                'auth',
                'token_verified',
                ['user_id' => $decoded->sub],
                $decoded->sub,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return (array)$decoded;
        } catch (Exception $e) {
            $this->logger->warning("Token verification failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Decode and validate a refresh token
     */
    public function decodeRefreshToken(string $refreshToken)
    {
        try {
            // Check if token has been revoked using RefreshToken model
            if ($this->refreshTokenModel->isRevoked($refreshToken)) {
                // Log revoked token attempt
                $userId = $this->refreshTokenModel->getUserId($refreshToken);
                if ($userId) {
                    $this->auditService->logEvent(
                        'auth',
                        'revoked_token_use_attempt',
                        [],
                        $userId,
                        null,
                        $_SERVER['REMOTE_ADDR'] ?? null
                    );
                }
                
                throw new Exception("Refresh token has been revoked.");
            }
            
            $decoded = JWT::decode($refreshToken, new Key($this->jwtRefreshSecret, 'HS256'));
            
            if ($decoded->exp < time()) {
                // Log expired token attempt
                $this->auditService->logEvent(
                    'auth',
                    'expired_token_use_attempt',
                    ['sub' => $decoded->sub],
                    $decoded->sub,
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
                
                throw new Exception("Refresh token has expired.");
            }
            
            $this->logger->debug("Refresh token decoded successfully", ['sub' => $decoded->sub]);
            return $decoded;
        } catch (Exception $e) {
            $this->logger->error("Failed to decode refresh token: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Refresh an access token using a refresh token
     */
    public function refreshToken(string $refreshToken): string
    {
        try {
            $decoded = $this->decodeRefreshToken($refreshToken);
            
            // Generate a new access token
            $user = $this->userModel->find($decoded->sub);
            if (!$user) {
                throw new Exception("User not found for token");
            }
            
            $newToken = $this->generateToken((object)$user);
            
            // Log token refresh as a business event
            $this->auditService->logEvent(
                'auth',
                'jwt_refreshed',
                ['user_id' => $decoded->sub],
                $decoded->sub,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return $newToken;
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Revoke a refresh token
     */
    public function revokeToken(string $token): void
    {
        try {
            // Get user ID for audit logging before revocation
            $userId = $this->refreshTokenModel->getUserId($token);
            
            // Revoke the token using RefreshToken model
            $this->refreshTokenModel->revoke($token);
            
            // Log token revocation as a business event
            if ($userId) {
                $this->auditService->logEvent(
                    'auth',
                    'token_revoked',
                    [],
                    $userId,
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
            }
            
            $this->logger->info("✅ [TokenService] Revoked refresh token.");
        } catch (Exception $e) {
            $this->logger->error("Failed to revoke token: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
        }
    }
    
    /**
     * Remove expired tokens from the database
     */
    public function purgeExpiredTokens(): int
    {
        try {
            // Use RefreshToken model to purge expired tokens
            $count = $this->refreshTokenModel->purgeExpired();
            
            // Log the maintenance action
            $this->auditService->logEvent(
                'system',
                'expired_tokens_purged',
                ['count' => $count],
                null,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return $count;
        } catch (Exception $e) {
            $this->logger->error("Failed to purge expired tokens: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return 0;
        }
    }
    
    /**
     * Get all active tokens for a user
     */
    public function getActiveTokensForUser(int $userId): array
    {
        try {
            // Use RefreshToken model to get active tokens
            return $this->refreshTokenModel->getActiveForUser($userId);
        } catch (Exception $e) {
            $this->logger->error("Failed to get active tokens: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return [];
        }
    }

    /**
     * Validate token and get user data in a single operation
     */
    public function validateRequest($request): ?array
    {
        $token = $this->extractToken($request);
        if (!$token) {
            return null;
        }
        
        try {
            $decoded = $this->verifyToken($token);
            return $this->userModel->find($decoded['sub']);
        } catch (Exception $e) {
            $this->logger->warning('Token validation failed during request', ['error' => $e->getMessage()]);
            
            // Log invalid token attempt
            $this->auditService->logEvent(
                'auth',
                'invalid_token_use',
                ['error' => $e->getMessage()],
                null,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return null;
        }
    }
    
    /**
     * Extract token from Authorization header or cookie
     */
    public function extractToken($request): ?string
    {
        // Handle different request formats
        if (is_string($request)) {
            // Assume $request is directly the Authorization header
            $authHeader = $request;
        } elseif (is_array($request) && isset($request['Authorization'])) {
            // Handle array format (e.g. from getHeader)
            $authHeader = $request['Authorization'];
        } elseif (is_object($request) && method_exists($request, 'getHeaderLine')) {
            // Handle PSR-7 request object
            $authHeader = $request->getHeaderLine('Authorization');
        } elseif (is_object($request) && method_exists($request, 'headers')) {
            // Handle Laravel/Symfony style request
            $authHeader = $request->headers->get('Authorization');
        } else {
            $authHeader = null;
        }
        
        // Extract token from Bearer format
        $token = null;
        if ($authHeader && strpos($authHeader, 'Bearer ') === 0) {
            $token = substr($authHeader, 7);
        }
        
        // If not found in Authorization header, check cookies
        if (!$token && isset($_COOKIE['jwt'])) {
            $token = $_COOKIE['jwt'];
        }
        
        return $token;
    }
}
=== App/Services/Auth/AuthService.php ===
<?php

namespace App\Services\Auth;

use App\Models\User;
use App\Helpers\DatabaseHelper;
use Firebase\JWT\JWT;
use App\Helpers\ExceptionHandler;
use Firebase\JWT\Key;
use Exception;
use Psr\Log\LoggerInterface;
use App\Helpers\ApiHelper;
use App\Services\Validator;
use App\Services\AuditService;

class AuthService
{
    private $pdo;
    private TokenService $tokenService;
    private ExceptionHandler $exceptionHandler;
    private LoggerInterface $logger;
    private AuditService $auditService;
    private array $encryptionConfig;
    private Validator $validator;
    private User $userModel;

    public function __construct(
        DatabaseHelper $dbHelper,
        TokenService $tokenService,
        ExceptionHandler $exceptionHandler,
        LoggerInterface $logger,
        AuditService $auditService,
        array $encryptionConfig,
        Validator $validator,
        User $userModel
    ) {
        $this->pdo = $dbHelper->getPdo();
        $this->tokenService = $tokenService;
        $this->exceptionHandler = $exceptionHandler;
        $this->logger = $logger;
        $this->auditService = $auditService;
        $this->encryptionConfig = $encryptionConfig;
        $this->validator = $validator;
        $this->userModel = $userModel;

        $this->logger->info("AuthService initialized with app_database connection");
    }

    public function login(array $data)
    {
        try {
            // Use the User model to validate password
            $user = $this->userModel->validatePassword($data['email'], $data['password']);
            $this->logger->debug("Executing login query for user email: {$data['email']}");
            
            if (!$user) {
                $this->logger->warning("Authentication failed", ['email' => $data['email']]);
                $this->auditService->logEvent(
                    'auth',
                    'Authentication failed',
                    ['email' => $data['email']],
                    null,
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
                
                throw new Exception("Invalid email or password", 401);
            }

            // Cast user array to object for TokenService
            $userObject = (object)$user;
            $this->logger->debug("User data converted to object", ['type' => gettype($userObject)]);

            $token = $this->tokenService->generateToken($userObject);
            $refreshToken = $this->tokenService->generateRefreshToken($userObject);

            // Store access token in application database
            $this->storeAccessToken($userObject->id, $token);

            // Keep audit log for successful login (security-critical)
            $this->auditService->logEvent(
                'auth',
                'Authentication successful',
                ['email' => $user['email'], 'user_id' => $user['id']],
                $user['id'],
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            // Include minimal user information in the result
            return [
                'token'         => $token,
                'refresh_token' => $refreshToken,
                'user_id'       => $user['id'],
                'name'          => $user['name'],
                'email'         => $user['email']
            ];
        } catch (Exception $e) {
            $this->logger->error("[auth] ❌ Login error: " . $e->getMessage());
            $this->exceptionHandler->handle($e); // Use handle() instead of handleException()
            throw $e;
        }
    }

    public function register(array $data)
    {
        try {
            $this->logger->info("Starting registration process", ['email' => $data['email'] ?? 'unknown']);
            
            // Define the validation rules, ensuring surname and confirm_password are required
            $rules = [
                'email'           => 'required|email|unique:users,email',
                'password'        => 'required|min:8',
                'confirm_password'=> 'required|same:password',
                'name'            => 'required|string',
                'surname'         => 'required|string', // Ensure surname is required
                'phone'           => 'string|nullable',
                'address'         => 'string|nullable',
                'pesel_or_id'     => 'string|nullable'
            ];

            // Log sanitized input data (without passwords)
            $logData = $data;
            if (isset($logData['password'])) unset($logData['password']);
            if (isset($logData['confirm_password'])) unset($logData['confirm_password']);
            $this->logger->debug("Registration input data", ['data' => $logData]);
            
            // Validate input data
            $this->validator->validate($data, $rules);
            
            // Check passwords match (redundant with validation but keeping as a double-check)
            if (!isset($data['password']) || !isset($data['confirm_password']) || $data['password'] !== $data['confirm_password']) {
                $this->logger->warning("Passwords don't match during registration");
                throw new Exception("Passwords do not match", 400);
            }
            
            // Prepare user data for creation via model
            $userData = [
                'name' => $data['name'],
                'surname' => $data['surname'],
                'email' => $data['email'],
                'password' => $data['password'], // User model will hash this
                'phone' => $data['phone'] ?? null,
                'address' => $data['address'] ?? null,
                'pesel_or_id' => $data['pesel_or_id'] ?? null,
                'role' => 'user', // Default role, only override if admin is creating the user
                'email_notifications' => $data['email_notifications'] ?? 0,
                'sms_notifications' => $data['sms_notifications'] ?? 0,
                'active' => 1,
                'created_at' => date('Y-m-d H:i:s'),
                'updated_at' => date('Y-m-d H:i:s')
            ];
            
            // Log prepared data (without password)
            $logUserData = $userData;
            unset($logUserData['password']);
            $this->logger->debug("Prepared user data for database", ['data' => $logUserData]);
            
            // Use the User model to create the user
            $userId = $this->userModel->create($userData);
            
            $this->logger->info("User registered successfully", ['user_id' => $userId, 'email' => $data['email']]);
            
            // Registration is not a security-critical event, so use logger instead of audit
            $this->logger->info("User registration completed", [
                'user_id' => $userId,
                'email' => $data['email'],
                'ip' => $_SERVER['REMOTE_ADDR'] ?? null
            ]);
            
            return ['user_id' => $userId];
        } catch (\InvalidArgumentException $e) {
            $this->logger->warning("Validation error during registration", ['error' => $e->getMessage()]);
            throw $e;
        } catch (Exception $e) {
            $this->logger->error("Registration error: " . $e->getMessage());
            $this->exceptionHandler->handle($e); // Use handle() instead of handleException()
            throw $e;
        }
    }

    public function refresh(array $data)
    {
        try {
            // Use the TokenService to decode the refresh token
            $decoded = $this->tokenService->decodeRefreshToken($data['refresh_token']);
            
            // Use the User model to find user by ID
            $user = $this->userModel->find($decoded->sub);
            $this->logger->debug("Executing refresh query for user ID: {$decoded->sub}");
            
            if (!$user) {
                $this->logger->warning("Invalid refresh token", ['token_sub' => $decoded->sub]);
                throw new Exception("Invalid refresh token", 400);
            }

            // Cast user array to object for TokenService
            $userObject = (object)$user;
            $this->logger->debug("User data converted to object for token refresh", ['type' => gettype($userObject)]);

            $token = $this->tokenService->generateToken($userObject);
            $this->logger->info("Token refreshed successfully", ['user_id' => $user['id']]);
            
            // Store new access token in application database
            $this->storeAccessToken($decoded->sub, $token);

            // Use logger instead of audit for token refresh (not security-critical)
            $this->logger->info("Token refreshed", [
                'user_id' => $user['id'],
                'ip' => $_SERVER['REMOTE_ADDR'] ?? null
            ]);
            
            return ['token' => $token];
        } catch (Exception $e) {
            $this->logger->error("Refresh token error: " . $e->getMessage());
            $this->exceptionHandler->handle($e); // Use handle() instead of handleException()
            throw $e;
        }
    }

    public function logout(array $data)
    {
        // Extract user ID from token if available
        $userId = null;
        if (!empty($data['user_id'])) {
            $userId = (int)$data['user_id'];
        }
        
        // Keep audit log for logout (security-critical event)
        $this->auditService->logEvent(
            'auth',
            'User logged out',
            [],
            $userId,
            null,
            $_SERVER['REMOTE_ADDR'] ?? null
        );
        
        return ["message" => "Logged out successfully"];
    }

    public function updateProfile($userId, array $data)
    {
        try {
            // Get current user data
            $user = $this->userModel->find($userId);
            if (!$user) {
                throw new Exception("User not found", 404);
            }
            
            // Prepare update data
            $updateData = [];
            
            // Handle fields that can be updated
            if (isset($data['name'])) {
                $updateData['name'] = $data['name'];
            }
            if (isset($data['surname'])) {
                $updateData['surname'] = $data['surname'];
            }
            if (isset($data['phone'])) {
                $updateData['phone'] = $data['phone'];
            }
            if (isset($data['address'])) {
                $updateData['address'] = $data['address'];
            }
            if (isset($data['email_notifications'])) {
                $updateData['email_notifications'] = (int)$data['email_notifications'];
            }
            if (isset($data['sms_notifications'])) {
                $updateData['sms_notifications'] = (int)$data['sms_notifications'];
            }
            
            // Only update if we have data
            if (!empty($updateData)) {
                $updateData['updated_at'] = date('Y-m-d H:i:s');
                
                // Update the user via model
                $this->userModel->update($userId, $updateData);
                
                // Use logger instead of audit for profile updates (not security-critical)
                $this->logger->info("Profile updated", [
                    'user_id' => $userId,
                    'fields_updated' => array_keys($updateData),
                    'ip' => $_SERVER['REMOTE_ADDR'] ?? null
                ]);
                
                return ["message" => "Profile updated successfully"];
            }
            
            return ["message" => "No changes to update"];
        } catch (Exception $e) {
            $this->logger->error("Update profile error: " . $e->getMessage());
            $this->exceptionHandler->handle($e); // Use handle() instead of handleException()
            throw $e;
        }
    }

    /**
     * Initiates the password reset process
     */
    public function resetPasswordRequest(array $data): array
    {
        try {
            if (!isset($data['email'])) {
                throw new Exception("Email is required", 400);
            }
            
            // Validate email format
            if (!filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
                throw new Exception("Invalid email format", 400);
            }
            
            // Use the User model to find user by email
            $user = $this->userModel->findByEmail($data['email']);
            $this->logger->debug("Executing password reset request query for email: {$data['email']}");
            
            if (!$user) {
                // Don't reveal that the email doesn't exist (security best practice)
                $this->logger->info("Password reset requested for non-existent email", ['email' => $data['email']]);
                return ["message" => "If your email is registered, you will receive a password reset link"];
            }
            
            // Generate a secure reset token
            $resetToken = bin2hex(random_bytes(32));
            $tokenExpiry = date('Y-m-d H:i:s', time() + 3600); // Token valid for 1 hour
            $ipAddress = $_SERVER['REMOTE_ADDR'] ?? null;
            
            // Store the token using a model method
            $this->userModel->createPasswordReset($user['email'], $resetToken, $ipAddress, $tokenExpiry);
            
            // Keep audit log for password reset request (security-critical)
            $this->auditService->logEvent(
                'auth',
                'Password reset requested',
                ['email' => $user['email']],
                $user['id'],
                null,
                $ipAddress
            );
            
            // In a real application, you would send an email here
            // For this example, we'll just return the token (not secure for production)
            return [
                "message" => "Password reset email sent",
                "debug_token" => $resetToken // Remove this in production!
            ];
        } catch (Exception $e) {
            $this->logger->error("Password reset request error: " . $e->getMessage());
            $this->exceptionHandler->handle($e); // Use handle() instead of handleException()
            throw $e;
        }
    }

    /**
     * Completes the password reset process
     */
    public function resetPassword(array $data): array
    {
        try {
            // Validate required fields
            if (!isset($data['token']) || !isset($data['password']) || !isset($data['confirm_password'])) {
                throw new Exception("Token, password and confirmation are required", 400);
            }
            
            // Validate password
            if (strlen($data['password']) < 8) {
                throw new Exception("Password must be at least 8 characters", 400);
            }
            
            // Check passwords match
            if ($data['password'] !== $data['confirm_password']) {
                throw new Exception("Passwords do not match", 400);
            }
            
            // Verify token using the User model
            $tokenRecord = $this->userModel->verifyResetToken($data['token']);
            $this->logger->debug("Verifying reset token: {$data['token']}");
            
            if (!$tokenRecord) {
                throw new Exception("Invalid or expired token", 400);
            }
            
            // Get user via model
            $user = $this->userModel->findByEmail($tokenRecord['email']);
            $this->logger->debug("Retrieving user for password reset, email: {$tokenRecord['email']}");
            
            if (!$user) {
                throw new Exception("User not found", 404);
            }
            
            // Update the password via User model
            $this->userModel->updatePassword($user['id'], $data['password']);
            $this->logger->debug("Updating password for user ID: {$user['id']}");
            
            // Mark token as used via model
            $this->userModel->markResetTokenUsed($tokenRecord['id']);
            
            // Keep audit log for password reset completion (security-critical)
            $this->auditService->logEvent(
                'auth',
                'Password reset completed',
                ['email' => $user['email']],
                $user['id'],
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return ["message" => "Password has been reset successfully"];
        } catch (Exception $e) {
            $this->logger->error("Password reset error: " . $e->getMessage());
            $this->exceptionHandler->handle($e); // Use handle() instead of handleException()
            throw $e;
        }
    }

    /**
     * Validate a token from the request
     */
    public function validateRequest(?string $authHeader = null): ?object
    {
        return $this->tokenService->validateRequest($authHeader);
    }

    private function storeAccessToken(int $userId, string $accessToken): void
    {
        try {
            // Store the token in the access_tokens table using app db helper
            $appDb = DatabaseHelper::getInstance();
            $appDb->insert('access_tokens', [
                'user_id' => $userId,
                'token' => hash('sha256', $accessToken), // Store hashed token for security
                'expires_at' => date('Y-m-d H:i:s', time() + 3600),
                'created_at' => date('Y-m-d H:i:s')
            ]);
            
            $this->logger->info("[auth] Access token stored in application database", ['user_id' => $userId]);
        } catch (\Exception $e) {
            $this->logger->error("[auth] Failed to store access token: " . $e->getMessage());
            $this->exceptionHandler->handle($e); // Use handle() instead of handleException()
            // Continue without failing - JWT will still work even if storage fails
        }
    }
}
?>
=== App/Services/DocumentService.php ===
<?php

namespace DocumentManager\Services;

use Exception;
use App\Helpers\DatabaseHelper;
use AuditManager\Services\AuditService;
use DocumentManager\Services\FileStorage;
use DocumentManager\Services\TemplateService;
use App\Services\EncryptionService;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use App\Models\Document;
use App\Models\DocumentTemplate;
use App\Models\Contract;
use App\Models\User;
use App\Models\Booking;

/**
 * Document Service
 *
 * Manages documents including templates, contracts, and Terms & Conditions (T&C).
 * Supports encryption, secure storage, logging, and dynamic document generation.
 */
class DocumentService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private DatabaseHelper $db;
    private AuditService $auditService;
    private FileStorage $fileStorage;
    private EncryptionService $encryptionService;
    private TemplateService $templateService;
    private Document $documentModel;
    private DocumentTemplate $templateModel;
    private Contract $contractModel;
    private User $userModel;
    private Booking $bookingModel;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        DatabaseHelper $db,
        AuditService $auditService,
        FileStorage $fileStorage,
        EncryptionService $encryptionService,
        TemplateService $templateService,
        Document $documentModel,
        DocumentTemplate $templateModel,
        Contract $contractModel,
        User $userModel,
        Booking $bookingModel
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->db = $db;
        $this->auditService = $auditService;
        $this->fileStorage = $fileStorage;
        $this->encryptionService = $encryptionService;
        $this->templateService = $templateService;
        $this->documentModel = $documentModel;
        $this->templateModel = $templateModel;
        $this->contractModel = $contractModel;
        $this->userModel = $userModel;
        $this->bookingModel = $bookingModel;
    }

    /**
     * Upload a document template.
     */
    public function uploadTemplate(string $name, string $content): void
    {
        $this->processTemplate($name, $content, 'template_uploaded');
    }

    /**
     * Upload the Terms & Conditions document.
     */
    public function uploadTerms(string $content): void
    {
        $this->processTemplate('terms_and_conditions', $content, 'terms_uploaded');
    }

    /**
     * Process template storage and logging.
     */
    private function processTemplate(string $name, string $content, string $logAction): void
    {
        try {
            if (self::DEBUG_MODE) {
                $this->logger->info("[Document] Uploading template: {$name}");
            }
            
            $encryptedContent = $this->encryptionService->encrypt($content);
            $filePath = $this->fileStorage->storeFile("templates", "{$name}.html", $encryptedContent);
            
            // Use template model instead of direct DB access
            $existingTemplate = $this->templateModel->findByName($name);
            
            if ($existingTemplate) {
                // Update existing template
                $this->templateModel->update($existingTemplate['id'], [
                    'content' => $encryptedContent,
                    'file_path' => $filePath,
                    'updated_at' => date('Y-m-d H:i:s')
                ]);
            } else {
                // Create new template
                $this->templateModel->create([
                    'name' => $name,
                    'content' => $encryptedContent,
                    'file_path' => $filePath,
                    'created_at' => date('Y-m-d H:i:s'),
                    'updated_at' => date('Y-m-d H:i:s')
                ]);
            }
            
            // Business-level audit logging - template operations are important business events
            $this->auditService->log($logAction, ['template' => $name]);
            
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Upload template exception: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to upload template: {$name} " . $e->getMessage());
        }
    }

    /**
     * Generate a rental contract document dynamically.
     */
    public function generateContract(int $bookingId, int $userId): string
    {
        try {
            if (self::DEBUG_MODE) {
                $this->logger->info("[Document] Generating contract for booking {$bookingId}");
            }

            // Load the contract template using template model
            $templateData = $this->templateModel->findByName('rental_contract');
            if (!$templateData) {
                throw new Exception("Contract template not found");
            }
            
            // Get user and booking data using models
            $userData = $this->userModel->find($userId);
            $bookingData = $this->bookingModel->find($bookingId);
            
            if (!$userData || !$bookingData) {
                throw new Exception("User or booking data not found");
            }

            // Prepare data for template rendering
            $data = array_merge($userData, $bookingData);
            
            // Decrypt template content and render with data
            $templateContent = $this->encryptionService->decrypt($templateData['content']);
            $renderedContent = $this->templateService->renderTemplateContent($templateContent, $data);

            // Encrypt the rendered content
            $encryptedContract = $this->encryptionService->encrypt($renderedContent);
            
            // Store the file
            $filePath = $this->fileStorage->storeFile("contracts", "contract_{$bookingId}.pdf", $encryptedContract);

            // Store contract record using contract model
            $this->contractModel->create([
                'booking_id'  => $bookingId,
                'user_id'     => $userId,
                'contract_pdf'=> $filePath,
                'created_at'  => date('Y-m-d H:i:s')
            ]);

            // Business-level audit log for contract generation - important business event
            $this->auditService->log('contract_generated', [
                'booking_id' => $bookingId, 
                'user_id' => $userId
            ]);

            return $filePath;
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Contract generation error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Retrieve and decrypt a document.
     */
    public function retrieveDocument(string $filePath): string
    {
        try {
            if (self::DEBUG_MODE) {
                $this->logger->info("[Document] Retrieving document from {$filePath}");
            }

            $encryptedContent = $this->fileStorage->retrieveFile($filePath);
            $decryptedContent = $this->encryptionService->decrypt($encryptedContent);

            // Business-level audit log for document retrieval - security-sensitive event
            $this->auditService->log('document_retrieved', ['file_path' => $filePath]);

            return $decryptedContent;
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Retrieve document error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to retrieve document " . $e->getMessage());
        }
    }

    /**
     * Delete a document.
     */
    public function deleteDocument(int $documentId): void
    {
        try {
            if (self::DEBUG_MODE) {
                $this->logger->info("[Document] Deleting document ID {$documentId}");
            }

            // Get document using model
            $document = $this->documentModel->find($documentId);

            if (!$document) {
                throw new Exception("Document not found.");
            }

            // Delete the physical file
            $this->fileStorage->deleteFile($document['file_path']);
            
            // Delete the document record using model
            $this->documentModel->delete($documentId);

            // Business-level audit log for document deletion - security-sensitive event
            $this->auditService->log('document_deleted', ['document_id' => $documentId]);
            
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Delete document error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to delete document " . $e->getMessage());
        }
    }

    /**
     * Get a list of available templates.
     */
    public function getTemplates(): array
    {
        try {
            // Use template model to get all templates
            $templates = $this->templateModel->getAll();
            
            // Return only necessary information, not the entire model
            return array_map(function($template) {
                return [
                    'id' => $template['id'],
                    'name' => $template['name'],
                    'created_at' => $template['created_at'],
                    'updated_at' => $template['updated_at']
                ];
            }, $templates);
            
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Get templates error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
    
    /**
     * Get a specific template by ID.
     */
    public function getTemplateById(int $templateId): array
    {
        try {
            // Use template model to get template by ID
            $template = $this->templateModel->find($templateId);
            
            if (!$template) {
                throw new Exception("Template not found.");
            }
            
            // Decrypt the content for use
            $template['content'] = $this->encryptionService->decrypt($template['content']);
            
            return $template;
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Get template error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
    
    /**
     * Get contracts for a specific user.
     */
    public function getUserContracts(int $userId): array
    {
        try {
            // Use contract model to get user contracts
            $contracts = $this->contractModel->getByUserId($userId);
            
            return $contracts;
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Get user contracts error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
    
    /**
     * Get contract for a specific booking.
     */
    public function getBookingContract(int $bookingId): array
    {
        try {
            // Use contract model to get booking contract
            $contract = $this->contractModel->getByBookingId($bookingId);
            
            if (!$contract) {
                throw new Exception("Contract not found for booking.");
            }
            
            return $contract;
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Get booking contract error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
}
=== App/Services/NotificationService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use App\Models\Notification;
use Psr\Log\LoggerInterface;
use PHPMailer\PHPMailer\PHPMailer;
use PHPMailer\PHPMailer\Exception;
use App\Helpers\ExceptionHandler;

/**
 * NotificationService
 *
 * Handles various notification types (email, SMS, webhook, push notifications).
 */
class NotificationService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private array $config;
    private DatabaseHelper $db;
    private Notification $notificationModel;

    public function __construct(
        LoggerInterface $logger, 
        ExceptionHandler $exceptionHandler, 
        DatabaseHelper $db, 
        Notification $notificationModel,
        array $config
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->db = $db;
        $this->notificationModel = $notificationModel;
        $this->config = $config;
    }

    /**
     * Send a notification
     */
    public function sendNotification(int $userId, string $type, string $message, array $options = []): bool
    {
        try {
            $this->storeNotification($userId, $type, $message);
            // Log notification preparation
            if (self::DEBUG_MODE) {
                $this->logger->info('Notification prepared for dispatch', ['user_id' => $userId, 'type' => $type]);
            }
            return $this->dispatchNotification($userId, $type, $message, $options);
        } catch (\Exception $e) {
            $this->logger->error('Failed to send notification', ['error' => $e->getMessage()]);
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Store notification in the database
     */
    private function storeNotification(int $userId, string $type, string $message): void
    {
        try {
            // Create the notification record
            $this->notificationModel->create([
                'user_id' => $userId,
                'type'    => $type,
                'message' => $message,
                'sent_at' => date('Y-m-d H:i:s'),
                'is_read' => false,
            ]);
            
            if (self::DEBUG_MODE) {
                $this->logger->info("Notification stored in database", [
                    'user_id' => $userId, 
                    'type' => $type
                ]);
            }
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ storeNotification error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function getUserNotifications(int $userId): array
    {
        try {
            // Get user notifications
            $notifications = $this->notificationModel->getByUserId($userId);
            
            // Log retrieval
            if (self::DEBUG_MODE) {
                $this->logger->info("[Notification] Retrieved notifications for user {$userId}");
            }
            
            return $notifications;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ getUserNotifications error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function markAsRead(int $notificationId): bool
    {
        try {
            // Mark notification as read
            $result = $this->notificationModel->markAsRead($notificationId);
            
            // Log the action
            if (self::DEBUG_MODE && $result) {
                $this->logger->info("[Notification] Marked notification {$notificationId} as read");
            }
            
            return $result;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ markAsRead error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function deleteNotification(int $notificationId): bool
    {
        try {
            // Delete notification
            $result = $this->notificationModel->delete($notificationId);
            
            // Log the deletion
            if (self::DEBUG_MODE && $result) {
                $this->logger->info("[Notification] Deleted notification {$notificationId}");
            }
            
            return $result;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ deleteNotification error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function markAllAsRead(int $userId): bool
    {
        try {
            // Mark all notifications as read
            $result = $this->notificationModel->markAllAsRead($userId);
            
            // Log the action
            if (self::DEBUG_MODE && $result) {
                $this->logger->info("[Notification] Marked all notifications as read for user {$userId}");
            }
            
            return $result;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ markAllAsRead error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Dispatch the appropriate notification method
     */
    private function dispatchNotification(int $userId, string $type, string $message, array $options): bool
    {
        $result = false;
        
        try {
            $result = match ($type) {
                'email' => $this->sendEmail($options['email'] ?? '', $message, $options['subject'] ?? 'Notification'),
                'sms' => $this->sendSMS($options['phone'] ?? '', $message),
                'webhook' => $this->sendWebhook($options['url'] ?? '', $message),
                'push' => $this->sendPushNotification($options['device_token'] ?? '', $message),
                default => throw new \InvalidArgumentException("Unsupported notification type: $type"),
            };
            
            // Business-level logging of success/failure
            if (self::DEBUG_MODE) {
                if ($result) {
                    $this->logger->info("[Notification] Successfully sent {$type} notification to user {$userId}");
                } else {
                    $this->logger->warning("[Notification] Failed to send {$type} notification to user {$userId}");
                }
            }
            
            return $result;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ Dispatch error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Send an email using PHPMailer
     */
    private function sendEmail(string $to, string $message, string $subject): bool
    {
        if (empty($to)) return false;

        try {
            $mail = new PHPMailer(true);
            $mail->isSMTP();
            $mail->Host = $this->config['smtp_host'];
            $mail->SMTPAuth = true;
            $mail->Username = $this->config['smtp_user'];
            $mail->Password = $this->config['smtp_password'];
            $mail->SMTPSecure = $this->config['smtp_secure'] ?? 'tls';
            $mail->Port = $this->config['smtp_port'];
            $mail->setFrom($this->config['from_email'], $this->config['from_name']);
            $mail->addAddress($to);
            $mail->Subject = $subject;
            $mail->isHTML(true);
            $mail->Body = "<p>$message</p>";
            $mail->send();

            // Business-level logging only - no need for audit here
            if (self::DEBUG_MODE) {
                $this->logger->info("[Notification] Email sent to {$to}");
            }

            return true;
        } catch (Exception $e) {
            $this->logger->error("[Notification] ❌ Email error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Send an SMS
     */
    private function sendSMS(string $phone, string $message): bool
    {
        if (empty($phone)) return false;

        try {
            // SMS implementation code would go here
            
            // Business-level logging only
            if (self::DEBUG_MODE) {
                $this->logger->info("[Notification] SMS sent to {$phone}");
            }
            return true;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ SMS error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Send a webhook notification
     */
    private function sendWebhook(string $url, string $message): bool
    {
        if (empty($url)) return false;

        try {
            $ch = curl_init($url);
            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
            curl_setopt($ch, CURLOPT_POST, true);
            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode(['message' => $message]));
            curl_setopt($ch, CURLOPT_HTTPHEADER, ['Content-Type: application/json']);
            $response = curl_exec($ch);
            curl_close($ch);

            // Business-level logging only
            if (self::DEBUG_MODE && $response !== false) {
                $this->logger->info("[Notification] Webhook sent to {$url}");
            }

            return $response !== false;
        } catch (\Exception $e) {
            $this->logger->error('[Notification] ❌ Webhook error: ' . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Send a push notification
     */
    private function sendPushNotification(string $deviceToken, string $message): bool
    {
        if (empty($deviceToken)) return false;

        try {
            $payload = [
                'to' => $deviceToken,
                'notification' => ['title' => 'Notification', 'body' => $message],
            ];
            
            $result = $this->sendFCMRequest($payload);
            
            // Business-level logging only
            if (self::DEBUG_MODE && $result) {
                $this->logger->info("[Notification] Push notification sent to device {$deviceToken}");
            }
            
            return $result;
        } catch (\Exception $e) {
            $this->logger->error('[Notification] ❌ Push notification error: ' . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Send Firebase Cloud Messaging (FCM) request
     */
    private function sendFCMRequest(array $payload): bool
    {
        $ch = curl_init('https://fcm.googleapis.com/fcm/send');
        curl_setopt($ch, CURLOPT_HTTPHEADER, [
            'Content-Type: application/json',
            'Authorization: key=' . $this->config['fcm_api_key'],
        ]);
        curl_setopt($ch, CURLOPT_POST, true);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($payload));
        $response = curl_exec($ch);

        curl_close($ch);
        return $response !== false;
    }
    
    /**
     * Get notification by ID
     */
    public function getNotificationById(int $id): ?array
    {
        try {
            $notification = $this->notificationModel->find($id);
            
            if (self::DEBUG_MODE && $notification) {
                $this->logger->info("[Notification] Retrieved notification by ID", ['id' => $id]);
            }
            
            return $notification;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ getNotificationById error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }
    
    /**
     * Get unread notifications count for user
     */
    public function getUnreadCount(int $userId): int
    {
        try {
            $count = $this->notificationModel->getUnreadCount($userId);
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Notification] Retrieved unread count for user", [
                    'user_id' => $userId, 
                    'count' => $count
                ]);
            }
            
            return $count;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ getUnreadCount error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return 0;
        }
    }
}
=== App/Services/AuditService.php ===
<?php

namespace App\Services;

use Exception;
use DateTimeImmutable;
use Ramsey\Uuid\Uuid;
use App\Helpers\DatabaseHelper;
use App\Helpers\LogLevelFilter;
use App\Helpers\ExceptionHandler;
use App\Helpers\SecurityHelper;
use App\Services\Audit\LogManagementService;
use App\Services\Audit\UserAuditService;
use App\Services\Audit\TransactionAuditService;
use App\Services\Audit\FraudAnalysisService;
use Psr\Log\LoggerInterface;

class AuditService
{
    // Categories and log levels remain unchanged
    public const CATEGORY_SYSTEM       = 'system';
    public const CATEGORY_AUTH         = 'auth';
    public const CATEGORY_TRANSACTION  = 'transaction';
    public const CATEGORY_BOOKING      = 'booking';
    public const CATEGORY_USER         = 'user';
    public const CATEGORY_ADMIN        = 'admin';
    public const CATEGORY_DOCUMENT     = 'document';
    public const CATEGORY_API          = 'api';
    public const CATEGORY_SECURITY     = 'security';
    public const CATEGORY_PAYMENT      = 'payment';
    
    public const LOG_LEVEL_DEBUG       = 'debug';
    public const LOG_LEVEL_INFO        = 'info';
    public const LOG_LEVEL_WARNING     = 'warning';
    public const LOG_LEVEL_ERROR       = 'error';
    public const LOG_LEVEL_CRITICAL    = 'critical';
    
    private const VALID_CATEGORIES = [
        self::CATEGORY_SYSTEM, self::CATEGORY_AUTH, self::CATEGORY_TRANSACTION,
        self::CATEGORY_BOOKING, self::CATEGORY_USER, self::CATEGORY_ADMIN,
        self::CATEGORY_DOCUMENT, self::CATEGORY_API, self::CATEGORY_SECURITY,
        self::CATEGORY_PAYMENT,
    ];
    
    private const CATEGORY_MAP = [
        self::CATEGORY_AUTH       => 'user',
        self::CATEGORY_USER       => 'user',
        self::CATEGORY_SYSTEM     => 'user',
        self::CATEGORY_API        => 'user',
        self::CATEGORY_SECURITY   => 'user', 
        self::CATEGORY_TRANSACTION=> 'transaction',
        self::CATEGORY_PAYMENT    => 'transaction'
    ];
    
    // Configuration constants
    public const DEBUG_MODE = true;
    
    // Injected services
    private DatabaseHelper $db;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private LogLevelFilter $logLevelFilter;
    private string $requestId;
    
    // Subservices - now created once and injected
    private LogManagementService $logManager;
    private UserAuditService $userAuditService;
    private TransactionAuditService $transactionAuditService;
    private FraudAnalysisService $fraudAnalysisService;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        DatabaseHelper $db,
        LogLevelFilter $logLevelFilter = null
    ) {
        $this->db = $db;
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->logLevelFilter = $logLevelFilter ?? new LogLevelFilter();
        $this->requestId = Uuid::uuid4()->toString();
        
        // Create all subservices once during initialization
        $this->logManager = new LogManagementService($logger, $this->requestId);
        $this->fraudAnalysisService = new FraudAnalysisService();
        $this->userAuditService = new UserAuditService($this->logManager);
        $this->transactionAuditService = new TransactionAuditService($this->logManager, $this->fraudAnalysisService);
        
        if (self::DEBUG_MODE) {
            $this->logger->debug("[Audit] Service initialized", [
                'request_id' => $this->requestId,
                'database' => $db === DatabaseHelper::getSecureInstance() ? 'secure_db' : 'app_db'
            ]);
        }
    }
    
    public function getRequestId(): string
    {
        return $this->requestId;
    }
    
    /**
     * Main entry point to log an event.
     */
    public function logEvent(
        string $category, 
        string $message, 
        array $context = [], 
        ?int $userId = null, 
        ?int $bookingId = null, 
        ?string $ipAddress = null,
        string $logLevel = self::LOG_LEVEL_INFO
    ): ?int {
        if (!$this->logLevelFilter->shouldLog($logLevel)) {
            return null;
        }
        
        try {
            $normalizedCat = $this->normalizeCategory($category);
            $context = $this->sanitizeContext($context);
            $context['request_id'] = $this->requestId;
            
            // Route to appropriate subservice based on category
            $serviceKey = self::CATEGORY_MAP[$normalizedCat] ?? null;
            
            if ($serviceKey === 'user') {
                // Use injected UserAuditService
                return $this->userAuditService->logEvent(
                    $normalizedCat, 
                    $context['action'] ?? '',
                    $message, 
                    $context,
                    $userId, 
                    $logLevel
                );
            }
            
            if ($serviceKey === 'transaction') {
                // Use injected TransactionAuditService
                return $this->transactionAuditService->logEvent(
                    $normalizedCat, 
                    $message, 
                    $context, 
                    $userId, 
                    $bookingId, 
                    $logLevel
                );
            }
            
            // Default direct logging for uncategorized events
            return $this->logManager->createLogEntry(
                $normalizedCat,
                $message,
                $context,
                $userId,
                $bookingId,
                $ipAddress,
                $logLevel
            );
            
        } catch (Exception $e) {
            $this->logger->error("[Audit] Logging failed: " . $e->getMessage(), [
                'request_id' => $this->requestId,
                'category' => $category,
                'error' => $e->getMessage()
            ]);
            $this->exceptionHandler->handleException($e);
            if (self::DEBUG_MODE) {
                throw new Exception('Failed to log audit event: ' . $e->getMessage());
            }
            return null;
        }
    }
    
    /**
     * Normalize and validate a category
     */
    private function normalizeCategory(string $category): string {
        $normalizedCat = strtolower(trim($category));
        if (!in_array($normalizedCat, self::VALID_CATEGORIES, true)) {
            $normalizedCat = self::CATEGORY_SYSTEM;
            if (self::DEBUG_MODE) {
                $this->logger->warning("[Audit] Invalid category", [
                    'request_id' => $this->requestId,
                    'invalid' => $category,
                    'default' => $normalizedCat
                ]);
            }
        }
        return $normalizedCat;
    }
    
    /**
     * Legacy method - remains for backward compatibility
     */
    public function recordEvent(
        string $category,
        string $action,
        string $message,
        array $context = [],
        ?int $userId = null,
        ?int $objectId = null,
        string $logLevel = self::LOG_LEVEL_INFO
    ): ?int {
        // ...forwarding to logEvent...
        $eventContext = array_merge($context, [
            'action' => $action,
            'timestamp' => (new DateTimeImmutable())->format('Y-m-d H:i:s'),
            'object_id' => $objectId
        ]);
        return $this->logEvent(
            $category,
            $message,
            $eventContext,
            $userId,
            $category === self::CATEGORY_BOOKING ? $objectId : null,
            null,
            $logLevel
        );
    }
    
    // All legacy methods remain as simple forwarders to logEvent
    // Each method like recordPaymentSuccess, logAuthEvent, etc. stays for backward compatibility
    public function recordPaymentSuccess(array $paymentData): ?int {
        return $this->logEvent(
            self::CATEGORY_PAYMENT,
            "Payment processed successfully",
            array_merge($paymentData, ['event_type' => 'payment_success']),
            $paymentData['user_id'] ?? null,
            $paymentData['booking_id'] ?? null,
            null,
            self::LOG_LEVEL_INFO
        );
    }
    
    public function logAuthEvent(string $action, string $message, array $context = [], ?int $userId = null, string $logLevel = self::LOG_LEVEL_INFO): ?int {
        $context['action'] = $action;
        return $this->logEvent(self::CATEGORY_AUTH, $message, $context, $userId, null, null, $logLevel);
    }
    
    // Delegate log management operations to LogManagementService
    public function getLogs(array $filters = []): array {
        return $this->logManager->getLogs($filters);
    }
    
    public function deleteLogs(array $filters, bool $forceBulkDelete = false): int {
        return $this->logManager->deleteLogs($filters, $forceBulkDelete);
    }
    
    public function exportLogs(array $filters): array {
        return $this->logManager->exportLogs($filters);
    }
    
    public function getLogById(int $logId): ?array {
        return $this->logManager->getLogById($logId);
    }
    
    // Helper methods
    private function sanitizeContext(array $context): array {
        // ...existing sanitization...
        $sensitiveKeys = ['password', 'secret', 'token', 'auth', 'key', 'apiKey', 'api_key', 'credential', 'credit_card', 'card_number', 'cvv', 'ssn'];
        $sanitized = [];
        
        foreach ($context as $key => $value) {
            if ($value === null) {
                continue;
            }
            
            $keyLower = strtolower($key);
            $isSensitive = false;
            foreach ($sensitiveKeys as $sensitiveKey) {
                if (strpos($keyLower, $sensitiveKey) !== false) {
                    $isSensitive = true;
                    break;
                }
            }
            
            if ($isSensitive) {
                $sanitized[$key] = '[REDACTED]';
            } elseif (is_array($value)) {
                $sanitized[$key] = $this->sanitizeContext($value);
            } else {
                $sanitized[$key] = $value;
            }
        }
        
        return $sanitized;
    }
    
    private function getClientIp(): string {
        // ...existing IP detection...
        foreach (['HTTP_X_FORWARDED_FOR', 'HTTP_CLIENT_IP'] as $header) {
            if (!empty($_SERVER[$header])) {
                $ips = explode(',', $_SERVER[$header]);
                $ip = trim($ips[0]);
                if (filter_var($ip, FILTER_VALIDATE_IP)) {
                    return $ip;
                }
            }
        }
        return $_SERVER['REMOTE_ADDR'] ?? '0.0.0.0';
    }
}
=== App/Services/Payment/PaymentProcessingService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use App\Models\Payment;
use App\Models\Booking;
use App\Models\TransactionLog;
use App\Services\AuditService;
use App\Logging\LoggerInterface;
use Exception;

class PaymentProcessingService
{
    /**
     * Handles payment initiation, validation, database transactions,
     * and logging for successful or failed payments.
     *
     * @author 
     * @version 1.0
     * @description
     *   - PaymentValidation & Payment Initiation
     *   - Transaction handling (beginTransaction, commit/rollback)
     *   - Stores payment record in Payment model
     *   - Updates booking status in Booking model
     *   - Logs transaction in TransactionLog model
     *   - Uses AuditService for successful payment and fraud validation
     *   - Uses LoggerInterface for API failures and debugging
     */
    private DatabaseHelper $dbHelper;
    private Payment $paymentModel;
    private Booking $bookingModel;
    private TransactionLog $transactionLogModel;
    private AuditService $auditService;
    private LoggerInterface $logger;

    /**
     * Constructor injects all necessary dependencies for payment processing.
     */
    public function __construct(
        DatabaseHelper $dbHelper,
        Payment $paymentModel,
        Booking $bookingModel,
        TransactionLog $transactionLogModel,
        AuditService $auditService,
        LoggerInterface $logger
    ) {
        $this->dbHelper = $dbHelper;
        $this->paymentModel = $paymentModel;
        $this->bookingModel = $bookingModel;
        $this->transactionLogModel = $transactionLogModel;
        $this->auditService = $auditService;
        $this->logger = $logger;
    }

    /**
     * Main method for processing a payment.
     * 
     * @param array $paymentData
     *   Example structure: [
     *       'booking_id' => 123,
     *       'amount'     => 500.00,
     *       'currency'   => 'USD',
     *       'payment_method' => 'stripe',
     *       'customer_id' => 456,
     *       // Other relevant data...
     *   ]
     * @return array
     *   Return a standardized response, e.g. ['status' => 'success', 'payment_id' => XYZ]
     * @throws Exception
     *   In case of transaction failure or invalid data
     */
    public function processPayment(array $paymentData): array
    {
        // Perform comprehensive fraud validation before processing
        $fraudCheckResult = $this->performFraudValidation($paymentData);
        if (!$fraudCheckResult['valid']) {
            $this->logger->error('Payment rejected: Potential fraud detected', [
                'payment_data' => $paymentData,
                'fraud_indicators' => $fraudCheckResult['indicators']
            ]);
            
            // Log the fraud attempt with detailed information for investigation
            $this->auditService->logEvent(
                'security', 
                'fraud_attempt', 
                [
                    'payment_data' => $paymentData,
                    'fraud_indicators' => $fraudCheckResult['indicators'],
                    'risk_score' => $fraudCheckResult['risk_score'] ?? null,
                    'ip_address' => $_SERVER['REMOTE_ADDR'] ?? null,
                    'timestamp' => date('Y-m-d H:i:s')
                ],
                $paymentData['user_id'] ?? null,
                $paymentData['booking_id'] ?? null
            );
            
            throw new Exception('Payment rejected due to fraud indicators: ' . 
                implode(', ', $fraudCheckResult['indicators']));
        }

        // Start DB transaction
        $this->dbHelper->beginTransaction();

        try {
            // 1. Create Payment record
            $paymentId = $this->paymentModel->createPayment($paymentData);

            // 2. Update Booking status using the updateStatus method
            $this->bookingModel->updateStatus($paymentData['booking_id'], 'paid');

            // 3. Insert Transaction Log entry
            $this->transactionLogModel->logTransaction([
                'payment_id' => $paymentId,
                'booking_id' => $paymentData['booking_id'],
                'amount' => $paymentData['amount'],
                'currency' => $paymentData['currency'],
                'status' => 'completed',
                'description' => 'Payment processed successfully.',
            ]);

            // 4. Commit transaction
            $this->dbHelper->commit();

            // 5. Audit successful payment with enhanced audit data
            $auditPaymentData = array_merge($paymentData, [
                'payment_id' => $paymentId,
                'timestamp' => date('Y-m-d H:i:s'),
                'status' => 'completed',
                'ip_address' => $_SERVER['REMOTE_ADDR'] ?? null
            ]);
            
            $this->auditService->recordPaymentSuccess($auditPaymentData);

            // Return success response
            return [
                'status' => 'success',
                'payment_id' => $paymentId,
                'message' => 'Payment processed successfully.'
            ];
        } catch (Exception $e) {
            // Roll back on any failure
            $this->dbHelper->rollback();

            // Log the error
            $this->logger->error('Payment processing failed', [
                'error' => $e->getMessage(),
                'data'  => $paymentData
            ]);

            // Rethrow or handle exception
            throw $e;
        }
    }

    /**
     * Perform comprehensive fraud validation on payment data
     * 
     * @param array $paymentData
     * @return array Result with validation status and fraud indicators
     */
    private function performFraudValidation(array $paymentData): array
    {
        $fraudIndicators = [];
        $riskScore = 0;
        
        // 1. Required field validation
        if (empty($paymentData['booking_id'])) {
            $fraudIndicators[] = 'missing_booking_id';
            $riskScore += 25;
        }
        
        if (empty($paymentData['amount']) || !is_numeric($paymentData['amount']) || $paymentData['amount'] <= 0) {
            $fraudIndicators[] = 'invalid_amount';
            $riskScore += 25;
        }
        
        if (empty($paymentData['currency'])) {
            $fraudIndicators[] = 'missing_currency';
            $riskScore += 15;
        }
        
        // 2. Velocity checks - too many transactions in short period
        if (!empty($paymentData['user_id'])) {
            $recentTransactions = $this->getRecentUserTransactions(
                $paymentData['user_id'], 
                15  // Look back 15 minutes
            );
            
            if (count($recentTransactions) > 5) {
                $fraudIndicators[] = 'transaction_velocity';
                $riskScore += 30;
            }
        }
        
        // 3. Amount threshold checks
        if (!empty($paymentData['amount'])) {
            // Unusually large payment
            if ($paymentData['amount'] > 10000) {
                $fraudIndicators[] = 'large_amount';
                $riskScore += 20;
            }
            
            // Round amount (often used in testing fraud)
            if ($paymentData['amount'] == round($paymentData['amount'])) {
                $fraudIndicators[] = 'round_amount';
                $riskScore += 5;
            }
        }
        
        // 4. IP address reputation check (pseudocode - implement with actual service)
        if (!empty($_SERVER['REMOTE_ADDR'])) {
            $ipReputation = $this->checkIpReputation($_SERVER['REMOTE_ADDR']);
            if ($ipReputation === 'suspicious') {
                $fraudIndicators[] = 'suspicious_ip';
                $riskScore += 40;
            } elseif ($ipReputation === 'high_risk') {
                $fraudIndicators[] = 'high_risk_ip';
                $riskScore += 70;
            }
        }
        
        // 5. Check if user account is flagged for suspicious activity
        if (!empty($paymentData['user_id'])) {
            $userFlags = $this->getUserFlags($paymentData['user_id']);
            if (in_array('suspicious_activity', $userFlags)) {
                $fraudIndicators[] = 'flagged_account';
                $riskScore += 50;
            }
        }
        
        // Determine validation result based on risk score and critical indicators
        $isValid = $riskScore < 50 && count($fraudIndicators) < 2;
        
        // Log for troubleshooting/tuning
        if ($riskScore > 30) {
            $this->logger->info('Elevated risk score in payment', [
                'risk_score' => $riskScore,
                'indicators' => $fraudIndicators,
                'user_id' => $paymentData['user_id'] ?? null
            ]);
        }
        
        return [
            'valid' => $isValid,
            'indicators' => $fraudIndicators,
            'risk_score' => $riskScore
        ];
    }
    
    /**
     * Get recent transactions from a specific user
     * 
     * @param int $userId User ID
     * @param int $minutesBack Minutes to look back
     * @return array Recent transactions
     */
    private function getRecentUserTransactions(int $userId, int $minutesBack = 15): array
    {
        $timestamp = date('Y-m-d H:i:s', time() - ($minutesBack * 60));
        
        $query = "SELECT * FROM transaction_logs 
                 WHERE user_id = :user_id 
                 AND created_at > :timestamp";
                 
        return $this->dbHelper->select($query, [
            ':user_id' => $userId,
            ':timestamp' => $timestamp
        ]);
    }
    
    /**
     * Check IP address reputation
     * 
     * @param string $ipAddress IP address to check
     * @return string Reputation score (safe, suspicious, high_risk)
     */
    private function checkIpReputation(string $ipAddress): string
    {
        // In a production environment, this would call an IP reputation service
        // such as MaxMind, IPQualityScore, or similar
        
        // For now, return safe for most IPs, with some randomized suspicious ones
        if (substr($ipAddress, 0, 3) === '10.' || substr($ipAddress, 0, 4) === '192.') {
            return 'safe'; // Most internal IPs are safe
        }
        
        // Very basic sample implementation - replace with actual service
        $ipHash = crc32($ipAddress);
        if ($ipHash % 100 < 3) {
            return 'high_risk';
        } elseif ($ipHash % 100 < 10) {
            return 'suspicious';
        }
        
        return 'safe';
    }
    
    /**
     * Get user account flags from security system
     * 
     * @param int $userId User ID
     * @return array List of user flags
     */
    private function getUserFlags(int $userId): array
    {
        // In production, fetch from user_security_flags table or similar
        // For now, we'll return empty array for most users
        
        // Example implementation - check if user has had chargebacks
        $query = "SELECT COUNT(*) as count FROM transaction_logs 
                 WHERE user_id = :user_id AND type = 'chargeback'";
                 
        $result = $this->dbHelper->select($query, [':user_id' => $userId]);
        if (isset($result[0]['count']) && $result[0]['count'] > 0) {
            return ['chargeback_history'];
        }
        
        return [];
    }

    /**
     * Basic check to ensure payment data meets minimal criteria.
     * This could be extended for additional fraud checks or data validation.
     * @deprecated Use performFraudValidation instead
     */
    private function isValidPaymentData(array $data): bool
    {
        if (empty($data['booking_id']) || empty($data['amount']) || empty($data['currency'])) {
            return false;
        }
        return true;
    }
}
=== App/Services/Payment/TransactionService.php ===
<?php

namespace App\Services;

use App\Models\TransactionLog;
use App\Services\AuditService;
use App\Logging\LoggerInterface;
use Exception;

class TransactionService
{
    /**
     * Handles transaction consistency, logging, and history retrieval.
     *
     * Responsibilities:
     *  - Log all transactions in `TransactionLog` (both payments and refunds)
     *  - Provide a method for retrieving transaction histories for users/admins
     *  - Use AuditService for security-sensitive transactions
     *  - Use LoggerInterface for debugging and general transaction info
     *
     * @author
     * @version 1.0
     */
    private TransactionLog $transactionLogModel;
    private AuditService $auditService;
    private LoggerInterface $logger;

    /**
     * Constructor to inject the `TransactionLog` model, `AuditService`, and `LoggerInterface`.
     */
    public function __construct(
        TransactionLog $transactionLogModel,
        AuditService $auditService,
        LoggerInterface $logger
    ) {
        $this->transactionLogModel = $transactionLogModel;
        $this->auditService = $auditService;
        $this->logger = $logger;
    }

    /**
     * Logs a transaction in the system (payments, refunds, chargebacks, etc.).
     *
     * @param array $transactionData
     *   Example:
     *   [
     *       'payment_id'    => 123,
     *       'booking_id'    => 555,
     *       'refund_id'     => null,
     *       'amount'        => 100.00,
     *       'currency'      => 'USD',
     *       'status'        => 'completed',
     *       'description'   => 'Test transaction log.',
     *       'type'          => 'payment', // or 'refund', 'chargeback', etc.
     *   ]
     * @return array
     *   Confirmation data about the logged transaction
     */
    public function logTransaction(array $transactionData): array
    {
        try {
            $logId = $this->transactionLogModel->logTransaction($transactionData);

            // If the transaction is security-sensitive, record it in the audit trail as well
            if (isset($transactionData['type']) && $this->isSecuritySensitive($transactionData['type'])) {
                $this->auditService->recordTransaction($transactionData);
            }

            // Optional: debug log
            $this->logger->info('Transaction logged successfully', [
                'transaction_log_id' => $logId,
                'transaction_data'   => $transactionData,
            ]);

            return [
                'status' => 'success',
                'log_id' => $logId,
                'message' => 'Transaction logged successfully.'
            ];
        } catch (Exception $e) {
            $this->logger->error('Error logging transaction', [
                'error' => $e->getMessage(),
                'transaction_data' => $transactionData,
            ]);
            throw $e;
        }
    }

    /**
     * Retrieves transaction history for a specific user.
     *
     * @param int $userId
     * @return array
     *   An array of transaction records
     */
    public function getHistoryByUser(int $userId): array
    {
        try {
            $history = $this->transactionLogModel->getTransactionsByUser($userId);

            // Debug log
            $this->logger->info("Retrieved transaction history for user {$userId}", [
                'history_count' => count($history)
            ]);

            return $history;
        } catch (Exception $e) {
            $this->logger->error('Error retrieving transaction history', [
                'userId' => $userId,
                'error'  => $e->getMessage()
            ]);
            throw $e;
        }
    }

    /**
     * Retrieves transaction history for an admin view, possibly with filters.
     *
     * @param array $filters
     *   Example: ['date_from' => '2024-01-01', 'date_to' => '2024-01-31', 'type' => 'refund']
     * @return array
     */
    public function getHistoryAdmin(array $filters): array
    {
        try {
            $history = $this->transactionLogModel->getTransactionsAdmin($filters);

            $this->logger->info('Retrieved admin transaction history', [
                'filters' => $filters,
                'history_count' => count($history)
            ]);

            return $history;
        } catch (Exception $e) {
            $this->logger->error('Error retrieving admin transaction history', [
                'filters' => $filters,
                'error'   => $e->getMessage()
            ]);
            throw $e;
        }
    }

    /**
     * Decide whether a particular transaction type is security-sensitive.
     *
     * @param string $transactionType
     * @return bool
     */
    private function isSecuritySensitive(string $transactionType): bool
    {
        // Example: mark refunds, chargebacks, or large payments as sensitive
        $sensitiveTypes = ['refund', 'chargeback'];
        return in_array($transactionType, $sensitiveTypes, true);
    }
}
=== App/Services/Payment/RefundService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use App\Models\Payment;
use App\Models\TransactionLog;
use App\Services\AuditService;
use App\Logging\LoggerInterface;
use Exception;

class RefundService
{
    /**
     * Handles all refund-related operations.
     * 
     * Responsibilities:
     *  - Securely process refund requests
     *  - Verify that original payment exists and is refundable
     *  - Log refund transactions in TransactionLog
     *  - Use AuditService for approved refunds and chargebacks
     *  - Use LoggerInterface for refund API failures and debugging
     *
     * @author 
     * @version 1.0
     * @description
     *   - Refund request handling
     *   - Database transaction with beginTransaction/commit/rollback
     *   - Verification of original Payment record
     *   - Logging successful or failed refunds
     */
    private DatabaseHelper $dbHelper;
    private Payment $paymentModel;
    private TransactionLog $transactionLogModel;
    private AuditService $auditService;
    private LoggerInterface $logger;

    /**
     * Constructor injects all necessary dependencies for refund operations.
     */
    public function __construct(
        DatabaseHelper $dbHelper,
        Payment $paymentModel,
        TransactionLog $transactionLogModel,
        AuditService $auditService,
        LoggerInterface $logger
    ) {
        $this->dbHelper = $dbHelper;
        $this->paymentModel = $paymentModel;
        $this->transactionLogModel = $transactionLogModel;
        $this->auditService = $auditService;
        $this->logger = $logger;
    }

    /**
     * Main method for processing a refund.
     *
     * @param array $refundData
     *   Example structure: [
     *       'payment_id'  => 123,
     *       'amount'      => 100.00,
     *       'reason'      => 'Product defective',
     *       'initiated_by'=> 'admin' or 'customer',
     *       // Other relevant data...
     *   ]
     * @return array
     *   Return a standardized response, e.g. ['status' => 'success', 'refund_id' => XYZ]
     * @throws Exception
     *   When refund cannot be processed
     */
    public function refund(array $refundData): array
    {
        // Check if refund data is valid
        if (!$this->isValidRefundData($refundData)) {
            $this->logger->error('Invalid refund data provided', $refundData);
            throw new Exception('Refund data is invalid.');
        }

        // Fetch and verify original payment
        $originalPayment = $this->paymentModel->find($refundData['payment_id']);
        if (!$originalPayment) {
            $this->logger->warning('No original payment found for refund', $refundData);
            throw new Exception('Original payment not found.');
        }

        // Check if the payment is eligible for refund
        if (!$this->isRefundable($originalPayment, $refundData)) {
            $this->logger->warning('Payment not eligible for refund', [
                'originalPayment' => $originalPayment,
                'refundRequest'   => $refundData
            ]);
            throw new Exception('Payment is not eligible for a refund.');
        }

        // Begin transaction
        $this->dbHelper->beginTransaction();
        try {
            // 1. Create a refund record (implementation depends on your Payment model's structure)
            //    You might track refunds in a separate 'refunds' table or as negative Payment entries.
            $refundId = $this->paymentModel->createRefund($refundData);

            // 2. Log the refund in the transaction log
            $this->transactionLogModel->logTransaction([
                'payment_id'    => $refundData['payment_id'],
                'refund_id'     => $refundId,
                'amount'        => $refundData['amount'],
                'status'        => 'refunded',
                'description'   => "Refund processed: {$refundData['reason']}",
            ]);

            // 3. Commit transaction
            $this->dbHelper->commit();

            // 4. Audit the approved refund or chargeback
            //    (You could distinguish between normal refunds and chargebacks if needed)
            $this->auditService->recordRefundSuccess($refundData);

            // Return success response
            return [
                'status' => 'success',
                'refund_id' => $refundId,
                'message' => 'Refund processed successfully.'
            ];
        } catch (Exception $e) {
            // Rollback transaction
            $this->dbHelper->rollback();

            // Log error
            $this->logger->error('Refund processing failed', [
                'error' => $e->getMessage(),
                'refundData' => $refundData
            ]);

            throw $e;
        }
    }

    /**
     * Validate minimal refund data.
     */
    private function isValidRefundData(array $refundData): bool
    {
        return (!empty($refundData['payment_id']) && !empty($refundData['amount']));
    }

    /**
     * Checks whether the original payment is eligible for a refund.
     * This can involve checking payment status, refund policies, etc.
     *
     * @param array $originalPayment Payment record from the DB
     * @param array $refundData
     * @return bool
     */
    private function isRefundable(array $originalPayment, array $refundData): bool
    {
        // Example checks:
        //  - Payment must be 'completed'
        //  - Refund amount <= original payment amount
        //  - Payment is within refundable time window, etc.
        if ($originalPayment['status'] !== 'completed') {
            return false;
        }

        if ($refundData['amount'] > $originalPayment['amount']) {
            return false;
        }

        // More sophisticated checks can go here
        return true;
    }
}
=== App/Services/Payment/PaymentGatewayService.php ===
<?php

namespace App\Services;

use App\Logging\LoggerInterface;
use Exception;

class PaymentGatewayService
{
    /**
     * Handles external gateway payments, including:
     *  - Initiating payment requests to Stripe, PayU, or other providers
     *  - Handling responses and mapping them to a standard format
     *  - Fraud detection/authorization logic (if the gateway doesn’t already do it)
     *  - Handling webhooks or callback data to confirm payment status
     *  - Logging relevant details for debugging
     *
     * @author 
     * @version 1.0
     * @description
     *   - External API calls to payment gateways
     *   - Securely handling API keys/credentials (from .env or config)
     *   - Logging errors, warnings, or debug info via LoggerInterface
     */

    private LoggerInterface $logger;

    /**
     * Depending on your actual gateway usage, you might need:
     *  - Guzzle or another HTTP client
     *  - Gateway-specific SDKs
     *  - Configuration values for API keys, secrets, etc.
     *
     * @param LoggerInterface $logger
     */
    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }

    /**
     * Orchestrates payment with the specified gateway.
     *
     * @param string $gatewayName  E.g. "stripe", "payu", etc.
     * @param array  $paymentData  [
     *       'amount'     => 120.00,
     *       'currency'   => 'USD',
     *       'card_token' => 'tok_abc123', // Stripe example
     *       // Possibly customer info, etc...
     * ]
     * @return array
     *   Typically includes a standardized response: ['status' => 'success', 'gateway_id' => 'XYZ']
     */
    public function processPayment(string $gatewayName, array $paymentData): array
    {
        try {
            // Example: Switch or strategy pattern for different gateways
            switch (strtolower($gatewayName)) {
                case 'stripe':
                    return $this->processStripePayment($paymentData);

                case 'payu':
                    return $this->processPayUPayment($paymentData);

                default:
                    throw new Exception("Unsupported payment gateway: {$gatewayName}");
            }
        } catch (Exception $e) {
            $this->logger->error('Payment gateway error', [
                'gateway' => $gatewayName,
                'data'    => $paymentData,
                'error'   => $e->getMessage()
            ]);
            throw $e;
        }
    }

    /**
     * Generic handler for gateway webhook callbacks.
     * Gateways typically send POST requests to a URL you define.
     *
     * @param string $gatewayName
     * @param array  $callbackData e.g. JSON payload from Stripe/PayU
     * @return array
     *   Provide a response that your app can use to confirm payment status, etc.
     */
    public function handleCallback(string $gatewayName, array $callbackData): array
    {
        try {
            // You might do signature verification or event type checks here
            // For example, with Stripe: verify the event using a secret key

            switch (strtolower($gatewayName)) {
                case 'stripe':
                    return $this->handleStripeCallback($callbackData);

                case 'payu':
                    return $this->handlePayUCallback($callbackData);

                default:
                    throw new Exception("Unsupported payment gateway callback: {$gatewayName}");
            }
        } catch (Exception $e) {
            $this->logger->error('Payment gateway callback error', [
                'gateway' => $gatewayName,
                'data'    => $callbackData,
                'error'   => $e->getMessage()
            ]);
            // In practice, you’d respond with an HTTP error or a structured JSON error
            throw $e;
        }
    }

    /**
     * Example: Implementation detail for Stripe payment
     *
     * @param array $paymentData
     * @return array
     */
    private function processStripePayment(array $paymentData): array
    {
        // Pseudocode for Stripe integration
        // You’d typically use Stripe’s PHP SDK or an HTTP call
        // $stripe = new \Stripe\StripeClient($this->stripeApiKey);
        // $charge = $stripe->charges->create([...]);
        // return some standardized format

        $this->logger->info('Processing Stripe payment', $paymentData);

        // Placeholder return
        return [
            'status'     => 'success',
            'gateway_id' => 'stripe_charge_ABC123',
            'message'    => 'Stripe payment completed.'
        ];
    }

    /**
     * Example: Implementation detail for PayU payment
     *
     * @param array $paymentData
     * @return array
     */
    private function processPayUPayment(array $paymentData): array
    {
        $this->logger->info('Processing PayU payment', $paymentData);

        // Pseudocode for PayU
        // $response = $this->httpClient->post('https://api.payu.com/v2/payments', [...]);
        // parse response, handle success/failure

        // Placeholder return
        return [
            'status'     => 'success',
            'gateway_id' => 'payu_transaction_ABC123',
            'message'    => 'PayU payment completed.'
        ];
    }

    /**
     * Example method for handling Stripe webhook data
     *
     * @param array $callbackData
     * @return array
     */
    private function handleStripeCallback(array $callbackData): array
    {
        // E.g., verify signature, parse event, check payment_intent status, etc.
        $this->logger->info('Handling Stripe webhook callback', $callbackData);

        // Return standardized response
        return [
            'status'  => 'received',
            'message' => 'Stripe webhook processed.'
        ];
    }

    /**
     * Example method for handling PayU webhook data
     *
     * @param array $callbackData
     * @return array
     */
    private function handlePayUCallback(array $callbackData): array
    {
        $this->logger->info('Handling PayU webhook callback', $callbackData);

        // Return standardized response
        return [
            'status'  => 'received',
            'message' => 'PayU webhook processed.'
        ];
    }
}
=== App/Services/README.md ===
# Token Validation Changes

## TokenValidator Deprecation

The `TokenValidator` class has been deprecated in favor of the more robust `TokenService` class. This change centralizes all token-related functionality into a single service class, making the codebase more maintainable and testable.

## Migration Guide

### Before

```php
use App\Helpers\TokenValidator;

// In controllers
$user = TokenValidator::validateToken($request->getHeader('Authorization'));
if (!$user) {
    // Handle unauthorized access
}
```

### After

```php
use App\Services\Auth\TokenService;

// In constructor
private TokenService $tokenService;

public function __construct(TokenService $tokenService, /* other dependencies */) {
    $this->tokenService = $tokenService;
    // ...
}

// In controller methods
$user = $this->tokenService->validateTokenFromHeader($request->getHeader('Authorization')[0] ?? null);
// or
$user = $this->tokenService->validateRequest($request);

if (!$user) {
    // Handle unauthorized access
}
```

## New TokenService Methods

- `validateTokenFromHeader($tokenHeader)` - Validates a token from an Authorization header
- `extractToken($request)` - Extracts a token from various request formats
- `validateRequest($request)` - Validates a token and returns user data in one step
- `verifyToken($token)` - Verifies JWT token and returns decoded payload

## Benefits

1. **Centralized Logic**: All token operations are now in one service
2. **Dependency Injection**: The service can be properly injected, allowing for easier testing
3. **Consistent Error Handling**: All token errors are handled consistently
4. **Audit Logging**: Token validations are now logged in the audit trail

## Automatic Compatibility

To ease migration, a compatibility layer has been added to the old `TokenValidator` class that delegates to `TokenService`. However, you should update your code to use `TokenService` directly, as the compatibility layer will be removed in a future release.
=== App/Services/EncryptionService.php ===
<?php

namespace App\Services;

use Illuminate\Support\Facades\Crypt;
use Illuminate\Support\Facades\Storage;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class EncryptionService
{
    public const DEBUG_MODE = true;

    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private string $encryptionKey;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        string $encryptionKey
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->encryptionKey = $encryptionKey;
    }

    public function encrypt(string $data): string
    {
        try {
            return Crypt::encryptString($data);
        } catch (\Exception $e) {
            $this->logger->error("[Encryption] ❌ Encryption failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function decrypt(string $encryptedData): ?string
    {
        try {
            return Crypt::decryptString($encryptedData);
        } catch (\Exception $e) {
            $this->logger->error("[Encryption] ❌ Decryption failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }

    public function encryptFile(string $inputFile, string $outputFile): bool
    {
        try {
            $data = file_get_contents($inputFile);
            if ($data === false) {
                throw new \RuntimeException("Failed to read file: $inputFile");
            }
            $encrypted = Crypt::encryptString($data);
            Storage::put($outputFile, $encrypted);
            return true;
        } catch (\Exception $e) {
            $this->logger->error("File encryption failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    public function decryptFile(string $inputFile, string $outputFile): bool
    {
        try {
            $encryptedData = Storage::get($inputFile);
            $decrypted = Crypt::decryptString($encryptedData);
            Storage::put($outputFile, $decrypted);
            return true;
        } catch (\Exception $e) {
            $this->logger->error("File decryption failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    public function sign(string $data): string
    {
        return hash_hmac('sha256', $data, $this->encryptionKey);
    }

    public function verify(string $data, string $signature): bool
    {
        return hash_equals($this->sign($data), $signature);
    }
}
=== App/Services/FileStorage.php ===
<?php

namespace App\Services;

use Exception;
use App\Services\EncryptionService;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class FileStorage
{
    public const DEBUG_MODE = true;
    private string $basePath;
    private array $config;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private EncryptionService $encryptionService;

    public function __construct(
        array $config,
        EncryptionService $encryptionService,
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->config = $config;
        $this->encryptionService = $encryptionService;
        $this->basePath = rtrim($config['base_directory'], DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;

        if (!is_dir($this->basePath) || !is_writable($this->basePath)) {
            throw new Exception("Invalid storage base path or insufficient permissions: {$this->basePath}");
        }
    }

    public function storeFile(string $directory, string $fileName, string $content, bool $encrypt = false): string
    {
        $safeDirectory = $this->getDirectoryPath($directory);
        $safeFileName = $this->sanitizeFileName($fileName);
        $filePath = $safeDirectory . $safeFileName;

        if ($encrypt) {
            $content = $this->encryptionService->encrypt($content);
        }

        try {
            if (file_put_contents($filePath, $content) === false) {
                throw new Exception("Failed to store file: $fileName");
            }

            chmod($filePath, $this->config['security']['permissions']['default']);
            if (self::DEBUG_MODE) {
                $this->logger->info("[FileStorage] File stored: {$fileName}");
            }

            return $filePath;
        } catch (\Exception $e) {
            $this->logger->error("[FileStorage] ❌ Failed to store file: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function retrieveFile(string $filePath, bool $decrypt = false): string
    {
        try {
            if (!file_exists($filePath) || !is_readable($filePath)) {
                throw new Exception("File not found or not readable: $filePath");
            }

            $content = file_get_contents($filePath);
            if ($content === false) {
                throw new Exception("Failed to retrieve file: $filePath");
            }

            if ($decrypt) {
                $content = $this->encryptionService->decrypt($content);
                if ($content === null) {
                    throw new Exception("Failed to decrypt file: $filePath");
                }
            }

            if (self::DEBUG_MODE) {
                $this->logger->info("[FileStorage] File retrieved: {$filePath}");
            }
            return $content;
        } catch (\Exception $e) {
            $this->logger->error("[FileStorage] ❌ Failed to retrieve file: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function deleteFile(string $filePath): void
    {
        try {
            if (!file_exists($filePath)) {
                throw new Exception("File not found: $filePath");
            }

            if (!unlink($filePath)) {
                throw new Exception("Failed to delete file: $filePath");
            }

            if (self::DEBUG_MODE) {
                $this->logger->info("[FileStorage] File deleted: {$filePath}");
            }
        } catch (\Exception $e) {
            $this->logger->error("[FileStorage] ❌ Failed to delete file: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    private function sanitizeFileName(string $fileName): string
    {
        return preg_replace('/[^a-zA-Z0-9_\.-]/', '_', $fileName);
    }

    private function getDirectoryPath(string $directory): string
    {
        $path = $this->basePath . trim($directory, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;

        if (!is_dir($path) && !mkdir($path, 0755, true)) {
            $this->logger->error("❌ Failed to create directory.", ['path' => $path, 'trace' => debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS)]);
            throw new Exception("Failed to create directory: $path");
        }

        if (!is_writable($path)) {
            $this->logger->error("❌ Directory is not writable.", ['path' => $path, 'trace' => debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS)]);
            throw new Exception("Directory is not writable: $path");
        }

        return $path;
    }
}
=== App/Services/RateLimiter.php ===
<?php

namespace App\Services;

use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

/**
 * Rate Limiter Service
 *
 * Implements IP-based rate limiting.
 */
class RateLimiter
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    public function __construct(LoggerInterface $logger, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
    }

    public function isRateLimited(string $ip): bool
    {
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }
        if (!isset($_SESSION['rate_limit'])) {
            $_SESSION['rate_limit'] = [];
        }
        $attempts = $_SESSION['rate_limit'][$ip] ?? 0;
        if ($attempts >= 5) {
            if (self::DEBUG_MODE) {
                $this->logger->warning("[security] Rate limit exceeded for IP: {$ip}", ['category' => 'security']);
            }
            return true;
        }
        return false;
    }

    public function recordFailedAttempt(string $ip): void
    {
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }
        if (!isset($_SESSION['rate_limit'])) {
            $_SESSION['rate_limit'] = [];
        }
        $_SESSION['rate_limit'][$ip] = ($_SESSION['rate_limit'][$ip] ?? 0) + 1;
        if (self::DEBUG_MODE) {
            $this->logger->info("[security] Recorded failed attempt for IP: {$ip}", ['category' => 'security']);
        }
    }
}
=== App/Services/RevenueService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use App\Models\Payment;
use App\Models\TransactionLog;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class RevenueService
{
    public const DEBUG_MODE = true;
    private $db;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    // Assume dependency injection now supplies the logger.
    public function __construct(LoggerInterface $logger, DatabaseHelper $db, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->db = $db;
        $this->exceptionHandler = $exceptionHandler;
    }

    public function getMonthlyRevenueTrends(): array
    {
        try {
            $data = $this->db->table('payments')
                ->where('status', 'completed')
                ->selectRaw('DATE_FORMAT(created_at, "%Y-%m") as month, SUM(amount) as revenue')
                ->groupBy('month')
                ->orderBy('month')
                ->get();
            $labels = array_column($data, 'month');
            $amounts = array_column($data, 'revenue');
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Retrieved monthly revenue trends", ['category' => 'revenue']);
            }
            return [
                'labels' => $labels,
                'data'   => $amounts,
            ];
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function getTotalRevenue(): float
    {
        try {
            $total = $this->db->table('transaction_logs')
                ->where('type', 'payment')
                ->sum('amount');
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Retrieved total revenue", ['category' => 'revenue']);
            }
            return (float) $total;
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function getTotalRefunds(): float
    {
        try {
            $total = $this->db->table('transaction_logs')
                ->where('type', 'refund')
                ->sum('amount');
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Retrieved total refunds", ['category' => 'revenue']);
            }
            return (float) $total;
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function getNetRevenue(): float
    {
        return $this->getTotalRevenue() - $this->getTotalRefunds();
    }
}
=== App/Services/Security/KeyManager.php ===
<?php

namespace App\Services\Security;

use Exception;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class KeyManager
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private array $keys;

    public function __construct(
        array $keys,
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->keys = $keys;
    }

    public function getKey(string $identifier): string
    {
        $keyName = 'encryption_key_' . strtolower($identifier);

        if (!isset($this->keys[$keyName]) || empty($this->keys[$keyName])) {
            $this->logger->error("[security] ❌ Encryption key for {$identifier} not found.", ['identifier' => $identifier]);
            throw new Exception("Encryption key for {$identifier} not found.");
        }

        return $this->keys[$keyName];
    }

    public function generateKey(): string
    {
        try {
            $key = base64_encode(random_bytes(32)); // AES-256 key
            $this->logger->info('Key generated', ['key_data' => $key]);
            return $key;
        } catch (Exception $e) {
            $this->logger->error('Failed to generate key', ['error' => $e->getMessage()]);
            throw $e;
        }
    }

    public function storeKey(string $identifier, string $key): void
    {
        if (self::DEBUG_MODE) {
            $this->logger->info("[security] Storing key for {$identifier}");
        }
        $this->logger->info("[security] ✅ Storing key for {$identifier}", ['identifier' => $identifier]);
        // Implementation for storing key securely (e.g., database, key vault)
    }

    public function rotateKey(string $identifier): void
    {
        $newKey = $this->generateKey();
        $this->storeKey($identifier, $newKey);
        $this->logger->info("[security] ✅ Rotated key for {$identifier}", ['identifier' => $identifier]);
    }

    public function revokeKey(string $identifier): void
    {
        $this->logger->info("[security] ✅ Revoking key for {$identifier}", ['identifier' => $identifier]);
        // Implementation for revoking key securely
    }
}
=== App/Services/SignatureService.php ===
<?php

namespace App\Services;

use Exception;
use GuzzleHttp\Client;
use Psr\Log\LoggerInterface;
use App\Services\FileStorage;
use App\Services\EncryptionService;
use App\Helpers\DatabaseHelper;
use App\Helpers\ExceptionHandler;

/**
 * Signature Service
 *
 * Manages electronic signatures both locally and via an external AES API.
 */
class SignatureService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private DatabaseHelper $db;
    private string $apiEndpoint;
    private string $apiKey;
    private FileStorage $fileStorage;
    private EncryptionService $encryptionService;
    private ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        DatabaseHelper $db,
        array $config,
        FileStorage $fileStorage,
        EncryptionService $encryptionService,
        ExceptionHandler $exceptionHandler
    ) {
        if (empty($config['api_endpoint']) || empty($config['api_key'])) {
            throw new Exception('AES API configuration is incomplete.');
        }

        $this->logger = $logger;
        $this->db = $db;
        $this->apiEndpoint = $config['api_endpoint'];
        $this->apiKey = $config['api_key'];
        $this->fileStorage = $fileStorage;
        $this->encryptionService = $encryptionService;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Upload a local signature securely.
     */
    public function uploadSignature(string $filePath, int $userId): string
    {
        $this->validateFileType($filePath);

        $encryptedContent = $this->encryptionService->encrypt(file_get_contents($filePath));
        $fileName = uniqid() . '.' . pathinfo($filePath, PATHINFO_EXTENSION);
        $storagePath = $this->fileStorage->storeFile("signatures/{$userId}", $fileName, $encryptedContent, false);

        try {
            $this->db->table('signatures')->insert([
                'user_id'   => $userId,
                'file_path' => $storagePath,
                'encrypted' => true,
                'created_at'=> date('Y-m-d H:i:s'),
            ]);
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Signature record created", ['userId' => $userId, 'storagePath' => $storagePath]);
            }
        } catch (Exception $e) {
            $this->logger->error("[db] ❌ Database error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
        if (self::DEBUG_MODE) {
            $this->logger->info("[system] Signature uploaded", ['userId' => $userId, 'storagePath' => $storagePath]);
        }
        return $storagePath;
    }

    /**
     * Send a document for AES signature.
     */
    public function sendForAdvancedSignature(string $filePath, int $userId, string $callbackUrl): array
    {
        try {
            $documentHash = hash_file('sha256', $filePath);

            $client = new Client();
            $response = $client->post("{$this->apiEndpoint}/sign-aes", [
                'headers' => $this->getAuthHeaders(),
                'multipart' => [
                    ['name' => 'file', 'contents' => fopen($filePath, 'r')],
                    ['name' => 'user_id', 'contents' => $userId],
                    ['name' => 'document_hash', 'contents' => $documentHash],
                    ['name' => 'callback_url', 'contents' => $callbackUrl],
                ],
            ]);

            return json_decode($response->getBody()->getContents(), true);
        } catch (Exception $e) {
            $this->logger->error("[api] Failed to send document for AES signing: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to send document for AES signing: " . $e->getMessage());
        }
    }

    /**
     * Verify an AES signature using Laravel HTTP client.
     */
    public function verifySignature(string $signedFilePath, string $originalFilePath): bool
    {
        try {
            $originalHash = hash_file('sha256', $originalFilePath);
            $signedHash = hash_file('sha256', $signedFilePath);
            
            $client = new Client();
            $response = $client->post("{$this->apiEndpoint}/verify-aes", [
                'headers' => $this->getAuthHeaders(),
                'json' => [
                    'original_hash' => $originalHash,
                    'signed_hash'   => $signedHash,
                ],
            ]);

            $result = json_decode($response->getBody()->getContents(), true);
            if (self::DEBUG_MODE) {
                $this->logger->info("[api] Signature verification", ['result' => $result]);
            }
            return $result['verified'] ?? false;
        } catch (Exception $e) {
            $this->logger->error("[api] Failed to verify signature: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to verify signature: " . $e->getMessage());
        }
    }

    /**
     * Retrieve stored local signatures for a user.
     */
    public function getSignatures(int $userId): array
    {
        $storedSignatures = $this->fileStorage->retrieveFiles("signatures/{$userId}");

        if (empty($storedSignatures)) {
            throw new Exception('No signatures found.');
        }

        return array_map(fn($path) => $this->encryptionService->decrypt($this->fileStorage->retrieveFile($path, false)), $storedSignatures);
    }

    /**
     * Check the status of an AES signature request.
     */
    public function checkAdvancedSignatureStatus(string $requestId): array
    {
        try {
            $client = new Client();
            $response = $client->get("{$this->apiEndpoint}/status/{$requestId}", [
                'headers' => $this->getAuthHeaders(),
            ]);

            return json_decode($response->getBody()->getContents(), true);
        } catch (Exception $e) {
            $this->logger->error("[api] Failed to check AES signature status: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to check AES signature status: " . $e->getMessage());
        }
    }

    /**
     * Download a signed AES document.
     */
    public function downloadSignedDocument(string $requestId, string $outputPath): bool
    {
        try {
            $client = new Client();
            $response = $client->get("{$this->apiEndpoint}/download/{$requestId}", [
                'headers' => $this->getAuthHeaders(),
                'sink' => $outputPath,
            ]);

            return $response->getStatusCode() === 200;
        } catch (Exception $e) {
            $this->logger->error("[api] Failed to download AES signed document: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to download AES signed document: " . $e->getMessage());
        }
    }

    /**
     * Get authentication headers for API requests.
     */
    private function getAuthHeaders(): array
    {
        return [
            'Authorization' => "Bearer {$this->apiKey}",
            'Content-Type'  => 'application/json',
        ];
    }

    /**
     * Validate allowed file types.
     */
    private function validateFileType(string $filePath): void
    {
        $allowedExtensions = ['png', 'jpg', 'svg'];
        if (!in_array(pathinfo($filePath, PATHINFO_EXTENSION), $allowedExtensions)) {
            throw new Exception('Invalid file type.');
        }
    }

    /**
     * Log error and throw exception.
     */
    private function logAndThrow(string $message, Exception $e): void
    {
        $this->logger->error($message, ['error' => $e->getMessage()]);
        throw new Exception("$message: " . $e->getMessage());
    }
}
=== App/Services/ReportService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use App\Models\Booking;
use App\Models\Payment;
use App\Models\User;
use Dompdf\Dompdf;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class ReportService
{
    public const DEBUG_MODE = true;
    private DatabaseHelper $db;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    public function __construct(LoggerInterface $logger, DatabaseHelper $db, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->db = $db;
        $this->exceptionHandler = $exceptionHandler;
    }    

    public function generateReport(string $reportType, array $dateRange, string $format, array $filters = []): string
    {
        $start = $dateRange['start'];
        $end   = $dateRange['end'];
        $data = match ($reportType) {
            'bookings' => $this->getBookingReportData($dateRange, $filters),
            'payments' => $this->getPaymentReportData($dateRange, $filters),
            'users'    => $this->getUserReportData($dateRange, $filters),
            default    => throw new \InvalidArgumentException("Invalid report type: $reportType"),
        };
        return $this->exportReport($data, "{$reportType}_" . date('YmdHis'), $format);
    }

    public function generateUserReport(int $userId, string $reportType, array $dateRange, string $format): string
    {
        $start = $dateRange['start'];
        $end   = $dateRange['end'];
        $data = match ($reportType) {
            'bookings' => Booking::with('user')
                         ->where('user_id', $userId)
                         ->whereBetween('created_at', [$start, $end])
                         ->get()
                         ->toArray(),
            'payments' => Payment::where('user_id', $userId)
                         ->whereBetween('created_at', [$start, $end])
                         ->get()
                         ->toArray(),
            default    => throw new \InvalidArgumentException("Invalid report type: $reportType"),
        };
        return $this->exportReport($data, "{$reportType}_user_{$userId}", $format);
    }

    private function getBookingReportData(array $dateRange, array $filters): array
    {
        try {
            $query = $this->db->table('bookings')->whereBetween('created_at', [$dateRange['start'], $dateRange['end']]);
            if (!empty($filters['status'])) {
                $query->where('status', $filters['status']);
            }
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Fetched booking report data", ['category' => 'report']);
            }
            return $query->get();
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error (booking): " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    private function getPaymentReportData(array $dateRange, array $filters): array
    {
        try {
            $query = $this->db->table('payments')->whereBetween('created_at', [$dateRange['start'], $dateRange['end']]);
            if (!empty($filters['type'])) {
                $query->where('type', $filters['type']);
            }
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Fetched payment report data", ['category' => 'report']);
            }
            return $query->get();
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error (payments): " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    private function getUserReportData(array $dateRange, array $filters): array
    {
        try {
            $data = $this->db->table('users')
                         ->whereBetween('created_at', [$dateRange['start'], $dateRange['end']])
                         ->get();
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Fetched user report data");
            }
            return $data;
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error (users): " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    private function exportReport(array $data, string $reportName, string $format): string
    {
        $filePath = __DIR__ . "/../../storage/reports/{$reportName}_" . date('YmdHis') . ".{$format}";

        if ($format === 'csv') {
            $file = fopen($filePath, 'w');
            if (!empty($data)) {
                fputcsv($file, array_keys($data[0])); // headers
                foreach ($data as $row) {
                    fputcsv($file, $row);
                }
            }
            fclose($file);
        } elseif ($format === 'pdf') {
            $dompdf = new Dompdf();
            $html = '<table border="1"><tr>';
            if (!empty($data)) {
                foreach (array_keys($data[0]) as $header) {
                    $html .= "<th>$header</th>";
                }
                $html .= "</tr>";
                foreach ($data as $row) {
                    $html .= "<tr>";
                    foreach ($row as $cell) {
                        $html .= "<td>$cell</td>";
                    }
                    $html .= "</tr>";
                }
            }
            $html .= "</table>";
            $dompdf->loadHtml($html);
            $dompdf->render();
            file_put_contents($filePath, $dompdf->output());
        } else {
            throw new \InvalidArgumentException("Unsupported format: $format");
        }
        if (self::DEBUG_MODE) {
            $this->logger->info("[system] Exported report: {$filePath}");
        }
        return $filePath;
    }
}
=== App/Services/Audit/UserAuditService.php ===
<?php

namespace App\Services\Audit;

use App\Services\Audit\LogManagementService;

class UserAuditService
{
    private LogManagementService $logManager;
    
    public function __construct(LogManagementService $logManager)
    {
        $this->logManager = $logManager;
    }
    
    /**
     * Generic user event logger
     */
    public function logUserEvent(
        string $category,
        string $action,
        string $message,
        array $context = [],
        ?int $userId = null,
        string $logLevel = 'info'
    ): ?int {
        // Ensure common user-related fields
        $enrichedContext = $this->enrichUserContext($action, $context);
        return $this->logManager->createLogEntry($category, $message, $enrichedContext, $userId, null, null, $logLevel);
    }
    
    /**
     * Log an authentication event
     */
    public function logAuthEvent(
        string $action,
        string $message,
        array $context = [],
        ?int $userId = null,
        string $logLevel = 'info'
    ): ?int {
        return $this->logUserEvent('auth', $action, $message, $context, $userId, $logLevel);
    }
    
    /**
     * Log a user action
     */
    public function logUserAction(
        string $action,
        string $message,
        array $context = [],
        ?int $userId = null,
        string $logLevel = 'info'
    ): ?int {
        return $this->logUserEvent('user', $action, $message, $context, $userId, $logLevel);
    }
    
    /**
     * Log a system event
     */
    public function logSystemEvent(
        string $action,
        string $message,
        array $context = [],
        ?int $userId = null,
        string $logLevel = 'info'
    ): ?int {
        return $this->logUserEvent('system', $action, $message, $context, $userId, $logLevel);
    }
    
    /**
     * Log a security event
     */
    public function logSecurityEvent(
        string $action,
        string $message,
        array $context = [],
        ?int $userId = null,
        string $logLevel = 'warning'
    ): ?int {
        return $this->logUserEvent('security', $action, $message, $context, $userId, $logLevel);
    }
    
    /**
     * Log an API request
     */
    public function logApiRequest(
        string $endpoint,
        string $method,
        string $message,
        array $context = [],
        ?int $userId = null,
        string $logLevel = 'info'
    ): ?int {
        $context = array_merge($context, [
            'endpoint' => $endpoint,
            'method' => $method
        ]);
        return $this->logUserEvent('api', 'api_request', $message, $context, $userId, $logLevel);
    }
    
    /**
     * Enrich context with user-specific data
     */
    private function enrichUserContext(string $action, array $context): array
    {
        return array_merge($context, [
            'action' => $action,
            'user_agent' => $context['user_agent'] ?? $_SERVER['HTTP_USER_AGENT'] ?? 'Unknown'
        ]);
    }
}
=== App/Services/Audit/FraudAnalysisService.php ===
<?php

namespace App\Services\Audit;

/**
 * FraudAnalysisService - Handles fraud detection logic
 * 
 * This service encapsulates all fraud-related detection rules and scoring logic
 */
class FraudAnalysisService
{
    /**
     * Risk thresholds for different risk levels
     */
    private const RISK_THRESHOLD_HIGH = 70;
    private const RISK_THRESHOLD_MEDIUM = 50;
    private const RISK_THRESHOLD_LOW = 30;
    
    /**
     * Fraud indicator weights - determines scoring impact
     */
    private const FRAUD_INDICATOR_WEIGHTS = [
        'high_amount' => 15,
        'multiple_attempts' => 20,
        'unusual_location' => 30,
        'address_mismatch' => 25,
        'card_country_mismatch' => 35,
        'rapid_transactions' => 18,
        'unusual_time' => 10,
        'ip_proxy_detected' => 40,
        'device_mismatch' => 28,
        'risky_email_domain' => 15
    ];
    
    /**
     * Analyze transaction data to detect potential fraud indicators
     *
     * @param array $data Transaction data
     * @return array Detected fraud indicators
     */
    public function detectFraudIndicators(array $data): array
    {
        $indicators = [];
        
        // Check for high amount transactions
        if (isset($data['amount']) && $data['amount'] > 1000) {
            $indicators['high_amount'] = true;
        }
        
        // Check for multiple payment attempts
        if (isset($data['attempts']) && $data['attempts'] > 3) {
            $indicators['multiple_attempts'] = true;
        }
        
        // Check for location mismatches
        if (isset($data['location'], $data['expected_location']) && 
            $data['location'] !== $data['expected_location']) {
            $indicators['unusual_location'] = true;
        }
        
        // Check for address mismatches between billing and shipping
        if (isset($data['billing_country'], $data['shipping_country']) && 
            $data['billing_country'] !== $data['shipping_country']) {
            $indicators['address_mismatch'] = true;
        }
        
        // Check for card country mismatch
        if (isset($data['card_country'], $data['user_country']) && 
            $data['card_country'] !== $data['user_country']) {
            $indicators['card_country_mismatch'] = true;
        }
        
        // Check for rapid transactions from the same user
        if (isset($data['last_transaction_minutes']) && $data['last_transaction_minutes'] < 5) {
            $indicators['rapid_transactions'] = true;
        }
        
        // Check for unusual transaction times
        if (isset($data['hour']) && ($data['hour'] < 6 || $data['hour'] > 23)) {
            $indicators['unusual_time'] = true;
        }
        
        // Check for IP proxy usage
        if (isset($data['ip_is_proxy']) && $data['ip_is_proxy'] === true) {
            $indicators['ip_proxy_detected'] = true;
        }
        
        // Check for device mismatch with previous session
        if (isset($data['device_changed']) && $data['device_changed'] === true) {
            $indicators['device_mismatch'] = true;
        }
        
        // Check for risky email domains
        if (isset($data['email']) && $this->isRiskyEmailDomain($data['email'])) {
            $indicators['risky_email_domain'] = true;
        }
        
        return $indicators;
    }
    
    /**
     * Calculate a risk score based on detected fraud indicators
     *
     * @param array $indicators Detected fraud indicators
     * @return int Risk score (0-100)
     */
    public function calculateRiskScore(array $indicators): int
    {
        $score = 0;
        
        foreach ($indicators as $key => $flag) {
            if ($flag && isset(self::FRAUD_INDICATOR_WEIGHTS[$key])) {
                $score += self::FRAUD_INDICATOR_WEIGHTS[$key];
            }
        }
        
        // Cap the score at 100
        return min($score, 100);
    }
    
    /**
     * Get risk level description based on score
     *
     * @param int $score Risk score
     * @return string Risk level (high, medium, low, minimal)
     */
    public function getRiskLevel(int $score): string
    {
        if ($score >= self::RISK_THRESHOLD_HIGH) return 'high';
        if ($score >= self::RISK_THRESHOLD_MEDIUM) return 'medium';
        if ($score >= self::RISK_THRESHOLD_LOW) return 'low';
        return 'minimal';
    }
    
    /**
     * Get appropriate log level based on risk score
     *
     * @param int $score Risk score
     * @return string Log level (critical, error, warning, info)
     */
    public function getLogLevelForRisk(int $score): string
    {
        if ($score >= self::RISK_THRESHOLD_HIGH) return 'critical';
        if ($score >= self::RISK_THRESHOLD_MEDIUM) return 'error';
        if ($score >= self::RISK_THRESHOLD_LOW) return 'warning';
        return 'info';
    }
    
    /**
     * Check if an email domain is considered risky
     *
     * @param string $email Email address to check
     * @return bool True if the domain is risky
     */
    private function isRiskyEmailDomain(string $email): bool
    {
        // Domain risk could be loaded from configuration or database
        $riskyDomains = [
            'tempmail.com', 'throwaway.com', 'mailinator.com', 
            'guerrillamail.com', 'yopmail.com', 'sharklasers.com'
        ];
        
        $parts = explode('@', $email);
        if (count($parts) != 2) {
            return false;
        }
        
        $domain = strtolower($parts[1]);
        return in_array($domain, $riskyDomains);
    }
}
=== App/Services/Audit/TransactionAuditService.php ===
<?php

namespace App\Services\Audit;

use App\Services\Audit\LogManagementService;
use App\Services\Audit\FraudAnalysisService;

class TransactionAuditService
{
    private LogManagementService $logManager;
    private FraudAnalysisService $fraudAnalyzer;
    
    public function __construct(LogManagementService $logManager, FraudAnalysisService $fraudAnalyzer)
    {
        $this->logManager = $logManager;
        $this->fraudAnalyzer = $fraudAnalyzer;
    }
    
    /**
     * Generic transaction event logger
     */
    public function logEvent(
        string $category,
        string $message,
        array $context,
        ?int $userId = null,
        ?int $bookingId = null,
        string $logLevel = 'info'
    ): ?int {
        // Ensure we have transaction type if not specified
        if (!isset($context['transaction_type']) && !isset($context['event_type'])) {
            $context['transaction_type'] = $category;
        }
        
        return $this->logManager->createLogEntry($category, $message, $context, $userId, $bookingId, null, $logLevel);
    }
    
    /**
     * Record a successful payment transaction
     */
    public function recordPaymentSuccess(array $paymentData): ?int
    {
        $message = "Payment processed successfully";
        if (isset($paymentData['amount'])) {
            $message .= sprintf(" for %.2f %s", $paymentData['amount'], $paymentData['currency'] ?? '');
        }
        
        $paymentData['payment_status'] = 'completed';
        
        return $this->logEvent(
            'payment', 
            $message, 
            $paymentData, 
            $paymentData['user_id'] ?? null,
            $paymentData['booking_id'] ?? null, 
            'info'
        );
    }
    
    /**
     * Record a failed fraud validation with enhanced risk scoring
     */
    public function recordFraudValidationFailure(
        array $paymentData, 
        array $fraudIndicators = [], 
        ?int $riskScore = null
    ): ?int {
        // Use FraudAnalysisService to calculate fraud indicators
        if (empty($fraudIndicators)) {
            $fraudIndicators = $this->fraudAnalyzer->detectFraudIndicators($paymentData);
        }
        
        // Calculate risk score if not provided
        if ($riskScore === null) {
            $riskScore = $this->fraudAnalyzer->calculateRiskScore($fraudIndicators);
        }
        
        // Get risk level and appropriate log level
        $riskLevel = $this->fraudAnalyzer->getRiskLevel($riskScore);
        $logLevel = $this->fraudAnalyzer->getLogLevelForRisk($riskScore);
        
        $message = sprintf("Potential fraud detected (%s risk) with score %d", $riskLevel, $riskScore);
        
        $context = array_merge($paymentData, [
            'fraud_indicators' => $fraudIndicators,
            'risk_score' => $riskScore,
            'risk_level' => $riskLevel,
            'event_type' => 'fraud_attempt'
        ]);
        
        return $this->logEvent(
            'security', 
            $message, 
            $context,
            $paymentData['user_id'] ?? null,
            $paymentData['booking_id'] ?? null,
            $logLevel
        );
    }
    
    /**
     * Record a transaction
     */
    public function recordTransaction(
        string $transactionType, 
        array $transactionData, 
        string $status, 
        ?string $message = null
    ): ?int {
        if ($message === null) {
            $message = ucfirst($transactionType) . " transaction " . $status;
            if (isset($transactionData['amount'])) {
                $message .= sprintf(" for %.2f %s", $transactionData['amount'], $transactionData['currency'] ?? '');
            }
        }
        
        $context = array_merge($transactionData, [
            'transaction_type' => $transactionType,
            'status' => $status
        ]);
        
        // Define log level based on transaction status
        $logLevel = $this->getLogLevelForStatus($status);
        
        return $this->logEvent(
            'transaction', 
            $message, 
            $context,
            $transactionData['user_id'] ?? null,
            $transactionData['booking_id'] ?? null,
            $logLevel
        );
    }
    
    /**
     * Record a refund event
     */
    public function recordRefund(array $refundData, string $status): ?int
    {
        $message = sprintf(
            "Refund %s for payment ID %s", 
            $status,
            $refundData['payment_id'] ?? 'unknown'
        );
        
        if (isset($refundData['amount'])) {
            $message .= sprintf(" (%.2f %s)", $refundData['amount'], $refundData['currency'] ?? '');
        }
        
        return $this->recordTransaction('refund', $refundData, $status, $message);
    }
    
    /**
     * Get log level for transaction status
     */
    private function getLogLevelForStatus(string $status): string
    {
        $map = [
            'completed' => 'info', 'success' => 'info', 'pending' => 'info', 'processing' => 'info',
            'failed' => 'warning', 'declined' => 'warning', 'error' => 'error', 'fraud' => 'error',
            'cancelled' => 'info', 'refunded' => 'info'
        ];
        
        $s = strtolower($status);
        return $map[$s] ?? 'info';
    }
}
=== App/Services/Audit/LogManagementService.php ===
<?php

namespace App\Services\Audit;

use App\Helpers\DatabaseHelper;
use App\Helpers\LogQueryBuilder;
use App\Helpers\SecurityHelper;
use Psr\Log\LoggerInterface;
use Exception;
use DateTime;
use DateTimeImmutable;

class LogManagementService
{
    // Configuration constants
    private const MAX_EXPORT_ROWS = 10000;
    private const BATCH_DELETE_SIZE = 1000;
    private const EXPORT_EXPIRY_HOURS = 24;
    
    private LoggerInterface $logger;
    private string $requestId;
    
    public function __construct(LoggerInterface $logger, string $requestId)
    {
        $this->logger = $logger;
        $this->requestId = $requestId;
    }
    
    /**
     * CENTRALIZED LOG INSERTION - All log writes go through this method
     *
     * @param string $category The category of the event
     * @param string $message The log message
     * @param array $context Additional context data
     * @param int|null $userId Associated user ID
     * @param int|null $bookingId Associated booking ID
     * @param string|null $ipAddress Client IP address
     * @param string $logLevel Log level
     * @return int|null ID of the created log entry
     */
    public function createLogEntry(
        string $category, 
        string $message, 
        array $context = [], 
        ?int $userId = null, 
        ?int $bookingId = null, 
        ?string $ipAddress = null,
        string $logLevel = 'info'
    ): ?int {
        // Sanitize inputs
        $message = SecurityHelper::sanitizeString($message);
        $context = $this->sanitizeContext($context);
        
        // Ensure request_id is included
        $context['request_id'] = $this->requestId;
        
        // Add client IP if not provided
        if (empty($ipAddress)) {
            $ipAddress = $this->getClientIp();
        }
        
        // Capture current time
        $timestamp = new DateTimeImmutable();
        
        // Prepare data for insertion
        $data = [
            'action'             => $category,
            'message'            => $message,
            'details'            => json_encode($context, JSON_UNESCAPED_UNICODE | JSON_PARTIAL_OUTPUT_ON_ERROR),
            'user_reference'     => $userId,
            'booking_reference'  => $bookingId,
            'ip_address'         => $ipAddress,
            'created_at'         => $timestamp->format('Y-m-d H:i:s'),
            'log_level'          => $logLevel,
            'request_id'         => $this->requestId,
        ];
        
        try {
            // Insert with secure database and prepared statements
            return DatabaseHelper::insert('audit_logs', $data, true);
        } catch (Exception $e) {
            $this->logger->error("[LogManager] Failed to create log entry: " . $e->getMessage(), [
                'request_id' => $this->requestId,
                'category' => $category
            ]);
            return null;
        }
    }
    
    /**
     * Sanitize context array to prevent sensitive data storage
     */
    private function sanitizeContext(array $context): array
    {
        $sensitiveKeys = ['password', 'secret', 'token', 'auth', 'key', 'apiKey', 'api_key', 'credential', 'credit_card', 'card_number', 'cvv', 'ssn'];
        $sanitized = [];
        
        foreach ($context as $key => $value) {
            if ($value === null) continue;
            
            $lower = strtolower($key);
            $isSensitive = false;
            
            foreach ($sensitiveKeys as $sKey) {
                if (strpos($lower, $sKey) !== false) {
                    $isSensitive = true;
                    break;
                }
            }
            
            $sanitized[$key] = $isSensitive 
                ? '[REDACTED]' 
                : (is_array($value) ? $this->sanitizeContext($value) : $value);
        }
        
        return $sanitized;
    }
    
    /**
     * Get client IP address
     */
    private function getClientIp(): string
    {
        foreach (['HTTP_X_FORWARDED_FOR', 'HTTP_CLIENT_IP'] as $header) {
            if (!empty($_SERVER[$header])) {
                $ips = explode(',', $_SERVER[$header]);
                $ip = trim($ips[0]);
                if (filter_var($ip, FILTER_VALIDATE_IP)) {
                    return $ip;
                }
            }
        }
        return $_SERVER['REMOTE_ADDR'] ?? '0.0.0.0';
    }

    /**
     * Retrieve logs from the audit_logs table with applied filters and pagination
     *
     * @param array $filters Various filters to apply (category, user_id, etc.)
     * @return array Paginated result containing logs and pagination metadata
     */
    public function getLogs(array $filters = []): array
    {
        try {
            // Get the query parts from LogQueryBuilder
            $query = LogQueryBuilder::buildSelectQuery($filters);
            
            // Execute the count query if pagination is needed
            $totalItems = 0;
            $totalPages = 0;
            
            if (!($filters['skip_pagination'] ?? false)) {
                $countResult = DatabaseHelper::select(
                    $query['countSql'],
                    $query['params'],
                    true
                );
                $totalItems = $countResult[0]['total'] ?? 0;
                $perPage = $query['perPage'];
                $totalPages = ceil($totalItems / $perPage);
            }
            
            // Execute the main query
            $logs = DatabaseHelper::select(
                $query['mainSql'],
                $query['params'],
                true
            );
            
            // Process results - parse JSON and format dates
            foreach ($logs as &$log) {
                if (isset($log['details']) && is_string($log['details'])) {
                    $log['details'] = json_decode($log['details'], true) ?? [];
                }
                
                if (!empty($log['created_at'])) {
                    $date = new DateTime($log['created_at']);
                    $log['formatted_date'] = $date->format('Y-m-d H:i:s');
                }
            }
            
            // Build the result array
            $result = ['data' => $logs];
            
            // Add pagination data if needed
            if (!($filters['skip_pagination'] ?? false)) {
                $page = $query['page'];
                $perPage = $query['perPage'];
                $offset = ($page - 1) * $perPage;
                
                $result['pagination'] = [
                    'total' => $totalItems,
                    'per_page' => $perPage,
                    'current_page' => $page,
                    'last_page' => $totalPages,
                    'from' => $offset + 1,
                    'to' => min($offset + $perPage, $totalItems),
                ];
            }
            
            return $result;
        } catch (Exception $e) {
            $this->logger->error("[Audit] Failed to get logs: " . $e->getMessage(), [
                'request_id' => $this->requestId,
                'filters' => $filters
            ]);
            throw $e; // Re-throw for higher-level handling
        }
    }
    
    /**
     * Delete logs from the audit_logs table based on specific filters
     *
     * @param array $filters Filters to determine which logs to delete
     * @param bool $forceBulkDelete Set to true to bypass safeguards for bulk deletion
     * @return int Number of logs deleted
     */
    public function deleteLogs(array $filters, bool $forceBulkDelete = false): int
    {
        try {
            // Get the query parts from LogQueryBuilder
            list($whereClause, $params) = LogQueryBuilder::buildWhereClause($filters);
            
            // Safety check: prevent accidental deletion of all logs
            if ($whereClause === "1=1" && count($params) === 0 && !$forceBulkDelete) {
                throw new Exception('Attempted to delete all logs without explicit confirmation');
            }
            
            // Get IDs to delete for batch processing
            $sql = "SELECT id FROM audit_logs WHERE {$whereClause}";
            
            // Add limit for safety if not forced bulk delete
            if (!$forceBulkDelete) {
                $sql .= " LIMIT " . self::MAX_EXPORT_ROWS;
            }
            
            $logIds = DatabaseHelper::select($sql, $params, true);
            $ids = array_column($logIds, 'id');
            
            if (empty($ids)) {
                return 0; // No matching logs to delete
            }
            
            // Log the deletion attempt
            $this->logger->info("[Audit] Deleting logs", [
                'request_id' => $this->requestId,
                'count' => count($ids)
            ]);
            
            // Use batch processing to delete
            $totalDeleted = 0;
            $batches = array_chunk($ids, self::BATCH_DELETE_SIZE);
            
            foreach ($batches as $batch) {
                $placeholders = implode(',', array_fill(0, count($batch), '?'));
                $deletedCount = DatabaseHelper::safeQuery(function ($pdo) use ($placeholders, $batch) {
                    $stmt = $pdo->prepare("DELETE FROM audit_logs WHERE id IN ({$placeholders})");
                    $stmt->execute($batch);
                    return $stmt->rowCount();
                }, true);
                
                $totalDeleted += $deletedCount;
            }
            
            return $totalDeleted;
        } catch (Exception $e) {
            $this->logger->error("[Audit] Failed to delete logs: " . $e->getMessage(), [
                'request_id' => $this->requestId,
                'filters' => $filters
            ]);
            throw $e; // Re-throw for higher-level handling
        }
    }
    
    /**
     * Export logs to a CSV file based on provided filters
     *
     * @param array $filters Filters to determine which logs to export
     * @return array Path info for the exported file
     */
    public function exportLogs(array $filters): array
    {
        try {
            // Create export file information
            $exportId = date('Ymd_His') . '_' . substr(uniqid(), -8);
            $filename = 'audit_logs_export_' . $exportId . '.csv';
            $exportDir = rtrim(sys_get_temp_dir(), '/') . '/secure_exports';
            
            // Ensure export directory exists with proper permissions
            if (!is_dir($exportDir)) {
                mkdir($exportDir, 0750, true);
            }
            
            $filepath = $exportDir . '/' . $filename;
            
            // Get export SQL from LogQueryBuilder
            $exportSql = LogQueryBuilder::buildExportQuery($filters, $filepath);
            
            // Execute export query
            $rowsExported = DatabaseHelper::executeExport($exportSql['sql'], $exportSql['params']);
            
            // Set appropriate permissions for the file
            chmod($filepath, 0640);
            
            // Calculate expiry time
            $expiryTime = time() + (self::EXPORT_EXPIRY_HOURS * 3600);
            
            // Return export information
            return [
                'file_path' => $filepath,
                'file_name' => $filename,
                'export_id' => $exportId,
                'row_count' => $rowsExported,
                'expiry_time' => $expiryTime,
                'expiry_formatted' => date('Y-m-d H:i:s', $expiryTime)
            ];
        } catch (Exception $e) {
            $this->logger->error("[Audit] Failed to export logs: " . $e->getMessage(), [
                'request_id' => $this->requestId,
                'filters' => $filters
            ]);
            throw $e; // Re-throw for higher-level handling
        }
    }
    
    /**
     * Get a single log entry by ID
     *
     * @param int $logId Log ID
     * @return array|null Log data or null if not found
     */
    public function getLogById(int $logId): ?array
    {
        try {
            $sql = "SELECT * FROM audit_logs WHERE id = ? LIMIT 1";
            $logs = DatabaseHelper::select($sql, [$logId], true);
            
            if (empty($logs)) {
                return null;
            }
            
            $log = $logs[0];
            
            // Parse JSON details if present
            if (isset($log['details']) && is_string($log['details'])) {
                $log['details'] = json_decode($log['details'], true) ?? [];
            }
            
            // Format timestamp
            if (!empty($log['created_at'])) {
                $date = new DateTime($log['created_at']);
                $log['formatted_date'] = $date->format('Y-m-d H:i:s');
            }
            
            return $log;
        } catch (Exception $e) {
            $this->logger->error("[Audit] Failed to get log by ID: " . $e->getMessage(), [
                'request_id' => $this->requestId,
                'log_id' => $logId
            ]);
            throw $e; // Re-throw for higher-level handling
        }
    }
}
=== App/Services/PaymentService.php ===
<?php

namespace App\Services;

use App\Services\Payment\PaymentProcessingService;
use App\Services\Payment\RefundService;
use App\Services\Payment\PaymentGatewayService;
use App\Services\Payment\TransactionService;

class PaymentService
{
    /**
     * PaymentService acts as a facade:
     *  - Delegates payment processing to PaymentProcessingService
     *  - Delegates refund handling to RefundService
     *  - Delegates external gateway calls to PaymentGatewayService
     *  - Delegates transaction logging/history to TransactionService
     *
     * Controllers (and other parts of your codebase) continue to call PaymentService
     * without knowing about the underlying subservices, avoiding any breaking changes.
     */

    private PaymentProcessingService $paymentProcessingService;
    private RefundService $refundService;
    private PaymentGatewayService $paymentGatewayService;
    private TransactionService $transactionService;

    /**
     * Constructor injects the four subservices, which are then used to delegate
     * the responsibilities away from this facade class.
     */
    public function __construct(
        PaymentProcessingService $paymentProcessingService,
        RefundService $refundService,
        PaymentGatewayService $paymentGatewayService,
        TransactionService $transactionService
    ) {
        $this->paymentProcessingService = $paymentProcessingService;
        $this->refundService = $refundService;
        $this->paymentGatewayService = $paymentGatewayService;
        $this->transactionService = $transactionService;
    }

    /**
     * Wrapper for handling a payment. Delegates the core logic to PaymentProcessingService.
     *
     * @param array $paymentData
     * @return array
     */
    public function processPayment(array $paymentData): array
    {
        return $this->paymentProcessingService->processPayment($paymentData);
    }

    /**
     * Wrapper for handling a refund. Delegates the core logic to RefundService.
     *
     * @param array $refundData
     * @return array
     */
    public function refundPayment(array $refundData): array
    {
        return $this->refundService->refund($refundData);
    }

    /**
     * For direct interactions with external gateways (e.g., if you need to manually
     * initiate a gateway payment step or retrieve gateway-specific responses).
     *
     * @param string $gatewayName  E.g. "stripe", "payu", etc.
     * @param array  $paymentData  Payment details to pass to the gateway
     * @return array
     */
    public function processPaymentGateway(string $gatewayName, array $paymentData): array
    {
        return $this->paymentGatewayService->processPayment($gatewayName, $paymentData);
    }

    /**
     * For handling gateway callback/webhook data. Delegates to PaymentGatewayService.
     *
     * @param string $gatewayName
     * @param array  $callbackData
     * @return array
     */
    public function handlePaymentCallback(string $gatewayName, array $callbackData): array
    {
        return $this->paymentGatewayService->handleCallback($gatewayName, $callbackData);
    }

    /**
     * For logging transactions directly through PaymentService, if needed.
     *
     * @param array $transactionData
     * @return array
     */
    public function logTransaction(array $transactionData): array
    {
        return $this->transactionService->logTransaction($transactionData);
    }

    /**
     * Retrieves transaction history for a specific user.
     *
     * @param int $userId
     * @return array
     */
    public function getTransactionHistory(int $userId): array
    {
        return $this->transactionService->getHistoryByUser($userId);
    }

    /**
     * Retrieves transaction history with admin filters (date range, type, etc.).
     *
     * @param array $filters
     * @return array
     */
    public function getTransactionHistoryAdmin(array $filters): array
    {
        return $this->transactionService->getHistoryAdmin($filters);
    }
}
