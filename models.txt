=== App/Models/Booking.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Booking Model
 *
 * Represents a booking and handles database interactions.
 */
class Booking extends BaseModel
{
    protected $table = 'bookings';
    protected $resourceName = 'booking';
    protected $useTimestamps = true;
    protected $useSoftDeletes = true;

    /**
     * Attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'user_id',
        'vehicle_id',
        'pickup_date',
        'dropoff_date',
        'status'
    ];

    /**
     * @var array Data type casting definitions
     */
    protected $casts = [
        'user_id' => 'int',
        'vehicle_id' => 'int',
        'pickup_date' => 'datetime',
        'dropoff_date' => 'datetime'
    ];
    
    /**
     * Constructor
     *
     * @param DatabaseHelper|null $dbHelper
     * @param AuditService|null $auditService
     */
    public function __construct(DatabaseHelper $dbHelper = null, AuditService $auditService = null)
    {
        parent::__construct($dbHelper, $auditService);
    }
    
    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'user_id' => 'required|exists:users,id',
        'vehicle_id' => 'required|exists:vehicles,id',
        'pickup_date' => 'required|date',
        'dropoff_date' => 'required|date|after_or_equal:pickup_date',
        'status' => 'required|string|in:pending,confirmed,cancelled,completed',
    ];

    /**
     * Update a booking's status
     * 
     * @param int|string $id
     * @param string $newStatus
     * @return bool
     */
    public function updateStatus(int|string $id, string $newStatus): bool
    {
        // Validate the status value
        $validStatuses = ['pending', 'confirmed', 'cancelled', 'completed', 'paid'];
        if (!in_array($newStatus, $validStatuses)) {
            if (isset($this->logger)) {
                $this->logger->error("Invalid booking status: {$newStatus}");
            }
            return false;
        }
        
        // Use the existing update method to update just the status field
        return $this->update($id, ['status' => $newStatus]);
    }

    /**
     * Get active bookings.
     *
     * @return array
     */
    public function getActive(): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE status = 'confirmed'
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query);
    }

    /**
     * Get bookings by user ID.
     *
     * @param int|string $userId
     * @return array
     */
    public function getByUser(int|string $userId): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE user_id = :user_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get bookings by status
     * 
     * @param string $status
     * @return array
     */
    public function getByStatus(string $status): array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE status = :status
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':status' => $status]);
    }

    /**
     * Get bookings within a date range with optional filters
     *
     * @param string $start
     * @param string $end
     * @param array $filters
     * @return array
     */
    public function getByDateRange(string $start, string $end, array $filters = []): array
    {
        // Check if we're filtering by pickup/dropoff dates or creation dates
        $dateField = !empty($filters['date_field']) ? $filters['date_field'] : 'created_at';
        
        $query = "SELECT b.*, u.name as user_name, v.model as vehicle_model 
                 FROM {$this->table} b
                 LEFT JOIN users u ON b.user_id = u.id
                 LEFT JOIN vehicles v ON b.vehicle_id = v.id
                 WHERE b.{$dateField} BETWEEN :start AND :end";
        
        $params = [':start' => $start, ':end' => $end];
        
        if (!empty($filters['status'])) {
            $query .= " AND b.status = :status";
            $params[':status'] = $filters['status'];
        }
        
        // Add sorting
        $query .= " ORDER BY b.{$dateField} ASC";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute($params);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Get bookings for a specific user within a date range
     *
     * @param int $userId
     * @param string $start
     * @param string $end
     * @return array
     */
    public function getByUserAndDateRange(int $userId, string $start, string $end): array
    {
        $query = "SELECT b.*, v.model as vehicle_model 
                 FROM {$this->table} b
                 LEFT JOIN vehicles v ON b.vehicle_id = v.id
                 WHERE b.user_id = :user_id
                 AND b.created_at BETWEEN :start AND :end";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([
            ':user_id' => $userId,
            ':start' => $start,
            ':end' => $end
        ]);
        
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Get user data for a booking.
     *
     * @param int|string $bookingId
     * @return array|null
     */
    public function getUser(int|string $bookingId): ?array
    {
        $query = "
            SELECT u.* FROM users u
            JOIN {$this->table} b ON u.id = b.user_id
            WHERE b.id = :booking_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND b.deleted_at IS NULL AND u.deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':booking_id' => $bookingId]);
        return $result ? $result[0] : null;
    }

    /**
     * Get vehicle data for a booking.
     *
     * @param int|string $bookingId
     * @return array|null
     */
    public function getVehicle(int|string $bookingId): ?array
    {
        $query = "
            SELECT v.* FROM vehicles v
            JOIN {$this->table} b ON v.id = b.vehicle_id
            WHERE b.id = :booking_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND b.deleted_at IS NULL AND v.deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':booking_id' => $bookingId]);
        return $result ? $result[0] : null;
    }

    /**
     * Get payment data for a booking.
     *
     * @param int|string $bookingId
     * @return array|null
     */
    public function getPayment(int|string $bookingId): ?array
    {
        $query = "
            SELECT p.* FROM payments p
            WHERE p.booking_id = :booking_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND p.deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':booking_id' => $bookingId]);
        return $result ? $result[0] : null;
    }
    
    /**
     * Check if a vehicle is available during a specific date range
     *
     * @param int|string $vehicleId
     * @param string $startDate
     * @param string $endDate
     * @param int|string|null $excludeBookingId Booking ID to exclude from check (for updates)
     * @return bool
     */
    public function isVehicleAvailable(int|string $vehicleId, string $startDate, string $endDate, int|string $excludeBookingId = null): bool
    {
        $query = "
            SELECT COUNT(*) as booking_count 
            FROM {$this->table}
            WHERE vehicle_id = :vehicle_id
            AND status IN ('pending', 'confirmed')
            AND NOT (
                dropoff_date < :start_date OR pickup_date > :end_date
            )
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        if ($excludeBookingId) {
            $query .= " AND id != :exclude_id";
        }
        
        $result = $this->dbHelper->select($query, [
            ':vehicle_id' => $vehicleId,
            ':start_date' => $startDate,
            ':end_date' => $endDate,
            ':exclude_id' => $excludeBookingId
        ]);
        
        return $result[0]['booking_count'] == 0;
    }

    /**
     * Get user ID for a booking
     * 
     * @param int|string $bookingId
     * @return int|null
     */
    public function getUserId(int|string $bookingId): ?int
    {
        $query = "
            SELECT user_id FROM {$this->table}
            WHERE id = :booking_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':booking_id' => $bookingId]);
        return isset($result[0]['user_id']) ? (int)$result[0]['user_id'] : null;
    }

    /**
     * Get monthly booking trends
     * 
     * @return array
     */
    public function getMonthlyTrends(): array
    {
        $year = date('Y');
        $query = "
            SELECT 
                MONTH(created_at) as month,
                COUNT(*) as total
            FROM {$this->table}
            WHERE YEAR(created_at) = :year
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " GROUP BY MONTH(created_at) ORDER BY month ASC";
        
        return $this->dbHelper->select($query, [':year' => $year]);
    }

    /**
     * Get total number of bookings
     * 
     * @return int
     */
    public function getTotalBookings(): int
    {
        $query = "SELECT COUNT(*) as total FROM {$this->table}";
        
        if ($this->useSoftDeletes) {
            $query .= " WHERE deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query);
        return isset($result[0]['total']) ? (int)$result[0]['total'] : 0;
    }

    /**
     * Get number of completed bookings
     * 
     * @return int
     */
    public function getCompletedBookings(): int
    {
        $query = "
            SELECT COUNT(*) as total FROM {$this->table}
            WHERE status = 'completed'
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query);
        return isset($result[0]['total']) ? (int)$result[0]['total'] : 0;
    }
    
    /**
     * Get number of canceled bookings
     * 
     * @return int
     */
    public function getCanceledBookings(): int
    {
        $query = "
            SELECT COUNT(*) as total FROM {$this->table}
            WHERE status = 'canceled'
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query);
        return isset($result[0]['total']) ? (int)$result[0]['total'] : 0;
    }
    
    /**
     * Get booking logs for a specific booking
     * 
     * @param int|string $bookingId
     * @return array
     */
    public function getLogs(int|string $bookingId): array
    {
        $query = "
            SELECT * FROM booking_logs
            WHERE booking_id = :booking_id
            ORDER BY created_at DESC
        ";
        
        return $this->dbHelper->select($query, [':booking_id' => $bookingId]);
    }
    
    /**
     * Check if a booking is available based on vehicle and dates
     * 
     * @param int|string $vehicleId
     * @param string $pickupDate
     * @param string $dropoffDate
     * @return bool
     */
    public function isAvailable(int|string $vehicleId, string $pickupDate, string $dropoffDate): bool
    {
        return $this->isVehicleAvailable($vehicleId, $pickupDate, $dropoffDate);
    }
}
=== App/Models/TransactionLog.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;
use App\Services\EncryptionService;

/**
 * TransactionLog Model
 *
 * Represents a financial transaction and handles interactions with the `transaction_logs` table.
 */
class TransactionLog extends BaseFinancialModel
{
    protected $table = 'transaction_logs';
    protected $resourceName = 'transaction_log';
    protected $useTimestamps = true; // Transaction logs use timestamps
    protected $useSoftDeletes = false; // Transaction logs don't use soft deletes

    private DatabaseHelper $dbHelper;
    private ?AuditService $auditService;

    public function __construct(DatabaseHelper $dbHelper, ?AuditService $auditService = null)
    {
        $this->dbHelper = $dbHelper;
        $this->auditService = $auditService;
    }

    /**
     * Get the database helper instance.
     *
     * @return DatabaseHelper
     */
    public function getDbHelper(): DatabaseHelper
    {
        return $this->dbHelper;
    }

    /**
     * Get the table name.
     *
     * @return string
     */
    public function getTable(): string
    {
        return $this->table;
    }

    /**
     * Log a transaction - this is the method that other services will call.
     *
     * @param array $transactionData
     * @return int The ID of the logged transaction
     */
    public function logTransaction(array $transactionData): int
    {
        // Apply any specific transaction logging logic here
        if (!isset($transactionData['created_at'])) {
            $transactionData['created_at'] = date('Y-m-d H:i:s');
        }

        // If a description is not provided, generate a generic one
        if (!isset($transactionData['description'])) {
            $type = $transactionData['type'] ?? 'transaction';
            $transactionData['description'] = ucfirst($type) . ' processed';
        }

        // Log this transaction for security audit
        if ($this->auditService && isset($transactionData['type'])) {
            $this->recordAuditEvent(
                $transactionData['type'] . '_logged',
                [
                    'payment_id' => $transactionData['payment_id'] ?? null,
                    'booking_id' => $transactionData['booking_id'] ?? null,
                    'amount' => $transactionData['amount'] ?? null,
                    'status' => $transactionData['status'] ?? null
                ],
                $transactionData['user_id'] ?? null
            );
        }

        // Encrypt any sensitive data and create the transaction log
        $encryptedData = $this->encryptSensitiveData($transactionData);
        return $this->create($encryptedData);
    }

    /**
     * Create a new transaction log.
     *
     * @param array $data
     * @return int The ID of the created transaction log
     * @throws \Exception If creation fails
     */
    public function create(array $data): int
    {
        // Required fields check
        if (!isset($data['payment_id']) || !isset($data['amount'])) {
            throw new \Exception('Transaction log requires payment_id and amount');
        }
        
        // Add timestamps
        if (!isset($data['created_at'])) {
            $data['created_at'] = date('Y-m-d H:i:s');
        }
        $data['updated_at'] = date('Y-m-d H:i:s');

        // Insert the record
        $logId = $this->dbHelper->insert($this->table, $data);
        
        if (!$logId) {
            throw new \Exception('Failed to create transaction log');
        }
        
        return (int)$logId;
    }

    /**
     * Get transactions by user ID.
     *
     * @param int $userId
     * @return array
     */
    public function getByUserId(int $userId): array
    {
        $query = "SELECT * FROM {$this->table} WHERE user_id = :user_id ORDER BY created_at DESC";
        $transactions = $this->dbHelper->select($query, [':user_id' => $userId]);

        // Decrypt transaction details
        foreach ($transactions as &$transaction) {
            $transaction['amount'] = EncryptionService::decrypt($transaction['amount']);
        }

        return $transactions;
    }

    /**
     * Get transaction by ID.
     *
     * @param int $id
     * @return array|null
     */
    public function getById(int $id): ?array
    {
        $query = "SELECT * FROM {$this->table} WHERE id = :id";
        $result = $this->dbHelper->select($query, [':id' => $id]);
        
        if (!empty($result)) {
            // Decrypt sensitive data before returning
            return $this->decryptSensitiveData($result[0]);
        }
        
        return null;
    }

    /**
     * Update transaction status.
     *
     * @param int $id
     * @param string $status
     * @return bool
     */
    public function updateStatus(int $id, string $status): bool
    {
        $data = [
            'status' => $status,
            'updated_at' => date('Y-m-d H:i:s')
        ];
        
        $result = $this->dbHelper->update($this->table, $data, ['id' => $id]);
        
        // Log the event
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'status_update', [
                'id' => $id,
                'status' => $status
            ]);
        }

        return (bool)$result;
    }

    /**
     * Get recent transactions.
     *
     * @param int $limit
     * @return array
     */
    public function getRecent(int $limit = 10): array
    {
        $query = "SELECT * FROM {$this->table} ORDER BY created_at DESC LIMIT :limit";
        $transactions = $this->dbHelper->select($query, [':limit' => $limit]);

        // Decrypt transaction details
        foreach ($transactions as &$transaction) {
            $transaction['amount'] = EncryptionService::decrypt($transaction['amount']);
        }

        return $transactions;
    }

    /**
     * Get transactions by payment ID.
     *
     * @param int $paymentId
     * @return array
     */
    public function getByPaymentId(int $paymentId): array
    {
        $query = "SELECT * FROM {$this->table} WHERE payment_id = :payment_id ORDER BY created_at DESC";
        return $this->dbHelper->select($query, [':payment_id' => $paymentId]);
    }

    /**
     * Get transactions by booking ID.
     *
     * @param int $bookingId
     * @return array
     */
    public function getByBookingId(int $bookingId): array
    {
        $query = "SELECT * FROM {$this->table} WHERE booking_id = :booking_id ORDER BY created_at DESC";
        return $this->dbHelper->select($query, [':booking_id' => $bookingId]);
    }
}
=== App/Models/RefreshToken.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use Exception;

class RefreshToken
{
    private DatabaseHelper $dbHelper;
    private LoggerInterface $logger;
    private bool $useSecureDb = true;

    public function __construct(DatabaseHelper $dbHelper, LoggerInterface $logger)
    {
        $this->dbHelper = $dbHelper;
        $this->logger = $logger;
    }

    /**
     * Store a refresh token in the database
     * 
     * @param int $userId The user ID
     * @param string $refreshToken The unhashed token
     * @param int $expiresIn Expiry time in seconds
     * @return bool Success status
     */
    public function store(int $userId, string $refreshToken, int $expiresIn = 604800): bool
    {
        try {
            // Hash token for secure storage
            $hashedToken = hash('sha256', $refreshToken);
            
            // Store the token in the refresh_tokens table
            $this->dbHelper->insert('refresh_tokens', [
                'user_id' => $userId,
                'token' => $hashedToken,
                'expires_at' => date('Y-m-d H:i:s', time() + $expiresIn),
                'created_at' => date('Y-m-d H:i:s'),
                'ip_address' => $_SERVER['REMOTE_ADDR'] ?? null
            ], $this->useSecureDb);
            
            $this->logger->info("Refresh token stored", ['user_id' => $userId]);
            return true;
        } catch (Exception $e) {
            $this->logger->error("Failed to store refresh token: " . $e->getMessage());
            return false;
        }
    }

    /**
     * Check if a token has been revoked
     * 
     * @param string $token The unhashed token
     * @return bool True if revoked
     */
    public function isRevoked(string $token): bool
    {
        try {
            // Check cache first for performance
            if (apcu_exists("revoked_refresh_token_$token")) {
                return true;
            }
            
            // If not in cache, check secure database
            $hashedToken = hash('sha256', $token);
            $query = "SELECT 1 FROM refresh_tokens WHERE token = :token AND revoked = 1 LIMIT 1";
            $revoked = $this->dbHelper->select($query, [':token' => $hashedToken], $this->useSecureDb);
                
            // If revoked in database, store in cache for next time
            if ($revoked) {
                apcu_store("revoked_refresh_token_$token", true, 604800);
            }
            
            return !empty($revoked);
        } catch (Exception $e) {
            $this->logger->warning("Error checking if token is revoked: " . $e->getMessage());
            // Default to not revoked if there's an error checking, but log it
            return false;
        }
    }

    /**
     * Find token data by the token string
     * 
     * @param string $token The unhashed token
     * @return array|null Token data or null if not found
     */
    public function findByToken(string $token): ?array
    {
        try {
            $hashedToken = hash('sha256', $token);
            $query = "SELECT * FROM refresh_tokens WHERE token = :token LIMIT 1";
            $result = $this->dbHelper->select($query, [':token' => $hashedToken], $this->useSecureDb);
            
            return $result[0] ?? null;
        } catch (Exception $e) {
            $this->logger->error("Error finding token: " . $e->getMessage());
            return null;
        }
    }

    /**
     * Revoke a token
     * 
     * @param string $token The unhashed token
     * @return bool Success status
     */
    public function revoke(string $token): bool
    {
        try {
            // Store in cache for quick lookups
            apcu_store("revoked_refresh_token_$token", true, 604800);
            
            // Store in secure database for persistence
            $hashedToken = hash('sha256', $token);
            
            // Update the token status in secure database
            $result = $this->dbHelper->update(
                'refresh_tokens', 
                [
                    'revoked' => 1,
                    'revoked_at' => date('Y-m-d H:i:s')
                ], 
                ['token' => $hashedToken], 
                $this->useSecureDb
            );
                
            return $result;
        } catch (Exception $e) {
            $this->logger->error("Failed to revoke token: " . $e->getMessage());
            return false;
        }
    }

    /**
     * Purge all expired tokens
     * 
     * @return int Number of tokens purged
     */
    public function purgeExpired(): int
    {
        try {
            $count = $this->dbHelper->delete(
                'refresh_tokens', 
                ['expires_at < ' => date('Y-m-d H:i:s')], 
                false,
                $this->useSecureDb
            );
                
            $this->logger->info("Purged {$count} expired tokens");
            return $count;
        } catch (Exception $e) {
            $this->logger->error("Failed to purge expired tokens: " . $e->getMessage());
            return 0;
        }
    }

    /**
     * Get all active tokens for a user
     * 
     * @param int $userId The user ID
     * @return array List of token records
     */
    public function getActiveForUser(int $userId): array
    {
        try {
            $query = "SELECT * FROM refresh_tokens WHERE user_id = :user_id AND revoked = 0 AND expires_at > :now";
            $tokens = $this->dbHelper->select(
                $query, 
                [
                    ':user_id' => $userId,
                    ':now' => date('Y-m-d H:i:s')
                ], 
                $this->useSecureDb
            );
                
            return $tokens ?? [];
        } catch (Exception $e) {
            $this->logger->error("Failed to get active tokens: " . $e->getMessage());
            return [];
        }
    }

    /**
     * Get user ID associated with a token
     * 
     * @param string $token The unhashed token
     * @return int|null User ID or null if not found
     */
    public function getUserId(string $token): ?int
    {
        $tokenData = $this->findByToken($token);
        return $tokenData['user_id'] ?? null;
    }
}
=== App/Models/Payment.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Payment Model
 *
 * Represents a payment transaction in the system.
 *
 * @property int $id Primary key
 * @property int $user_id ID of the user who made the payment
 * @property int $booking_id ID of the associated booking
 * @property float $amount Transaction amount
 * @property string $method Payment method (credit_card, PayPal, etc.)
 * @property string $status Status of the payment (pending, completed, failed)
 * @property string|null $transaction_id Unique external transaction identifier
 * @property string $type Type of transaction ('payment' or 'refund')
 * @property string|null $refund_reason Reason for refund, if applicable
 * @property int|null $original_payment_id ID of the original payment (for refunds only)
 */
class Payment extends BaseModel
{
    protected $table = 'payments';
    protected $resourceName = 'payment';
    protected $useSoftDeletes = true;

    /**
     * Attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'user_id',
        'booking_id',
        'amount',
        'type',
        'status',
        'created_at',
        'updated_at'
    ];

    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'user_id' => 'required|exists:users,id',
        'booking_id' => 'required|exists:bookings,id',
        'amount' => 'required|numeric|min:0',
        'method' => 'required|string|in:credit_card,paypal,bank_transfer',
        'status' => 'required|string|in:pending,completed,failed',
        'transaction_id' => 'nullable|string|max:255',
        'type' => 'string|in:payment,refund',
        'refund_reason' => 'nullable|string|max:255',
        'original_payment_id' => 'nullable|integer|exists:payments,id',
    ];

    public function __construct(DatabaseHelper $dbHelper, AuditService $auditService = null)
    {
        $this->dbHelper = $dbHelper;
        $this->auditService = $auditService;
    }

    /**
     * Find a payment by ID.
     *
     * @param int $id
     * @return array|null
     */
    public function find(int $id): ?array
    {
        $query = "SELECT * FROM {$this->table} WHERE id = :id AND deleted_at IS NULL LIMIT 1";
        $result = $this->dbHelper->select($query, [':id' => $id]);
        return $result[0] ?? null; // Return first result or null
    }
    

    /**
     * Get all payments.
     *
     * @return array
     */
    public function all(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query);
    }

    /**
     * Create a new payment or refund.
     *
     * @param array $data
     * @return int|null ID of the created payment/refund, or null on failure
     */
    public function create(array $data): ?int
    {
        // Set default type to 'payment' if not specified
        $data['type'] = $data['type'] ?? 'payment';
        
        // Validate the data
        if (isset($this->validator)) {
            $validation = $this->validator->validate($data, self::$rules);
            if ($validation->fails()) {
                if (isset($this->logger)) {
                    $this->logger->error('Payment validation failed', $validation->errors()->all());
                }
                return null;
            }
        }
        
        // For refunds, the amount should be negative (to represent money going out)
        if ($data['type'] === 'refund' && $data['amount'] > 0) {
            $data['amount'] = -1 * abs($data['amount']);
        }

        $data['created_at'] = $data['updated_at'] = date('Y-m-d H:i:s');
        $paymentId = $this->dbHelper->insert($this->table, $data);
        
        if (!$paymentId) {
            return null; // Return null if insertion fails
        }

        if ($this->auditService) {
            $eventType = ($data['type'] === 'refund') ? 'Created refund' : 'Created payment';
            
            $auditData = [
                'payment_id' => $paymentId,
                'user_id' => $data['user_id'],
                'booking_id' => $data['booking_id'],
                'amount' => $data['amount'],
                'method' => $data['method'],
                'type' => $data['type']
            ];
            
            // Add refund-specific data if applicable
            if ($data['type'] === 'refund') {
                $auditData['refund_reason'] = $data['refund_reason'] ?? null;
                $auditData['original_payment_id'] = $data['original_payment_id'] ?? null;
            }
            
            $this->auditService->logEvent($this->resourceName, $eventType, $auditData);
        }
        
        return (int) $paymentId; // Ensure ID is always an integer
    }

    /**
     * Create a refund record.
     * 
     * @param array $refundData Must contain: user_id, booking_id, amount, method, original_payment_id
     * @return int|null ID of the created refund, or null on failure
     */
    public function createRefund(array $refundData): ?int
    {
        // Ensure the type is set to refund
        $refundData['type'] = 'refund';
        
        // Set status to completed by default if not specified
        if (!isset($refundData['status'])) {
            $refundData['status'] = 'completed';
        }
        
        // Ensure refund reason is set
        if (!isset($refundData['refund_reason'])) {
            $refundData['refund_reason'] = 'Refund processed';
        }
        
        // Validate required fields specific to refunds
        if (!isset($refundData['original_payment_id'])) {
            if (isset($this->logger)) {
                $this->logger->error('Refund creation failed: original_payment_id is required');
            }
            return null;
        }
        
        // Check if original payment exists
        $originalPayment = $this->find($refundData['original_payment_id']);
        if (!$originalPayment) {
            if (isset($this->logger)) {
                $this->logger->error('Refund creation failed: original payment not found', [
                    'original_payment_id' => $refundData['original_payment_id']
                ]);
            }
            return null;
        }
        
        // Ensure original payment is a payment, not a refund
        if ($originalPayment['type'] === 'refund') {
            if (isset($this->logger)) {
                $this->logger->error('Refund creation failed: cannot refund a refund', [
                    'original_payment_id' => $refundData['original_payment_id']
                ]);
            }
            return null;
        }
        
        // Check if original payment is already fully refunded
        $refundedAmount = $this->getRefundedAmount($refundData['original_payment_id']);
        $originalAmount = abs($originalPayment['amount']);
        $requestedRefundAmount = abs($refundData['amount']);
        
        if (($refundedAmount + $requestedRefundAmount) > $originalAmount) {
            if (isset($this->logger)) {
                $this->logger->error('Refund creation failed: refund amount exceeds original payment', [
                    'original_payment_id' => $refundData['original_payment_id'],
                    'original_amount' => $originalAmount,
                    'already_refunded' => $refundedAmount,
                    'requested_refund' => $requestedRefundAmount
                ]);
            }
            return null;
        }
        
        // Ensure refund amount is stored as negative
        $refundData['amount'] = -1 * abs($refundData['amount']);
        
        // Use the create method to insert the refund record
        $refundId = $this->create($refundData);
        
        if ($refundId && $this->auditService) {
            // Add specialized refund audit log
            $this->auditService->logEvent(
                $this->resourceName, 
                'refund_processed', 
                [
                    'refund_id' => $refundId,
                    'original_payment_id' => $refundData['original_payment_id'],
                    'user_id' => $refundData['user_id'],
                    'booking_id' => $refundData['booking_id'],
                    'amount' => $refundData['amount'],
                    'reason' => $refundData['refund_reason'],
                    'remaining_balance' => $originalAmount - ($refundedAmount + abs($refundData['amount']))
                ]
            );
        }
        
        return $refundId;
    }

    /**
     * Update a payment.
     *
     * @param int $id
     * @param array $data
     * @return bool
     */
    public function update(int $id, array $data): bool
    {
        $data['updated_at'] = date('Y-m-d H:i:s');
        $result = $this->dbHelper->update($this->table, $data, ['id' => $id, 'deleted_at IS NULL']);
        
        // Log audit if service is available and update was successful
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'Updated payment', [
                'payment_id' => $id,
                'updated_fields' => array_keys($data)
            ]);
        }
        
        return $result;
    }

    /**
     * Soft delete a payment.
     *
     * @param int $id
     * @return bool
     */
    public function delete(int $id): bool
    {
        $result = $this->dbHelper->update($this->table, ['deleted_at' => date('Y-m-d H:i:s')], ['id' => $id]);
    
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'Deleted payment', ['payment_id' => $id]);
        }
        
        return $result;
    }
    

    /**
     * Get payments by user ID.
     * Replaces scopeByUser.
     *
     * @param int $userId
     * @return array
     */
    public function getByUser(int $userId): array
    {
        $query = "SELECT * FROM {$this->table} WHERE user_id = :user_id AND deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get completed payments.
     * Replaces scopeCompleted.
     *
     * @return array
     */
    public function getCompleted(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE status = 'completed' AND deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query);
    }

    /**
     * Get payments by status.
     * Replaces scopeByStatus.
     *
     * @param string $status
     * @return array
     */
    public function getByStatus(string $status): array
    {
        $query = "SELECT * FROM {$this->table} WHERE status = :status AND deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query, [':status' => $status]);
    }

    /**
     * Get payments within a date range with optional filters
     *
     * @param string $start
     * @param string $end
     * @param array $filters
     * @return array
     */
    public function getByDateRange(string $start, string $end, array $filters = []): array
    {
        $query = "SELECT p.*, u.name as user_name 
                 FROM {$this->table} p
                 LEFT JOIN users u ON p.user_id = u.id
                 WHERE p.created_at BETWEEN :start AND :end";

        if ($this->useSoftDeletes) {
            $query .= " AND p.deleted_at IS NULL";
        }
        
        $params = [':start' => $start, ':end' => $end];
        
        if (!empty($filters['type'])) {
            $query .= " AND p.type = :type";
            $params[':type'] = $filters['type'];
        }
        
        if (!empty($filters['status'])) {
            $query .= " AND p.status = :status";
            $params[':status'] = $filters['status'];
        }
        
        // Add sorting
        $query .= " ORDER BY p.created_at DESC";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute($params);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Get user data for a payment.
     * Replaces user relationship.
     *
     * @param int $paymentId
     * @return array|null
     */
    public function getUser(int $paymentId): ?array
    {
        $query = "SELECT u.* FROM users u JOIN {$this->table} p ON u.id = p.user_id WHERE p.id = :payment_id AND p.deleted_at IS NULL";
        return $this->dbHelper->select($query, [':payment_id' => $paymentId]);
    }

    /**
     * Get booking data for a payment.
     * Replaces booking relationship.
     *
     * @param int $paymentId
     * @return array|null
     */
    public function getBooking(int $paymentId): ?array
    {
        $query = "SELECT b.* FROM bookings b JOIN {$this->table} p ON b.id = p.booking_id WHERE p.id = :payment_id AND p.deleted_at IS NULL AND b.deleted_at IS NULL";
        return $this->dbHelper->select($query, [':payment_id' => $paymentId]);
    }

    /**
     * Get payments by booking ID
     * 
     * @param int $bookingId
     * @return array
     */
    public function getByBooking(int $bookingId): array
    {
        $query = "SELECT * FROM {$this->table} WHERE booking_id = :booking_id AND deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query, [':booking_id' => $bookingId]);
    }

    /**
     * Get refunds for a specific payment
     *
     * @param int $paymentId
     * @return array
     */
    public function getRefundsForPayment(int $paymentId): array
    {
        $query = "SELECT * FROM {$this->table} 
                  WHERE original_payment_id = :payment_id 
                  AND type = 'refund' 
                  AND deleted_at IS NULL
                  ORDER BY created_at DESC";
                  
        return $this->dbHelper->select($query, [':payment_id' => $paymentId]);
    }

    /**
     * Get all refunds
     *
     * @return array
     */
    public function getAllRefunds(): array
    {
        $query = "SELECT * FROM {$this->table} 
                  WHERE type = 'refund' 
                  AND deleted_at IS NULL
                  ORDER BY created_at DESC";
                  
        return $this->dbHelper->select($query);
    }

    /**
     * Check if a payment has been refunded
     *
     * @param int $paymentId
     * @return bool
     */
    public function hasRefunds(int $paymentId): bool
    {
        $query = "SELECT COUNT(*) as refund_count 
                  FROM {$this->table} 
                  WHERE original_payment_id = :payment_id 
                  AND type = 'refund' 
                  AND deleted_at IS NULL";
                  
        $result = $this->dbHelper->select($query, [':payment_id' => $paymentId]);
        return (int)$result[0]['refund_count'] > 0;
    }

    /**
     * Get total refunded amount for a payment
     *
     * @param int $paymentId
     * @return float
     */
    public function getRefundedAmount(int $paymentId): float
    {
        $query = "SELECT SUM(ABS(amount)) as total_refunded 
                  FROM {$this->table} 
                  WHERE original_payment_id = :payment_id 
                  AND type = 'refund' 
                  AND status = 'completed' 
                  AND deleted_at IS NULL";
                  
        $result = $this->dbHelper->select($query, [':payment_id' => $paymentId]);
        return (float)($result[0]['total_refunded'] ?? 0);
    }

    /**
     * Create a payment and return its ID
     * 
     * @param array $paymentData Payment details
     * @return int ID of created payment
     * @throws \Exception If creation fails
     */
    public function createPayment(array $paymentData): int
    {
        // Set default values if not provided
        $data = array_merge([
            'status' => 'pending',
            'type' => 'payment',
            'created_at' => date('Y-m-d H:i:s'),
            'updated_at' => date('Y-m-d H:i:s')
        ], $paymentData);
        
        // Encrypt sensitive data
        $data = $this->encryptSensitiveData($data);
        
        // Create the payment record
        $paymentId = $this->create($data);
        
        if (!$paymentId) {
            throw new \Exception('Payment creation failed');
        }
        
        // Log the payment creation for security auditing
        if ($this->auditService) {
            $this->auditService->logEvent(
                $this->resourceName,
                'payment_created',
                [
                    'payment_id' => $paymentId,
                    'user_id' => $data['user_id'],
                    'amount' => $paymentData['amount'], // Use unencrypted amount for audit
                    'method' => $data['method'],
                    'status' => $data['status']
                ],
                $data['user_id'] ?? null
            );
        }
        
        return $paymentId;
    }

    /**
     * Get payments for a specific user within a date range
     *
     * @param int $userId
     * @param string $start
     * @param string $end
     * @return array
     */
    public function getByUserAndDateRange(int $userId, string $start, string $end): array
    {
        $query = "SELECT * FROM {$this->table} 
                 WHERE user_id = :user_id
                 AND created_at BETWEEN :start AND :end";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([
            ':user_id' => $userId,
            ':start' => $start,
            ':end' => $end
        ]);
        
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }
}
=== App/Models/Contract.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;

/**
 * Contract Model
 *
 * Handles contract specific database operations
 */
class Contract extends BaseModel
{
    protected $table = 'contracts';
    protected $resourceName = 'contract';

    /**
     * @var array The attributes that are mass assignable
     */
    protected $fillable = [
        'booking_id',
        'user_id',
        'content',
        'status'
    ];

    /**
     * @var array Data type casting definitions
     */
    protected $casts = [
        'booking_id' => 'int',
        'user_id' => 'int'
    ];
    
    /**
     * Constructor
     * 
     * @param DatabaseHelper $db Database helper instance
     * @param LoggerInterface $logger Logger instance
     */
    public function __construct(DatabaseHelper $db, LoggerInterface $logger)
    {
        parent::__construct($db, null, $logger);
    }
    
    /**
     * Get contract by booking ID
     * 
     * @param int $bookingId Booking ID
     * @return array|null Contract or null if not found
     */
    public function getByBookingId(int $bookingId): ?array
    {
        $query = "SELECT * FROM {$this->table} WHERE booking_id = :booking_id LIMIT 1";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':booking_id' => $bookingId]);
        $result = $stmt->fetch(\PDO::FETCH_ASSOC);
        return $result ?: null;
    }
    
    /**
     * Get contracts by user ID
     * 
     * @param int $userId User ID
     * @return array Contracts
     */
    public function getByUserId(int $userId): array
    {
        $query = "SELECT * FROM {$this->table} WHERE user_id = :user_id ORDER BY created_at DESC";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':user_id' => $userId]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }
}
=== App/Models/Admin.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Admin Model - Manages system administrators.
 */
class Admin extends BaseModel
{
    protected $table = 'admins';
    protected $resourceName = 'admin';
    protected $useTimestamps = true;
    protected $useSoftDeletes = true;

    /**
     * @var array The attributes that are mass assignable
     */
    protected $fillable = [
        'name',
        'email',
        'password',
        'role'
    ];

    /**
     * @var array Data type casting definitions
     */
    protected $casts = [
        'id' => 'int',
        'email' => 'string',
        'role' => 'string'
    ];
    
    /**
     * Constructor
     *
     * @param DatabaseHelper $dbHelper
     * @param AuditService|null $auditService
     */
    public function __construct(DatabaseHelper $dbHelper = null, AuditService $auditService = null)
    {
        parent::__construct($dbHelper, $auditService);
    }
    
    /**
     * Hash a password.
     *
     * @param string $password
     * @return string
     */
    public static function hashPassword(string $password): string
    {
        return password_hash($password, PASSWORD_BCRYPT, ['cost' => 12]);
    }
    
    /**
     * Verify password.
     *
     * @param string $plainPassword
     * @param string $hashedPassword
     * @return bool
     */
    public static function verifyPassword(string $plainPassword, string $hashedPassword): bool
    {
        return password_verify($plainPassword, $hashedPassword);
    }
    
    /**
     * Override create to handle password hashing.
     *
     * @param array $data
     * @return int|string
     */
    public function create(array $data): int
    {
        if (isset($data['password'])) {
            $data['password'] = self::hashPassword($data['password']);
        }
        
        $id = parent::create($data);
        
        // Add custom audit logging if needed
        if ($this->auditService) {
            $this->auditService->logEvent('admin', 'admin_created', [
                'id' => $id,
                'name' => $data['name'] ?? null,
                'email' => $data['email'] ?? null,
                'role' => $data['role'] ?? null
            ]);
        }
        
        return $id;
    }
    
    /**
     * Override update to handle password hashing.
     *
     * @param int|string $id
     * @param array $data
     * @return bool
     */
    public function update(int|string $id, array $data): bool
    {
        if (isset($data['password'])) {
            $data['password'] = self::hashPassword($data['password']);
        }
        
        $result = parent::update($id, $data);
        
        // Add custom audit logging if needed
        if ($result && $this->auditService) {
            $this->auditService->logEvent('admin', 'admin_updated', [
                'id' => $id,
                'updated_fields' => array_keys($data)
            ]);
        }
        
        return $result;
    }
    
    /**
     * Get admin by email.
     *
     * @param string $email
     * @return array|null
     */
    public function getByEmail(string $email): ?array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE email = :email
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':email' => $email]);
        return $result ? $result[0] : null;
    }
    
    /**
     * Restore a soft deleted admin.
     *
     * @param int|string $id
     * @return bool
     */
    public function restore(int|string $id): bool
    {
        if (!$this->useSoftDeletes) {
            return false;
        }
        
        $result = $this->dbHelper->update($this->table, ['deleted_at' => null], ['id' => $id]);
        
        if ($result && $this->auditService) {
            $this->auditService->logEvent('admin', 'admin_restored', [
                'admin_id' => $id
            ]);
        }
        
        return $result;
    }
    
    /**
     * Get users managed by this admin.
     *
     * @param int|string $adminId
     * @return array
     */
    public function getManagedUsers(int|string $adminId): array
    {
        $query = "
            SELECT * FROM users
            WHERE managed_by = :admin_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " ORDER BY name ASC";
        
        return $this->dbHelper->select($query, [':admin_id' => $adminId]);
    }
    
    /**
     * Get admin permissions.
     *
     * @param int|string $adminId
     * @return array
     */
    public function getPermissions(int|string $adminId): array
    {
        $query = "
            SELECT p.* FROM permissions p
            JOIN admin_permissions ap ON p.id = ap.permission_id
            WHERE ap.admin_id = :admin_id
        ";
        
        return $this->dbHelper->select($query, [':admin_id' => $adminId]);
    }

    /**
     * Find admin by token
     * 
     * @param string $token
     * @return array|null
     */
    public function findByToken(string $token): ?array
    {
        $query = "SELECT id, email, role FROM {$this->table} 
                 WHERE token = :token AND token_expiry > NOW()";
                 
        $result = $this->dbHelper->select($query, [':token' => $token], true);
        return !empty($result) ? $result[0] : null;
    }

    /**
     * Get paginated list of all users with their roles
     * 
     * @param int $page
     * @param int $perPage
     * @return array
     */
    public function getPaginatedUsers(int $page, int $perPage): array
    {
        $offset = ($page - 1) * $perPage;
        
        $query = "SELECT u.*, r.name as role_name 
                 FROM users u 
                 LEFT JOIN roles r ON u.role_id = r.id 
                 ORDER BY u.created_at DESC 
                 LIMIT :limit OFFSET :offset";
                 
        return $this->dbHelper->select($query, [
            ':limit' => $perPage,
            ':offset' => $offset
        ], false);
    }

    /**
     * Get total user count
     * 
     * @return int
     */
    public function getTotalUserCount(): int
    {
        $result = $this->dbHelper->select(
            "SELECT COUNT(*) as count FROM users",
            [],
            false
        );
        
        return (int)$result[0]['count'];
    }

    /**
     * Get user by ID
     * 
     * @param int $userId
     * @return array|null
     */
    public function getUserById(int $userId): ?array
    {
        $result = $this->dbHelper->select(
            "SELECT id, email, role FROM users WHERE id = :id",
            [':id' => $userId],
            false
        );
        
        return !empty($result) ? $result[0] : null;
    }

    /**
     * Update user role
     * 
     * @param int $userId
     * @param string $role
     * @return bool
     */
    public function updateUserRole(int $userId, string $role): bool
    {
        return $this->dbHelper->update(
            "users",
            ["role" => $role],
            ["id" => $userId],
            false
        );
    }

    /**
     * Soft delete user
     * 
     * @param int $userId
     * @return bool
     */
    public function softDeleteUser(int $userId): bool
    {
        return $this->dbHelper->update(
            "users",
            ["deleted_at" => date('Y-m-d H:i:s')],
            ["id" => $userId],
            false
        );
    }

    /**
     * Get dashboard statistics
     * 
     * @return array
     */
    public function getDashboardStatistics(): array
    {
        // Get total users count
        $userQuery = "SELECT COUNT(*) as count FROM users WHERE deleted_at IS NULL";
        $totalUsers = $this->dbHelper->select($userQuery, [], false)[0]['count'];
        
        // Get total bookings count
        $bookingQuery = "SELECT COUNT(*) as count FROM bookings";
        $totalBookings = $this->dbHelper->select($bookingQuery, [], false)[0]['count'];
        
        // Get total revenue
        $revenueQuery = "SELECT SUM(amount) as total FROM payments WHERE status = 'completed'";
        $revenueResult = $this->dbHelper->select($revenueQuery, [], false);
        $totalRevenue = $revenueResult[0]['total'] ?? 0;
        
        // Get latest 5 users
        $latestUserQuery = "SELECT u.*, r.name as role_name 
            FROM users u 
            LEFT JOIN roles r ON u.role_id = r.id 
            WHERE u.deleted_at IS NULL 
            ORDER BY u.created_at DESC 
            LIMIT 5";
        $latestUsers = $this->dbHelper->select($latestUserQuery, [], false);
        
        // Get latest 5 transactions
        $transactionQuery = "SELECT * FROM transaction_logs ORDER BY created_at DESC LIMIT 5";
        $latestTransactions = $this->dbHelper->select($transactionQuery, [], false);
        
        return [
            'total_users' => $totalUsers,
            'total_bookings' => $totalBookings,
            'total_revenue' => $totalRevenue,
            'latest_users' => $latestUsers,
            'latest_transactions' => $latestTransactions,
        ];
    }

    /**
     * Find admin by email
     * 
     * @param string $email
     * @return array|null
     */
    public function findByEmail(string $email): ?array
    {
        $query = "SELECT id FROM {$this->table} WHERE email = :email";
        
        $result = $this->dbHelper->select($query, [':email' => $email], true);
        return !empty($result) ? $result[0] : null;
    }

    /**
     * Create new admin user
     * 
     * @param array $adminData
     * @return int|null
     */
    public function createAdmin(array $adminData): ?int
    {
        return DatabaseHelper::insert(
            "admins",
            $adminData,
            true // Using secure database
        );
    }

    /**
     * Find admin by ID
     * 
     * @param int $adminId
     * @return array|null
     */
    public function findById(int $adminId): ?array
    {
        $query = "SELECT id, name, email, role, created_at FROM {$this->table} WHERE id = :id";
        
        $result = $this->dbHelper->select($query, [':id' => $adminId], true);
        return !empty($result) ? $result[0] : null;
    }
}
=== App/Models/Notification.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Notification Model
 *
 * Represents a notification in the system.
 */
class Notification extends BaseModel
{
    protected $table = 'notifications';
    protected $resourceName = 'notification';
    protected $useTimestamps = true;  // We'll use sent_at instead of created_at
    protected $useSoftDeletes = false; // Notifications don't use soft deletes

    /**
     * @var array The attributes that are mass assignable
     */
    protected $fillable = [
        'user_id',
        'message',
        'type',
        'link',
        'is_read',
        'sent_at'
    ];

    /**
     * @var array Data type casting definitions
     */
    protected $casts = [
        'user_id' => 'int',
        'is_read' => 'bool',
        'sent_at' => 'datetime'
    ];

    /**
     * Mark a notification as read.
     *
     * @param int $id
     * @return bool
     */
    public function markAsRead(int $id): bool
    {
        $result = $this->dbHelper->update($this->table, ['is_read' => 1], ['id' => $id]);
        
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'notification_read', [
                'id' => $id
            ]);
        }
        
        return $result;
    }

    /**
     * Create a new notification.
     *
     * @param array $data
     * @return int
     */
    public function create(array $data): int
    {
        // Set sent_at to now if not provided
        if (!isset($data['sent_at'])) {
            $data['sent_at'] = date('Y-m-d H:i:s');
        }
        
        // Default is_read to false if not provided
        if (!isset($data['is_read'])) {
            $data['is_read'] = 0;
        }
        
        return parent::create($data);
    }

    /**
     * Get notifications by user ID.
     *
     * @param int $userId
     * @return array
     */
    public function getByUserId(int $userId): array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE user_id = :user_id
            ORDER BY sent_at DESC
        ";
        
        $notifications = $this->dbHelper->select($query, [':user_id' => $userId]);
        return $notifications ?: [];
    }

    /**
     * Get unread notifications for a user.
     *
     * @param int $userId
     * @return array
     */
    public function getUnreadByUserId(int $userId): array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE user_id = :user_id AND is_read = 0
            ORDER BY sent_at DESC
        ";
        
        $notifications = $this->dbHelper->select($query, [':user_id' => $userId]);
        return $notifications ?: [];
    }

    /**
     * Mark all notifications as read for a user.
     *
     * @param int $userId
     * @return bool
     */
    public function markAllAsReadForUser(int $userId): bool
    {
        $result = $this->dbHelper->update($this->table, ['is_read' => 1], ['user_id' => $userId, 'is_read' => 0]);
        
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'all_notifications_read', [
                'user_id' => $userId
            ]);
        }
        
        return $result;
    }

    /**
     * Mark all notifications as read for a user.
     *
     * @param int $userId
     * @return bool
     */
    public function markAllAsRead(int $userId): bool
    {
        return $this->markAllAsReadForUser($userId);
    }

    /**
     * Get unread notifications count for a user.
     *
     * @param int $userId
     * @return int
     */
    public function getUnreadCount(int $userId): int
    {
        $query = "
            SELECT COUNT(*) as count FROM {$this->table}
            WHERE user_id = :user_id AND is_read = 0
        ";
        
        $result = $this->dbHelper->selectOne($query, [':user_id' => $userId]);
        return $result ? (int)$result['count'] : 0;
    }

    /**
     * Find a notification by ID and ensure it belongs to the specified user.
     *
     * @param int $id
     * @param int $userId
     * @return array|null
     */
    public function findForUser(int $id, int $userId): ?array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE id = :id AND user_id = :user_id
        ";
        
        $result = $this->dbHelper->select($query, [':id' => $id, ':user_id' => $userId]);
        return $result[0] ?? null;
    }

    /**
     * Delete all notifications for a user.
     *
     * @param int $userId
     * @return bool
     */
    public function deleteAllForUser(int $userId): bool
    {
        $result = $this->dbHelper->delete($this->table, ['user_id' => $userId]);
        
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'all_notifications_deleted', [
                'user_id' => $userId
            ]);
        }
        
        return $result;
    }

    /**
     * Get the user associated with a notification.
     *
     * @param int $notificationId
     * @return array|null
     */
    public function getUser(int $notificationId): ?array
    {
        $notification = $this->find($notificationId);
        
        if (!$notification || !isset($notification['user_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM users WHERE id = :user_id";
        $result = $this->dbHelper->select($query, [':user_id' => $notification['user_id']]);
        return $result[0] ?? null;
    }
}
=== App/Models/PaymentMethod.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;

/**
 * PaymentMethod Model
 *
 * Represents a payment method and handles interactions with the `payment_methods` table.
 */
class PaymentMethod extends BaseModel
{
    protected $table = 'payment_methods';
    protected $resourceName = 'payment_method';
    
    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'name' => 'required|string|max:255',
        'description' => 'nullable|string',
        'is_active' => 'boolean',
        'user_id' => 'required|exists:users,id',
        'payment_type' => 'required|string|in:credit_card,paypal,bank_transfer'
    ];

    public function __construct(DatabaseHelper $dbHelper)
    {
        $this->pdo = $dbHelper->getPdo();
    }

    /**
     * Get all available payment methods.
     */
    public function getAll(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE is_active = 1";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute();
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Get payment method by ID.
     */
    public function getById(int $id): ?array
    {
        $stmt = $this->pdo->prepare("SELECT * FROM payment_methods WHERE id = :id");
        $stmt->execute([':id' => $id]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }

    /**
     * Add a new payment method.
     */
    public function create(array $data): int
    {
        $validPaymentTypes = ['credit_card', 'paypal', 'bank_transfer'];
        if (!in_array($data['payment_type'], $validPaymentTypes)) {
            throw new \InvalidArgumentException("Invalid payment type.");
        }

        return parent::create($data);
    }
    
    /**
     * Update a payment method.
     */
    public function update(int $id, array $data): bool
    {
        $setClauses = [];
        $params = [':id' => $id];

        foreach ($data as $key => $value) {
            if (in_array($key, ['name', 'description', 'is_active', 'payment_type'])) {
                $setClauses[] = "$key = :$key";
                $params[":$key"] = $value;
            }
        }

        if (empty($setClauses)) {
            return false;
        }

        $setClauses[] = "updated_at = NOW()";
        $setClause = implode(', ', $setClauses);

        $stmt = $this->pdo->prepare("
            UPDATE payment_methods 
            SET $setClause 
            WHERE id = :id
        ");
        return $stmt->execute($params);
    }
    
    /**
     * Delete a payment method.
     */
    public function delete(int $id): bool
    {
        $stmt = $this->pdo->prepare("DELETE FROM payment_methods WHERE id = :id");
        return $stmt->execute([':id' => $id]);
    }

    /**
     * Get payment methods by user ID.
     * Replaces scopeByUser.
     */
    public function getByUser(int $userId): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE user_id = :user_id
            ORDER BY created_at DESC
        ";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':user_id' => $userId]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }
    
    /**
     * Get user data for a payment method.
     * Replaces user relationship.
     */
    public function getUser(int $paymentMethodId): ?array
    {
        $query = "
            SELECT u.* FROM users u
            JOIN {$this->table} pm ON u.id = pm.user_id
            WHERE pm.id = :payment_method_id
        ";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':payment_method_id' => $paymentMethodId]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }
}
=== App/Models/Document.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Document Model
 *
 * Represents documents stored in the system and provides methods
 * for managing and querying them.
 */
class Document extends BaseModel
{
    protected $table = 'documents';
    protected $resourceName = 'document';
    protected $useSoftDeletes = false; // Document model doesn't use soft deletes

    /**
     * @var array The attributes that are mass assignable
     */
    protected $fillable = [
        'name',
        'file_path',
        'user_id',
        'type'
    ];

    /**
     * @var array Data type casting definitions
     */
    protected $casts = [
        'user_id' => 'int'
    ];

    /**
     * Retrieve documents associated with a user.
     *
     * @param int $userId The ID of the user.
     * @return array A list of documents associated with the user.
     */
    public function getByUserId(int $userId): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE user_id = :user_id 
            ORDER BY created_at DESC
        ";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':user_id' => $userId]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Retrieve documents by type.
     *
     * @param string $type The type of document (e.g., 'contract', 'terms').
     * @return array A list of documents matching the specified type.
     */
    public function getByType(string $type): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE type = :type 
            ORDER BY created_at DESC
        ";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':type' => $type]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }
}
=== App/Models/BaseFinancialModel.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;
use App\Services\EncryptionService;

/**
 * Base class for any model dealing with financial data
 * to provide consistent handling of sensitive information
 */
abstract class BaseFinancialModel extends BaseModel
{
    /** @var DatabaseHelper */
    protected $dbHelper;
    
    /** @var AuditService|null */
    protected $auditService;
    
    /**
     * Fields that should be encrypted when stored in the database
     *
     * @var array
     */
    protected $encryptedFields = ['amount', 'card_number', 'card_last4'];
    
    /**
     * Encrypt sensitive data before insert/update
     *
     * @param array $data
     * @return array
     */
    protected function encryptSensitiveData(array $data): array
    {
        foreach ($this->encryptedFields as $field) {
            if (isset($data[$field])) {
                $data[$field] = EncryptionService::encrypt($data[$field]);
            }
        }
        
        return $data;
    }
    
    /**
     * Decrypt sensitive data after fetch
     *
     * @param array $data
     * @return array
     */
    protected function decryptSensitiveData(array $data): array
    {
        foreach ($this->encryptedFields as $field) {
            if (isset($data[$field])) {
                $data[$field] = EncryptionService::decrypt($data[$field]);
            }
        }
        
        return $data;
    }
    
    /**
     * Record a security event in the audit log
     *
     * @param string $action
     * @param array $data
     * @param int|null $userId
     */
    protected function recordAuditEvent(string $action, array $data, ?int $userId = null): void
    {
        if ($this->auditService) {
            $this->auditService->logEvent(
                $this->resourceName,
                $action,
                $data,
                $userId
            );
        }
    }
}
=== App/Models/Vehicle.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Vehicle Model
 *
 * Represents a vehicle in the system.
 */
class Vehicle extends BaseModel
{
    protected $table = 'vehicles';
    protected $resourceName = 'vehicle';
    protected $useSoftDeletes = false; // Vehicles use hard deletes

    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'registration_number' => 'required|string|unique:vehicles,registration_number',
        'type' => 'required|string',
        'status' => 'required|in:available,unavailable,maintenance',
        'make' => 'required|string|max:255',
        'model' => 'required|string|max:255',
        'year' => 'required|integer|min:1886|max:' . PHP_INT_MAX,
    ];

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'registration_number',
        'type',
        'status',
        'make',
        'model',
        'year',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array
     */
    protected $casts = [
        'year' => 'integer',
    ];

    /**
     * Find available vehicles
     *
     * @return array
     */
    public function findAvailable(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE status = :status";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':status' => 'available']);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Find vehicles by type
     *
     * @param string $type
     * @return array
     */
    public function findByType(string $type): array
    {
        $query = "SELECT * FROM {$this->table} WHERE type = :type";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':type' => $type]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Get vehicle's bookings
     *
     * @param int $vehicleId
     * @return array
     */
    public function getBookings(int $vehicleId): array
    {
        $query = "SELECT * FROM bookings WHERE vehicle_id = :vehicle_id";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':vehicle_id' => $vehicleId]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }
    
    /**
     * Set a vehicle to maintenance status
     *
     * @param int $id
     * @param string $reason
     * @return bool
     */
    public function setToMaintenance(int $id, string $reason = ''): bool
    {
        $result = $this->update($id, ['status' => 'maintenance']);
        
        // Add custom audit logging for maintenance status
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'vehicle_maintenance', [
                'vehicle_id' => $id,
                'reason' => $reason
            ]);
        }
        
        return $result;
    }
    
    /**
     * Set a vehicle to available status
     *
     * @param int $id
     * @return bool
     */
    public function setToAvailable(int $id): bool
    {
        return $this->update($id, ['status' => 'available']);
    }
}
=== App/Models/DocumentTemplate.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;
use Psr\Log\LoggerInterface;

/**
 * DocumentTemplate Model
 *
 * Manages templates for documents such as contracts, invoices, and Terms & Conditions.
 */
class DocumentTemplate extends BaseModel
{
    protected $table = 'document_templates';
    protected $resourceName = 'document_template';
    protected $useSoftDeletes = true;

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'name',
        'content',
        'description',
        'file_path'
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array
     */
    protected $casts = [
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Constructor
     *
     * @param DatabaseHelper $dbHelper
     * @param LoggerInterface|null $logger
     */
    public function __construct(DatabaseHelper $dbHelper, ?LoggerInterface $logger = null)
    {
        parent::__construct($dbHelper, null, $logger);
    }

    /**
     * Get the validation rules for the model.
     *
     * @return array
     */
    public static function validationRules(): array
    {
        return [
            'name' => 'required|string|max:255',
            'content' => 'required|string',
            'file_path' => 'required|string|max:255',
        ];
    }

    /**
     * Find a template by its name
     * 
     * @param string $name The template name
     * @return array|null The template or null if not found
     */
    public function findByName(string $name): ?array
    {
        return $this->findOneBy('name', $name);
    }
}
=== App/Models/User.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use Exception;
use Psr\Log\LoggerInterface;
use Illuminate\Support\Facades\Hash;
use Ramsey\Uuid\Uuid;
use App\Services\AuditService;

/**
 * User Model
 * 
 * Represents a user in the system with their associated data and relationships.
 * 
 * @property string $id UUID of the user
 * @property string $name User's first name
 * @property string $surname User's last name
 * @property string $email User's email address
 * @property string $password_hash Hashed password
 * @property string $role User role (user, admin, super_admin)
 * @property string $phone Phone number
 * @property string $address Physical address
 * @property \DateTime $created_at
 * @property \DateTime $updated_at
 * @property \DateTime $deleted_at
 */
class User extends BaseModel
{
    protected $logger;

    public function __construct(DatabaseHelper $dbHelper = null, LoggerInterface $logger = null, AuditService $auditService = null)
    {
        parent::__construct($dbHelper, $auditService);
        $this->logger = $logger;
    }

    protected $table = 'users';
    protected $primaryKey = 'id';
    protected $resourceName = 'user';
    protected $useTimestamps = true;
    protected $useSoftDeletes = true;
    protected $useUuid = true;

    protected $fillable = [
        'name',
        'surname',
        'email',
        'password_hash',
        'role',
        'phone',
        'address',
        'status',
        'created_at',
        'updated_at'
    ];

    protected $hidden = [
        'password_hash',
        'remember_token',
        'deleted_at',
    ];

    public static array $rules = [
        'name' => 'required|string|max:255',
        'surname' => 'required|string|max:255',
        'email' => 'required|email|unique:users,email',
        'password' => 'required|min:8|regex:/^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/',
        'role' => 'required|in:user,admin,super_admin',
        'phone' => 'nullable|string|max:20',
        'address' => 'nullable|string|max:255',
    ];

    /**
     * Relationships
     */

    /**
     * Get user's bookings
     * 
     * @param string $userId
     * @return array
     */
    public function getBookings(string $userId): array
    {
        $query = "SELECT * FROM bookings WHERE user_id = :user_id";
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's payments
     * 
     * @param int $userId
     * @return array
     */
    public function getPayments(int $userId): array
    {
        $query = "SELECT p.* FROM payments p 
                 JOIN bookings b ON p.booking_id = b.id 
                 WHERE b.user_id = :user_id AND p.deleted_at IS NULL 
                 ORDER BY p.created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }
    
    /**
     * Get all transactions for a user
     * 
     * @param int $userId
     * @return array
     */
    public function getTransactions(int $userId): array
    {
        $query = "SELECT t.* FROM transaction_logs t 
                 WHERE t.user_id = :user_id 
                 ORDER BY t.created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's notifications
     * 
     * @param string $userId
     * @return array
     */
    public function getNotifications(string $userId): array
    {
        $query = "SELECT * FROM notifications WHERE user_id = :user_id";
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's logs
     * 
     * @param string $userId
     * @return array
     */
    public function getLogs(string $userId): array
    {
        $query = "SELECT * FROM logs WHERE user_reference = :user_id";
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's audit trails
     * 
     * @param string $userId
     * @return array
     */
    public function getAuditTrails(string $userId): array
    {
        $query = "SELECT * FROM audit_trails WHERE user_reference = :user_id";
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's contracts
     * 
     * @param string $userId
     * @return array
     */
    public function getContracts(string $userId): array
    {
        $query = "SELECT * FROM contracts WHERE user_reference = :user_id";
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Accessors & Helpers
     */
    
    /**
     * Get full name by combining first and last name
     * 
     * @param array $user User data
     * @return string
     */
    public static function getFullName(array $user): string
    {
        return "{$user['name']} {$user['surname']}";
    }

    /**
     * Check if user is an admin
     * 
     * @param array $user User data
     * @return bool
     */
    public static function isAdmin(array $user): bool
    {
        return in_array($user['role'], ['admin', 'super_admin']);
    }

    /**
     * Check if user is a super admin
     * 
     * @param array $user User data
     * @return bool
     */
    public static function isSuperAdmin(array $user): bool
    {
        return $user['role'] === 'super_admin';
    }

    /**
     * Check if user has a specific permission
     * 
     * @param array $user User data
     * @param string $permission
     * @return bool
     */
    public static function hasPermission(array $user, string $permission): bool
    {
        $rolePermissions = [
            'user' => ['read_own'],
            'admin' => ['read_own', 'read_all', 'write_all'],
            'super_admin' => ['read_own', 'read_all', 'write_all', 'delete_all'],
        ];

        return in_array($permission, $rolePermissions[$user['role']] ?? []);
    }

    /**
     * Password handling
     */
    
    /**
     * Hash a password
     * 
     * @param string $password
     * @return string
     */
    public static function hashPassword(string $password): string
    {
        return Hash::make($password);
    }
    
    /**
     * Verify a password
     * 
     * @param string $password
     * @param string $hash
     * @return bool
     */
    public static function verifyPassword(string $password, string $hash): bool
    {
        return Hash::check($password, $hash);
    }

    /**
     * Database operations
     */

    /**
     * Create a new user
     * 
     * @param array $data
     * @return int The ID of the created user (or UUID converted to integer if using UUID)
     */
    public function create(array $data): int
    {
        if (isset($data['password'])) {
            $data['password_hash'] = self::hashPassword($data['password']);
            unset($data['password']);
        }

        if ($this->useUuid && !isset($data['id'])) {
            $data['id'] = Uuid::uuid4()->toString();
        }

        if ($this->useTimestamps) {
            $now = date('Y-m-d H:i:s');
            $data['created_at'] = $now;
            $data['updated_at'] = $now;
        }

        $id = $this->dbHelper->insert($this->table, $data);
        
        // Log the creation if audit service is available
        if ($this->auditService) {
            $this->auditService->logEvent('user', 'created', [
                'id' => $id,
                'email' => $data['email'] ?? 'unknown'
            ]);
        }

        // Ensure we return an integer to match the parent class signature
        return is_numeric($id) ? (int)$id : crc32($id);
    }

    /**
     * Update user data
     * 
     * @param string|int $id
     * @param array $data
     * @return bool
     */
    public function update(string|int $id, array $data): bool
    {
        if (isset($data['password'])) {
            $data['password_hash'] = self::hashPassword($data['password']);
            unset($data['password']);
        }

        if ($this->useTimestamps) {
            $data['updated_at'] = date('Y-m-d H:i:s');
        }

        $conditions = ['id' => $id];
        if ($this->useSoftDeletes) {
            $conditions['deleted_at IS NULL'] = null;
        }

        $result = $this->dbHelper->update($this->table, $data, $conditions);
        
        // Log the update if audit service is available
        if ($result && $this->auditService) {
            $this->auditService->logEvent('user', 'updated', [
                'id' => $id,
                'updated_fields' => array_keys($data)
            ]);
        }

        return $result;
    }

    /**
     * Find a user by their email address
     * 
     * @param string $email
     * @return array|null
     */
    public function findByEmail(string $email): ?array
    {
        try {
            $stmt = $this->pdo->prepare("SELECT * FROM users WHERE email = ? AND active = 1");
            $stmt->execute([$email]);
            return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
        } catch (Exception $e) {
            $this->logger->error("Error finding user by email: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Find a user by their ID
     * 
     * @param string|int $id
     * @return array|null
     */
    public function find(string|int $id): ?array
    {
        try {
            $stmt = $this->pdo->prepare("SELECT * FROM users WHERE id = ? AND active = 1");
            $stmt->execute([$id]);
            return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
        } catch (Exception $e) {
            $this->logger->error("Error finding user by ID: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Validate a user's password
     */
    public function validatePassword(string $email, string $password): ?array
    {
        $user = $this->findByEmail($email);
        
        if (!$user || !password_verify($password, $user['password_hash'])) {
            return null;
        }
        
        return $user;
    }

    /**
     * Update a user's password
     */
    public function updatePassword(int $userId, string $newPassword): bool
    {
        try {
            $hashedPassword = $this->hashPassword($newPassword);
            return $this->update($userId, [
                'password_hash' => $hashedPassword,
                'updated_at' => date('Y-m-d H:i:s')
            ]);
        } catch (Exception $e) {
            $this->logger->error("Error updating password: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Create a password reset token
     */
    public function createPasswordReset(string $email, string $token, ?string $ipAddress, string $expiry): bool
    {
        try {
            $stmt = $this->pdo->prepare("INSERT INTO password_resets (email, token, ip_address, expires_at, created_at) VALUES (?, ?, ?, ?, ?)");
            return $stmt->execute([
                $email, 
                $token, 
                $ipAddress, 
                $expiry, 
                date('Y-m-d H:i:s')
            ]);
        } catch (Exception $e) {
            $this->logger->error("Error creating password reset: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Verify a password reset token
     */
    public function verifyResetToken(string $token): ?array
    {
        try {
            $stmt = $this->pdo->prepare(
                "SELECT * FROM password_resets 
                 WHERE token = ? AND used = 0 AND expires_at > ? 
                 ORDER BY created_at DESC LIMIT 1"
            );
            $stmt->execute([$token, date('Y-m-d H:i:s')]);
            return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
        } catch (Exception $e) {
            $this->logger->error("Error verifying reset token: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Mark a reset token as used
     */
    public function markResetTokenUsed(int $tokenId): bool
    {
        try {
            $stmt = $this->pdo->prepare("UPDATE password_resets SET used = 1, used_at = ? WHERE id = ?");
            return $stmt->execute([date('Y-m-d H:i:s'), $tokenId]);
        } catch (Exception $e) {
            $this->logger->error("Error marking reset token as used: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Get active users (not deleted)
     * 
     * @return array
     */
    public function getActive(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE deleted_at IS NULL";
        return $this->dbHelper->select($query);
    }

    /**
     * Get users with a specific role
     * 
     * @param string $role
     * @return array
     */
    public function getWithRole(string $role): array
    {
        $query = "SELECT * FROM {$this->table} WHERE role = :role";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        return $this->dbHelper->select($query, [':role' => $role]);
    }

    /**
     * Get a user by email
     * 
     * @param string $email
     * @return array|null
     */
    public function getUserByEmail(string $email): ?array
    {
        return $this->findByEmail($email);
    }

    /**
     * Update user profile
     * 
     * @param string|int $userId
     * @param array $profileData
     * @return bool
     */
    public function updateProfile(string|int $userId, array $profileData): bool
    {
        try {
            // Filter out sensitive fields that shouldn't be updated via profile update
            $allowedFields = ['name', 'surname', 'phone', 'address'];
            $filteredData = array_intersect_key($profileData, array_flip($allowedFields));
            
            return $this->update($userId, $filteredData);
        } catch (Exception $e) {
            $this->logger->error("Error updating user profile: " . $e->getMessage(), [
                'user_id' => $userId,
                'exception' => $e
            ]);
            throw $e;
        }
    }

    /**
     * Update user role
     * 
     * @param string|int $userId
     * @param string $newRole
     * @return bool
     * @throws Exception If role is invalid
     */
    public function updateUserRole(string|int $userId, string $newRole): bool
    {
        try {
            // Validate role
            $validRoles = ['user', 'admin', 'super_admin'];
            if (!in_array($newRole, $validRoles)) {
                throw new Exception("Invalid role: {$newRole}");
            }

            return $this->update($userId, ['role' => $newRole]);
        } catch (Exception $e) {
            $this->logger->error("Error updating user role: " . $e->getMessage(), [
                'user_id' => $userId,
                'new_role' => $newRole,
                'exception' => $e
            ]);
            throw $e;
        }
    }

    /**
     * Soft delete a user
     * 
     * @param string|int $userId
     * @return bool
     */
    public function deleteUser(string|int $userId): bool
    {
        try {
            // Fetch the user first to check role
            $user = $this->find($userId);
            
            // Return false if the user is a super admin
            if ($user && isset($user['role']) && $user['role'] === 'super_admin') {
                return false;
            }

            if (!$this->useSoftDeletes) {
                throw new Exception("Soft deletes not enabled for User model");
            }
            
            $data = ['deleted_at' => date('Y-m-d H:i:s')];
            $conditions = ['id' => $userId];
            
            $result = $this->dbHelper->update($this->table, $data, $conditions);
            
            if ($result && $this->auditService) {
                $this->auditService->logEvent('user', 'deleted', [
                    'id' => $userId
                ]);
            }
            
            return $result;
        } catch (Exception $e) {
            $this->logger->error("Error deleting user: " . $e->getMessage(), [
                'user_id' => $userId,
                'exception' => $e
            ]);
            throw $e;
        }
    }

    /**
     * Change user password
     * 
     * @param string|int $userId 
     * @param string $currentPassword
     * @param string $newPassword
     * @return bool
     * @throws Exception If current password is invalid
     */
    public function changePassword(string|int $userId, string $currentPassword, string $newPassword): bool
    {
        try {
            // Get user first to verify current password
            $user = $this->find($userId);
            
            if (!$user) {
                throw new Exception("User not found");
            }
            
            // Verify current password
            if (!self::verifyPassword($currentPassword, $user['password_hash'])) {
                throw new Exception("Current password is incorrect");
            }
            
            // Update password
            return $this->updatePassword($userId, $newPassword);
        } catch (Exception $e) {
            $this->logger->error("Error changing password: " . $e->getMessage(), [
                'user_id' => $userId,
                'exception' => $e
            ]);
            throw $e;
        }
    }

    public function getRecentActivity(string|int $userId, int $limit = 5): array
    {
        $query = "SELECT activity_type, description, created_at 
                  FROM user_activities 
                  WHERE user_id = :user_id 
                  ORDER BY created_at DESC 
                  LIMIT $limit";
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    public function logActivity(string|int $userId, string $activityType, string $description, ?string $ipAddress = null): bool
    {
        $data = [
            'user_id'       => $userId,
            'activity_type' => $activityType,
            'description'   => $description,
            'created_at'    => date('Y-m-d H:i:s'),
            'ip_address'    => $ipAddress
        ];
        return (bool) $this->dbHelper->insert('user_activities', $data);
    }

    /**
     * Get users within a date range with optional filters
     *
     * @param string $start
     * @param string $end
     * @param array $filters
     * @return array
     */
    public function getByDateRange(string $start, string $end, array $filters = []): array
    {
        $query = "SELECT * FROM {$this->table} WHERE created_at BETWEEN :start AND :end";
        
        $params = [':start' => $start, ':end' => $end];
        
        if (!empty($filters['status'])) {
            $query .= " AND status = :status";
            $params[':status'] = $filters['status'];
        }
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute($params);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }
}
=== App/Models/AuditLog.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Helpers\LogQueryBuilder;
use App\Helpers\SecurityHelper;
use DateTime;

/**
 * AuditLog Model
 *
 * Represents the audit_logs table and provides methods for
 * retrieving, searching, and exporting audit data.
 */
class AuditLog
{
    protected $table = 'audit_logs';
    
    /**
     * Get logs with filtering and pagination
     *
     * @param array $filters Filter criteria
     * @return array Logs and pagination information
     */
    public function getLogs(array $filters = []): array
    {
        // Use LogQueryBuilder for building the query
        $query = LogQueryBuilder::buildSelectQuery($filters);
        
        // Execute count query for pagination
        $totalItems = 0;
        $totalPages = 0;
        
        if (!($filters['skip_pagination'] ?? false)) {
            $countResult = DatabaseHelper::select(
                $query['countSql'],
                $query['params'],
                true
            );
            $totalItems = $countResult[0]['total'] ?? 0;
            $perPage = $query['perPage'];
            $totalPages = ceil($totalItems / $perPage);
        }
        
        // Execute the main query
        $logs = DatabaseHelper::select(
            $query['mainSql'],
            $query['params'],
            true
        );
        
        // Process results
        foreach ($logs as &$log) {
            $this->processLogData($log);
        }
        
        // Build response
        $result = ['data' => $logs];
        
        // Add pagination if needed
        if (!($filters['skip_pagination'] ?? false)) {
            $result['pagination'] = [
                'total' => $totalItems,
                'per_page' => $query['perPage'],
                'current_page' => $query['page'],
                'last_page' => $totalPages,
                'from' => (($query['page'] - 1) * $query['perPage']) + 1,
                'to' => min(($query['page'] * $query['perPage']), $totalItems),
            ];
        }
        
        return $result;
    }
    
    /**
     * Get a single log by ID
     *
     * @param int $id Log ID
     * @return array|null Log data or null if not found
     */
    public function getById(int $id): ?array
    {
        $sql = "SELECT * FROM {$this->table} WHERE id = ? LIMIT 1";
        $logs = DatabaseHelper::select($sql, [$id], true);
        
        if (empty($logs)) {
            return null;
        }
        
        $log = $logs[0];
        $this->processLogData($log);
        
        return $log;
    }
    
    /**
     * Delete logs based on criteria
     *
     * @param array $filters Filter criteria
     * @param bool $forceBulkDelete Allow bulk deletion
     * @return int Number of deleted records
     */
    public function deleteLogs(array $filters, bool $forceBulkDelete = false): int
    {
        // Use LogQueryBuilder to build the where clause
        list($whereClause, $params) = LogQueryBuilder::buildWhereClause($filters);
        
        // Safety check
        if (empty($whereClause) || $whereClause === "1=1" && count($params) === 0 && !$forceBulkDelete) {
            throw new \Exception('Attempted to delete all logs without explicit confirmation');
        }
        
        // Get IDs to delete for batch processing
        $sql = "SELECT id FROM {$this->table} WHERE {$whereClause}";
        
        // Add limit for safety if not forced bulk delete
        if (!$forceBulkDelete) {
            $sql .= " LIMIT 10000";
        }
        
        $logIds = DatabaseHelper::select($sql, $params, true);
        $ids = array_column($logIds, 'id');
        
        if (empty($ids)) {
            return 0;
        }
        
        // Use batch processing to delete
        $totalDeleted = 0;
        $batches = array_chunk($ids, 1000);
        
        foreach ($batches as $batch) {
            $placeholders = implode(',', array_fill(0, count($batch), '?'));
            $deleteSql = "DELETE FROM {$this->table} WHERE id IN ({$placeholders})";
            $rowsDeleted = DatabaseHelper::execute($deleteSql, $batch, true);
            $totalDeleted += $rowsDeleted;
        }
        
        return $totalDeleted;
    }
    
    /**
     * Export logs to CSV
     *
     * @param array $filters Filter criteria
     * @return array Export file information
     */
    public function exportLogs(array $filters): array
    {
        // Create export file information
        $exportId = date('Ymd_His') . '_' . substr(uniqid(), -8);
        $filename = 'audit_logs_export_' . $exportId . '.csv';
        $exportDir = rtrim(sys_get_temp_dir(), '/') . '/secure_exports';
        
        // Ensure directory exists
        if (!is_dir($exportDir)) {
            mkdir($exportDir, 0750, true);
        }
        
        $filepath = $exportDir . '/' . $filename;
        
        // Get export query
        $exportQuery = LogQueryBuilder::buildExportQuery($filters);
        
        // Execute export
        $rowsExported = DatabaseHelper::executeExport($exportQuery['sql'], $exportQuery['params'], $filepath);
        
        // Set permissions
        chmod($filepath, 0640);
        
        // Calculate expiry
        $expiryTime = time() + (24 * 3600); // 24 hours
        
        return [
            'file_path' => $filepath,
            'file_name' => $filename,
            'export_id' => $exportId,
            'row_count' => $rowsExported,
            'expiry_time' => $expiryTime,
            'expiry_formatted' => date('Y-m-d H:i:s', $expiryTime)
        ];
    }
    
    /**
     * Create a new log entry
     *
     * @param array $data Log data
     * @return int|null ID of created log or null on failure
     */
    public function createLog(array $data): ?int
    {
        // Ensure required fields are present
        $requiredFields = ['action', 'message', 'log_level'];
        foreach ($requiredFields as $field) {
            if (!isset($data[$field])) {
                throw new \InvalidArgumentException("Missing required field: {$field}");
            }
        }
        
        // Format details as JSON if it's an array
        if (isset($data['details']) && is_array($data['details'])) {
            $data['details'] = json_encode($data['details'], JSON_UNESCAPED_UNICODE | JSON_PARTIAL_OUTPUT_ON_ERROR);
        }
        
        // Add timestamp if not present
        if (!isset($data['created_at'])) {
            $data['created_at'] = date('Y-m-d H:i:s');
        }
        
        return DatabaseHelper::insert($this->table, $data, true);
    }
    
    /**
     * Process log data for output
     *
     * @param array &$log Log data to process
     */
    private function processLogData(array &$log): void
    {
        // Parse JSON details
        if (isset($log['details']) && is_string($log['details'])) {
            $log['details'] = json_decode($log['details'], true) ?? [];
        }
        
        // Format timestamp
        if (!empty($log['created_at'])) {
            $date = new DateTime($log['created_at']);
            $log['formatted_date'] = $date->format('Y-m-d H:i:s');
        }
    }
}
=== App/Models/BaseModel.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;
use Psr\Log\LoggerInterface;
use PDO;

/**
 * BaseModel
 * 
 * Base class for all models that use the DatabaseHelper instead of Eloquent
 */
abstract class BaseModel
{
    /**
     * @var string The table associated with the model
     */
    protected $table;
    
    /**
     * @var string The name of the resource for audit logging
     */
    protected $resourceName;
    
    /**
     * @var bool Whether the model uses timestamps
     */
    protected $useTimestamps = true;
    
    /**
     * @var bool Whether the model uses soft deletes
     */
    protected $useSoftDeletes = false;
    
    /**
     * @var bool Whether the model uses UUID as primary key
     */
    protected $useUuid = false;
    
    /**
     * @var DatabaseHelper Database helper instance
     */
    protected $dbHelper;
    
    /**
     * @var AuditService|null Audit service instance
     */
    protected $auditService;
    
    /**
     * @var LoggerInterface|null Logger instance
     */
    protected $logger;
    
    /**
     * @var PDO PDO instance
     */
    protected $pdo;

    /**
     * @var array The attributes that are mass assignable
     */
    protected $fillable = [];
    
    /**
     * @var array Data type casting definitions
     */
    protected $casts = [];

    /**
     * Constructor
     *
     * @param DatabaseHelper $dbHelper Database helper instance
     * @param AuditService|null $auditService Audit service instance for logging
     * @param LoggerInterface|null $logger Logger for errors and debug info
     */
    public function __construct(DatabaseHelper $dbHelper, ?AuditService $auditService = null, ?LoggerInterface $logger = null)
    {
        $this->dbHelper = $dbHelper;
        $this->auditService = $auditService;
        $this->logger = $logger;
        $this->pdo = $this->dbHelper->getPdo();
        
        if (!$this->table) {
            throw new \RuntimeException("Table name must be defined in the model class");
        }
    }

    /**
     * Find a record by ID
     *
     * @param int|string $id
     * @return array|null
     */
    public function find(int|string $id): ?array
    {
        try {
            $query = "SELECT * FROM {$this->table} WHERE id = :id";
            
            if ($this->useSoftDeletes) {
                $query .= " AND deleted_at IS NULL";
            }
            
            $stmt = $this->pdo->prepare($query);
            $stmt->bindValue(':id', $id);
            $stmt->execute();
            
            $result = $stmt->fetch(\PDO::FETCH_ASSOC);
            return $result ?: null;
        } catch (\PDOException $e) {
            if ($this->logger) {
                $this->logger->error("Database error in find(): " . $e->getMessage(), ['id' => $id, 'table' => $this->table]);
            }
            throw $e;
        }
    }

    /**
     * Find records by a field value
     *
     * @param string $field Field name
     * @param mixed $value Field value
     * @param string $operator Comparison operator (=, >, <, etc.)
     * @return array
     */
    public function findBy(string $field, $value, string $operator = '='): array
    {
        try {
            $query = "SELECT * FROM {$this->table} WHERE {$field} {$operator} :value";
            
            if ($this->useSoftDeletes) {
                $query .= " AND deleted_at IS NULL";
            }
            
            $stmt = $this->pdo->prepare($query);
            $stmt->bindValue(':value', $value);
            $stmt->execute();
            
            $result = $stmt->fetchAll(\PDO::FETCH_ASSOC);
            return $result ?: [];
        } catch (\PDOException $e) {
            if ($this->logger) {
                $this->logger->error("Database error in findBy(): " . $e->getMessage(), [
                    'field' => $field,
                    'value' => $value,
                    'table' => $this->table
                ]);
            }
            throw $e;
        }
    }

    /**
     * Find a single record by a field value
     *
     * @param string $field Field name
     * @param mixed $value Field value
     * @return array|null
     */
    public function findOneBy(string $field, $value): ?array
    {
        try {
            $query = "SELECT * FROM {$this->table} WHERE {$field} = :value";
            
            if ($this->useSoftDeletes) {
                $query .= " AND deleted_at IS NULL";
            }
            
            $query .= " LIMIT 1";
            
            $stmt = $this->pdo->prepare($query);
            $stmt->bindValue(':value', $value);
            $stmt->execute();
            
            $result = $stmt->fetch(\PDO::FETCH_ASSOC);
            return $result ?: null;
        } catch (\PDOException $e) {
            if ($this->logger) {
                $this->logger->error("Database error in findOneBy(): " . $e->getMessage(), [
                    'field' => $field,
                    'value' => $value,
                    'table' => $this->table
                ]);
            }
            throw $e;
        }
    }

    /**
     * Get all records from the table
     *
     * @param array $orderBy Optional ordering ['field' => 'ASC|DESC']
     * @param int|null $limit Optional record limit
     * @param int|null $offset Optional offset for pagination
     * @return array
     */
    public function all(array $orderBy = [], ?int $limit = null, ?int $offset = null): array
    {
        try {
            $query = "SELECT * FROM {$this->table}";
            
            if ($this->useSoftDeletes) {
                $query .= " WHERE deleted_at IS NULL";
            }
            
            // Add ordering
            if (!empty($orderBy)) {
                $query .= " ORDER BY ";
                $orders = [];
                foreach ($orderBy as $field => $direction) {
                    $orders[] = "{$field} {$direction}";
                }
                $query .= implode(', ', $orders);
            }
            
            // Add limit and offset
            if ($limit !== null) {
                $query .= " LIMIT {$limit}";
                if ($offset !== null) {
                    $query .= " OFFSET {$offset}";
                }
            }
            
            $stmt = $this->pdo->prepare($query);
            $stmt->execute();
            
            $result = $stmt->fetchAll(\PDO::FETCH_ASSOC);
            return $result ?: [];
        } catch (\PDOException $e) {
            if ($this->logger) {
                $this->logger->error("Database error in all(): " . $e->getMessage(), ['table' => $this->table]);
            }
            throw $e;
        }
    }

    /**
     * Create a new record
     *
     * @param array $data
     * @return int|string The ID of the created record
     */
    public function create(array $data): int|string
    {
        try {
            // Filter data to only include fillable fields
            if (!empty($this->fillable)) {
                $data = array_intersect_key($data, array_flip($this->fillable));
            }
            
            // Add timestamps
            if ($this->useTimestamps) {
                $now = date('Y-m-d H:i:s');
                if (!isset($data['created_at'])) {
                    $data['created_at'] = $now;
                }
                if (!isset($data['updated_at'])) {
                    $data['updated_at'] = $now;
                }
            }
            
            // Generate UUID if needed
            if ($this->useUuid && !isset($data['id'])) {
                $data['id'] = \Ramsey\Uuid\Uuid::uuid4()->toString();
            }
            
            // Create placeholders
            $fields = array_keys($data);
            $placeholders = array_map(function($field) {
                return ":{$field}";
            }, $fields);
            
            $query = "INSERT INTO {$this->table} (" . implode(', ', $fields) . ") 
                     VALUES (" . implode(', ', $placeholders) . ")";
            
            $stmt = $this->pdo->prepare($query);
            
            // Bind values with appropriate types based on casts
            foreach ($data as $field => $value) {
                $type = PDO::PARAM_STR;
                if (isset($this->casts[$field])) {
                    if (in_array($this->casts[$field], ['int', 'integer', 'timestamp'])) {
                        $type = PDO::PARAM_INT;
                    } elseif (in_array($this->casts[$field], ['bool', 'boolean'])) {
                        $type = PDO::PARAM_BOOL;
                    }
                }
                $stmt->bindValue(":{$field}", $value, $type);
            }
            
            $stmt->execute();
            
            // Get the ID of the inserted record
            $id = $this->useUuid && isset($data['id']) ? $data['id'] : $this->pdo->lastInsertId();
            
            // Log audit event if service is available
            if ($this->auditService && $this->resourceName) {
                $this->auditService->logEvent(
                    "{$this->resourceName}_created",
                    "{$this->resourceName} record created",
                    ['id' => $id, 'data' => $data],
                    $data['user_id'] ?? null,
                    $id,
                    $this->resourceName
                );
            }
            
            return $id;
        } catch (\PDOException $e) {
            if ($this->logger) {
                $this->logger->error("Database error in create(): " . $e->getMessage(), [
                    'data' => $data,
                    'table' => $this->table
                ]);
            }
            throw $e;
        }
    }

    /**
     * Update a record
     *
     * @param int|string $id
     * @param array $data
     * @return bool
     */
    public function update(int|string $id, array $data): bool
    {
        try {
            // Filter data to only include fillable fields
            if (!empty($this->fillable)) {
                $data = array_intersect_key($data, array_flip($this->fillable));
            }
            
            // Add updated_at timestamp
            if ($this->useTimestamps && !isset($data['updated_at'])) {
                $data['updated_at'] = date('Y-m-d H:i:s');
            }
            
            // Build SET clause
            $setClauses = [];
            foreach ($data as $field => $value) {
                $setClauses[] = "{$field} = :{$field}";
            }
            
            $query = "UPDATE {$this->table} SET " . implode(', ', $setClauses) . " WHERE id = :id";
            
            if ($this->useSoftDeletes) {
                $query .= " AND deleted_at IS NULL";
            }
            
            $stmt = $this->pdo->prepare($query);
            
            // Bind values
            $stmt->bindValue(':id', $id);
            foreach ($data as $field => $value) {
                $type = PDO::PARAM_STR;
                if (isset($this->casts[$field])) {
                    if (in_array($this->casts[$field], ['int', 'integer', 'timestamp'])) {
                        $type = PDO::PARAM_INT;
                    } elseif (in_array($this->casts[$field], ['bool', 'boolean'])) {
                        $type = PDO::PARAM_BOOL;
                    }
                }
                $stmt->bindValue(":{$field}", $value, $type);
            }
            
            $stmt->execute();
            
            $affected = $stmt->rowCount();
            
            // Log audit event if service is available
            if ($affected > 0 && $this->auditService && $this->resourceName) {
                $this->auditService->logEvent(
                    "{$this->resourceName}_updated",
                    "{$this->resourceName} record updated",
                    ['id' => $id, 'updated_fields' => array_keys($data)],
                    $data['user_id'] ?? null, 
                    $id,
                    $this->resourceName
                );
            }
            
            return $affected > 0;
        } catch (\PDOException $e) {
            if ($this->logger) {
                $this->logger->error("Database error in update(): " . $e->getMessage(), [
                    'id' => $id,
                    'data' => $data,
                    'table' => $this->table
                ]);
            }
            throw $e;
        }
    }

    /**
     * Delete a record (soft delete if enabled)
     *
     * @param int|string $id
     * @return bool
     */
    public function delete(int|string $id): bool
    {
        try {
            if ($this->useSoftDeletes) {
                // Soft delete - update the deleted_at field
                $query = "UPDATE {$this->table} SET deleted_at = :deleted_at WHERE id = :id AND deleted_at IS NULL";
                $stmt = $this->pdo->prepare($query);
                $stmt->bindValue(':deleted_at', date('Y-m-d H:i:s'));
                $stmt->bindValue(':id', $id);
            } else {
                // Hard delete - remove the record completely
                $query = "DELETE FROM {$this->table} WHERE id = :id";
                $stmt = $this->pdo->prepare($query);
                $stmt->bindValue(':id', $id);
            }
            
            $stmt->execute();
            
            $affected = $stmt->rowCount();
            
            // Log audit event if service is available
            if ($affected > 0 && $this->auditService && $this->resourceName) {
                $eventType = $this->useSoftDeletes ? "{$this->resourceName}_soft_deleted" : "{$this->resourceName}_deleted";
                $this->auditService->logEvent(
                    $eventType,
                    "{$this->resourceName} record deleted",
                    ['id' => $id, 'soft_delete' => $this->useSoftDeletes],
                    null,
                    $id,
                    $this->resourceName
                );
            }
            
            return $affected > 0;
        } catch (\PDOException $e) {
            if ($this->logger) {
                $this->logger->error("Database error in delete(): " . $e->getMessage(), [
                    'id' => $id, 
                    'table' => $this->table
                ]);
            }
            throw $e;
        }
    }

    /**
     * Get validation rules for the model
     *
     * @return array
     */
    public static function validationRules(): array
    {
        return [];
    }

    /**
     * Execute a raw SQL query
     * 
     * @param string $query SQL query with placeholders
     * @param array $params Parameters for the query
     * @param bool $fetchAll Whether to fetch all results or just one
     * @return array|null Query results
     */
    protected function rawQuery(string $query, array $params = [], bool $fetchAll = true): ?array
    {
        try {
            $stmt = $this->pdo->prepare($query);
            $stmt->execute($params);
            
            if ($fetchAll) {
                $result = $stmt->fetchAll(\PDO::FETCH_ASSOC);
                return $result ?: [];
            } else {
                $result = $stmt->fetch(\PDO::FETCH_ASSOC);
                return $result ?: null;
            }
        } catch (\PDOException $e) {
            if ($this->logger) {
                $this->logger->error("Database error in rawQuery(): " . $e->getMessage(), [
                    'query' => $query,
                    'params' => $params
                ]);
            }
            throw $e;
        }
    }
}
=== App/Models/Report.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Report Model
 *
 * Represents an admin report in the system.
 */
class Report extends BaseModel
{
    protected $table = 'reports';
    protected $resourceName = 'report';
    protected $useSoftDeletes = true;

    /**
     * Attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'admin_id',
        'title',
        'content',
        'status',
        'created_at',
        'updated_at'
    ];

    /**
     * Get reports within a date range.
     *
     * @param string $start
     * @param string $end
     * @return array
     */
    public function getByDateRange(string $start, string $end): array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE created_at BETWEEN :start AND :end
        ";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':start' => $start, ':end' => $end]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Get the admin who created the report.
     *
     * @param int $reportId
     * @return array|null
     */
    public function getAdmin(int $reportId): ?array
    {
        $report = $this->find($reportId);
        
        if (!$report || !isset($report['admin_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM admins WHERE id = :admin_id";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':admin_id' => $report['admin_id']]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }
}
=== App/Models/AuditTrail.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * AuditTrail Model
 *
 * Represents the audit trails stored in the database and provides methods
 * for accessing and filtering the logs.
 */
class AuditTrail extends BaseModel
{
    protected $table = 'audit_trails';
    protected $resourceName = 'audit_trail';
    protected $useTimestamps = true;
    protected $useSoftDeletes = false;

    /**
     * @var array The attributes that are mass assignable
     */
    protected $fillable = [
        'user_id',
        'booking_id',
        'action',
        'message',
        'details'
    ];

    /**
     * @var array Data type casting definitions
     */
    protected $casts = [
        'user_id' => 'int',
        'booking_id' => 'int'
    ];

    /**
     * Retrieve audit trail records based on filters.
     *
     * @param array $filters An associative array of filters:
     *                       - 'user_id' (int): Filter by user ID.
     *                       - 'booking_id' (int): Filter by booking ID.
     *                       - 'action' (string): Filter by action type.
     *                       - 'start_date' (string): Filter by start date (YYYY-MM-DD).
     *                       - 'end_date' (string): Filter by end date (YYYY-MM-DD).
     * @return array An array of matching audit trail records.
     */
    public function getLogs(array $filters = []): array
    {
        $query = "SELECT * FROM {$this->table} WHERE 1=1";
        $params = [];

        if (!empty($filters['user_id'])) {
            $query .= " AND user_id = :user_id";
            $params[':user_id'] = $filters['user_id'];
        }

        if (!empty($filters['booking_id'])) {
            $query .= " AND booking_id = :booking_id";
            $params[':booking_id'] = $filters['booking_id'];
        }

        if (!empty($filters['action'])) {
            $query .= " AND action = :action";
            $params[':action'] = $filters['action'];
        }

        if (!empty($filters['start_date'])) {
            $query .= " AND created_at >= :start_date";
            $params[':start_date'] = $filters['start_date'];
        }

        if (!empty($filters['end_date'])) {
            $query .= " AND created_at <= :end_date";
            $params[':end_date'] = $filters['end_date'];
        }

        $query .= " ORDER BY created_at DESC";

        return $this->dbHelper->select($query, $params);
    }
}
=== App/Models/RefundLog.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * RefundLog Model
 *
 * Represents a refund and handles interactions with the `refund_logs` table.
 */
class RefundLog extends BaseModel
{
    protected $table = 'refund_logs';
    protected $resourceName = 'refund_log';
    protected $useTimestamps = true;
    protected $useSoftDeletes = true;

    /**
     * Get the user associated with the refund.
     *
     * @param int $refundId
     * @return array|null
     */
    public function getUser(int $refundId): ?array
    {
        $refund = $this->find($refundId);
        
        if (!$refund || !isset($refund['user_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM users WHERE id = :user_id";
        $result = $this->dbHelper->select($query, [':user_id' => $refund['user_id']]);
        return $result[0] ?? null;
    }

    /**
     * Get the payment associated with the refund.
     *
     * @param int $refundId
     * @return array|null
     */
    public function getPayment(int $refundId): ?array
    {
        $refund = $this->find($refundId);
        
        if (!$refund || !isset($refund['payment_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM payments WHERE id = :payment_id";
        $result = $this->dbHelper->select($query, [':payment_id' => $refund['payment_id']]);
        return $result[0] ?? null;
    }
}=== App/Models/Signature.php ===
<?php


namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;
use App\Services\EncryptionService;

class Signature extends BaseModel
{
    protected $table = 'signatures';
    protected $resourceName = 'signature';
    protected $useTimestamps = true;
    protected $useSoftDeletes = false;
    private EncryptionService $encryptionService;

    public function __construct(DatabaseHelper $db, EncryptionService $encryptionService = null)
    {
        parent::__construct($db);
        // If encryption service is not injected, try to resolve it through container or create new instance
        $this->encryptionService = $encryptionService ?? app(EncryptionService::class) ?? new EncryptionService();
    }

    /**
     * Create a new signature.
     *
     * @param array $data
     * @return int
     */
    public function create(array $data): int
    {
        if (isset($data['signature'])) {
            $data['signature'] = $this->encryptionService->encrypt($data['signature']);
        }

        return parent::create($data);
    }

    /**
     * Update a signature.
     *
     * @param int $id
     * @param array $data
     * @return bool
     */
    public function update(int $id, array $data): bool
    {
        if (isset($data['signature'])) {
            $data['signature'] = $this->encryptionService->encrypt($data['signature']);
        }

        return parent::update($id, $data);
    }

    /**
     * Get the signature.
     *
     * @param int $signatureId
     * @return string|null
     */
    public function getSignature(int $signatureId): ?string
    {
        $signature = $this->find($signatureId);

        if ($signature && isset($signature['signature'])) {
            return $this->encryptionService->decrypt($signature['signature']);
        }

        return null;
    }

    /**
     * Get the user associated with the signature.
     *
     * @param int $signatureId
     * @return array|null
     */
    public function getUser(int $signatureId): ?array
    {
        $signature = $this->find($signatureId);
        
        if (!$signature || !isset($signature['user_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM users WHERE id = :user_id";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':user_id' => $signature['user_id']]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }

    /**
     * Store signature file path.
     *
     * @param int $userId
     * @param string $filePath
     * @param bool $encrypted
     * @return int
     */
    public function storeSignaturePath(int $userId, string $filePath, bool $encrypted = true): int
    {
        return $this->create([
            'user_id' => $userId,
            'file_path' => $filePath,
            'encrypted' => $encrypted,
            'created_at' => date('Y-m-d H:i:s')
        ]);
    }

    /**
     * Get signatures by user ID.
     *
     * @param int $userId
     * @return array
     */
    public function getSignaturesByUserId(int $userId): array
    {
        $query = "SELECT * FROM {$this->table} WHERE user_id = :user_id";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':user_id' => $userId]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC);
    }

    /**
     * Get signature path by user ID.
     *
     * @param int $userId
     * @return string|null
     */
    public function getSignaturePathByUserId(int $userId): ?string
    {
        $query = "SELECT file_path FROM {$this->table} WHERE user_id = :user_id ORDER BY created_at DESC LIMIT 1";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':user_id' => $userId]);
        $result = $stmt->fetch(\PDO::FETCH_ASSOC);
        
        return $result ? $result['file_path'] : null;
    }
}
=== App/Models/PasswordReset.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * PasswordReset Model
 *
 * Represents a password reset request.
 */
class PasswordReset extends BaseModel
{
    protected $table = 'password_resets';
    protected $resourceName = 'password_reset';
    protected $useTimestamps = true;
    protected $useSoftDeletes = false;

    /**
     * Find a password reset by token.
     *
     * @param string $token
     * @return array|null
     */
    public function findByToken(string $token): ?array
    {
        $query = "SELECT * FROM {$this->table} WHERE token = :token";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':token' => $token]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }

    /**
     * Create a new password reset.
     *
     * @param array $data
     * @return int
     */
    public function create(array $data): int
    {
        // Generate a token if not provided
        if (!isset($data['token'])) {
            $data['token'] = bin2hex(random_bytes(32));
        }

        $id = parent::create($data);

        // Add custom audit logging if needed
        if ($this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'password_reset_created', [
                'id' => $id,
                'email' => $data['email'] ?? null
            ]);
        }

        return $id;
    }
}
