=== App/Models/Booking.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Booking Model
 *
 * Represents a booking and handles database interactions.
 */
class Booking extends BaseModel
{
    protected $table = 'bookings';
    protected $resourceName = 'booking';
    protected $useTimestamps = true;
    protected $useSoftDeletes = true;
    
    /**
     * Constructor
     *
     * @param DatabaseHelper|null $dbHelper
     * @param AuditService|null $auditService
     */
    public function __construct(DatabaseHelper $dbHelper = null, AuditService $auditService = null)
    {
        parent::__construct($dbHelper, $auditService);
    }
    
    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'user_id' => 'required|exists:users,id',
        'vehicle_id' => 'required|exists:vehicles,id',
        'pickup_date' => 'required|date',
        'dropoff_date' => 'required|date|after_or_equal:pickup_date',
        'status' => 'required|string|in:pending,confirmed,cancelled,completed',
    ];

    /**
     * Create a new booking
     * 
     * @param array $data
     * @return int|string
     */
    public function create(array $data): int|string
    {
        $id = parent::create($data);
        
        // Custom audit logging
        if ($id && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'booking_created', [
                'booking_id' => $id,
                'user_id' => $data['user_id'] ?? null,
                'vehicle_id' => $data['vehicle_id'] ?? null,
                'status' => $data['status'] ?? null
            ]);
        }
        
        return $id;
    }

    /**
     * Update a booking
     * 
     * @param int|string $id
     * @param array $data
     * @return bool
     */
    public function update(int|string $id, array $data): bool
    {
        $result = parent::update($id, $data);
        
        // Custom audit logging
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'booking_updated', [
                'booking_id' => $id,
                'updated_fields' => array_keys($data)
            ]);
        }
        
        return $result;
    }

    /**
     * Update a booking's status
     * 
     * @param int|string $id
     * @param string $newStatus
     * @return bool
     */
    public function updateStatus(int|string $id, string $newStatus): bool
    {
        // Validate the status value
        $validStatuses = ['pending', 'confirmed', 'cancelled', 'completed', 'paid'];
        if (!in_array($newStatus, $validStatuses)) {
            if (isset($this->logger)) {
                $this->logger->error("Invalid booking status: {$newStatus}");
            }
            return false;
        }
        
        // Use the existing update method to update just the status field
        return $this->update($id, ['status' => $newStatus]);
    }

    /**
     * Get active bookings.
     *
     * @return array
     */
    public function getActive(): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE status = 'confirmed'
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query);
    }

    /**
     * Get bookings by user ID.
     *
     * @param int|string $userId
     * @return array
     */
    public function getByUser(int|string $userId): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE user_id = :user_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get bookings by status
     * 
     * @param string $status
     * @return array
     */
    public function getByStatus(string $status): array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE status = :status
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':status' => $status]);
    }

    /**
     * Get bookings by date range
     * 
     * @param string $startDate
     * @param string $endDate
     * @return array
     */
    public function getByDateRange(string $startDate, string $endDate): array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE pickup_date >= :start_date AND dropoff_date <= :end_date
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " ORDER BY pickup_date ASC";
        
        return $this->dbHelper->select($query, [
            ':start_date' => $startDate,
            ':end_date' => $endDate
        ]);
    }

    /**
     * Get user data for a booking.
     *
     * @param int|string $bookingId
     * @return array|null
     */
    public function getUser(int|string $bookingId): ?array
    {
        $query = "
            SELECT u.* FROM users u
            JOIN {$this->table} b ON u.id = b.user_id
            WHERE b.id = :booking_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND b.deleted_at IS NULL AND u.deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':booking_id' => $bookingId]);
        return $result ? $result[0] : null;
    }

    /**
     * Get vehicle data for a booking.
     *
     * @param int|string $bookingId
     * @return array|null
     */
    public function getVehicle(int|string $bookingId): ?array
    {
        $query = "
            SELECT v.* FROM vehicles v
            JOIN {$this->table} b ON v.id = b.vehicle_id
            WHERE b.id = :booking_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND b.deleted_at IS NULL AND v.deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':booking_id' => $bookingId]);
        return $result ? $result[0] : null;
    }

    /**
     * Get payment data for a booking.
     *
     * @param int|string $bookingId
     * @return array|null
     */
    public function getPayment(int|string $bookingId): ?array
    {
        $query = "
            SELECT p.* FROM payments p
            WHERE p.booking_id = :booking_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND p.deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':booking_id' => $bookingId]);
        return $result ? $result[0] : null;
    }
    
    /**
     * Check if a vehicle is available during a specific date range
     *
     * @param int|string $vehicleId
     * @param string $startDate
     * @param string $endDate
     * @param int|string|null $excludeBookingId Booking ID to exclude from check (for updates)
     * @return bool
     */
    public function isVehicleAvailable(int|string $vehicleId, string $startDate, string $endDate, int|string $excludeBookingId = null): bool
    {
        $query = "
            SELECT COUNT(*) as booking_count 
            FROM {$this->table}
            WHERE vehicle_id = :vehicle_id
            AND status IN ('pending', 'confirmed')
            AND NOT (
                dropoff_date < :start_date OR pickup_date > :end_date
            )
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        if ($excludeBookingId) {
            $query .= " AND id != :exclude_id";
        }
        
        $result = $this->dbHelper->select($query, [
            ':vehicle_id' => $vehicleId,
            ':start_date' => $startDate,
            ':end_date' => $endDate,
            ':exclude_id' => $excludeBookingId
        ]);
        
        return $result[0]['booking_count'] == 0;
    }
}
=== App/Models/TransactionLog.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;
use App\Services\EncryptionService;

/**
 * TransactionLog Model
 *
 * Represents a financial transaction and handles interactions with the `transaction_logs` table.
 */
class TransactionLog extends BaseModel
{
    protected $table = 'transaction_logs';
    protected $resourceName = 'transaction_log';
    protected $useTimestamps = true; // Transaction logs use timestamps
    protected $useSoftDeletes = false; // Transaction logs don't use soft deletes

    /**
     * Create a new transaction log.
     *
     * @param array $data
     * @return int
     */
    public function create(array $data): int
    {
        // Encrypt transaction details
        $data['amount'] = EncryptionService::encrypt($data['amount']);

        return parent::create($data);
    }

    /**
     * Log a transaction - convenience method that uses create().
     * This method is used for consistency with service calls.
     *
     * @param array $transactionData
     * @return int The ID of the logged transaction
     */
    public function logTransaction(array $transactionData): int
    {
        // Apply any specific transaction logging logic here
        if (!isset($transactionData['created_at'])) {
            $transactionData['created_at'] = date('Y-m-d H:i:s');
        }

        // If a description is not provided, generate a generic one
        if (!isset($transactionData['description'])) {
            $type = $transactionData['type'] ?? 'transaction';
            $transactionData['description'] = ucfirst($type) . ' processed';
        }

        // Log this transaction
        if ($this->auditService && isset($transactionData['type'])) {
            $this->auditService->logEvent(
                $this->resourceName,
                $transactionData['type'] . '_logged',
                [
                    'payment_id' => $transactionData['payment_id'] ?? null,
                    'booking_id' => $transactionData['booking_id'] ?? null,
                    'amount' => $transactionData['amount'] ?? null,
                    'status' => $transactionData['status'] ?? null
                ]
            );
        }

        // Use the create method to insert the transaction record
        return $this->create($transactionData);
    }

    /**
     * Get transactions by user ID.
     *
     * @param int $userId
     * @return array
     */
    public function getByUserId(int $userId): array
    {
        $query = "SELECT * FROM {$this->table} WHERE user_id = :user_id ORDER BY created_at DESC";
        $transactions = $this->dbHelper->select($query, [':user_id' => $userId]);

        // Decrypt transaction details
        foreach ($transactions as &$transaction) {
            $transaction['amount'] = EncryptionService::decrypt($transaction['amount']);
        }

        return $transactions;
    }

    /**
     * Get transaction by ID.
     *
     * @param int $id
     * @return array|null
     */
    public function getById(int $id): ?array
    {
        $query = "SELECT * FROM {$this->table} WHERE id = :id";
        $transaction = $this->dbHelper->select($query, [':id' => $id]);

        if ($transaction) {
            $transaction = $transaction[0] ?? null;
            // Decrypt transaction details
            $transaction['amount'] = EncryptionService::decrypt($transaction['amount']);
        }

        return $transaction ?: null;
    }

    /**
     * Update transaction status.
     *
     * @param int $id
     * @param string $status
     * @return bool
     */
    public function updateStatus(int $id, string $status): bool
    {
        $result = parent::update($id, ['status' => $status]);

        // Log the event
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'status_update', [
                'id' => $id,
                'status' => $status
            ]);
        }

        return $result;
    }

    /**
     * Get recent transactions.
     *
     * @param int $limit
     * @return array
     */
    public function getRecent(int $limit = 10): array
    {
        $query = "SELECT * FROM {$this->table} ORDER BY created_at DESC LIMIT :limit";
        $transactions = $this->dbHelper->select($query, [':limit' => $limit]);

        // Decrypt transaction details
        foreach ($transactions as &$transaction) {
            $transaction['amount'] = EncryptionService::decrypt($transaction['amount']);
        }

        return $transactions;
    }
}
=== App/Models/RefreshToken.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use Exception;

class RefreshToken
{
    private DatabaseHelper $dbHelper;
    private LoggerInterface $logger;
    private bool $useSecureDb = true;

    public function __construct(DatabaseHelper $dbHelper, LoggerInterface $logger)
    {
        $this->dbHelper = $dbHelper;
        $this->logger = $logger;
    }

    /**
     * Store a refresh token in the database
     * 
     * @param int $userId The user ID
     * @param string $refreshToken The unhashed token
     * @param int $expiresIn Expiry time in seconds
     * @return bool Success status
     */
    public function store(int $userId, string $refreshToken, int $expiresIn = 604800): bool
    {
        try {
            // Hash token for secure storage
            $hashedToken = hash('sha256', $refreshToken);
            
            // Store the token in the refresh_tokens table
            $this->dbHelper->insert('refresh_tokens', [
                'user_id' => $userId,
                'token' => $hashedToken,
                'expires_at' => date('Y-m-d H:i:s', time() + $expiresIn),
                'created_at' => date('Y-m-d H:i:s'),
                'ip_address' => $_SERVER['REMOTE_ADDR'] ?? null
            ], $this->useSecureDb);
            
            $this->logger->info("Refresh token stored", ['user_id' => $userId]);
            return true;
        } catch (Exception $e) {
            $this->logger->error("Failed to store refresh token: " . $e->getMessage());
            return false;
        }
    }

    /**
     * Check if a token has been revoked
     * 
     * @param string $token The unhashed token
     * @return bool True if revoked
     */
    public function isRevoked(string $token): bool
    {
        try {
            // Check cache first for performance
            if (apcu_exists("revoked_refresh_token_$token")) {
                return true;
            }
            
            // If not in cache, check secure database
            $hashedToken = hash('sha256', $token);
            $query = "SELECT 1 FROM refresh_tokens WHERE token = :token AND revoked = 1 LIMIT 1";
            $revoked = $this->dbHelper->select($query, [':token' => $hashedToken], $this->useSecureDb);
                
            // If revoked in database, store in cache for next time
            if ($revoked) {
                apcu_store("revoked_refresh_token_$token", true, 604800);
            }
            
            return !empty($revoked);
        } catch (Exception $e) {
            $this->logger->warning("Error checking if token is revoked: " . $e->getMessage());
            // Default to not revoked if there's an error checking, but log it
            return false;
        }
    }

    /**
     * Find token data by the token string
     * 
     * @param string $token The unhashed token
     * @return array|null Token data or null if not found
     */
    public function findByToken(string $token): ?array
    {
        try {
            $hashedToken = hash('sha256', $token);
            $query = "SELECT * FROM refresh_tokens WHERE token = :token LIMIT 1";
            $result = $this->dbHelper->select($query, [':token' => $hashedToken], $this->useSecureDb);
            
            return $result[0] ?? null;
        } catch (Exception $e) {
            $this->logger->error("Error finding token: " . $e->getMessage());
            return null;
        }
    }

    /**
     * Revoke a token
     * 
     * @param string $token The unhashed token
     * @return bool Success status
     */
    public function revoke(string $token): bool
    {
        try {
            // Store in cache for quick lookups
            apcu_store("revoked_refresh_token_$token", true, 604800);
            
            // Store in secure database for persistence
            $hashedToken = hash('sha256', $token);
            
            // Update the token status in secure database
            $result = $this->dbHelper->update(
                'refresh_tokens', 
                [
                    'revoked' => 1,
                    'revoked_at' => date('Y-m-d H:i:s')
                ], 
                ['token' => $hashedToken], 
                $this->useSecureDb
            );
                
            return $result;
        } catch (Exception $e) {
            $this->logger->error("Failed to revoke token: " . $e->getMessage());
            return false;
        }
    }

    /**
     * Purge all expired tokens
     * 
     * @return int Number of tokens purged
     */
    public function purgeExpired(): int
    {
        try {
            $count = $this->dbHelper->delete(
                'refresh_tokens', 
                ['expires_at < ' => date('Y-m-d H:i:s')], 
                false,
                $this->useSecureDb
            );
                
            $this->logger->info("Purged {$count} expired tokens");
            return $count;
        } catch (Exception $e) {
            $this->logger->error("Failed to purge expired tokens: " . $e->getMessage());
            return 0;
        }
    }

    /**
     * Get all active tokens for a user
     * 
     * @param int $userId The user ID
     * @return array List of token records
     */
    public function getActiveForUser(int $userId): array
    {
        try {
            $query = "SELECT * FROM refresh_tokens WHERE user_id = :user_id AND revoked = 0 AND expires_at > :now";
            $tokens = $this->dbHelper->select(
                $query, 
                [
                    ':user_id' => $userId,
                    ':now' => date('Y-m-d H:i:s')
                ], 
                $this->useSecureDb
            );
                
            return $tokens ?? [];
        } catch (Exception $e) {
            $this->logger->error("Failed to get active tokens: " . $e->getMessage());
            return [];
        }
    }

    /**
     * Get user ID associated with a token
     * 
     * @param string $token The unhashed token
     * @return int|null User ID or null if not found
     */
    public function getUserId(string $token): ?int
    {
        $tokenData = $this->findByToken($token);
        return $tokenData['user_id'] ?? null;
    }
}
=== App/Models/Payment.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Payment Model
 *
 * Represents a payment transaction in the system.
 *
 * @property int $id Primary key
 * @property int $user_id ID of the user who made the payment
 * @property int $booking_id ID of the associated booking
 * @property float $amount Transaction amount
 * @property string $method Payment method (credit_card, PayPal, etc.)
 * @property string $status Status of the payment (pending, completed, failed)
 * @property string|null $transaction_id Unique external transaction identifier
 * @property string $type Type of transaction ('payment' or 'refund')
 * @property string|null $refund_reason Reason for refund, if applicable
 * @property int|null $original_payment_id ID of the original payment (for refunds only)
 */
class Payment extends BaseModel
{
    protected $table = 'payments';
    protected $resourceName = 'payment';
    
    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'user_id' => 'required|exists:users,id',
        'booking_id' => 'required|exists:bookings,id',
        'amount' => 'required|numeric|min:0',
        'method' => 'required|string|in:credit_card,paypal,bank_transfer',
        'status' => 'required|string|in:pending,completed,failed',
        'transaction_id' => 'nullable|string|max:255',
        'type' => 'string|in:payment,refund',
        'refund_reason' => 'nullable|string|max:255',
        'original_payment_id' => 'nullable|integer|exists:payments,id',
    ];

    public function __construct(DatabaseHelper $dbHelper, AuditService $auditService = null)
    {
        $this->dbHelper = $dbHelper;
        $this->auditService = $auditService;
    }

    /**
     * Find a payment by ID.
     *
     * @param int $id
     * @return array|null
     */
    public function find(int $id): ?array
    {
        $query = "SELECT * FROM {$this->table} WHERE id = :id AND deleted_at IS NULL LIMIT 1";
        $result = $this->dbHelper->select($query, [':id' => $id]);
        return $result[0] ?? null; // Return first result or null
    }
    

    /**
     * Get all payments.
     *
     * @return array
     */
    public function all(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query);
    }

    /**
     * Create a new payment or refund.
     *
     * @param array $data
     * @return int|null ID of the created payment/refund, or null on failure
     */
    public function create(array $data): ?int
    {
        // Set default type to 'payment' if not specified
        $data['type'] = $data['type'] ?? 'payment';
        
        // Validate the data
        if (isset($this->validator)) {
            $validation = $this->validator->validate($data, self::$rules);
            if ($validation->fails()) {
                if (isset($this->logger)) {
                    $this->logger->error('Payment validation failed', $validation->errors()->all());
                }
                return null;
            }
        }
        
        // For refunds, the amount should be negative (to represent money going out)
        if ($data['type'] === 'refund' && $data['amount'] > 0) {
            $data['amount'] = -1 * abs($data['amount']);
        }

        $data['created_at'] = $data['updated_at'] = date('Y-m-d H:i:s');
        $paymentId = $this->dbHelper->insert($this->table, $data);
        
        if (!$paymentId) {
            return null; // Return null if insertion fails
        }

        if ($this->auditService) {
            $eventType = ($data['type'] === 'refund') ? 'Created refund' : 'Created payment';
            
            $auditData = [
                'payment_id' => $paymentId,
                'user_id' => $data['user_id'],
                'booking_id' => $data['booking_id'],
                'amount' => $data['amount'],
                'method' => $data['method'],
                'type' => $data['type']
            ];
            
            // Add refund-specific data if applicable
            if ($data['type'] === 'refund') {
                $auditData['refund_reason'] = $data['refund_reason'] ?? null;
                $auditData['original_payment_id'] = $data['original_payment_id'] ?? null;
            }
            
            $this->auditService->logEvent($this->resourceName, $eventType, $auditData);
        }
        
        return (int) $paymentId; // Ensure ID is always an integer
    }

    /**
     * Create a refund record.
     * 
     * @param array $refundData Must contain: user_id, booking_id, amount, method, original_payment_id
     * @return int|null ID of the created refund, or null on failure
     */
    public function createRefund(array $refundData): ?int
    {
        // Ensure the type is set to refund
        $refundData['type'] = 'refund';
        
        // Set status to completed by default if not specified
        if (!isset($refundData['status'])) {
            $refundData['status'] = 'completed';
        }
        
        // Ensure refund reason is set
        if (!isset($refundData['refund_reason'])) {
            $refundData['refund_reason'] = 'Refund processed';
        }
        
        // Validate required fields specific to refunds
        if (!isset($refundData['original_payment_id'])) {
            if (isset($this->logger)) {
                $this->logger->error('Refund creation failed: original_payment_id is required');
            }
            return null;
        }
        
        // Check if original payment exists
        $originalPayment = $this->find($refundData['original_payment_id']);
        if (!$originalPayment) {
            if (isset($this->logger)) {
                $this->logger->error('Refund creation failed: original payment not found', [
                    'original_payment_id' => $refundData['original_payment_id']
                ]);
            }
            return null;
        }
        
        // Ensure original payment is a payment, not a refund
        if ($originalPayment['type'] === 'refund') {
            if (isset($this->logger)) {
                $this->logger->error('Refund creation failed: cannot refund a refund', [
                    'original_payment_id' => $refundData['original_payment_id']
                ]);
            }
            return null;
        }
        
        // Check if original payment is already fully refunded
        $refundedAmount = $this->getRefundedAmount($refundData['original_payment_id']);
        $originalAmount = abs($originalPayment['amount']);
        $requestedRefundAmount = abs($refundData['amount']);
        
        if (($refundedAmount + $requestedRefundAmount) > $originalAmount) {
            if (isset($this->logger)) {
                $this->logger->error('Refund creation failed: refund amount exceeds original payment', [
                    'original_payment_id' => $refundData['original_payment_id'],
                    'original_amount' => $originalAmount,
                    'already_refunded' => $refundedAmount,
                    'requested_refund' => $requestedRefundAmount
                ]);
            }
            return null;
        }
        
        // Ensure refund amount is stored as negative
        $refundData['amount'] = -1 * abs($refundData['amount']);
        
        // Use the create method to insert the refund record
        $refundId = $this->create($refundData);
        
        if ($refundId && $this->auditService) {
            // Add specialized refund audit log
            $this->auditService->logEvent(
                $this->resourceName, 
                'refund_processed', 
                [
                    'refund_id' => $refundId,
                    'original_payment_id' => $refundData['original_payment_id'],
                    'user_id' => $refundData['user_id'],
                    'booking_id' => $refundData['booking_id'],
                    'amount' => $refundData['amount'],
                    'reason' => $refundData['refund_reason'],
                    'remaining_balance' => $originalAmount - ($refundedAmount + abs($refundData['amount']))
                ]
            );
        }
        
        return $refundId;
    }

    /**
     * Update a payment.
     *
     * @param int $id
     * @param array $data
     * @return bool
     */
    public function update(int $id, array $data): bool
    {
        $data['updated_at'] = date('Y-m-d H:i:s');
        $result = $this->dbHelper->update($this->table, $data, ['id' => $id, 'deleted_at IS NULL']);
        
        // Log audit if service is available and update was successful
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'Updated payment', [
                'payment_id' => $id,
                'updated_fields' => array_keys($data)
            ]);
        }
        
        return $result;
    }

    /**
     * Soft delete a payment.
     *
     * @param int $id
     * @return bool
     */
    public function delete(int $id): bool
    {
        $result = $this->dbHelper->update($this->table, ['deleted_at' => date('Y-m-d H:i:s')], ['id' => $id]);
    
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'Deleted payment', ['payment_id' => $id]);
        }
        
        return $result;
    }
    

    /**
     * Get payments by user ID.
     * Replaces scopeByUser.
     *
     * @param int $userId
     * @return array
     */
    public function getByUser(int $userId): array
    {
        $query = "SELECT * FROM {$this->table} WHERE user_id = :user_id AND deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get completed payments.
     * Replaces scopeCompleted.
     *
     * @return array
     */
    public function getCompleted(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE status = 'completed' AND deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query);
    }

    /**
     * Get payments by status.
     * Replaces scopeByStatus.
     *
     * @param string $status
     * @return array
     */
    public function getByStatus(string $status): array
    {
        $query = "SELECT * FROM {$this->table} WHERE status = :status AND deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query, [':status' => $status]);
    }

    /**
     * Get payments within a date range.
     * Replaces scopeByDateRange.
     *
     * @param string $startDate
     * @param string $endDate
     * @return array
     */
    public function getByDateRange(string $startDate, string $endDate): array
    {
        $query = "SELECT * FROM {$this->table} WHERE created_at BETWEEN :start_date AND :end_date AND deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query, [':start_date' => $startDate, ':end_date' => $endDate]);
    }

    /**
     * Get user data for a payment.
     * Replaces user relationship.
     *
     * @param int $paymentId
     * @return array|null
     */
    public function getUser(int $paymentId): ?array
    {
        $query = "SELECT u.* FROM users u JOIN {$this->table} p ON u.id = p.user_id WHERE p.id = :payment_id AND p.deleted_at IS NULL";
        return $this->dbHelper->select($query, [':payment_id' => $paymentId]);
    }

    /**
     * Get booking data for a payment.
     * Replaces booking relationship.
     *
     * @param int $paymentId
     * @return array|null
     */
    public function getBooking(int $paymentId): ?array
    {
        $query = "SELECT b.* FROM bookings b JOIN {$this->table} p ON b.id = p.booking_id WHERE p.id = :payment_id AND p.deleted_at IS NULL AND b.deleted_at IS NULL";
        return $this->dbHelper->select($query, [':payment_id' => $paymentId]);
    }

    /**
     * Get payments by booking ID
     * 
     * @param int $bookingId
     * @return array
     */
    public function getByBooking(int $bookingId): array
    {
        $query = "SELECT * FROM {$this->table} WHERE booking_id = :booking_id AND deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query, [':booking_id' => $bookingId]);
    }

    /**
     * Get refunds for a specific payment
     *
     * @param int $paymentId
     * @return array
     */
    public function getRefundsForPayment(int $paymentId): array
    {
        $query = "SELECT * FROM {$this->table} 
                  WHERE original_payment_id = :payment_id 
                  AND type = 'refund' 
                  AND deleted_at IS NULL
                  ORDER BY created_at DESC";
                  
        return $this->dbHelper->select($query, [':payment_id' => $paymentId]);
    }

    /**
     * Get all refunds
     *
     * @return array
     */
    public function getAllRefunds(): array
    {
        $query = "SELECT * FROM {$this->table} 
                  WHERE type = 'refund' 
                  AND deleted_at IS NULL
                  ORDER BY created_at DESC";
                  
        return $this->dbHelper->select($query);
    }

    /**
     * Check if a payment has been refunded
     *
     * @param int $paymentId
     * @return bool
     */
    public function hasRefunds(int $paymentId): bool
    {
        $query = "SELECT COUNT(*) as refund_count 
                  FROM {$this->table} 
                  WHERE original_payment_id = :payment_id 
                  AND type = 'refund' 
                  AND deleted_at IS NULL";
                  
        $result = $this->dbHelper->select($query, [':payment_id' => $paymentId]);
        return (int)$result[0]['refund_count'] > 0;
    }

    /**
     * Get total refunded amount for a payment
     *
     * @param int $paymentId
     * @return float
     */
    public function getRefundedAmount(int $paymentId): float
    {
        $query = "SELECT SUM(ABS(amount)) as total_refunded 
                  FROM {$this->table} 
                  WHERE original_payment_id = :payment_id 
                  AND type = 'refund' 
                  AND status = 'completed' 
                  AND deleted_at IS NULL";
                  
        $result = $this->dbHelper->select($query, [':payment_id' => $paymentId]);
        return (float)($result[0]['total_refunded'] ?? 0);
    }
}
=== App/Models/Admin.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Admin Model - Manages system administrators.
 */
class Admin extends BaseModel
{
    protected $table = 'admins';
    protected $resourceName = 'admin';
    protected $useTimestamps = true;
    protected $useSoftDeletes = true;
    
    /**
     * Constructor
     *
     * @param DatabaseHelper $dbHelper
     * @param AuditService|null $auditService
     */
    public function __construct(DatabaseHelper $dbHelper = null, AuditService $auditService = null)
    {
        parent::__construct($dbHelper, $auditService);
    }
    
    /**
     * Hash a password.
     *
     * @param string $password
     * @return string
     */
    public static function hashPassword(string $password): string
    {
        return password_hash($password, PASSWORD_BCRYPT, ['cost' => 12]);
    }
    
    /**
     * Verify password.
     *
     * @param string $plainPassword
     * @param string $hashedPassword
     * @return bool
     */
    public static function verifyPassword(string $plainPassword, string $hashedPassword): bool
    {
        return password_verify($plainPassword, $hashedPassword);
    }
    
    /**
     * Create an admin.
     * Override to handle password hashing.
     *
     * @param array $data
     * @return int|string
     */
    public function create(array $data): int|string
    {
        if (isset($data['password'])) {
            $data['password'] = self::hashPassword($data['password']);
        }
        
        $id = parent::create($data);
        
        // Add custom audit logging if needed
        if ($this->auditService) {
            $this->auditService->logEvent('admin', 'admin_created', [
                'id' => $id,
                'name' => $data['name'] ?? null,
                'email' => $data['email'] ?? null,
                'role' => $data['role'] ?? null
            ]);
        }
        
        return $id;
    }
    
    /**
     * Update an admin.
     * Override to handle password hashing.
     *
     * @param int|string $id
     * @param array $data
     * @return bool
     */
    public function update(int|string $id, array $data): bool
    {
        if (isset($data['password'])) {
            $data['password'] = self::hashPassword($data['password']);
        }
        
        $result = parent::update($id, $data);
        
        // Add custom audit logging if needed
        if ($result && $this->auditService) {
            $this->auditService->logEvent('admin', 'admin_updated', [
                'id' => $id,
                'updated_fields' => array_keys($data)
            ]);
        }
        
        return $result;
    }
    
    /**
     * Get admin by email.
     *
     * @param string $email
     * @return array|null
     */
    public function getByEmail(string $email): ?array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE email = :email
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':email' => $email]);
        return $result ? $result[0] : null;
    }
    
    /**
     * Restore a soft deleted admin.
     *
     * @param int|string $id
     * @return bool
     */
    public function restore(int|string $id): bool
    {
        if (!$this->useSoftDeletes) {
            return false;
        }
        
        $result = $this->dbHelper->update($this->table, ['deleted_at' => null], ['id' => $id]);
        
        if ($result && $this->auditService) {
            $this->auditService->logEvent('admin', 'admin_restored', [
                'admin_id' => $id
            ]);
        }
        
        return $result;
    }
    
    /**
     * Get users managed by this admin.
     *
     * @param int|string $adminId
     * @return array
     */
    public function getManagedUsers(int|string $adminId): array
    {
        $query = "
            SELECT * FROM users
            WHERE managed_by = :admin_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " ORDER BY name ASC";
        
        return $this->dbHelper->select($query, [':admin_id' => $adminId]);
    }
    
    /**
     * Get admin permissions.
     *
     * @param int|string $adminId
     * @return array
     */
    public function getPermissions(int|string $adminId): array
    {
        $query = "
            SELECT p.* FROM permissions p
            JOIN admin_permissions ap ON p.id = ap.permission_id
            WHERE ap.admin_id = :admin_id
        ";
        
        return $this->dbHelper->select($query, [':admin_id' => $adminId]);
    }

    /**
     * Find admin by token
     */
    public function findByToken(string $token): ?array
    {
        $adminData = DatabaseHelper::select(
            "SELECT id, email, role FROM admins WHERE token = ? AND token_expiry > NOW()",
            [$token],
            true // Using secure database
        );
        
        return !empty($adminData) ? $adminData[0] : null;
    }

    /**
     * Get paginated list of all users with their roles
     */
    public function getPaginatedUsers(int $page, int $perPage): array
    {
        $offset = ($page - 1) * $perPage;
        
        $users = DatabaseHelper::select(
            "SELECT u.*, r.name as role_name 
             FROM users u 
             LEFT JOIN roles r ON u.role_id = r.id 
             ORDER BY u.created_at DESC 
             LIMIT ? OFFSET ?",
            [$perPage, $offset],
            false // Using application database
        );
        
        return $users;
    }

    /**
     * Get total user count
     */
    public function getTotalUserCount(): int
    {
        $result = DatabaseHelper::select(
            "SELECT COUNT(*) as count FROM users",
            [],
            false // Using application database
        );
        
        return (int)$result[0]['count'];
    }

    /**
     * Get user by ID
     */
    public function getUserById(int $userId): ?array
    {
        $user = DatabaseHelper::select(
            "SELECT id, email, role FROM users WHERE id = ?",
            [$userId],
            false // Using application database
        );
        
        return !empty($user) ? $user[0] : null;
    }

    /**
     * Update user role
     */
    public function updateUserRole(int $userId, string $role): bool
    {
        return DatabaseHelper::update(
            "users",
            ["role" => $role],
            ["id" => $userId],
            false // Using application database
        );
    }

    /**
     * Soft delete user
     */
    public function softDeleteUser(int $userId): bool
    {
        return DatabaseHelper::update(
            "users",
            ["deleted_at" => date('Y-m-d H:i:s')],
            ["id" => $userId],
            false // Using application database
        );
    }

    /**
     * Get dashboard statistics
     */
    public function getDashboardStatistics(): array
    {
        // Get total users count
        $totalUsers = DatabaseHelper::select(
            "SELECT COUNT(*) as count FROM users WHERE deleted_at IS NULL",
            [],
            false
        )[0]['count'];
        
        // Get total bookings count
        $totalBookings = DatabaseHelper::select(
            "SELECT COUNT(*) as count FROM bookings",
            [],
            false
        )[0]['count'];
        
        // Get total revenue
        $totalRevenue = DatabaseHelper::select(
            "SELECT SUM(amount) as total FROM payments WHERE status = 'completed'",
            [],
            false
        )[0]['total'] ?? 0;
        
        // Get latest 5 users
        $latestUsers = DatabaseHelper::select(
            "SELECT u.*, r.name as role_name 
             FROM users u 
             LEFT JOIN roles r ON u.role_id = r.id 
             WHERE u.deleted_at IS NULL 
             ORDER BY u.created_at DESC 
             LIMIT 5",
            [],
            false
        );
        
        // Get latest 5 transactions
        $latestTransactions = DatabaseHelper::select(
            "SELECT * FROM transaction_logs ORDER BY created_at DESC LIMIT 5",
            [],
            false
        );
        
        return [
            'total_users' => $totalUsers,
            'total_bookings' => $totalBookings,
            'total_revenue' => $totalRevenue,
            'latest_users' => $latestUsers,
            'latest_transactions' => $latestTransactions,
        ];
    }

    /**
     * Check if admin with email exists
     */
    public function findByEmail(string $email): ?array
    {
        $admin = DatabaseHelper::select(
            "SELECT id FROM admins WHERE email = ?",
            [$email],
            true // Using secure database
        );
        
        return !empty($admin) ? $admin[0] : null;
    }

    /**
     * Create new admin user
     * 
     * @param array $adminData
     * @return int|null
     */
    public function createAdmin(array $adminData): ?int
    {
        return DatabaseHelper::insert(
            "admins",
            $adminData,
            true // Using secure database
        );
    }

    /**
     * Get admin by ID
     */
    public function findById(int $adminId): ?array
    {
        $admin = DatabaseHelper::select(
            "SELECT id, name, email, role, created_at FROM admins WHERE id = ?",
            [$adminId],
            true // Using secure database
        );
        
        return !empty($admin) ? $admin[0] : null;
    }
}
=== App/Models/Notification.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Notification Model
 *
 * Represents a notification in the system.
 */
class Notification extends BaseModel
{
    protected $table = 'notifications';
    protected $resourceName = 'notification';
    protected $useTimestamps = false;  // We'll use sent_at instead of created_at
    protected $useSoftDeletes = false; // Notifications don't use soft deletes

    /**
     * Mark a notification as read.
     *
     * @param int $id
     * @return bool
     */
    public function markAsRead(int $id): bool
    {
        $result = $this->dbHelper->update($this->table, ['is_read' => 1], ['id' => $id]);
        
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'notification_read', [
                'id' => $id
            ]);
        }
        
        return $result;
    }

    /**
     * Create a new notification.
     *
     * @param array $data
     * @return int
     */
    public function create(array $data): int
    {
        // Set sent_at to now if not provided
        if (!isset($data['sent_at'])) {
            $data['sent_at'] = date('Y-m-d H:i:s');
        }
        
        // Default is_read to false if not provided
        if (!isset($data['is_read'])) {
            $data['is_read'] = 0;
        }
        
        return parent::create($data);
    }

    /**
     * Get notifications by user ID.
     *
     * @param int $userId
     * @return array
     */
    public function getByUserId(int $userId): array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE user_id = :user_id
            ORDER BY sent_at DESC
        ";
        
        $notifications = $this->dbHelper->select($query, [':user_id' => $userId]);
        return $notifications ?: [];
    }

    /**
     * Get unread notifications for a user.
     *
     * @param int $userId
     * @return array
     */
    public function getUnreadByUserId(int $userId): array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE user_id = :user_id AND is_read = 0
            ORDER BY sent_at DESC
        ";
        
        $notifications = $this->dbHelper->select($query, [':user_id' => $userId]);
        return $notifications ?: [];
    }

    /**
     * Mark all notifications as read for a user.
     *
     * @param int $userId
     * @return bool
     */
    public function markAllAsReadForUser(int $userId): bool
    {
        $result = $this->dbHelper->update($this->table, ['is_read' => 1], ['user_id' => $userId, 'is_read' => 0]);
        
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'all_notifications_read', [
                'user_id' => $userId
            ]);
        }
        
        return $result;
    }

    /**
     * Get the user associated with a notification.
     *
     * @param int $notificationId
     * @return array|null
     */
    public function getUser(int $notificationId): ?array
    {
        $notification = $this->find($notificationId);
        
        if (!$notification || !isset($notification['user_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM users WHERE id = :user_id";
        $result = $this->dbHelper->select($query, [':user_id' => $notification['user_id']]);
        return $result[0] ?? null;
    }
}
=== App/Models/PaymentMethod.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;

/**
 * PaymentMethod Model
 *
 * Represents a payment method and handles interactions with the `payment_methods` table.
 */
class PaymentMethod extends BaseModel
{
    protected $table = 'payment_methods';
    protected $resourceName = 'payment_method';
    
    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'name' => 'required|string|max:255',
        'description' => 'nullable|string',
        'is_active' => 'boolean',
        'user_id' => 'required|exists:users,id',
        'payment_type' => 'required|string|in:credit_card,paypal,bank_transfer'
    ];

    public function __construct(DatabaseHelper $dbHelper)
    {
        $this->pdo = $dbHelper->getPdo();
    }

    /**
     * Get all available payment methods.
     */
    public function getAll(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE is_active = 1";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute();
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Get payment method by ID.
     */
    public function getById(int $id): ?array
    {
        $stmt = $this->pdo->prepare("SELECT * FROM payment_methods WHERE id = :id");
        $stmt->execute([':id' => $id]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }

    /**
     * Add a new payment method.
     */
    public function create(array $data): int
    {
        $validPaymentTypes = ['credit_card', 'paypal', 'bank_transfer'];
        if (!in_array($data['payment_type'], $validPaymentTypes)) {
            throw new \InvalidArgumentException("Invalid payment type.");
        }

        return parent::create($data);
    }
    
    /**
     * Update a payment method.
     */
    public function update(int $id, array $data): bool
    {
        $setClauses = [];
        $params = [':id' => $id];

        foreach ($data as $key => $value) {
            if (in_array($key, ['name', 'description', 'is_active', 'payment_type'])) {
                $setClauses[] = "$key = :$key";
                $params[":$key"] = $value;
            }
        }

        if (empty($setClauses)) {
            return false;
        }

        $setClauses[] = "updated_at = NOW()";
        $setClause = implode(', ', $setClauses);

        $stmt = $this->pdo->prepare("
            UPDATE payment_methods 
            SET $setClause 
            WHERE id = :id
        ");
        return $stmt->execute($params);
    }
    
    /**
     * Delete a payment method.
     */
    public function delete(int $id): bool
    {
        $stmt = $this->pdo->prepare("DELETE FROM payment_methods WHERE id = :id");
        return $stmt->execute([':id' => $id]);
    }

    /**
     * Get payment methods by user ID.
     * Replaces scopeByUser.
     */
    public function getByUser(int $userId): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE user_id = :user_id
            ORDER BY created_at DESC
        ";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':user_id' => $userId]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }
    
    /**
     * Get user data for a payment method.
     * Replaces user relationship.
     */
    public function getUser(int $paymentMethodId): ?array
    {
        $query = "
            SELECT u.* FROM users u
            JOIN {$this->table} pm ON u.id = pm.user_id
            WHERE pm.id = :payment_method_id
        ";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':payment_method_id' => $paymentMethodId]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }
}
=== App/Models/Document.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Document Model
 *
 * Represents documents stored in the system and provides methods
 * for managing and querying them.
 */
class Document extends BaseModel
{
    protected $table = 'documents';
    protected $resourceName = 'document';
    protected $useSoftDeletes = false; // Document model doesn't use soft deletes

    /**
     * Create a new document record.
     *
     * @param array $data Data including name, file_path, user_id, type
     * @return int The ID of the newly created document.
     */
    public function create(array $data): int
    {
        // Add created_at if using timestamps but not provided
        if ($this->useTimestamps && !isset($data['created_at'])) {
            $data['created_at'] = date('Y-m-d H:i:s');
        }
        
        $id = parent::create($data);
        
        // Add custom audit logging if needed
        if ($this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'document_created', [
                'id' => $id,
                'name' => $data['name'] ?? null,
                'type' => $data['type'] ?? null,
                'user_id' => $data['user_id'] ?? null
            ]);
        }
        
        return $id;
    }

    /**
     * Override find to add audit logging for views.
     *
     * @param int $id
     * @return array|null
     */
    public function find(int $id): ?array
    {
        $document = parent::find($id);
        
        // Log view event if document was found
        if ($document && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'document_viewed', [
                'id' => $id,
                'name' => $document['name'] ?? 'unknown'
            ]);
        }
        
        return $document;
    }

    /**
     * Retrieve documents associated with a user.
     *
     * @param int $userId The ID of the user.
     * @return array A list of documents associated with the user.
     */
    public function getByUserId(int $userId): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE user_id = :user_id 
            ORDER BY created_at DESC
        ";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':user_id' => $userId]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Retrieve documents by type.
     *
     * @param string $type The type of document (e.g., 'contract', 'terms').
     * @return array A list of documents matching the specified type.
     */
    public function getByType(string $type): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE type = :type 
            ORDER BY created_at DESC
        ";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':type' => $type]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Delete a document by its ID.
     *
     * @param int $id The ID of the document to delete.
     * @return bool True on success, false otherwise.
     */
    public function delete(int $id): bool
    {
        // First, get document details for audit log
        $document = $this->find($id);
        
        if (!$document) {
            return false;
        }
        
        $result = parent::delete($id);
        
        // Add custom audit log if needed
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'document_deleted', [
                'id' => $id,
                'name' => $document['name'] ?? 'unknown',
                'type' => $document['type'] ?? null
            ]);
        }
        
        return $result;
    }
    
    /**
     * Update a document's details.
     *
     * @param int $id The ID of the document to update.
     * @param array $data The data to update.
     * @return bool True on success, false otherwise.
     */
    public function update(int $id, array $data): bool
    {
        // Filter data to only include allowed fields
        $validData = array_filter($data, function($key) {
            return in_array($key, ['name', 'file_path', 'type']);
        }, ARRAY_FILTER_USE_KEY);
        
        if (empty($validData)) {
            return false;
        }
        
        $result = parent::update($id, $validData);
        
        // Add custom audit log if needed
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'document_updated', [
                'id' => $id,
                'updated_fields' => array_keys($validData)
            ]);
        }
        
        return $result;
    }
}
=== App/Models/Vehicle.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Vehicle Model
 *
 * Represents a vehicle in the system.
 */
class Vehicle extends BaseModel
{
    protected $table = 'vehicles';
    protected $resourceName = 'vehicle';
    protected $useSoftDeletes = false; // Vehicles use hard deletes

    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'registration_number' => 'required|string|unique:vehicles,registration_number',
        'type' => 'required|string',
        'status' => 'required|in:available,unavailable,maintenance',
        'make' => 'required|string|max:255',
        'model' => 'required|string|max:255',
        'year' => 'required|integer|min:1886|max:' . PHP_INT_MAX,
    ];

    /**
     * Create a new vehicle
     * 
     * @param array $data
     * @return int
     */
    public function create(array $data): int
    {
        // Ensure status is properly managed
        if (empty($data['status'])) {
            $data['status'] = 'available';
        }

        return parent::create($data);
    }

    /**
     * Find available vehicles
     *
     * @return array
     */
    public function findAvailable(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE status = :status";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':status' => 'available']);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Find vehicles by type
     *
     * @param string $type
     * @return array
     */
    public function findByType(string $type): array
    {
        $query = "SELECT * FROM {$this->table} WHERE type = :type";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':type' => $type]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Get vehicle's bookings
     *
     * @param int $vehicleId
     * @return array
     */
    public function getBookings(int $vehicleId): array
    {
        $query = "SELECT * FROM bookings WHERE vehicle_id = :vehicle_id";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':vehicle_id' => $vehicleId]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }
    
    /**
     * Set a vehicle to maintenance status
     *
     * @param int $id
     * @param string $reason
     * @return bool
     */
    public function setToMaintenance(int $id, string $reason = ''): bool
    {
        $result = $this->update($id, ['status' => 'maintenance']);
        
        // Add custom audit logging for maintenance status
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'vehicle_maintenance', [
                'vehicle_id' => $id,
                'reason' => $reason
            ]);
        }
        
        return $result;
    }
    
    /**
     * Set a vehicle to available status
     *
     * @param int $id
     * @return bool
     */
    public function setToAvailable(int $id): bool
    {
        return $this->update($id, ['status' => 'available']);
    }
}
=== App/Models/DocumentTemplate.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use App\Traits\Auditable;

/**
 * DocumentTemplate Model
 *
 * Manages templates for documents such as contracts, invoices, and Terms & Conditions.
 */
class DocumentTemplate extends Model
{
    use SoftDeletes, Auditable;

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'name',
        'content',
        'description'
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array
     */
    protected $casts = [
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Get the validation rules for the model.
     *
     * @return array
     */
    public static function validationRules(): array
    {
        return [
            'name' => 'required|string|max:255',
            'content' => 'required|string',
            'description' => 'nullable|string'
        ];
    }
}
=== App/Models/User.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use Exception;
use Psr\Log\LoggerInterface;
use Illuminate\Support\Facades\Hash;
use Ramsey\Uuid\Uuid;
use App\Services\AuditService;

/**
 * User Model
 * 
 * Represents a user in the system with their associated data and relationships.
 * 
 * @property string $id UUID of the user
 * @property string $name User's first name
 * @property string $surname User's last name
 * @property string $email User's email address
 * @property string $password_hash Hashed password
 * @property string $role User role (user, admin, super_admin)
 * @property string $phone Phone number
 * @property string $address Physical address
 * @property \DateTime $created_at
 * @property \DateTime $updated_at
 * @property \DateTime $deleted_at
 */
class User extends BaseModel
{
    private $pdo;
    private LoggerInterface $logger;

    public function __construct(DatabaseHelper $dbHelper, LoggerInterface $logger)
    {
        $this->pdo = $dbHelper->getPdo();
        $this->logger = $logger;
    }

    protected $table = 'users';
    protected $primaryKey = 'id';
    protected $resourceName = 'user';
    protected $useTimestamps = true;
    protected $useSoftDeletes = true;
    protected $useUuid = true;

    protected $fillable = [
        'name',
        'surname',
        'email',
        'password_hash',
        'role',
        'phone',
        'address',
    ];

    protected $hidden = [
        'password_hash',
        'remember_token',
        'deleted_at',
    ];

    public static array $rules = [
        'name' => 'required|string|max:255',
        'surname' => 'required|string|max:255',
        'email' => 'required|email|unique:users,email',
        'password' => 'required|min:8|regex:/^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/',
        'role' => 'required|in:user,admin,super_admin',
        'phone' => 'nullable|string|max:20',
        'address' => 'nullable|string|max:255',
    ];

    /**
     * Relationships
     */

    /**
     * Get user's bookings
     * 
     * @param string $userId
     * @return array
     */
    public function getBookings(string $userId): array
    {
        $query = "SELECT * FROM bookings WHERE user_id = :user_id";
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's payments
     * 
     * @param int $userId
     * @return array
     */
    public function getPayments(int $userId): array
    {
        $query = "SELECT p.* FROM payments p 
                 JOIN bookings b ON p.booking_id = b.id 
                 WHERE b.user_id = :user_id AND p.deleted_at IS NULL 
                 ORDER BY p.created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }
    
    /**
     * Get all transactions for a user
     * 
     * @param int $userId
     * @return array
     */
    public function getTransactions(int $userId): array
    {
        $query = "SELECT t.* FROM transaction_logs t 
                 WHERE t.user_id = :user_id 
                 ORDER BY t.created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's notifications
     * 
     * @param string $userId
     * @return array
     */
    public function getNotifications(string $userId): array
    {
        $query = "SELECT * FROM notifications WHERE user_id = :user_id";
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's logs
     * 
     * @param string $userId
     * @return array
     */
    public function getLogs(string $userId): array
    {
        $query = "SELECT * FROM logs WHERE user_reference = :user_id";
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's audit trails
     * 
     * @param string $userId
     * @return array
     */
    public function getAuditTrails(string $userId): array
    {
        $query = "SELECT * FROM audit_trails WHERE user_reference = :user_id";
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's contracts
     * 
     * @param string $userId
     * @return array
     */
    public function getContracts(string $userId): array
    {
        $query = "SELECT * FROM contracts WHERE user_reference = :user_id";
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Accessors & Helpers
     */
    
    /**
     * Get full name by combining first and last name
     * 
     * @param array $user User data
     * @return string
     */
    public static function getFullName(array $user): string
    {
        return "{$user['name']} {$user['surname']}";
    }

    /**
     * Check if user is an admin
     * 
     * @param array $user User data
     * @return bool
     */
    public static function isAdmin(array $user): bool
    {
        return in_array($user['role'], ['admin', 'super_admin']);
    }

    /**
     * Check if user is a super admin
     * 
     * @param array $user User data
     * @return bool
     */
    public static function isSuperAdmin(array $user): bool
    {
        return $user['role'] === 'super_admin';
    }

    /**
     * Check if user has a specific permission
     * 
     * @param array $user User data
     * @param string $permission
     * @return bool
     */
    public static function hasPermission(array $user, string $permission): bool
    {
        $rolePermissions = [
            'user' => ['read_own'],
            'admin' => ['read_own', 'read_all', 'write_all'],
            'super_admin' => ['read_own', 'read_all', 'write_all', 'delete_all'],
        ];

        return in_array($permission, $rolePermissions[$user['role']] ?? []);
    }

    /**
     * Password handling
     */
    
    /**
     * Hash a password
     * 
     * @param string $password
     * @return string
     */
    public static function hashPassword(string $password): string
    {
        return Hash::make($password);
    }
    
    /**
     * Verify a password
     * 
     * @param string $password
     * @param string $hash
     * @return bool
     */
    public static function verifyPassword(string $password, string $hash): bool
    {
        return Hash::check($password, $hash);
    }

    /**
     * Database operations
     */

    /**
     * Create a new user
     * 
     * @param array $data
     * @return int The ID of the created user (or UUID converted to integer if using UUID)
     */
    public function create(array $data): int
    {
        if (isset($data['password'])) {
            $data['password_hash'] = self::hashPassword($data['password']);
            unset($data['password']);
        }

        if ($this->useUuid && !isset($data['id'])) {
            $data['id'] = Uuid::uuid4()->toString();
        }

        if ($this->useTimestamps) {
            $now = date('Y-m-d H:i:s');
            $data['created_at'] = $now;
            $data['updated_at'] = $now;
        }

        $id = $this->dbHelper->insert($this->table, $data);
        
        // Log the creation if audit service is available
        if ($this->auditService) {
            $this->auditService->logEvent('user', 'created', [
                'id' => $id,
                'email' => $data['email'] ?? 'unknown'
            ]);
        }

        // Ensure we return an integer to match the parent class signature
        return is_numeric($id) ? (int)$id : crc32($id);
    }

    /**
     * Update user data
     * 
     * @param string|int $id
     * @param array $data
     * @return bool
     */
    public function update(string|int $id, array $data): bool
    {
        if (isset($data['password'])) {
            $data['password_hash'] = self::hashPassword($data['password']);
            unset($data['password']);
        }

        if ($this->useTimestamps) {
            $data['updated_at'] = date('Y-m-d H:i:s');
        }

        $conditions = ['id' => $id];
        if ($this->useSoftDeletes) {
            $conditions['deleted_at IS NULL'] = null;
        }

        $result = $this->dbHelper->update($this->table, $data, $conditions);
        
        // Log the update if audit service is available
        if ($result && $this->auditService) {
            $this->auditService->logEvent('user', 'updated', [
                'id' => $id,
                'updated_fields' => array_keys($data)
            ]);
        }

        return $result;
    }

    /**
     * Find a user by their email address
     * 
     * @param string $email
     * @return array|null
     */
    public function findByEmail(string $email): ?array
    {
        try {
            $stmt = $this->pdo->prepare("SELECT * FROM users WHERE email = ? AND active = 1");
            $stmt->execute([$email]);
            return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
        } catch (Exception $e) {
            $this->logger->error("Error finding user by email: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Find a user by their ID
     */
    public function find(int $id): ?array
    {
        try {
            $stmt = $this->pdo->prepare("SELECT * FROM users WHERE id = ? AND active = 1");
            $stmt->execute([$id]);
            return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
        } catch (Exception $e) {
            $this->logger->error("Error finding user by ID: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Validate a user's password
     */
    public function validatePassword(string $email, string $password): ?array
    {
        $user = $this->findByEmail($email);
        
        if (!$user || !password_verify($password, $user['password_hash'])) {
            return null;
        }
        
        return $user;
    }

    /**
     * Update a user's password
     */
    public function updatePassword(int $userId, string $newPassword): bool
    {
        try {
            $hashedPassword = $this->hashPassword($newPassword);
            return $this->update($userId, [
                'password_hash' => $hashedPassword,
                'updated_at' => date('Y-m-d H:i:s')
            ]);
        } catch (Exception $e) {
            $this->logger->error("Error updating password: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Create a password reset token
     */
    public function createPasswordReset(string $email, string $token, ?string $ipAddress, string $expiry): bool
    {
        try {
            $stmt = $this->pdo->prepare("INSERT INTO password_resets (email, token, ip_address, expires_at, created_at) VALUES (?, ?, ?, ?, ?)");
            return $stmt->execute([
                $email, 
                $token, 
                $ipAddress, 
                $expiry, 
                date('Y-m-d H:i:s')
            ]);
        } catch (Exception $e) {
            $this->logger->error("Error creating password reset: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Verify a password reset token
     */
    public function verifyResetToken(string $token): ?array
    {
        try {
            $stmt = $this->pdo->prepare(
                "SELECT * FROM password_resets 
                 WHERE token = ? AND used = 0 AND expires_at > ? 
                 ORDER BY created_at DESC LIMIT 1"
            );
            $stmt->execute([$token, date('Y-m-d H:i:s')]);
            return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
        } catch (Exception $e) {
            $this->logger->error("Error verifying reset token: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Mark a reset token as used
     */
    public function markResetTokenUsed(int $tokenId): bool
    {
        try {
            $stmt = $this->pdo->prepare("UPDATE password_resets SET used = 1, used_at = ? WHERE id = ?");
            return $stmt->execute([date('Y-m-d H:i:s'), $tokenId]);
        } catch (Exception $e) {
            $this->logger->error("Error marking reset token as used: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Get active users (not deleted)
     * 
     * @return array
     */
    public function getActive(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE deleted_at IS NULL";
        return $this->dbHelper->select($query);
    }

    /**
     * Get users with a specific role
     * 
     * @param string $role
     * @return array
     */
    public function getWithRole(string $role): array
    {
        $query = "SELECT * FROM {$this->table} WHERE role = :role";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        return $this->dbHelper->select($query, [':role' => $role]);
    }

    /**
     * Get a user by email
     * 
     * @param string $email
     * @return array|null
     */
    public function getUserByEmail(string $email): ?array
    {
        return $this->findByEmail($email);
    }

    /**
     * Update user profile
     * 
     * @param string|int $userId
     * @param array $profileData
     * @return bool
     */
    public function updateProfile(string|int $userId, array $profileData): bool
    {
        try {
            // Filter out sensitive fields that shouldn't be updated via profile update
            $allowedFields = ['name', 'surname', 'phone', 'address'];
            $filteredData = array_intersect_key($profileData, array_flip($allowedFields));
            
            return $this->update($userId, $filteredData);
        } catch (Exception $e) {
            $this->logger->error("Error updating user profile: " . $e->getMessage(), [
                'user_id' => $userId,
                'exception' => $e
            ]);
            throw $e;
        }
    }

    /**
     * Update user role
     * 
     * @param string|int $userId
     * @param string $newRole
     * @return bool
     * @throws Exception If role is invalid
     */
    public function updateUserRole(string|int $userId, string $newRole): bool
    {
        try {
            // Validate role
            $validRoles = ['user', 'admin', 'super_admin'];
            if (!in_array($newRole, $validRoles)) {
                throw new Exception("Invalid role: {$newRole}");
            }

            return $this->update($userId, ['role' => $newRole]);
        } catch (Exception $e) {
            $this->logger->error("Error updating user role: " . $e->getMessage(), [
                'user_id' => $userId,
                'new_role' => $newRole,
                'exception' => $e
            ]);
            throw $e;
        }
    }

    /**
     * Soft delete a user
     * 
     * @param string|int $userId
     * @return bool
     */
    public function deleteUser(string|int $userId): bool
    {
        try {
            // Fetch the user first to check role
            $user = $this->find($userId);
            
            // Return false if the user is a super admin
            if ($user && isset($user['role']) && $user['role'] === 'super_admin') {
                return false;
            }

            if (!$this->useSoftDeletes) {
                throw new Exception("Soft deletes not enabled for User model");
            }
            
            $data = ['deleted_at' => date('Y-m-d H:i:s')];
            $conditions = ['id' => $userId];
            
            $result = $this->dbHelper->update($this->table, $data, $conditions);
            
            if ($result && $this->auditService) {
                $this->auditService->logEvent('user', 'deleted', [
                    'id' => $userId
                ]);
            }
            
            return $result;
        } catch (Exception $e) {
            $this->logger->error("Error deleting user: " . $e->getMessage(), [
                'user_id' => $userId,
                'exception' => $e
            ]);
            throw $e;
        }
    }

    /**
     * Change user password
     * 
     * @param string|int $userId 
     * @param string $currentPassword
     * @param string $newPassword
     * @return bool
     * @throws Exception If current password is invalid
     */
    public function changePassword(string|int $userId, string $currentPassword, string $newPassword): bool
    {
        try {
            // Get user first to verify current password
            $user = $this->find($userId);
            
            if (!$user) {
                throw new Exception("User not found");
            }
            
            // Verify current password
            if (!self::verifyPassword($currentPassword, $user['password_hash'])) {
                throw new Exception("Current password is incorrect");
            }
            
            // Update password
            return $this->updatePassword($userId, $newPassword);
        } catch (Exception $e) {
            $this->logger->error("Error changing password: " . $e->getMessage(), [
                'user_id' => $userId,
                'exception' => $e
            ]);
            throw $e;
        }
    }
}
=== App/Models/BaseModel.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;
use PDO;

/**
 * BaseModel
 * 
 * Base class for all models that use the DatabaseHelper instead of Eloquent
 */
abstract class BaseModel
{
    /**
     * @var string The table associated with the model
     */
    protected $table;
    
    /**
     * @var string The name of the resource for audit logging
     */
    protected $resourceName;
    
    /**
     * @var bool Whether the model uses timestamps
     */
    protected $useTimestamps = true;
    
    /**
     * @var bool Whether the model uses soft deletes
     */
    protected $useSoftDeletes = false;
    
    /**
     * @var bool Whether the model uses UUID as primary key
     */
    protected $useUuid = false;
    
    /**
     * @var DatabaseHelper Database helper instance
     */
    protected $dbHelper;
    
    /**
     * @var AuditService|null Audit service instance
     */
    protected $auditService;
    
    /**
     * @var PDO PDO instance
     */
    protected $pdo;

    /**
     * Constructor
     *
     * @param DatabaseHelper|null $dbHelper
     * @param AuditService|null $auditService
     */
    public function __construct(DatabaseHelper $dbHelper = null, AuditService $auditService = null)
    {
        $this->dbHelper = $dbHelper ?? new DatabaseHelper();
        $this->auditService = $auditService;
        $this->pdo = $this->dbHelper->getPdo();
    }

    /**
     * Find a record by ID
     *
     * @param int $id
     * @return array|null
     */
    public function find(int|string $id): ?array
    {
        $query = "SELECT * FROM {$this->table} WHERE id = :id";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':id' => $id]);
        return $result ? $result[0] : null;
    }

    /**
     * Get all records from the table
     *
     * @return array
     */
    public function all(): array
    {
        $query = "SELECT * FROM {$this->table}";
        
        if ($this->useSoftDeletes) {
            $query .= " WHERE deleted_at IS NULL";
        }
        
        return $this->dbHelper->select($query);
    }

    /**
     * Create a new record
     *
     * @param array $data
     * @return int The ID of the created record
     */
    public function create(array $data): int
    {
        if ($this->useTimestamps && !isset($data['created_at'])) {
            $data['created_at'] = date('Y-m-d H:i:s');
        }
        
        if ($this->useTimestamps && !isset($data['updated_at'])) {
            $data['updated_at'] = date('Y-m-d H:i:s');
        }
        
        if ($this->useUuid && !isset($data['id'])) {
            $data['id'] = \Ramsey\Uuid\Uuid::uuid4()->toString();
        }
        
        $id = $this->dbHelper->insert($this->table, $data);
        
        // Log audit event if service is available
        if ($this->auditService && $this->resourceName) {
            $this->auditService->logEvent($this->resourceName, 'create', [
                'id' => $id,
                'data' => $data
            ]);
        }
        
        return $id;
    }

    /**
     * Update a record
     *
     * @param int $id
     * @param array $data
     * @return bool
     */
    public function update(int|string $id, array $data): bool
    {
        if ($this->useTimestamps) {
            $data['updated_at'] = date('Y-m-d H:i:s');
        }
        
        $conditions = ['id' => $id];
        
        if ($this->useSoftDeletes) {
            $conditions['deleted_at IS NULL'] = null;
        }
        
        $result = $this->dbHelper->update($this->table, $data, $conditions);
        
        // Log audit event if service is available
        if ($result && $this->auditService && $this->resourceName) {
            $this->auditService->logEvent($this->resourceName, 'update', [
                'id' => $id,
                'updated_fields' => array_keys($data)
            ]);
        }
        
        return $result;
    }

    /**
     * Delete a record (soft delete if enabled)
     *
     * @param int $id
     * @return bool
     */
    public function delete(int|string $id): bool
    {
        if ($this->useSoftDeletes) {
            $data = ['deleted_at' => date('Y-m-d H:i:s')];
            $result = $this->dbHelper->update($this->table, $data, ['id' => $id]);
        } else {
            $result = $this->dbHelper->delete($this->table, ['id' => $id]);
        }
        
        // Log audit event if service is available
        if ($result && $this->auditService && $this->resourceName) {
            $this->auditService->logEvent($this->resourceName, 'delete', [
                'id' => $id
            ]);
        }
        
        return $result;
    }
}
=== App/Models/Report.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Report Model
 *
 * Represents an admin report in the system.
 */
class Report extends BaseModel
{
    protected $table = 'reports';
    protected $resourceName = 'report';
    protected $useSoftDeletes = true;

    /**
     * Attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'admin_id',
        'title',
        'content',
        'status',
        'created_at',
        'updated_at'
    ];

    /**
     * Get reports within a date range.
     *
     * @param string $start
     * @param string $end
     * @return array
     */
    public function getByDateRange(string $start, string $end): array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE created_at BETWEEN :start AND :end
        ";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':start' => $start, ':end' => $end]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Get the admin who created the report.
     *
     * @param int $reportId
     * @return array|null
     */
    public function getAdmin(int $reportId): ?array
    {
        $report = $this->find($reportId);
        
        if (!$report || !isset($report['admin_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM admins WHERE id = :admin_id";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':admin_id' => $report['admin_id']]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }
}
=== App/Models/AuditTrail.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * AuditTrail Model
 *
 * Represents the audit trails stored in the database and provides methods
 * for accessing and filtering the logs.
 */
class AuditTrail extends BaseModel
{
    protected $table = 'audit_trails';
    protected $resourceName = 'audit_trail';
    protected $useTimestamps = true;
    protected $useSoftDeletes = false;

    /**
     * Retrieve audit trail records based on filters.
     *
     * @param array $filters An associative array of filters:
     *                       - 'user_id' (int): Filter by user ID.
     *                       - 'booking_id' (int): Filter by booking ID.
     *                       - 'action' (string): Filter by action type.
     *                       - 'start_date' (string): Filter by start date (YYYY-MM-DD).
     *                       - 'end_date' (string): Filter by end date (YYYY-MM-DD).
     * @return array An array of matching audit trail records.
     */
    public function getLogs(array $filters = []): array
    {
        $query = "SELECT * FROM {$this->table} WHERE 1=1";
        $params = [];

        if (!empty($filters['user_id'])) {
            $query .= " AND user_id = :user_id";
            $params[':user_id'] = $filters['user_id'];
        }

        if (!empty($filters['booking_id'])) {
            $query .= " AND booking_id = :booking_id";
            $params[':booking_id'] = $filters['booking_id'];
        }

        if (!empty($filters['action'])) {
            $query .= " AND action = :action";
            $params[':action'] = $filters['action'];
        }

        if (!empty($filters['start_date'])) {
            $query .= " AND created_at >= :start_date";
            $params[':start_date'] = $filters['start_date'];
        }

        if (!empty($filters['end_date'])) {
            $query .= " AND created_at <= :end_date";
            $params[':end_date'] = $filters['end_date'];
        }

        $query .= " ORDER BY created_at DESC";

        return $this->dbHelper->select($query, $params);
    }
}
=== App/Models/RefundLog.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * RefundLog Model
 *
 * Represents a refund and handles interactions with the `refund_logs` table.
 */
class RefundLog extends BaseModel
{
    protected $table = 'refund_logs';
    protected $resourceName = 'refund_log';
    protected $useTimestamps = true;
    protected $useSoftDeletes = true;

    /**
     * Get the user associated with the refund.
     *
     * @param int $refundId
     * @return array|null
     */
    public function getUser(int $refundId): ?array
    {
        $refund = $this->find($refundId);
        
        if (!$refund || !isset($refund['user_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM users WHERE id = :user_id";
        $result = $this->dbHelper->select($query, [':user_id' => $refund['user_id']]);
        return $result[0] ?? null;
    }

    /**
     * Get the payment associated with the refund.
     *
     * @param int $refundId
     * @return array|null
     */
    public function getPayment(int $refundId): ?array
    {
        $refund = $this->find($refundId);
        
        if (!$refund || !isset($refund['payment_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM payments WHERE id = :payment_id";
        $result = $this->dbHelper->select($query, [':payment_id' => $refund['payment_id']]);
        return $result[0] ?? null;
    }
}=== App/Models/Signature.php ===
namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;
use App\Services\EncryptionService;

class Signature extends BaseModel
{
    protected $table = 'signatures';
    protected $resourceName = 'signature';
    protected $useTimestamps = true;
    protected $useSoftDeletes = false;

    /**
     * Create a new signature.
     *
     * @param array $data
     * @return int
     */
    public function create(array $data): int
    {
        if (isset($data['signature'])) {
            $data['signature'] = EncryptionService::encrypt($data['signature']);
        }

        return parent::create($data);
    }

    /**
     * Update a signature.
     *
     * @param int $id
     * @param array $data
     * @return bool
     */
    public function update(int $id, array $data): bool
    {
        if (isset($data['signature'])) {
            $data['signature'] = EncryptionService::encrypt($data['signature']);
        }

        return parent::update($id, $data);
    }

    /**
     * Get the signature.
     *
     * @param int $signatureId
     * @return string|null
     */
    public function getSignature(int $signatureId): ?string
    {
        $signature = $this->find($signatureId);

        if ($signature && isset($signature['signature'])) {
            return EncryptionService::decrypt($signature['signature']);
        }

        return null;
    }

    /**
     * Get the user associated with the signature.
     *
     * @param int $signatureId
     * @return array|null
     */
    public function getUser(int $signatureId): ?array
    {
        $signature = $this->find($signatureId);
        
        if (!$signature || !isset($signature['user_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM users WHERE id = :user_id";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':user_id' => $signature['user_id']]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }
}
=== App/Models/PasswordReset.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * PasswordReset Model
 *
 * Represents a password reset request.
 */
class PasswordReset extends BaseModel
{
    protected $table = 'password_resets';
    protected $resourceName = 'password_reset';
    protected $useTimestamps = true;
    protected $useSoftDeletes = false;

    /**
     * Find a password reset by token.
     *
     * @param string $token
     * @return array|null
     */
    public function findByToken(string $token): ?array
    {
        $query = "SELECT * FROM {$this->table} WHERE token = :token";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':token' => $token]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }

    /**
     * Create a new password reset.
     *
     * @param array $data
     * @return int
     */
    public function create(array $data): int
    {
        // Generate a token if not provided
        if (!isset($data['token'])) {
            $data['token'] = bin2hex(random_bytes(32));
        }

        $id = parent::create($data);

        // Add custom audit logging if needed
        if ($this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'password_reset_created', [
                'id' => $id,
                'email' => $data['email'] ?? null
            ]);
        }

        return $id;
    }
}
