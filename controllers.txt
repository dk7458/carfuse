=== App/Controllers/UserController.php ===
<?php

namespace App\Controllers;

use App\Services\NotificationService;
use App\Services\Validator;
use App\Services\RateLimiter;
use AuditManager\Services\AuditService;
use PDO;
use Psr\Log\LoggerInterface;
use Firebase\JWT\JWT;

/**
 * User Management Controller
 *
 * Handles user registration, authentication, profile management, and password resets.
 * Implements enhanced security and scalability features.
 */
class UserController
{
    private PDO $appDb;
    private PDO $secureDb;
    private LoggerInterface $logger;
    private array $config;
    private Validator $validator;
    private RateLimiter $rateLimiter;
    private AuditService $auditService;
    private NotificationService $notificationService;

    public function __construct(
        PDO $appDb,
        PDO $secureDb,
        LoggerInterface $logger,
        array $config,
        Validator $validator,
        RateLimiter $rateLimiter,
        AuditService $auditService,
        NotificationService $notificationService
    ) {
        $this->appDb = $appDb;
        $this->secureDb = $secureDb;
        $this->logger = $logger;
        $this->config = $config;
        $this->validator = $validator;
        $this->rateLimiter = $rateLimiter;
        $this->auditService = $auditService;
        $this->notificationService = $notificationService;
    }

    /**
     * Register a new user
     */
    public function register(array $data): array
    {
        $rules = [
            'name' => 'required|string|max:255',
            'email' => 'required|email|unique:users',
            'password' => 'required|string|min:8|regex:/^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/',
            'phone' => 'required|string|max:20',
            'address' => 'required|string|max:255',
        ];

        if (!$this->validator->validate($data, $rules)) {
            return ['status' => 'error', 'message' => 'Validation failed', 'errors' => $this->validator->errors()];
        }

        try {
            // Store user in secure database
            $stmt = $this->secureDb->prepare("
                INSERT INTO users (name, email, password_hash, phone, address, role, created_at)
                VALUES (:name, :email, :password, :phone, :address, 'user', NOW())
            ");
            $stmt->execute([
                'name' => $data['name'],
                'email' => $data['email'],
                'password' => password_hash($data['password'], PASSWORD_BCRYPT),
                'phone' => $data['phone'],
                'address' => $data['address'],
            ]);

            $userId = $this->secureDb->lastInsertId();

            // Log action in secure database
            $this->auditService->log(
                'user_registered',
                'A new user has been registered.',
                $userId,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            // Send notification
            $this->notificationService->sendNotification(
                $userId,
                'email',
                'Welcome to Carfuse! Your account has been created successfully.',
                ['email' => $data['email']]
            );

            return ['status' => 'success', 'message' => 'Registration successful'];
        } catch (\PDOException $e) {
            $this->logger->error('Registration failed', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Registration failed'];
        }
    }

    /**
     * Authenticate user and generate JWT token
     */
    public function login(string $email, string $password, string $ip): array
    {
        if ($this->rateLimiter->isRateLimited($ip)) {
            return ['status' => 'error', 'message' => 'Too many attempts'];
        }

        // Fetch user from secure database
        $stmt = $this->secureDb->prepare("SELECT * FROM users WHERE email = ?");
        $stmt->execute([$email]);
        $user = $stmt->fetch(PDO::FETCH_ASSOC);

        if (!$user || !password_verify($password, $user['password_hash'])) {
            $this->auditService->log(
                'failed_login_attempt',
                'Failed login attempt.',
                null,
                null,
                $ip
            );
            return ['status' => 'error', 'message' => 'Invalid credentials'];
        }

        $token = $this->generateJWT($user);

        $this->auditService->log(
            'user_logged_in',
            'User logged in successfully.',
            $user['id'],
            null,
            $ip
        );

        return ['status' => 'success', 'token' => $token];
    }

    /**
     * Update user profile
     */
    public function updateProfile(int $userId, array $data): array
    {
        $rules = [
            'name' => 'string|max:255',
            'phone' => 'string|max:20',
            'address' => 'string|max:255',
        ];

        if (!$this->validator->validate($data, $rules)) {
            return ['status' => 'error', 'message' => 'Validation failed', 'errors' => $this->validator->errors()];
        }

        try {
            $allowedFields = array_keys($rules);
            $updates = array_intersect_key($data, array_flip($allowedFields));
            $sql = "UPDATE users SET " . implode(', ', array_map(fn($k) => "$k = :$k", array_keys($updates))) . " WHERE id = :id";

            $stmt = $this->secureDb->prepare($sql);
            $stmt->execute([...$updates, 'id' => $userId]);

            $this->auditService->log(
                'user_profile_updated',
                'User profile updated.',
                $userId,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            return ['status' => 'success', 'message' => 'Profile updated'];
        } catch (\PDOException $e) {
            $this->logger->error('Profile update failed', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Update failed'];
        }
    }

    /**
     * Generate password reset token
     */
    public function requestPasswordReset(string $email): array
    {
        $stmt = $this->secureDb->prepare("SELECT * FROM users WHERE email = ?");
        $stmt->execute([$email]);
        $user = $stmt->fetch(PDO::FETCH_ASSOC);

        if (!$user) {
            return ['status' => 'error', 'message' => 'Email not found'];
        }

        $token = bin2hex(random_bytes(32));
        $expires = date('Y-m-d H:i:s', strtotime('+1 hour'));

        $stmt = $this->secureDb->prepare("
            INSERT INTO password_resets (email, token, expires_at) 
            VALUES (:email, :token, :expires)
        ");
        $stmt->execute([
            'email' => $email,
            'token' => $token,
            'expires' => $expires,
        ]);

        // Send password reset notification
        $this->notificationService->sendNotification(
            $user['id'],
            'email',
            "Use this link to reset your password: {$this->config['reset_url']}?token=$token",
            ['email' => $email]
        );

        return ['status' => 'success', 'message' => 'Reset instructions sent'];
    }

    private function generateJWT(array $user): string
    {
        $payload = [
            'sub' => $user['id'],
            'email' => $user['email'],
            'role' => $user['role'],
            'iat' => time(),
            'exp' => time() + 3600,
        ];

        return JWT::encode($payload, $this->config['jwt_secret'], 'HS256');
    }
}
=== App/Controllers/BookingController.php ===
<?php

namespace App\Controllers;

use App\Services\BookingService;
use App\Services\PaymentService;
use App\Services\Validator;
use AuditManager\Services\AuditService;
use App\Services\NotificationService;
use Psr\Log\LoggerInterface;
use App\Middleware\AuthMiddleware;

/**
 * Booking Controller
 *
 * Handles booking operations, including creating, rescheduling,
 * canceling bookings, and fetching booking details or logs.
 */
class BookingController
{
    private BookingService $bookingService;
    private PaymentService $paymentService;
    private Validator $validator;
    private AuditService $auditService;
    private NotificationService $notificationService;
    private LoggerInterface $logger;

    public function __construct(
        BookingService $bookingService,
        PaymentService $paymentService,
        Validator $validator,
        AuditService $auditService,
        NotificationService $notificationService,
        LoggerInterface $logger
    ) {
        $this->bookingService = $bookingService;
        $this->paymentService = $paymentService;
        $this->validator = $validator;
        $this->auditService = $auditService;
        $this->notificationService = $notificationService;
        $this->logger = $logger;
    }

    /**
     * View Booking Details
     */
    public function viewBooking(int $id)
    {
        try {
            AuthMiddleware::validateSession();
            $booking = $this->bookingService->getBookingById($id);
            $logs = $this->bookingService->getBookingLogs($id);

            if (!$booking) {
                throw new \Exception("Booking not found.");
            }

            require_once __DIR__ . '/../views/bookings/view.php';
        } catch (\Exception $e) {
            $this->logger->error('Failed to fetch booking details', ['error' => $e->getMessage()]);
            http_response_code(404);
            echo json_encode(['status' => 'error', 'message' => 'Booking not found.']);
        }
    }

    /**
     * Reschedule Booking
     */
    public function rescheduleBooking(int $id, array $data): array
    {
        AuthMiddleware::validateSession();
        $rules = [
            'pickup_date' => 'required|date|after_or_equal:today',
            'dropoff_date' => 'required|date|after:pickup_date',
        ];

        if (!$this->validator->validate($data, $rules)) {
            return ['status' => 'error', 'message' => 'Validation failed', 'errors' => $this->validator->errors()];
        }

        try {
            $this->bookingService->rescheduleBooking($id, $data['pickup_date'], $data['dropoff_date']);
            $this->auditService->log(
                'booking_rescheduled',
                'Booking successfully rescheduled.',
                $this->bookingService->getUserIdByBooking($id),
                $id,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            $this->notificationService->sendNotification(
                $this->bookingService->getUserIdByBooking($id),
                'email',
                'Your booking has been rescheduled successfully.',
                []
            );

            return ['status' => 'success', 'message' => 'Booking rescheduled successfully'];
        } catch (\Exception $e) {
            $this->logger->error('Failed to reschedule booking', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to reschedule booking'];
        }
    }

    /**
     * Cancel Booking
     */
    public function cancelBooking(int $id): array
    {
        AuthMiddleware::validateSession();
        try {
            $refundAmount = $this->bookingService->cancelBooking($id);

            if ($refundAmount > 0) {
                $this->paymentService->processRefundForBooking($id, $refundAmount);
            }

            $this->auditService->log(
                'booking_canceled',
                'Booking successfully canceled.',
                $this->bookingService->getUserIdByBooking($id),
                $id,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            $this->notificationService->sendNotification(
                $this->bookingService->getUserIdByBooking($id),
                'email',
                'Your booking has been canceled.',
                []
            );

            return ['status' => 'success', 'message' => 'Booking canceled successfully'];
        } catch (\Exception $e) {
            $this->logger->error('Failed to cancel booking', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to cancel booking'];
        }
    }

    /**
     * Fetch Booking Logs
     */
    public function getBookingLogs(int $bookingId): array
    {
        AuthMiddleware::validateSession();
        try {
            $logs = $this->bookingService->getBookingLogs($bookingId);
            return ['status' => 'success', 'logs' => $logs];
        } catch (\Exception $e) {
            $this->logger->error('Failed to fetch booking logs', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to fetch booking logs'];
        }
    }

    /**
     * List All Bookings for a User
     */
    public function getUserBookings(int $userId): array
    {
        AuthMiddleware::validateSession();
        try {
            $bookings = $this->bookingService->getUserBookings($userId);
            return ['status' => 'success', 'bookings' => $bookings];
        } catch (\Exception $e) {
            $this->logger->error('Failed to fetch user bookings', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to fetch user bookings'];
        }
    }

    /**
     * Create New Booking
     */
    public function createBooking(array $data): array
    {
        AuthMiddleware::validateSession();
        $rules = [
            'user_id' => 'required|integer',
            'vehicle_id' => 'required|integer',
            'pickup_date' => 'required|date|after_or_equal:today',
            'dropoff_date' => 'required|date|after:pickup_date',
        ];

        if (!$this->validator->validate($data, $rules)) {
            return ['status' => 'error', 'message' => 'Validation failed', 'errors' => $this->validator->errors()];
        }

        try {
            if (!$this->bookingService->isVehicleAvailable($data['vehicle_id'], $data['pickup_date'], $data['dropoff_date'])) {
                return ['status' => 'error', 'message' => 'Vehicle is not available for the selected dates'];
            }

            $bookingId = $this->bookingService->createBooking($data);

            $this->auditService->log(
                'booking_created',
                'New booking created.',
                $data['user_id'],
                $bookingId,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            $this->notificationService->sendNotification(
                $data['user_id'],
                'email',
                'Your booking has been created successfully.',
                []
            );

            return ['status' => 'success', 'message' => 'Booking created successfully', 'booking_id' => $bookingId];
        } catch (\Exception $e) {
            $this->logger->error('Failed to create booking', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to create booking'];
        }
    }
}
=== App/Controllers/NotificationController.php ===
<?php

namespace App\Controllers;

use App\Services\NotificationService;
use App\Services\Validator;
use Psr\Log\LoggerInterface;
use App\Queue\NotificationQueue;

/**
 * Notification Controller
 *
 * Handles notification management, including sending notifications,
 * marking notifications as read, deleting notifications, and
 * fetching user notifications for display.
 */
class NotificationController
{
    private NotificationService $notificationService;
    private Validator $validator;
    private LoggerInterface $logger;
    private NotificationQueue $notificationQueue;

    public function __construct(
        NotificationService $notificationService,
        Validator $validator,
        LoggerInterface $logger,
        NotificationQueue $notificationQueue
    ) {
        $this->notificationService = $notificationService;
        $this->validator = $validator;
        $this->logger = $logger;
        $this->notificationQueue = $notificationQueue;
    }

    /**
     * Display user notifications in the view.
     */
    public function viewNotifications(int $userId): void
    {
        try {
            $notifications = $this->notificationService->getUserNotifications($userId);
            require_once __DIR__ . '/../views/user/notifications.php';
        } catch (\Exception $e) {
            $this->logger->error('Failed to load notifications view', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo 'An error occurred while fetching notifications.';
        }
    }

    /**
     * Fetch all notifications for a user via API.
     */
    public function getUserNotifications(int $userId): array
    {
        try {
            $notifications = $this->notificationService->getUserNotifications($userId);
            return ['status' => 'success', 'notifications' => $notifications];
        } catch (\Exception $e) {
            $this->logger->error('Failed to fetch user notifications', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to fetch user notifications'];
        }
    }

    /**
     * Fetch all notifications for a user via AJAX.
     */
    public function fetchNotificationsAjax(int $userId): void
    {
        try {
            $notifications = $this->notificationService->getUserNotifications($userId);
            echo json_encode(['status' => 'success', 'notifications' => $notifications]);
        } catch (\Exception $e) {
            $this->logger->error('Failed to fetch user notifications via AJAX', ['error' => $e->getMessage()]);
            echo json_encode(['status' => 'error', 'message' => 'Failed to fetch user notifications']);
        }
    }

    /**
     * Mark a notification as read.
     */
    public function markNotificationAsRead(int $notificationId): array
    {
        try {
            $this->notificationService->markAsRead($notificationId);
            $this->logger->info("Notification marked as read", ['notification_id' => $notificationId]);

            return ['status' => 'success', 'message' => 'Notification marked as read'];
        } catch (\Exception $e) {
            $this->logger->error('Failed to mark notification as read', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to mark notification as read'];
        }
    }

    /**
     * Mark a notification as read via POST request.
     */
    public function markNotificationAsReadPost(): void
    {
        $notificationId = $_POST['notification_id'] ?? null;

        if (!$notificationId) {
            echo json_encode(['status' => 'error', 'message' => 'Notification ID is required']);
            return;
        }

        try {
            $this->notificationService->markAsRead((int)$notificationId);
            $this->logger->info("Notification marked as read", ['notification_id' => $notificationId]);
            echo json_encode(['status' => 'success', 'message' => 'Notification marked as read']);
        } catch (\Exception $e) {
            $this->logger->error('Failed to mark notification as read', ['error' => $e->getMessage()]);
            echo json_encode(['status' => 'error', 'message' => 'Failed to mark notification as read']);
        }
    }

    /**
     * Delete a notification.
     */
    public function deleteNotification(int $notificationId): array
    {
        try {
            $this->notificationService->deleteNotification($notificationId);
            $this->logger->info("Notification deleted", ['notification_id' => $notificationId]);

            return ['status' => 'success', 'message' => 'Notification deleted'];
        } catch (\Exception $e) {
            $this->logger->error('Failed to delete notification', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to delete notification'];
        }
    }

    /**
     * Send a notification to a user.
     */
    public function sendNotification(array $data): array
    {
        $rules = [
            'user_id' => 'required|integer',
            'type' => 'required|in:email,sms,webhook,push',
            'message' => 'required|string|max:1000',
            'options' => 'array',
        ];

        if (!$this->validator->validate($data, $rules)) {
            $this->logger->warning('Notification validation failed', ['data' => $data]);
            return ['status' => 'error', 'message' => 'Validation failed', 'errors' => $this->validator->errors()];
        }

        try {
            $success = $this->notificationService->sendNotification(
                $data['user_id'],
                $data['type'],
                $data['message'],
                $data['options'] ?? []
            );

            if ($success) {
                $this->logger->info('Notification sent successfully', ['data' => $data]);
                $this->notificationQueue->queueNotification($data);
                return ['status' => 'success', 'message' => 'Notification sent successfully'];
            }

            return ['status' => 'error', 'message' => 'Notification delivery failed'];
        } catch (\Exception $e) {
            $this->logger->error('Failed to send notification', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to send notification'];
        }
    }

    /**
     * Retry sending a notification.
     */
    public function retryNotification(array $data): array
    {
        $rules = [
            'user_id' => 'required|integer',
            'type' => 'required|in:email,sms,webhook,push',
            'message' => 'required|string|max:1000',
            'options' => 'array',
        ];

        if (!$this->validator->validate($data, $rules)) {
            $this->logger->warning('Retry validation failed', ['data' => $data]);
            return ['status' => 'error', 'message' => 'Validation failed', 'errors' => $this->validator->errors()];
        }

        try {
            $success = $this->notificationService->sendNotificationWithRetry(
                $data['user_id'],
                $data['type'],
                $data['message'],
                $data['options'] ?? []
            );

            if ($success) {
                $this->logger->info('Notification retry succeeded', ['data' => $data]);
                return ['status' => 'success', 'message' => 'Notification sent successfully after retries'];
            }

            return ['status' => 'error', 'message' => 'Notification delivery failed after retries'];
        } catch (\Exception $e) {
            $this->logger->error('Retry failed', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Retry failed'];
        }
    }
}
=== App/Controllers/AuthController.php ===
<?php

namespace App\Controllers;

use App\Services\Auth\TokenService;
use PDO;
use Exception;

class AuthController
{
    protected TokenService $tokenService;
    protected PDO $pdo;

    public function __construct()
    {
        // Load the encryption configuration
        $configPath = __DIR__ . '/../../config/encryption.php';
        if (!file_exists($configPath)) {
            throw new Exception("Encryption configuration missing.");
        }

        $encryptionConfig = require $configPath;

        // Ensure required keys exist
        if (!isset($encryptionConfig['jwt_secret'], $encryptionConfig['jwt_refresh_secret'])) {
            throw new Exception("JWT configuration missing in encryption.php.");
        }

        // Instantiate TokenService
        $this->tokenService = new TokenService(
            $encryptionConfig['jwt_secret'],
            $encryptionConfig['jwt_refresh_secret']
        );

        // Load the database connection
        $dbConfig = require __DIR__ . '/../../config/database.php';
        try {
            $this->pdo = new PDO(
                "mysql:host={$dbConfig['app_database']['host']};dbname={$dbConfig['app_database']['database']};charset=utf8mb4",
                $dbConfig['app_database']['username'],
                $dbConfig['app_database']['password'],
                [PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION]
            );
        } catch (Exception $e) {
            throw new Exception("Database connection failed: " . $e->getMessage());
        }
    }

    /**
     * Show the login page (GET /login)
     */
    public function loginView()
    {
        require __DIR__ . '/../Views/auth/login.php';
    }

    /**
     * Show the register page (GET /register)
     */
    public function registerView()
    {
        require __DIR__ . '/../Views/auth/register.php';
    }

    /**
     * Handle user login (POST /login)
     */
    public function login()
    {
        header('Content-Type: application/json');

        if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
            http_response_code(405);
            echo json_encode(['error' => 'Method Not Allowed']);
            return;
        }

        $email = $_POST['email'] ?? null;
        $password = $_POST['password'] ?? null;

        if (!$email || !$password) {
            http_response_code(400);
            echo json_encode(['error' => 'Email and password are required']);
            return;
        }

        // Fetch user from the database
        $stmt = $this->pdo->prepare("SELECT * FROM users WHERE email = :email LIMIT 1");
        $stmt->execute(['email' => $email]);
        $user = $stmt->fetch(PDO::FETCH_ASSOC);

        if (!$user || !password_verify($password, $user['password'])) {
            http_response_code(401);
            echo json_encode(['error' => 'Invalid credentials']);
            return;
        }

        $token = $this->tokenService->generateToken((object) ['id' => $user['id']]);
        $refreshToken = $this->tokenService->generateRefreshToken((object) ['id' => $user['id']]);

        echo json_encode([
            'access_token' => $token,
            'refresh_token' => $refreshToken
        ]);
    }

    /**
     * Refresh access token (POST /refresh)
     */
    public function refresh()
    {
        header('Content-Type: application/json');

        if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
            http_response_code(405);
            echo json_encode(['error' => 'Method Not Allowed']);
            return;
        }

        $refreshToken = $_POST['refresh_token'] ?? null;

        if (!$refreshToken) {
            http_response_code(400);
            echo json_encode(['error' => 'Refresh token is required']);
            return;
        }

        $newToken = $this->tokenService->refreshAccessToken($refreshToken);

        if ($newToken) {
            echo json_encode(['access_token' => $newToken]);
        } else {
            http_response_code(401);
            echo json_encode(['error' => 'Invalid refresh token']);
        }
    }

    /**
     * Handle user logout (POST /logout)
     */
    public function logout()
    {
        header('Content-Type: application/json');

        if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
            http_response_code(405);
            echo json_encode(['error' => 'Method Not Allowed']);
            return;
        }

        $refreshToken = $_POST['refresh_token'] ?? null;

        if ($refreshToken) {
            $this->tokenService->revokeToken($refreshToken);
        }

        session_destroy();
        echo json_encode(['message' => 'Logged out successfully']);
    }
}
=== App/Controllers/DashboardController.php ===
<?php

namespace App\Controllers;

use App\Services\BookingService;

class DashboardController
{
    private BookingService $bookingService;

    public function __construct(BookingService $bookingService)
    {
        $this->bookingService = $bookingService;
    }

    /**
     * Render user dashboard view
     */
    public function userDashboard()
    {
        require_once __DIR__ . '/../views/dashboard/user_dashboard.php';
    }

    /**
     * Fetch user bookings
     */
    public function getUserBookings(): void
    {
        $userId = $_SESSION['user_id']; // Replace with actual session logic

        try {
            $bookings = $this->bookingService->getUserBookings($userId);
            echo json_encode(['status' => 'success', 'bookings' => $bookings]);
        } catch (\Exception $e) {
            echo json_encode(['status' => 'error', 'message' => $e->getMessage()]);
        }
    }
}
=== App/Controllers/AdminDashboardController.php ===
<?php

namespace App\Controllers;

use App\Services\BookingService;
use App\Services\PaymentService;
use App\Services\UserService;
use Psr\Log\LoggerInterface;

class AdminDashboardController
{
    private BookingService $bookingService;
    private PaymentService $paymentService;
    private UserService $userService;
    private LoggerInterface $logger;

    public function __construct(
        BookingService $bookingService,
        PaymentService $paymentService,
        UserService $userService,
        LoggerInterface $logger
    ) {
        $this->bookingService = $bookingService;
        $this->paymentService = $paymentService;
        $this->userService = $userService;
        $this->logger = $logger;
    }

    /**
     * Render the admin dashboard view.
     */
    public function index(): void
    {
        try {
            $metrics = [
                'total_users' => $this->userService->getTotalUsers(),
                'active_users' => $this->userService->getActiveUsers(),
                'total_bookings' => $this->bookingService->getTotalBookings(),
                'completed_bookings' => $this->bookingService->getCompletedBookings(),
                'canceled_bookings' => $this->bookingService->getCanceledBookings(),
                'total_revenue' => $this->paymentService->getTotalRevenue(),
                'total_refunds' => $this->paymentService->getTotalRefunds(),
                'net_revenue' => $this->paymentService->getNetRevenue(),
            ];

            // Fetch data for graphs
            $graphData = [
                'booking_trends' => $this->bookingService->getMonthlyBookingTrends(),
                'revenue_trends' => $this->paymentService->getMonthlyRevenueTrends(),
            ];

            require_once __DIR__ . '/../views/admin/dashboard.php';
        } catch (\Exception $e) {
            $this->logger->error('Failed to load admin dashboard', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo 'Error loading the dashboard. Please try again later.';
        }
    }

    /**
     * Get data for admin dashboard metrics and graphs (API).
     */
    public function getDashboardData(): void
    {
        try {
            $metrics = [
                'total_users' => $this->userService->getTotalUsers(),
                'active_users' => $this->userService->getActiveUsers(),
                'total_bookings' => $this->bookingService->getTotalBookings(),
                'completed_bookings' => $this->bookingService->getCompletedBookings(),
                'canceled_bookings' => $this->bookingService->getCanceledBookings(),
                'total_revenue' => $this->paymentService->getTotalRevenue(),
                'total_refunds' => $this->paymentService->getTotalRefunds(),
                'net_revenue' => $this->paymentService->getNetRevenue(),
            ];

            $graphData = [
                'booking_trends' => $this->bookingService->getMonthlyBookingTrends(),
                'revenue_trends' => $this->paymentService->getMonthlyRevenueTrends(),
            ];

            echo json_encode([
                'status' => 'success',
                'metrics' => $metrics,
                'graph_data' => $graphData,
            ]);
        } catch (\Exception $e) {
            $this->logger->error('Failed to fetch admin dashboard data', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error', 'message' => 'Failed to fetch dashboard data']);
        }
    }
}
=== App/Controllers/PaymentController.php ===
<?php

namespace App\Controllers;

use App\Services\PaymentService;
use App\Services\Validator;
use App\Services\NotificationService;
use AuditManager\Services\AuditService;
use PDO;
use Psr\Log\LoggerInterface;

/**
 * Payment Controller
 *
 * Handles payment processing, refunds, installment payments, and user transactions.
 */
class PaymentController
{
    private PaymentService $paymentService;
    private Validator $validator;
    private NotificationService $notificationService;
    private AuditService $auditService;
    private PDO $db;
    private LoggerInterface $logger;

    public function __construct(
        PaymentService $paymentService,
        Validator $validator,
        NotificationService $notificationService,
        AuditService $auditService,
        PDO $db,
        LoggerInterface $logger
    ) {
        $this->paymentService = $paymentService;
        $this->validator = $validator;
        $this->notificationService = $notificationService;
        $this->auditService = $auditService;
        $this->db = $db;
        $this->logger = $logger;
    }

    /**
     * Process a payment.
     */
    public function processPayment(array $data): array
    {
        $rules = [
            'user_id' => 'required|integer',
            'amount' => 'required|numeric|min:0.01',
            'payment_method_id' => 'required|integer',
        ];

        if (!$this->validator->validate($data, $rules)) {
            return ['status' => 'error', 'message' => 'Validation failed', 'errors' => $this->validator->errors()];
        }

        try {
            $transaction = $this->paymentService->processPayment(
                $data['user_id'],
                $data['payment_method_id'],
                $data['amount']
            );

            $this->auditService->log(
                'payment_processed',
                'Payment successfully processed.',
                $data['user_id'],
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            $this->notificationService->sendNotification(
                $data['user_id'],
                'email',
                "Payment of {$data['amount']} was successfully processed.",
                ['email' => $transaction['email']]
            );

            return ['status' => 'success', 'transaction' => $transaction];
        } catch (\Exception $e) {
            $this->logger->error('Payment processing failed', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Payment processing failed'];
        }
    }

    /**
     * Refund a payment.
     */
    public function refundPayment(array $data): array
    {
        $rules = [
            'transaction_id' => 'required|integer',
            'amount' => 'required|numeric|min:0.01',
        ];

        if (!$this->validator->validate($data, $rules)) {
            return ['status' => 'error', 'message' => 'Validation failed', 'errors' => $this->validator->errors()];
        }

        try {
            $refund = $this->paymentService->processRefund(
                $data['transaction_id'],
                $data['amount']
            );

            $this->auditService->log(
                'refund_processed',
                'Refund successfully processed.',
                null,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            $this->notificationService->sendNotification(
                $refund['user_id'],
                'email',
                "A refund of {$data['amount']} was processed for your transaction.",
                ['email' => $refund['email']]
            );

            return ['status' => 'success', 'refund' => $refund];
        } catch (\Exception $e) {
            $this->logger->error('Refund processing failed', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Refund processing failed'];
        }
    }

    /**
     * Set up installment payments.
     */
    public function setupInstallment(array $data): array
    {
        $rules = [
            'user_id' => 'required|integer',
            'total_amount' => 'required|numeric|min:0.01',
            'installments' => 'required|integer|min:2',
            'payment_method_id' => 'required|integer',
        ];

        if (!$this->validator->validate($data, $rules)) {
            return ['status' => 'error', 'message' => 'Validation failed', 'errors' => $this->validator->errors()];
        }

        try {
            $installmentPlan = $this->paymentService->createInstallmentPlan(
                $data['user_id'],
                $data['total_amount'],
                $data['installments'],
                $data['payment_method_id']
            );

            $this->auditService->log(
                'installment_plan_created',
                'Installment plan successfully created.',
                $data['user_id'],
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            $this->notificationService->sendNotification(
                $data['user_id'],
                'email',
                "Your installment plan for {$data['total_amount']} has been set up successfully.",
                ['email' => $installmentPlan['email']]
            );

            return ['status' => 'success', 'installment_plan' => $installmentPlan];
        } catch (\Exception $e) {
            $this->logger->error('Installment plan setup failed', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Installment plan setup failed'];
        }
    }

    /**
     * Fetch all user transactions.
     */
    public function getUserTransactions(int $userId): array
    {
        try {
            $transactions = $this->paymentService->getUserTransactions($userId);
            return ['status' => 'success', 'transactions' => $transactions];
        } catch (\Exception $e) {
            $this->logger->error('Failed to fetch user transactions', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to fetch user transactions'];
        }
    }

    /**
     * Fetch payment details.
     */
    public function getPaymentDetails(int $transactionId): array
    {
        try {
            $details = $this->paymentService->getPaymentDetails($transactionId);
            return ['status' => 'success', 'details' => $details];
        } catch (\Exception $e) {
            $this->logger->error('Failed to fetch payment details', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to fetch payment details'];
        }
    }
}
=== App/Controllers/ReportController.php ===
<?php

namespace App\Controllers;

use App\Services\ReportService;
use App\Services\Validator;
use App\Services\NotificationService;
use Psr\Log\LoggerInterface;

class ReportController
{
    private ReportService $reportService;
    private Validator $validator;
    private NotificationService $notificationService;
    private LoggerInterface $logger;

    public function __construct(
        ReportService $reportService,
        Validator $validator,
        NotificationService $notificationService,
        LoggerInterface $logger
    ) {
        $this->reportService = $reportService;
        $this->validator = $validator;
        $this->notificationService = $notificationService;
        $this->logger = $logger;
    }

    /**
     * Admin Report Dashboard View
     */
    public function index()
    {
        try {
            // Render admin report dashboard
            require_once __DIR__ . '/../views/admin/reports.php';
        } catch (\Exception $e) {
            $this->logger->error('Failed to load admin report dashboard', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo 'Failed to load report dashboard.';
        }
    }

    /**
     * Generate Report for Admin
     */
    public function generateReport(array $data): array
    {
        $rules = [
            'report_type' => 'required|in:bookings,payments,users',
            'date_range' => 'required|array',
            'date_range.start' => 'required|date',
            'date_range.end' => 'required|date',
            'filters' => 'array',
            'format' => 'required|in:csv,pdf',
        ];

        if (!$this->validator->validate($data, $rules)) {
            return ['status' => 'error', 'message' => 'Validation failed', 'errors' => $this->validator->errors()];
        }

        try {
            $report = $this->reportService->generateReport(
                $data['report_type'],
                $data['date_range'],
                $data['filters'] ?? [],
                $data['format']
            );

            return ['status' => 'success', 'report' => $report];
        } catch (\Exception $e) {
            $this->logger->error('Failed to generate report', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to generate report'];
        }
    }

    /**
     * User Report Dashboard View
     */
    public function userReports()
    {
        try {
            // Render user report dashboard
            require_once __DIR__ . '/../views/user/reports.php';
        } catch (\Exception $e) {
            $this->logger->error('Failed to load user report dashboard', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo 'Failed to load report dashboard.';
        }
    }

    /**
     * Generate Report for Users
     */
    public function generateUserReport(array $data): array
    {
        $rules = [
            'user_id' => 'required|integer',
            'report_type' => 'required|in:bookings,payments',
            'date_range' => 'required|array',
            'date_range.start' => 'required|date',
            'date_range.end' => 'required|date',
            'format' => 'required|in:csv,pdf',
        ];

        if (!$this->validator->validate($data, $rules)) {
            return ['status' => 'error', 'message' => 'Validation failed', 'errors' => $this->validator->errors()];
        }

        try {
            $report = $this->reportService->generateUserReport(
                $data['user_id'],
                $data['report_type'],
                $data['date_range'],
                $data['format']
            );

            return ['status' => 'success', 'report' => $report];
        } catch (\Exception $e) {
            $this->logger->error('Failed to generate user report', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Failed to generate report'];
        }
    }

    /**
     * Download a Report
     */
    public function downloadReport(string $filePath): void
    {
        try {
            if (!file_exists($filePath)) {
                http_response_code(404);
                echo 'Report not found.';
                return;
            }

            header('Content-Description: File Transfer');
            header('Content-Type: application/octet-stream');
            header('Content-Disposition: attachment; filename=' . basename($filePath));
            header('Expires: 0');
            header('Cache-Control: must-revalidate');
            header('Pragma: public');
            header('Content-Length: ' . filesize($filePath));
            readfile($filePath);
            exit;
        } catch (\Exception $e) {
            $this->logger->error('Failed to download report', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo 'Failed to download report.';
        }
    }
}
