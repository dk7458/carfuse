=== App/Controllers/UserController.php ===
<?php

namespace App\Controllers;

use App\Helpers\ApiHelper;
use App\Helpers\DatabaseHelper;
use App\Services\Validator;
use App\Services\Auth\TokenService;
use App\Services\AuditService;
use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;
use App\Services\Auth\AuthService;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;

/**
 * User Management Controller
 *
 * Handles profile management, password resets, and dashboard access.
 */
class UserController extends Controller
{
    private Validator $validator;
    private TokenService $tokenService;
    protected ExceptionHandler $exceptionHandler;
    protected LoggerInterface $logger;
    private AuthService $authService;
    private AuditService $auditService;

    public function __construct(
        LoggerInterface $logger,
        Validator $validator,
        TokenService $tokenService,
        ExceptionHandler $exceptionHandler,
        AuthService $authService,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->validator = $validator;
        $this->tokenService = $tokenService;
        $this->exceptionHandler = $exceptionHandler;
        $this->authService = $authService;
        $this->auditService = $auditService;
    }

    /**
     * Register a new user.
     */
    public function registerUser(Request $request, Response $response)
    {
        try {
            $data = json_decode($request->getBody()->getContents(), true);
            $this->logger->info("Processing user registration", ['email' => $data['email'] ?? 'not provided']);
            
            // Validate input data
            $rules = [
                'email'    => 'required|email',
                'password' => 'required|min:6',
                'name'     => 'required|string',
            ];
            
            $this->validator->validate($data, $rules);
            
            // Check if email is already in use
            $existingUser = DatabaseHelper::select(
                "SELECT id FROM users WHERE email = ?",
                [$data['email']],
                false // Using application database
            );
            
            if (!empty($existingUser)) {
                return ApiHelper::sendJsonResponse('error', 'Email already in use', [], 400);
            }
            
            // Hash password and prepare user data
            $userData = [
                'email' => $data['email'],
                'name' => $data['name'],
                'password' => password_hash($data['password'], PASSWORD_BCRYPT),
                'created_at' => date('Y-m-d H:i:s'),
                'role' => 'user',
                'status' => 'active'
            ];
            
            // Insert new user using application database
            $userId = DatabaseHelper::insert(
                'users',
                $userData,
                false, // Use application database
                ['operation' => 'user_registration']
            );
            
            // Log the registration in audit logs
            $this->auditService->logEvent(
                'user_registered',
                'User registered successfully',
                ['email' => $data['email']],
                $userId,
                null,
                'user'
            );
            
            $this->logger->info("User registered successfully", [
                'user_id' => $userId,
                'email' => $data['email']
            ]);
            
            return ApiHelper::sendJsonResponse('success', 'User registered successfully', ['user_id' => $userId], 201);
            
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ApiHelper::sendJsonResponse('error', 'Registration failed', [], 500);
        }
    }

    /**
     * Retrieve current user profile.
     */
    public function getUserProfile(Request $request, Response $response)
    {
        try {
            // Get user from TokenService validation
            $user = $this->tokenService->validateRequest($request);
            if (!$user) {
                return ApiHelper::sendJsonResponse('error', 'User not authenticated', [], 401);
            }
            
            $userId = $user['id'];
            $this->logger->info("Fetching user profile", ['user_id' => $userId]);
            
            // Fetch user data with a single optimized query
            $userData = DatabaseHelper::select(
                "SELECT u.id, u.name, u.email, u.created_at, u.role, 
                        u.status, u.last_login, p.bio, p.avatar_url, p.location
                 FROM users u
                 LEFT JOIN user_profiles p ON u.id = p.user_id
                 WHERE u.id = ? AND u.deleted_at IS NULL",
                [$userId],
                false // Using application database
            );
            
            if (empty($userData)) {
                return ApiHelper::sendJsonResponse('error', 'User not found', [], 404);
            }
            
            // Log profile view in audit logs
            $this->auditService->logEvent(
                'profile_viewed',
                'User viewed their profile',
                ['user_id' => $userId],
                $userId,
                null,
                'user'
            );
            
            return ApiHelper::sendJsonResponse('success', 'User profile retrieved', $userData[0], 200);
            
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ApiHelper::sendJsonResponse('error', 'Failed to retrieve profile', [], 500);
        }
    }

    /**
     * Update user profile.
     */
    public function updateProfile(Request $request, Response $response)
    {
        try {
            // Get user from TokenService validation
            $user = $this->tokenService->validateRequest($request);
            if (!$user) {
                return ApiHelper::sendJsonResponse('error', 'User not authenticated', [], 401);
            }
            
            $userId = $user['id'];
            
            $data = json_decode($request->getBody()->getContents(), true);
            $this->logger->info("Updating user profile", ['user_id' => $userId]);
            
            // Validate input data
            $rules = [
                'name'     => 'string|max:100',
                'bio'      => 'string|max:500',
                'location' => 'string|max:100',
                'avatar_url' => 'url|max:255'
            ];
            
            $this->validator->validate($data, $rules);
            
            // Separate user table fields from profile fields
            $userData = array_intersect_key($data, array_flip(['name']));
            $profileData = array_intersect_key($data, array_flip(['bio', 'location', 'avatar_url']));
            
            // Start transaction for updating both tables
            DatabaseHelper::rawQuery(
                "START TRANSACTION",
                [],
                false // Using application database
            );
            
            // Update user main data if needed
            if (!empty($userData)) {
                DatabaseHelper::update(
                    'users',
                    $userData,
                    ['id' => $userId],
                    false, // Using application database
                    ['operation' => 'profile_update', 'user_id' => $userId]
                );
            }
            
            // Update or insert profile data if needed
            if (!empty($profileData)) {
                // Check if profile exists
                $existingProfile = DatabaseHelper::select(
                    "SELECT user_id FROM user_profiles WHERE user_id = ?",
                    [$userId],
                    false // Using application database
                );
                
                if (empty($existingProfile)) {
                    // Create new profile entry
                    $profileData['user_id'] = $userId;
                    $profileData['created_at'] = date('Y-m-d H:i:s');
                    
                    DatabaseHelper::insert(
                        'user_profiles',
                        $profileData,
                        false, // Using application database
                        ['operation' => 'profile_create', 'user_id' => $userId]
                    );
                } else {
                    // Update existing profile
                    $profileData['updated_at'] = date('Y-m-d H:i:s');
                    
                    DatabaseHelper::update(
                        'user_profiles',
                        $profileData,
                        ['user_id' => $userId],
                        false, // Using application database
                        ['operation' => 'profile_update', 'user_id' => $userId]
                    );
                }
            }
            
            // Commit the transaction
            DatabaseHelper::rawQuery(
                "COMMIT",
                [],
                false // Using application database
            );
            
            // Log profile update in audit logs
            $this->auditService->logEvent(
                'profile_updated',
                'User updated their profile',
                [
                    'user_id' => $userId, 
                    'fields_updated' => array_merge(array_keys($userData), array_keys($profileData))
                ],
                $userId,
                null,
                'user'
            );
            
            // Get updated profile
            $updatedProfile = DatabaseHelper::select(
                "SELECT u.id, u.name, u.email, u.role, u.created_at, 
                        p.bio, p.location, p.avatar_url
                 FROM users u
                 LEFT JOIN user_profiles p ON u.id = p.user_id
                 WHERE u.id = ?",
                [$userId],
                false // Using application database
            );
            
            return ApiHelper::sendJsonResponse('success', 'Profile updated successfully', $updatedProfile[0], 200);
            
        } catch (\Exception $e) {
            // Rollback transaction on error
            DatabaseHelper::rawQuery(
                "ROLLBACK",
                [],
                false // Using application database
            );
            
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ApiHelper::sendJsonResponse('error', 'Failed to update profile', [], 500);
        }
    }

    /**
     * Request password reset.
     */
    public function requestPasswordReset(Request $request, Response $response)
    {
        try {
            $data = json_decode($request->getBody()->getContents(), true);
            
            if (!isset($data['email']) || !filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
                return ApiHelper::sendJsonResponse('error', 'Valid email is required', [], 400);
            }
            
            $this->logger->info("Processing password reset request", ['email' => $data['email']]);
            
            // Check if user exists
            $user = DatabaseHelper::select(
                "SELECT id, email FROM users WHERE email = ? AND deleted_at IS NULL",
                [$data['email']],
                false // Using application database
            );
            
            if (empty($user)) {
                // Don't reveal that the email doesn't exist, but log it
                $this->logger->info("Password reset requested for non-existent email", [
                    'email' => $data['email']
                ]);
                return ApiHelper::sendJsonResponse('success', 'If your email is in our system, you will receive reset instructions shortly', [], 200);
            }
            
            // Generate a secure token
            $token = bin2hex(random_bytes(30));
            $expiresAt = date('Y-m-d H:i:s', strtotime('+1 hour'));
            
            // Store token in secure database
            DatabaseHelper::insert(
                'password_resets',
                [
                    'email' => $data['email'],
                    'token' => $token,
                    'expires_at' => $expiresAt,
                    'created_at' => date('Y-m-d H:i:s')
                ],
                true, // Use secure database
                ['operation' => 'password_reset_request', 'user_id' => $user[0]['id']]
            );
            
            // Log password reset request in audit logs
            $this->auditService->logEvent(
                'password_reset_requested',
                'Password reset requested',
                ['email' => $data['email'], 'expires_at' => $expiresAt],
                $user[0]['id'],
                null,
                'user'
            );
            
            return ApiHelper::sendJsonResponse('success', 'Password reset instructions sent to your email', [], 200);
            
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ApiHelper::sendJsonResponse('error', 'Failed to process password reset request', [], 500);
        }
    }

    /**
     * Reset password with token.
     */
    public function resetPassword(Request $request, Response $response)
    {
        try {
            $data = json_decode($request->getBody()->getContents(), true);
            
            // Validate input
            if (!isset($data['token']) || !isset($data['password']) || strlen($data['password']) < 6) {
                return ApiHelper::sendJsonResponse('error', 'Token and password (min 6 chars) required', [], 400);
            }
            
            $this->logger->info("Processing password reset with token");
            
            // Check if token is valid and not expired using secure database
            $resetRequest = DatabaseHelper::select(
                "SELECT email, token, expires_at FROM password_resets 
                 WHERE token = ? AND expires_at > NOW()",
                [$data['token']],
                true // Use secure database
            );
            
            if (empty($resetRequest)) {
                $this->logger->warning("Invalid or expired password reset token used");
                return ApiHelper::sendJsonResponse('error', 'Invalid or expired token', [], 400);
            }
            
            $email = $resetRequest[0]['email'];
            
            // Get user ID
            $user = DatabaseHelper::select(
                "SELECT id FROM users WHERE email = ?",
                [$email]
            );
            
            if (empty($user)) {
                $this->logger->warning("User not found for password reset", ['email' => $email]);
                return ApiHelper::sendJsonResponse('error', 'User not found', [], 404);
            }
            
            $userId = $user[0]['id'];
            
            // Update the password
            $hashedPassword = password_hash($data['password'], PASSWORD_BCRYPT);
            
            DatabaseHelper::update(
                'users',
                [
                    'password' => $hashedPassword,
                    'updated_at' => date('Y-m-d H:i:s')
                ],
                ['id' => $userId],
                false,
                ['operation' => 'password_reset', 'user_id' => $userId]
            );
            
            // Delete the used token using secure database
            DatabaseHelper::delete(
                'password_resets',
                ['token' => $data['token']],
                false,
                true // Use secure database
            );
            
            $this->logger->info("Password reset successful", [
                'user_id' => $userId,
                'email' => $email
            ]);
            
            return ApiHelper::sendJsonResponse('success', 'Password has been reset successfully', [], 200);
            
        } catch (\Exception $e) {
            $this->logger->error("Failed to reset password", [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            return ApiHelper::sendJsonResponse('error', 'Failed to reset password', [], 500);
        }
    }

    /**
     * User dashboard access.
     */
    public function userDashboard(Request $request, Response $response)
    {
        try {
            // Get user from TokenService validation
            $user = $this->tokenService->validateRequest($request);
            if (!$user) {
                return ApiHelper::sendJsonResponse('error', 'User not authenticated', [], 401);
            }
            
            $userId = $user['id'];
            
            $this->logger->info("User accessing dashboard", ['user_id' => $userId]);
            
            // Get user data
            $user = DatabaseHelper::select(
                "SELECT id, name, email, role FROM users WHERE id = ? AND deleted_at IS NULL",
                [$userId]
            );
            
            if (empty($user)) {
                return ApiHelper::sendJsonResponse('error', 'User not found', [], 404);
            }
            
            // Get user's recent activity in a single query
            $userActivity = DatabaseHelper::select(
                "SELECT activity_type, description, created_at 
                 FROM user_activities 
                 WHERE user_id = ? 
                 ORDER BY created_at DESC LIMIT 5",
                [$userId]
            );
            
            // Build dashboard data
            $dashboardData = [
                'user' => $user[0],
                'recent_activity' => $userActivity,
                'account_age_days' => $this->calculateAccountAge($userId)
            ];
            
            // Log dashboard access
            DatabaseHelper::insert(
                'user_activities',
                [
                    'user_id' => $userId,
                    'activity_type' => 'dashboard_access',
                    'description' => 'User accessed their dashboard',
                    'created_at' => date('Y-m-d H:i:s'),
                    'ip_address' => $_SERVER['REMOTE_ADDR'] ?? null
                ]
            );
            
            return ApiHelper::sendJsonResponse('success', 'User Dashboard', $dashboardData, 200);
            
        } catch (\Exception $e) {
            $this->logger->error("Failed to load user dashboard", [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
                'user_id' => $request->getAttribute('user_id') ?? 'unknown'
            ]);
            return ApiHelper::sendJsonResponse('error', 'Failed to load dashboard', [], 500);
        }
    }
    
    /**
     * Calculate user account age in days
     */
    private function calculateAccountAge(int $userId): int
    {
        $creationDate = DatabaseHelper::select(
            "SELECT created_at FROM users WHERE id = ?",
            [$userId]
        );
        
        if (empty($creationDate)) {
            return 0;
        }
        
        $createdTimestamp = strtotime($creationDate[0]['created_at']);
        $currentTimestamp = time();
        return floor(($currentTimestamp - $createdTimestamp) / (60 * 60 * 24));
    }
}
=== App/Controllers/BookingController.php ===
<?php

namespace App\Controllers;

use App\Models\Booking;
use App\Models\RefundLog;
use App\Services\AuthService;
use App\Services\AuditService;
use App\Services\Auth\TokenService;
use App\Helpers\DatabaseHelper;
use App\Helpers\ExceptionHandler;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Log\LoggerInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

/**
 * Booking Controller
 *
 * Handles booking operations, including creating, rescheduling,
 * canceling bookings, and fetching booking details or logs.
 */
class BookingController extends Controller
{
    private BookingService $bookingService;
    private PaymentService $paymentService;
    private Validator $validator;
    private AuditService $auditService;
    private NotificationService $notificationService;
    private ResponseFactoryInterface $responseFactory;
    protected LoggerInterface $logger;
    private TokenService $tokenService;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        BookingService $bookingService,
        PaymentService $paymentService,
        Validator $validator,
        AuditService $auditService,
        NotificationService $notificationService,
        ResponseFactoryInterface $responseFactory,
        TokenService $tokenService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->bookingService = $bookingService;
        $this->paymentService = $paymentService;
        $this->validator = $validator;
        $this->auditService = $auditService;
        $this->notificationService = $notificationService;
        $this->responseFactory = $responseFactory;
        $this->tokenService = $tokenService;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Create standardized PSR-7 JSON response
     */
    protected function jsonResponse(array $data, int $status = 200): ResponseInterface
    {
        $response = $this->responseFactory->createResponse($status);
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    /**
     * View Booking Details
     */
    public function viewBooking(int $id): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $booking = Booking::with('logs')->findOrFail($id);
            
            // Audit log for viewing booking
            $this->auditService->logEvent(
                'booking_viewed',
                "Booking #{$id} details viewed",
                ['booking_id' => $id, 'user_id' => $user['id']],
                $user['id'],
                $id,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking details fetched',
                'data' => ['booking' => $booking]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch booking details'
            ], 500);
        }
    }

    /**
     * Reschedule Booking
     */
    public function rescheduleBooking(int $id): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $data = $_POST; // minimal custom validation assumed
            
            $booking = Booking::findOrFail($id);
            $oldPickup = $booking->pickup_date;
            $oldDropoff = $booking->dropoff_date;
            
            $booking->update([
                'pickup_date'  => $data['pickup_date'],
                'dropoff_date' => $data['dropoff_date'],
            ]);
            
            // Audit the rescheduling action
            $this->auditService->logEvent(
                'booking_rescheduled',
                "Booking #{$id} rescheduled",
                [
                    'booking_id' => $id,
                    'user_id' => $user['id'],
                    'old_pickup' => $oldPickup,
                    'new_pickup' => $data['pickup_date'],
                    'old_dropoff' => $oldDropoff,
                    'new_dropoff' => $data['dropoff_date']
                ],
                $user['id'],
                $id,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking rescheduled successfully'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to reschedule booking'
            ], 500);
        }
    }

    /**
     * Cancel Booking
     */
    public function cancelBooking(int $id): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $booking = Booking::findOrFail($id);
            $oldStatus = $booking->status;
            $booking->update(['status' => 'canceled']);

            // Process refund if applicable.
            $refundAmount = $booking->calculateRefund(); // Assumes a calculateRefund() method exists.
            if ($refundAmount > 0) {
                $refund = RefundLog::create([
                    'booking_id' => $id,
                    'amount'     => $refundAmount,
                    'status'     => 'processed'
                ]);
                
                // Audit the refund processed
                $this->auditService->logEvent(
                    'refund_processed',
                    "Refund processed for booking #{$id}",
                    [
                        'booking_id' => $id,
                        'user_id' => $user['id'],
                        'refund_amount' => $refundAmount,
                        'refund_id' => $refund->id
                    ],
                    $user['id'],
                    $id,
                    'payment'
                );
            }
            
            // Audit the cancellation
            $this->auditService->logEvent(
                'booking_canceled',
                "Booking #{$id} canceled",
                [
                    'booking_id' => $id,
                    'user_id' => $user['id'],
                    'old_status' => $oldStatus,
                    'refund_amount' => $refundAmount ?? 0
                ],
                $user['id'],
                $id,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking canceled successfully'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to cancel booking'
            ], 500);
        }
    }

    /**
     * Fetch Booking Logs
     */
    public function getBookingLogs(int $bookingId): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            // Instead of getting booking logs directly from a logs table,
            // fetch audit events related to this booking from the audit service
            $logs = $this->auditService->getEventsByReference('booking_reference', $bookingId);
            
            // Log this access to audit logs
            $this->auditService->logEvent(
                'booking_logs_viewed',
                "Booking #{$bookingId} logs accessed",
                [
                    'booking_id' => $bookingId,
                    'user_id' => $user['id']
                ],
                $user['id'],
                $bookingId,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking logs fetched successfully',
                'data' => ['logs' => $logs]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch booking logs'
            ], 500);
        }
    }

    /**
     * List All Bookings for a User
     */
    public function getUserBookings(): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $bookings = Booking::where('user_id', $user['id'])->latest()->get();
            
            // Log the fetch operation
            $this->auditService->logEvent(
                'user_bookings_listed',
                "User retrieved their booking list",
                ['user_id' => $user['id']],
                $user['id'],
                null,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'User bookings fetched successfully',
                'data' => ['bookings' => $bookings]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch user bookings'
            ], 500);
        }
    }

    /**
     * Create New Booking
     */
    public function createBooking(): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $data = $_POST; // assuming custom validation is performed elsewhere
            
            // Check vehicle availability using an assumed Booking::isAvailable() scope.
            if (!Booking::isAvailable($data['vehicle_id'], $data['pickup_date'], $data['dropoff_date'])) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Vehicle is not available for the selected dates'
                ], 400);
            }
            
            $booking = Booking::create($data);
            
            // Log the booking creation to the audit logs
            $this->auditService->logEvent(
                'booking_created',
                "New booking #{$booking->id} created",
                [
                    'booking_id' => $booking->id,
                    'user_id' => $user['id'],
                    'vehicle_id' => $data['vehicle_id'],
                    'pickup_date' => $data['pickup_date'], 
                    'dropoff_date' => $data['dropoff_date']
                ],
                $user['id'],
                $booking->id,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking created successfully',
                'data' => ['booking_id' => $booking->id]
            ], 201);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to create booking'
            ], 500);
        }
    }
}
=== App/Controllers/NotificationController.php ===
<?php

namespace App\Controllers;

use App\Models\Notification;
use App\Services\AuthService;
use App\Helpers\JsonResponse;
use App\Helpers\TokenValidator;
use App\Helpers\ExceptionHandler;
use App\Services\AuditService;
use Psr\Log\LoggerInterface;
use Psr\Http\Message\ResponseInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

/**
 * Notification Controller
 *
 * Handles notification management, including sending notifications,
 * marking notifications as read, deleting notifications, and
 * fetching user notifications for display.
 */
class NotificationController extends Controller
{
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;
    private AuditService $auditService;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    /**
     * Display user notifications.
     */
    public function viewNotifications(): ResponseInterface
    {
        try {
            $userId = AuthService::getUserIdFromToken();
            
            $notifications = Notification::with('user')
                ->where('user_id', $userId)
                ->latest()
                ->get();
                
            // Log notification view in audit logs
            $this->auditService->logEvent(
                'notifications_viewed',
                "User viewed their notifications",
                ['user_id' => $userId],
                $userId,
                null,
                'notification'
            );
                
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Notifications loaded',
                'data'    => ['notifications' => $notifications]
            ], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'An error occurred while fetching notifications'
            ], 500);
        }
    }

    /**
     * Fetch all notifications for the authenticated user.
     */
    public function getUserNotifications(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $notifications = Notification::with('user')
                ->where('user_id', $user->id)
                ->latest()
                ->get();
                
            // Log in audit logs
            $this->auditService->logEvent(
                'user_notifications_fetched',
                "User fetched their notifications via API",
                ['user_id' => $user->id],
                $user->id,
                null,
                'notification'
            );
                
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notifications retrieved successfully',
                'data' => ['notifications' => $notifications]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch user notifications'
            ], 500);
        }
    }

    /**
     * Fetch unread notifications via AJAX.
     */
    public function fetchNotificationsAjax(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $notifications = Notification::with('user')
                ->where('user_id', $user->id)
                ->where('is_read', false)
                ->latest()
                ->get();
                
            // Log notification fetch in audit logs
            $this->auditService->logEvent(
                'unread_notifications_fetched',
                "User fetched unread notifications",
                ['user_id' => $user->id, 'count' => $notifications->count()],
                $user->id,
                null,
                'notification'
            );
                
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notifications retrieved successfully',
                'data' => ['notifications' => $notifications]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch notifications'
            ], 500);
        }
    }

    /**
     * Mark a notification as read.
     */
    public function markNotificationAsRead(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $data = $this->validateRequest($_POST, [
                'notification_id' => 'required|integer'
            ]);

            $notification = Notification::findOrFail($data['notification_id']);
            
            // Ensure user owns this notification
            if ($notification->user_id != $user->id) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized'
                ], 403);
            }

            $notification->update(['is_read' => true]);
            
            // Log in audit logs
            $this->auditService->logEvent(
                'notification_marked_as_read',
                "User marked a notification as read",
                ['user_id' => $user->id, 'notification_id' => $data['notification_id']],
                $user->id,
                null,
                'notification'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notification marked as read'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to mark notification as read'
            ], 500);
        }
    }

    /**
     * Delete a notification.
     */
    public function deleteNotification(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $data = $this->validateRequest($_POST, [
                'notification_id' => 'required|integer'
            ]);

            $notification = Notification::findOrFail($data['notification_id']);
            
            // Ensure user owns this notification
            if ($notification->user_id != $user->id) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized'
                ], 403);
            }

            $notification->delete();
            
            // Log in audit logs
            $this->auditService->logEvent(
                'notification_deleted',
                "User deleted a notification",
                ['user_id' => $user->id, 'notification_id' => $data['notification_id']],
                $user->id,
                null,
                'notification'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notification deleted'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to delete notification'
            ], 500);
        }
    }

    /**
     * Send a notification.
     */
    public function sendNotification(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $data = $this->validateRequest($_POST, [
                'user_id' => 'required|integer',
                'type'    => 'required|in:email,sms,webhook,push',
                'message' => 'required|string|max:1000',
                'options' => 'nullable|array',
            ]);

            // Store notification via Eloquent
            $notification = Notification::create([
                'user_id' => $data['user_id'],
                'type'    => $data['type'],
                'message' => $data['message'],
                'sent_at' => date('Y-m-d H:i:s'),
                'is_read' => false,
            ]);
            
            // Log in audit logs
            $this->auditService->logEvent(
                'notification_sent',
                "User sent a notification",
                ['user_id' => $data['user_id'], 'notification_id' => $notification->id],
                $user->id,
                null,
                'notification'
            );
            
            // Optionally dispatch via queue or any external channel here.
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notification sent successfully',
                'data' => ['notification' => $notification]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to send notification'
            ], 500);
        }
    }
}
=== App/Controllers/AdminController.php ===
<?php

namespace App\Controllers;

use App\Services\AdminService;
use App\Services\AuditService;
use App\Services\Auth\TokenService;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

/**
 * AdminController - Handles admin user management and dashboard operations.
 */
class AdminController extends Controller
{
    private AdminService $adminService;
    private ResponseFactoryInterface $responseFactory;
    protected LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        AdminService $adminService,
        ResponseFactoryInterface $responseFactory,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->adminService = $adminService;
        $this->responseFactory = $responseFactory;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Create standardized PSR-7 JSON response
     */
    protected function jsonResponse(array $data, int $status = 200): ResponseInterface
    {
        $response = $this->responseFactory->createResponse($status);
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    /**
     * ✅ Get a paginated list of all users with their roles.
     */
    public function getAllUsers(): ResponseInterface
    {
        try {
            $admin = $this->adminService->validateAdmin($this->request);
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }

            // Get pagination parameters
            $page = (int) ($this->request->getQueryParams()['page'] ?? 1);
            
            $userData = $this->adminService->getAllUsers($page, $admin['id']);
            
            return $this->jsonResponse([
                'status' => 'success', 
                'message' => 'User list retrieved successfully', 
                'data' => $userData
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to retrieve users'], 500);
        }
    }

    /**
     * ✅ Update a user's role.
     */
    public function updateUserRole($userId): ResponseInterface
    {
        try {
            $admin = $this->adminService->validateAdmin($this->request);
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }

            $data = $this->request->getParsedBody();
            $role = $data['role'] ?? '';
            $allowedRoles = ['user', 'admin', 'manager'];
            if (!$role || !in_array($role, $allowedRoles)) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid role'
                ], 400);
            }
            
            $result = $this->adminService->updateUserRole((int)$userId, $role, $admin['id']);
            
            if (!$result) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'User not found'
                ], 404);
            }
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'User role updated successfully'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to update user role'], 500);
        }
    }

    /**
     * ✅ Delete a user (Soft delete).
     */
    public function deleteUser($userId): ResponseInterface
    {
        try {
            $admin = $this->adminService->validateAdmin($this->request);
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }
            
            $result = $this->adminService->deleteUser((int)$userId, $admin['id']);
            
            if ($result === null) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'User not found'
                ], 404);
            }
            
            if (isset($result['error'])) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => $result['error']
                ], 403);
            }
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'User deleted successfully'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to delete user'], 500);
        }
    }

    /**
     * ✅ Fetch admin dashboard statistics.
     */
    public function getDashboardData(): ResponseInterface
    {
        try {
            $admin = $this->adminService->validateAdmin($this->request);
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }
            
            $dashboardData = $this->adminService->getDashboardData($admin['id']);
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Dashboard data retrieved successfully',
                'data' => $dashboardData
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to retrieve dashboard data'], 500);
        }
    }

    /**
     * ✅ Create a new admin user.
     */
    public function createAdmin(): ResponseInterface
    {
        try {
            $admin = $this->adminService->validateAdmin($this->request);
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }

            $data = $this->request->getParsedBody();
            
            // Validate input
            if (!isset($data['name'], $data['email'], $data['password']) ||
                !filter_var($data['email'], FILTER_VALIDATE_EMAIL) ||
                strlen($data['password']) < 8
            ) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid input. Email must be valid and password must be at least 8 characters'
                ], 400);
            }
            
            $newAdmin = $this->adminService->createAdmin($data, $admin['id']);
            
            if (!$newAdmin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Email already in use or failed to create admin'
                ], 400);
            }
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Admin created successfully',
                'data' => $newAdmin
            ], 201);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to create admin user'], 500);
        }
    }
}
=== App/Controllers/AuthController.php ===
<?php

namespace App\Controllers;

use App\Services\Auth\AuthService;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Log\LoggerInterface;
use App\Services\Auth\TokenService;
use App\Helpers\DatabaseHelper;
use App\Services\RateLimiter;
use App\Helpers\ExceptionHandler;

class AuthController extends Controller
{
    protected LoggerInterface $logger;
    private AuthService $authService;
    private TokenService $tokenService;
    private $pdo;
    private RateLimiter $rateLimiter;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        AuthService $authService,
        TokenService $tokenService,
        DatabaseHelper $dbHelper,
        RateLimiter $rateLimiter,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->authService = $authService;
        $this->tokenService = $tokenService;
        $this->pdo = $dbHelper->getPdo();
        $this->rateLimiter = $rateLimiter;
        $this->exceptionHandler = $exceptionHandler;
    }    

    public function login(Request $request, Response $response)
    {
        try {
            // Rewind the request body stream in case it was consumed
            $request->getBody()->rewind();
            
            // Use getParsedBody() for consistency with other endpoints
            $data = $request->getParsedBody();
            
            if (!is_array($data)) {
                $this->logger->error("Parsed body is not an array or is null in login.");
                return $this->jsonResponse($response, ["error" => "Invalid JSON input"], 400);
            }

            $this->logger->debug("Parsed request data in login: " . print_r($data, true));

            if (!isset($data['email']) || !isset($data['password'])) {
                $this->logger->warning("Missing required fields in login");
                return $this->jsonResponse($response, ["error" => "Email and password are required"], 400);
            }

            // Rate Limiting Logic
            $email = $data['email'];
            $ipAddress = $request->getServerParams()['REMOTE_ADDR'] ?? 'UNKNOWN';

        
            if ($this->rateLimiter->isRateLimited($email, $ipAddress, 'login')) {
                $this->logger->warning("Rate limit exceeded for login", ['email' => $email, 'ip' => $ipAddress]);
                return $this->jsonResponse($response, ["error" => "Too many login attempts. Please try again later."], 429);
            }

            $result = $this->authService->login($data);
            $this->logger->info('User login successful', ['email' => $data['email']]);
            
            // Set JWT token as a secure HttpOnly cookie
            setcookie('jwt', $result['token'], [
                'expires'  => time() + 3600,
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            // Set refresh token as a secure HttpOnly cookie with longer expiration
            setcookie('refresh_token', $result['refresh_token'], [
                'expires'  => time() + 604800,
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            // Return success message without exposing tokens in the response body
            return $this->jsonResponse($response, [
                "message" => "Login successful",
                "user_id" => $result['user_id'] ?? null,
                "name" => $result['name'] ?? null
            ]);
            
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Authentication failed"], 401);
        }
    }

    public function register(Request $request, Response $response)
    {
        try {
            // Use getParsedBody() since the parsed body was set in index.php
            $data = $request->getParsedBody();
            
            if (!is_array($data)) {
                $this->logger->error("Parsed body is not an array or is null.");
                return $this->jsonResponse($response, ["error" => "Invalid JSON input"], 400);
            }

            $this->logger->debug("Parsed request data in register: " . print_r($data, true));

            $requiredFields = ['name', 'surname', 'email', 'password'];
            $missingFields = array_diff($requiredFields, array_keys($data));

            if (!empty($missingFields)) {
                $this->logger->warning("Missing required fields in register: " . implode(', ', $missingFields));
                return $this->jsonResponse($response, ["error" => "Missing fields: " . implode(', ', $missingFields)], 400);
            }

            $result = $this->authService->register($data);
            $this->logger->info('User registration attempt', ['data' => $data]);

            return $this->jsonResponse($response, $result);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Registration failed"], 500);
        }
    }

    public function refresh(Request $request, Response $response)
    {
        try {
            // Try to get refresh token from cookie first
            $refreshToken = $_COOKIE['refresh_token'] ?? null;
            
            // If not in cookie, try to get from request body
            if (!$refreshToken) {
                $request->getBody()->rewind();
                $data = $request->getParsedBody();
                $refreshToken = $data['refresh_token'] ?? null;
            }
            
            if (!$refreshToken) {
                $this->logger->warning('Refresh token missing');
                return $this->jsonResponse($response, ["error" => "Refresh token is required"], 400);
            }
            
            $result = $this->authService->refresh(['refresh_token' => $refreshToken]);
            $this->logger->info('Token refreshed successfully');
            
            // Set the new JWT token as a cookie
            setcookie('jwt', $result['token'], [
                'expires'  => time() + 3600,
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            return $this->jsonResponse($response, ["message" => "Token refreshed successfully"]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Token refresh failed"], 401);
        }
    }

    public function logout(Request $request, Response $response)
    {
        try {
            // Clear both JWT and refresh token cookies
            setcookie('jwt', '', [
                'expires'  => time() - 3600, // Expire in the past
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            setcookie('refresh_token', '', [
                'expires'  => time() - 3600, // Expire in the past
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            // Log the logout action
            $this->logger->info('User logged out successfully');
            
            // Call the service logout method if needed (e.g., to revoke tokens server-side)
            $this->authService->logout([]);
            
            return $this->jsonResponse($response, ["message" => "Logout successful"]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Logout failed"], 500);
        }
    }

    /**
     * Get authenticated user details
     * 
     * This endpoint assumes AuthMiddleware is applied to the route.
     * For protected routes, use AuthMiddleware with required=true.
     */
    public function userDetails(Request $request, Response $response): Response
    {
        try {
            $user = $request->getAttribute('user');
            
            if (!$user) {
                $this->logger->error("User not authenticated");
                return $this->jsonResponse($response->withStatus(401), ['error' => 'Authentication required']);
            }
            
            // Remove sensitive fields
            $userDetails = array_diff_key($user, array_flip(['password_hash']));
            
            $this->logger->info("User details retrieved successfully", ['user_id' => $user['id']]);
            return $this->jsonResponse($response, ['user' => $userDetails]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Failed to get user details"], 500);
        }
    }

    public function resetPasswordRequest(Request $request, Response $response)
    {
        try {
            $request->getBody()->rewind();
            $data = $request->getParsedBody();
            
            if (!is_array($data)) {
                $this->logger->error("Invalid JSON input for password reset request");
                return $this->jsonResponse($response, ["error" => "Invalid JSON input"], 400);
            }
            
            if (!isset($data['email'])) {
                $this->logger->warning("Missing email in password reset request");
                return $this->jsonResponse($response, ["error" => "Email is required"], 400);
            }
            
            $result = $this->authService->resetPasswordRequest($data);
            $this->logger->info("Password reset requested", ['email' => $data['email']]);
            return $this->jsonResponse($response, ["message" => "Password reset email sent"]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Password reset request failed"], 500);
        }
    }

    public function resetPassword(Request $request, Response $response)
    {
        try {
            $request->getBody()->rewind();
            $data = $request->getParsedBody();
            
            if (!is_array($data)) {
                $this->logger->error("Invalid JSON input for password reset");
                return $this->jsonResponse($response, ["error" => "Invalid JSON input"], 400);
            }
            
            // Validate required fields
            $requiredFields = ['token', 'password', 'confirm_password'];
            $missingFields = array_diff($requiredFields, array_keys($data));
            
            if (!empty($missingFields)) {
                $this->logger->warning("Missing fields in password reset", ['missing' => $missingFields]);
                return $this->jsonResponse($response, [
                    "error" => "Missing required fields: " . implode(', ', $missingFields)
                ], 400);
            }
            
            // Check if passwords match
            if ($data['password'] !== $data['confirm_password']) {
                $this->logger->warning("Password mismatch in reset");
                return $this->jsonResponse($response, ["error" => "Passwords do not match"], 400);
            }
            
            $result = $this->authService->resetPassword($data);
            $this->logger->info("Password reset completed successfully");
            return $this->jsonResponse($response, ["message" => "Password has been reset successfully"]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Password reset failed"], 500);
        }
    }
}
=== App/Controllers/README.md ===
# Controller Audit Logging Guide

## Overview
This guide explains how to properly log audit events directly from controllers using the `AuditService`. The `AuditTrailMiddleware` is now deprecated and controllers should handle their own audit logging.

## Basic Usage

```php
// Inject AuditService in your controller
private AuditService $auditService;

public function __construct(AuditService $auditService) 
{
    $this->auditService = $auditService;
}

// Example usage in a controller method
public function login(Request $request)
{
    // Process login
    $success = $this->authService->authenticate($request->email, $request->password);
    
    if ($success) {
        // Log successful login
        $this->auditService->logAuthEvent(
            $user->id,
            'login',
            ['device' => $request->userAgent()]
        );
        
        return $this->response->json(['success' => true]);
    } else {
        // Log failed login attempt
        $this->auditService->logAuthEvent(
            0,  // No user ID for failed login
            'failed_login',
            ['email' => $request->email]
        );
        
        return $this->response->json(['error' => 'Invalid credentials'], 401);
    }
}
```

## Common Audit Scenarios

### Authentication Events
```php
// Login
$this->auditService->logAuthEvent($userId, 'login', $context);

// Logout
$this->auditService->logAuthEvent($userId, 'logout', $context);

// Password reset
$this->auditService->logAuthEvent($userId, 'password_reset', $context);
```

### User Actions
```php
// Create user
$this->auditService->logUserAction(
    $adminId,
    'create',
    'user',
    $newUserId,
    ['user_data' => $userData]
);

// Update user
$this->auditService->logUserAction(
    $userId,
    'update',
    'user',
    $userId,
    [
        'before' => $oldData,
        'after' => $newData
    ]
);

// Delete user
$this->auditService->logUserAction($adminId, 'delete', 'user', $deletedUserId);
```

### Booking Events
```php
// Create booking
$this->auditService->logBookingEvent(
    $bookingId,
    'created',
    $userId,
    ['amount' => $amount, 'details' => $bookingDetails]
);

// Update booking
$this->auditService->logBookingEvent(
    $bookingId,
    'updated',
    $userId,
    ['changes' => $changes]
);

// Cancel booking
$this->auditService->logBookingEvent(
    $bookingId,
    'cancelled',
    $userId,
    ['reason' => $reason]
);
```

### API Requests
```php
// In API controllers, after processing
$this->auditService->logApiRequest(
    '/api/v1/resource',
    'POST',
    $request->all(),
    $responseData,
    $statusCode,
    $userId
);
```

### Security Events
```php
// Failed login attempts
$this->auditService->logSecurityEvent(
    'failed_login',
    'Multiple failed login attempts',
    ['attempts' => $attempts, 'email' => $email],
    null
);

// Permission denied
$this->auditService->logSecurityEvent(
    'permission_denied',
    'User attempted to access restricted resource',
    ['resource' => $resource],
    $userId
);
```

## Best Practices

1. Always log at the outcome of an operation, not before it happens
2. Include relevant context but avoid sensitive information
3. Use the appropriate helper method for the type of action
4. For custom events, use the generic `logEvent()` method
5. Keep log messages concise and action-oriented
=== App/Controllers/SignatureController.php ===
<?php

namespace App\Controllers;

use App\Services\SignatureService;
use App\Services\AuditService;
use App\Helpers\TokenValidator;
use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

/**
 * Signature Controller
 *
 * Handles the management of user signatures, including uploading,
 * verifying, and retrieving signatures for documents.
 */
class SignatureController extends Controller
{
    private SignatureService $signatureService;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;
    private AuditService $auditService;

    public function __construct(
        LoggerInterface $logger,
        SignatureService $signatureService,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->signatureService = $signatureService;
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    /**
     * Upload a signature.
     *
     * @param array $data The uploaded signature file and associated metadata.
     * @return array Response indicating success or failure.
     */
    public function uploadSignature(array $data): array
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return ['status' => 'error', 'message' => 'Unauthorized access', 'code' => 401];
            }

            $rules = [
                'user_id' => 'required|integer',
                'file' => 'required|file|mimes:png,jpg,jpeg|max:2048', // Max 2MB
            ];

            $this->validator->validate($data, $rules);

            $signaturePath = $this->signatureService->uploadSignature($data['user_id'], $data['file']);
            
            // Log the signature upload event
            $this->auditService->logEvent(
                'signature_uploaded',
                "Signature uploaded successfully",
                ['user_id' => $data['user_id']],
                $user->id,
                null,
                'document'
            );
            
            return ['status' => 'success', 'message' => 'Signature uploaded successfully', 'data' => $signaturePath];
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ['status' => 'error', 'message' => 'Failed to upload signature', 'code' => 500];
        }
    }

    /**
     * Verify a signature.
     *
     * @param int $userId The ID of the user whose signature is to be verified.
     * @param string $documentHash The hash of the document to verify against the signature.
     * @return array Verification result.
     */
    public function verifySignature(int $userId, string $documentHash): array
    {
        try {
            $isValid = $this->signatureService->verifySignature($userId, $documentHash);
            
            // Log the signature verification attempt
            $this->auditService->logEvent(
                'signature_verified',
                "Signature verification " . ($isValid ? "successful" : "failed"),
                [
                    'user_id' => $userId,
                    'document_hash' => substr($documentHash, 0, 10) . '...',
                    'result' => $isValid ? 'valid' : 'invalid'
                ],
                null, // No authenticated user (system action)
                null,
                'document'
            );

            if ($isValid) {
                return ['status' => 'success', 'message' => 'Signature verified successfully'];
            }

            return ['status' => 'error', 'message' => 'Signature verification failed', 'code' => 400];
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ['status' => 'error', 'message' => 'Failed to verify signature', 'code' => 500];
        }
    }

    /**
     * Retrieve a user's signature.
     *
     * @param int $userId The ID of the user.
     * @return array Response containing the signature path or error message.
     */
    public function getSignature(int $userId): array
    {
        try {
            $requestingUser = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$requestingUser) {
                return ['status' => 'error', 'message' => 'Unauthorized access', 'code' => 401];
            }
            
            $signaturePath = $this->signatureService->getSignature($userId);
            
            // Log the signature retrieval
            $this->auditService->logEvent(
                'signature_retrieved',
                "Signature retrieved " . ($signaturePath ? "successfully" : "failed - not found"),
                [
                    'user_id' => $userId,
                    'requested_by' => $requestingUser->id
                ],
                $requestingUser->id,
                null,
                'document'
            );

            if ($signaturePath) {
                return ['status' => 'success', 'message' => 'Signature retrieved successfully', 'data' => $signaturePath];
            }

            return ['status' => 'error', 'message' => 'Signature not found', 'code' => 404];
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ['status' => 'error', 'message' => 'Failed to retrieve signature', 'code' => 500];
        }
    }
}
=== App/Controllers/DashboardController.php ===
<?php

namespace App\Controllers;

use App\Models\Booking;
use App\Models\Payment;
use App\Models\Notification;
use App\Models\User;
use App\Services\AuditService;
use App\Helpers\ExceptionHandler;
use Illuminate\Support\Facades\Cache;
use Psr\Log\LoggerInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

class DashboardController extends Controller
{
    private BookingService $bookingService;
    private StatisticsService $statisticsService;
    private NotificationService $notificationService;
    private UserService $userService;
    private AuditService $auditService;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        BookingService $bookingService,
        StatisticsService $statisticsService,
        NotificationService $notificationService,
        UserService $userService,
        AuditService $auditService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->bookingService = $bookingService;
        $this->statisticsService = $statisticsService;
        $this->notificationService = $notificationService;
        $this->userService = $userService;
        $this->auditService = $auditService;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Render user dashboard view.
     */
    public function userDashboard()
    {
        try {
            // Assume session_start() is already called.
            $user = (object)['id' => $_SESSION['user_id'] ?? null]; // Replace with native session retrieval
            // ...existing code for eager loading if needed...
            $statistics = Cache::remember('user_dashboard_' . $user->id, 60, function () use ($user) {
                return [
                    'total_bookings'     => Booking::where('user_id', $user->id)->count(),
                    'completed_bookings' => Booking::where('user_id', $user->id)->where('status', 'completed')->count(),
                    'total_payments'     => Payment::where('user_id', $user->id)->sum('amount'),
                ];
            });
            
            // Log dashboard access
            $this->auditService->logEvent(
                'dashboard_accessed',
                "User accessed their dashboard",
                ['user_id' => $user->id],
                $user->id,
                null,
                'user'
            );
            
            view('dashboard/user_dashboard', ['user' => $user, 'statistics' => $statistics]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    /**
     * Fetch user bookings.
     */
    public function getUserBookings(): void
    {
        try {
            $userId = $_SESSION['user_id'] ?? null;
            $bookings = Booking::where('user_id', $userId)->get();
            
            // Log bookings fetch
            $this->auditService->logEvent(
                'bookings_fetched',
                "User fetched their bookings",
                ['user_id' => $userId],
                $userId,
                null,
                'booking'
            );
            
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Bookings fetched',
                'data'    => ['bookings' => $bookings]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    /**
     * Fetch dashboard statistics.
     */
    public function fetchStatistics(): void
    {
        try {
            $userId = $_SESSION['user_id'] ?? null;
            
            $stats = Cache::remember('dashboard_statistics', 60, function () {
                return [
                    'total_bookings'     => Booking::count(),
                    'completed_bookings' => Booking::where('status', 'completed')->count(),
                    'total_revenue'      => Payment::sum('amount')
                ];
            });
            
            // Log statistics fetch
            $this->auditService->logEvent(
                'statistics_fetched',
                "User fetched dashboard statistics",
                ['user_id' => $userId],
                $userId,
                null,
                'user'
            );
            
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Statistics fetched',
                'data'    => $stats
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    /**
     * Fetch user notifications.
     */
    public function fetchNotifications(): void
    {
        try {
            $userId = $_SESSION['user_id'] ?? null;
            
            $notifications = Notification::where('user_id', $userId)
                ->latest()
                ->get();
                
            // Log notifications fetch
            $this->auditService->logEvent(
                'notifications_fetched',
                "User fetched their notifications",
                ['user_id' => $userId],
                $userId,
                null,
                'notification'
            );
            
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Notifications fetched',
                'data'    => ['notifications' => $notifications]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    /**
     * Fetch user profile.
     */
    public function fetchUserProfile(): void
    {
        try {
            $userId = $_SESSION['user_id'] ?? null;
            $profile = User::findOrFail($userId);
            
            // Log profile fetch
            $this->auditService->logEvent(
                'profile_fetched',
                "User fetched their profile",
                ['user_id' => $userId],
                $userId,
                null,
                'user'
            );
            
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'User profile fetched',
                'data'    => ['profile' => $profile]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }
}
=== App/Controllers/update_catch.sh ===
#!/bin/bash

# Define the ExceptionHandler include statement
EXCEPTION_HANDLER_INCLUDE="require_once '/../Helpers/ExceptionHandler.php';"

# Define the output file for constructor exports
CONSTRUCTS_EXPORT="constructs_export.txt"

# Clear the export file before starting
> "$CONSTRUCTS_EXPORT"

# Find all PHP files and process them
find . -type f -name "*.php" | while read -r file; do
    echo "Processing: $file"

    # Check if the file contains a try-catch block
    if grep -q "try\s*{" "$file"; then
        # Replace all try-catch blocks with ExceptionHandler usage
        sed -i -E 's|try\s*\{([^}]*)\}\s*catch\s*\((Exception\s+\$\w+)\)\s*\{([^}]*)\}|try {\1} catch (\2) {\n    ExceptionHandler::handle(\2);\n}|g' "$file"
        
        echo "Updated try-catch blocks in: $file"
    fi

    # Check if the ExceptionHandler is already included
    if ! grep -q "require_once 'path/to/ExceptionHandler.php';" "$file"; then
        # Add ExceptionHandler inclusion at the top of the file
        sed -i "1s|^|$EXCEPTION_HANDLER_INCLUDE\n|" "$file"
        echo "Added ExceptionHandler inclusion to: $file"
    fi

    # Extract and export all constructor methods
    if grep -q "function __construct" "$file"; then
        echo "Extracting constructor from: $file"
        echo -e "\n--- Constructor from $file ---" >> "$CONSTRUCTS_EXPORT"
        awk '/function __construct/,/}/{print}' "$file" >> "$CONSTRUCTS_EXPORT"
    fi
done

echo "✅ All files processed. Constructor exports saved to $CONSTRUCTS_EXPORT."
=== App/Controllers/AdminDashboardController.php ===
<?php

namespace App\Controllers;

use App\Models\User;
use App\Models\Booking;
use App\Models\Payment;
use Illuminate\Support\Facades\Cache;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use App\Services\AuditService;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

class AdminDashboardController extends Controller
{
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;
    private AuditService $auditService;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    public function index(): void
    {
        try {
            $metrics = Cache::remember('dashboard_metrics', 60, function () {
                $totalRevenue = Payment::where('status', 'completed')->sum('amount');
                $totalRefunds = Payment::where('status', 'completed')->where('type', 'refund')->sum('amount');
                return [
                    'total_users'        => User::count(),
                    'active_users'       => User::where('active', true)->count(),
                    'total_bookings'     => Booking::count(),
                    'completed_bookings' => Booking::where('status', 'completed')->count(),
                    'canceled_bookings'  => Booking::where('status', 'canceled')->count(),
                    'total_revenue'      => $totalRevenue,
                    'total_refunds'      => $totalRefunds,
                    'net_revenue'        => $totalRevenue - $totalRefunds,
                ];
            });
            $recentBookings = Booking::with('user')->latest()->limit(5)->get();

            // Log this dashboard view in audit logs
            $this->auditService->logEvent(
                'admin_dashboard_viewed',
                'Admin dashboard viewed',
                ['admin_id' => $_SESSION['user_id'] ?? 'unknown'],
                $_SESSION['user_id'] ?? null,
                null,
                'admin'
            );

            extract(compact('metrics', 'recentBookings'));
            include BASE_PATH . '/public/views/admin/dashboard.php';
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    public function getDashboardData(): void
    {
        try {
            requireAuth(); // ensure admin authentication is in place
            
            $metrics = Cache::remember('dashboard_metrics', 60, function () {
                $totalRevenue = Payment::where('status', 'completed')->sum('amount');
                $totalRefunds = Payment::where('status', 'completed')->where('type', 'refund')->sum('amount');
                return [
                    'total_users'        => User::count(),
                    'active_users'       => User::where('active', true)->count(),
                    'total_bookings'     => Booking::count(),
                    'completed_bookings' => Booking::where('status', 'completed')->count(),
                    'canceled_bookings'  => Booking::where('status', 'canceled')->count(),
                    'total_revenue'      => $totalRevenue,
                    'total_refunds'      => $totalRefunds,
                    'net_revenue'        => $totalRevenue - $totalRefunds,
                ];
            });
            $recentBookings = Booking::with('user')->latest()->limit(5)->get();

            // Log this API request in audit logs
            $this->auditService->logEvent(
                'admin_dashboard_data_api',
                'Admin dashboard data API requested',
                ['admin_id' => $_SESSION['user_id'] ?? 'unknown'],
                $_SESSION['user_id'] ?? null,
                null,
                'admin'
            );

            header('Content-Type: application/json');
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Dashboard data fetched',
                'data'    => [
                    'metrics'         => $metrics,
                    'recent_bookings' => $recentBookings,
                ]
            ]);
            exit;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }
}
=== App/Controllers/PaymentController.php ===
<?php

namespace App\Controllers;

use App\Models\Payment;
use App\Models\RefundLog;
use App\Models\TransactionLog;
use App\Models\InstallmentPlan;
use App\Services\AuditService;
use App\Helpers\TokenValidator;
use App\Helpers\ExceptionHandler;
use App\Helpers\DatabaseHelper;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Log\LoggerInterface;

/**
 * Payment Controller
 *
 * Handles payment processing, refunds, installment payments, and user transactions.
 */
class PaymentController extends Controller
{
    private PaymentService $paymentService;
    private Validator $validator;
    private NotificationService $notificationService;
    private AuditService $auditService;
    private ResponseFactoryInterface $responseFactory;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        PaymentService $paymentService,
        Validator $validator,
        NotificationService $notificationService,
        AuditService $auditService,
        ResponseFactoryInterface $responseFactory,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->paymentService = $paymentService;
        $this->validator = $validator;
        $this->notificationService = $notificationService;
        $this->auditService = $auditService;
        $this->responseFactory = $responseFactory;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Create standardized PSR-7 JSON response
     */
    protected function jsonResponse(array $data, int $status = 200): ResponseInterface
    {
        $response = $this->responseFactory->createResponse($status);
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    /**
     * Process a payment.
     */
    public function processPayment(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $data = $this->validateRequest($_POST, [
                'booking_id'       => 'required|integer',
                'amount'           => 'required|numeric|min:0.01',
                'payment_method_id' => 'required|integer',
            ]);
            
            $payment = Payment::create([
                'booking_id'     => $data['booking_id'],
                'user_id'        => $user->id,
                'amount'         => $data['amount'],
                'payment_method' => $data['payment_method_id'],
                'status'         => 'completed'
            ]);
            
            // Update related booking status via Eloquent relationship
            $payment->booking()->update(['status' => 'paid']);
            
            // Log the payment in the secure audit logs
            $this->auditService->logEvent(
                'payment_processed',
                "Payment of {$data['amount']} processed for booking #{$data['booking_id']}",
                [
                    'payment_id' => $payment->id,
                    'booking_id' => $data['booking_id'],
                    'user_id' => $user->id,
                    'amount' => $data['amount'],
                    'payment_method' => $data['payment_method_id']
                ],
                $user->id,
                $data['booking_id'],
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Payment processed',
                'data'    => ['payment' => $payment]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Payment processing failed'
            ], 500);
        }
    }

    /**
     * Refund a payment.
     */
    public function refundPayment(): ResponseInterface
    {
        try {
            $admin = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$admin || !$admin->isAdmin()) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized - admin rights required'
                ], 401);
            }
            
            $data = $this->validateRequest($_POST, [
                'transaction_id' => 'required|integer',
                'amount'         => 'required|numeric|min:0.01',
            ]);
            
            // Get the original transaction
            $transaction = TransactionLog::findOrFail($data['transaction_id']);
            
            $refund = RefundLog::create([
                'transaction_id' => $data['transaction_id'],
                'amount'         => $data['amount'],
                'status'         => 'processed'
            ]);
            
            // Log the refund in the secure audit logs
            $this->auditService->logEvent(
                'refund_processed',
                "Refund of {$data['amount']} processed for transaction #{$data['transaction_id']}",
                [
                    'refund_id' => $refund->id,
                    'transaction_id' => $data['transaction_id'],
                    'booking_id' => $transaction->booking_id,
                    'user_id' => $transaction->user_id,
                    'admin_id' => $admin->id,
                    'amount' => $data['amount']
                ],
                $admin->id,
                $transaction->booking_id,
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Refund processed',
                'data'    => ['refund' => $refund]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Refund processing failed'
            ], 500);
        }
    }

    /**
     * Set up installment payments.
     */
    public function setupInstallment(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $data = $this->validateRequest($_POST, [
                'total_amount'      => 'required|numeric|min:0.01',
                'installments'      => 'required|integer|min:2',
                'payment_method_id' => 'required|integer',
                'booking_id'        => 'required|integer',
            ]);
            
            $plan = InstallmentPlan::create([
                'user_id'        => $user->id,
                'booking_id'     => $data['booking_id'],
                'total_amount'   => $data['total_amount'],
                'installments'   => $data['installments'],
                'payment_method' => $data['payment_method_id'],
            ]);
            
            // Log the installment plan creation
            $this->auditService->logEvent(
                'installment_plan_created',
                "Installment plan created for user #{$user->id} with {$data['installments']} installments",
                [
                    'plan_id' => $plan->id,
                    'user_id' => $user->id,
                    'booking_id' => $data['booking_id'],
                    'total_amount' => $data['total_amount'],
                    'installments' => $data['installments']
                ],
                $user->id,
                $data['booking_id'],
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Installment plan created',
                'data'    => ['installment_plan' => $plan]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Installment plan setup failed'
            ], 500);
        }
    }

    /**
     * Fetch all user transactions.
     */
    public function getUserTransactions(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $transactions = TransactionLog::with(['payment', 'booking'])
                ->where('user_id', $user->id)
                ->latest()
                ->get();
            
            // Log the transaction view activity
            $this->auditService->logEvent(
                'transactions_viewed',
                "User viewed their transaction history",
                ['user_id' => $user->id],
                $user->id,
                null,
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Transactions fetched',
                'data'    => ['transactions' => $transactions]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to fetch user transactions'
            ], 500);
        }
    }

    /**
     * Fetch payment details.
     */
    public function getPaymentDetails(int $transactionId): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $details = TransactionLog::findOrFail($transactionId);
            
            // Verify the user owns this transaction or is an admin
            if ($details->user_id != $user->id && !$user->isAdmin()) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'You do not have permission to view this transaction'
                ], 403);
            }
            
            // Log the access to payment details
            $this->auditService->logEvent(
                'payment_details_viewed',
                "Payment details accessed for transaction #{$transactionId}",
                [
                    'transaction_id' => $transactionId,
                    'user_id' => $user->id,
                    'is_admin' => $user->isAdmin() ? 'yes' : 'no'
                ],
                $user->id,
                $details->booking_id ?? null,
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Payment details fetched',
                'data'    => ['details' => $details]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to fetch payment details'
            ], 500);
        }
    }

    /**
     * Process payment for an installment.
     */
    public function processInstallmentPayment(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $data = $this->validateRequest($_POST, [
                'installment_id'    => 'required|integer',
                'payment_method_id' => 'required|integer',
            ]);
            
            // Get the installment details using DatabaseHelper
            $installment = DatabaseHelper::select(
                "SELECT * FROM installments WHERE id = ? AND user_id = ?",
                [(int)$data['installment_id'], $user->id],
                false // Using application database
            );
            
            if (empty($installment)) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Installment not found or does not belong to you'
                ], 404);
            }
            
            $installmentData = $installment[0];
            
            // Process payment for this specific installment
            $payment = Payment::create([
                'user_id'        => $user->id,
                'booking_id'     => $installmentData['booking_id'],
                'installment_id' => $data['installment_id'],
                'amount'         => $installmentData['amount'],
                'payment_method' => $data['payment_method_id'],
                'status'         => 'completed',
            ]);
            
            // Update installment status
            DatabaseHelper::update(
                "installments",
                ["status" => "paid", "paid_at" => date('Y-m-d H:i:s')],
                ["id" => (int)$data['installment_id']],
                false // Using application database
            );
            
            // Log the payment in audit logs
            $this->auditService->logEvent(
                'installment_payment_processed',
                "Installment payment processed",
                [
                    'user_id' => $user->id,
                    'installment_id' => $data['installment_id'],
                    'payment_id' => $payment->id,
                    'amount' => $installmentData['amount']
                ],
                $user->id,
                $installmentData['booking_id'],
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Installment payment processed successfully',
                'data'    => ['payment' => $payment]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to process installment payment'
            ], 500);
        }
    }

    /**
     * Add a payment method.
     */
    public function addPaymentMethod(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $data = $this->validateRequest($_POST, [
                'type'        => 'required|string',
                'card_last4'  => 'required_if:type,credit_card|numeric',
                'card_brand'  => 'required_if:type,credit_card|string',
                'expiry_date' => 'required_if:type,credit_card|string',
                'is_default'  => 'nullable|boolean',
            ]);
            
            // Add payment method using DatabaseHelper for secure storage
            $paymentMethodId = DatabaseHelper::insert(
                "payment_methods",
                [
                    "user_id" => $user->id,
                    "type" => $data['type'],
                    "card_last4" => $data['card_last4'] ?? null,
                    "card_brand" => $data['card_brand'] ?? null,
                    "expiry_date" => $data['expiry_date'] ?? null,
                    "is_default" => $data['is_default'] ?? false,
                    "created_at" => date('Y-m-d H:i:s')
                ],
                true // Using secure database for payment details
            );
            
            if (!$paymentMethodId) {
                throw new \RuntimeException("Failed to add payment method");
            }
            
            // If this is set as default, update other methods to non-default
            if (!empty($data['is_default']) && $data['is_default']) {
                DatabaseHelper::execute(
                    "UPDATE payment_methods SET is_default = 0 WHERE user_id = ? AND id != ?",
                    [$user->id, $paymentMethodId],
                    true // Using secure database
                );
            }
            
            // Get the newly created payment method
            $paymentMethod = DatabaseHelper::select(
                "SELECT id, type, card_brand, card_last4, expiry_date, is_default 
                 FROM payment_methods 
                 WHERE id = ?",
                [$paymentMethodId],
                true // Using secure database
            )[0];
            
            // Log in audit logs
            $this->auditService->logEvent(
                'payment_method_added',
                "User added a payment method",
                [
                    'user_id' => $user->id,
                    'payment_method_id' => $paymentMethodId,
                    'type' => $data['type']
                ],
                $user->id,
                null,
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Payment method added successfully',
                'data'    => ['payment_method' => $paymentMethod]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to add payment method'
            ], 500);
        }
    }
    
    /**
     * Get all payment methods for a user.
     */
    public function getUserPaymentMethods(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            // Fetch payment methods using DatabaseHelper from secure database
            $paymentMethods = DatabaseHelper::select(
                "SELECT id, type, card_brand, card_last4, expiry_date, is_default 
                 FROM payment_methods 
                 WHERE user_id = ? AND deleted_at IS NULL",
                [$user->id],
                true // Using secure database
            );
            
            // Log in audit logs
            $this->auditService->logEvent(
                'payment_methods_viewed',
                "User viewed their payment methods",
                ['user_id' => $user->id],
                $user->id,
                null,
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Payment methods retrieved successfully',
                'data'    => ['payment_methods' => $paymentMethods]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to retrieve payment methods'
            ], 500);
        }
    }
}
=== App/Controllers/Controller.php ===
<?php

namespace App\Controllers;

use Exception;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use Psr\Http\Message\ResponseInterface as Response;

/**
 * Base Controller - Provides shared methods for all controllers.
 */
class Controller
{
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(LoggerInterface $logger, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * ✅ Standard JSON Response
     */
    protected function jsonResponse(Response $response, $data, $status = 200)
    {
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json')->withStatus($status);
    }

    /**
     * ✅ Error Response
     */
    protected function errorResponse(Response $response, $message, $status = 400)
    {
        return $this->jsonResponse($response, ['error' => $message], $status);
    }

    /**
     * ✅ Handle Exceptions & Log Errors
     * This method is for backward compatibility, new controllers should use ExceptionHandler
     */
    protected function handleException(Exception $e, string $context = 'General Error'): void
    {
        if ($this->exceptionHandler) {
            $this->exceptionHandler->handleException($e);
        } else {
            // Legacy fallback behavior
            $this->logger->error("{$context}: " . $e->getMessage());
            $this->jsonResponse(['status' => 'error', 'message' => 'An error occurred.'], 500);
        }
    }

    /**
     * ✅ Input Validation Helper
     */
    protected function validateRequest(array $data, array $rules): array
    {
        $errors = [];

        foreach ($rules as $field => $rule) {
            $value = $data[$field] ?? null;

            if (strpos($rule, 'required') !== false && empty($value)) {
                $errors[$field] = "{$field} is required.";
            }

            if (strpos($rule, 'integer') !== false && !filter_var($value, FILTER_VALIDATE_INT)) {
                $errors[$field] = "{$field} must be an integer.";
            }

            if (strpos($rule, 'email') !== false && !filter_var($value, FILTER_VALIDATE_EMAIL)) {
                $errors[$field] = "{$field} must be a valid email.";
            }
        }

        if (!empty($errors)) {
            if ($this->exceptionHandler) {
                throw new \InvalidArgumentException(json_encode(['validation' => $errors]));
            } else {
                // Legacy fallback behavior
                $this->jsonResponse(['status' => 'error', 'message' => 'Validation failed', 'errors' => $errors], 422);
            }
        }

        return $data;
    }
}
=== App/Controllers/DocumentController.php ===
<?php

namespace App\Controllers;

use App\Services\DocumentService;
use App\Services\EncryptionService;
use App\Services\FileStorage;
use App\Services\Validator;
use App\Services\AuditService;
use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;
use App\Models\DocumentTemplate;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

class DocumentController extends Controller
{
    private DocumentService $documentService;
    private Validator $validator;
    private AuditService $auditService;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        DocumentService $documentService,
        Validator $validator,
        AuditService $auditService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->documentService = $documentService;
        $this->validator = $validator;
        $this->auditService = $auditService;
        $this->exceptionHandler = $exceptionHandler;
    }
    
    /**
     * Upload a document template.
     */
    public function uploadTemplate(array $data): array
    {
        try {
            $rules = [
                'name' => 'required|string|max:255',
                'file' => 'required|file|mimes:pdf,docx|max:10240', // Max 10MB
            ];

            if (!$this->validator->validate($data, $rules)) {
                return $this->jsonResponse('error', ['message' => 'Validation failed', 'errors' => $this->validator->errors()], 400);
            }

            // Store file using FileStorage service
            $filePath = FileStorage::store($data['file']);
            // Create a new template using Eloquent ORM
            $template = DocumentTemplate::create([
                'name' => $data['name'],
                'file_path' => $filePath,
            ]);
            
            // Log document creation using unified audit service
            $this->auditService->logEvent(
                'document_template_uploaded', 
                "Template uploaded successfully", 
                ['template_id' => $template->id, 'template_name' => $data['name']],
                $_SESSION['user_id'] ?? null,
                null,
                'document'
            );
            
            return $this->jsonResponse('success', ['message' => 'Template uploaded successfully', 'template_id' => $template->id], 201);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', ['message' => 'Failed to upload template'], 500);
        }
    }

    /**
     * Generate a contract for a booking.
     */
    public function generateContract(int $bookingId, int $userId): array
    {
        try {
            // Use a secure contract generation method ensuring encryption is applied
            $contractPath = $this->documentService->generateContractSecure($bookingId, $userId);
            
            // Log the contract generation using unified audit service
            $this->auditService->logEvent(
                'contract_generated',
                "Contract generated successfully",
                ['contract_type' => 'booking', 'booking_id' => $bookingId], 
                $userId,
                $bookingId,
                'document'
            );
            
            return $this->jsonResponse('success', ['message' => 'Contract generated successfully', 'contract_path' => $contractPath], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', ['message' => 'Failed to generate contract'], 500);
        }
    }

    /**
     * Upload and manage the Terms & Conditions document.
     */
    public function uploadTerms(array $data): array
    {
        try {
            $rules = [
                'file' => 'required|file|mimes:pdf|max:5120', // Max 5MB
            ];

            if (!$this->validator->validate($data, $rules)) {
                return $this->jsonResponse('error', ['message' => 'Validation failed', 'errors' => $this->validator->errors()], 400);
            }

            $path = $this->documentService->uploadTerms($data['file']);
            
            // Log using the unified audit service
            $this->auditService->logEvent(
                'terms_uploaded',
                "Terms and Conditions document uploaded",
                ['document_type' => 'terms_conditions', 'path' => $path],
                $_SESSION['user_id'] ?? null,
                null,
                'document'
            );

            return $this->jsonResponse('success', ['message' => 'T&C document uploaded successfully'], 201);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', ['message' => 'Failed to upload T&C document'], 500);
        }
    }

    /**
     * Generate an invoice for a booking.
     */
    public function generateInvoice(int $bookingId): array
    {
        try {
            $invoicePath = $this->documentService->generateInvoice($bookingId);
            
            // Log using the unified audit service
            $this->auditService->logEvent(
                'invoice_generated',
                "Invoice generated successfully",
                ['document_type' => 'invoice', 'booking_id' => $bookingId],
                $_SESSION['user_id'] ?? null,
                $bookingId,
                'document'
            );

            return $this->jsonResponse('success', ['message' => 'Invoice generated successfully', 'invoice_path' => $invoicePath], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', ['message' => 'Failed to generate invoice'], 500);
        }
    }

    /**
     * Delete a document (template or user-specific).
     */
    public function deleteDocument(int $documentId): array
    {
        try {
            $this->documentService->deleteDocument($documentId);
            
            // Log using the unified audit service
            $this->auditService->logEvent(
                'document_deleted',
                "Document deleted successfully",
                ['document_id' => $documentId],
                $_SESSION['user_id'] ?? null,
                null,
                'document'
            );

            return $this->jsonResponse('success', ['message' => 'Document deleted successfully'], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', ['message' => 'Failed to delete document'], 500);
        }
    }
}
=== App/Controllers/ReportController.php ===
<?php

namespace App\Controllers;

use App\Models\Booking;
use App\Models\Payment;
use App\Models\User;
use App\Services\AuditService;
use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;

class ReportController extends Controller
{
    private ReportService $reportService;
    private NotificationService $notificationService;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;
    private AuditService $auditService;

    public function __construct(
        LoggerInterface $logger,
        ReportService $reportService,
        NotificationService $notificationService,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->reportService = $reportService;
        $this->notificationService = $notificationService;
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    /**
     * Admin Report Dashboard View
     */
    public function index()
    {
        try {
            // Log the dashboard access in audit logs
            $this->auditService->logEvent(
                'report_dashboard_accessed',
                'Admin report dashboard accessed',
                ['user_id' => $_SESSION['user_id'] ?? 'unknown'],
                $_SESSION['user_id'] ?? null,
                null,
                'report'
            );
            
            $data = ['view' => 'admin/reports'];
            http_response_code(200);
            echo json_encode(['status' => 'success', 'message' => 'Report dashboard loaded', 'data' => $data]);
            exit;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
        }
    }

    /**
     * Generate Report for Admin using Eloquent ORM.
     */
    public function generateReport()
    {
        try {
            // Replace Request validation with native PHP validation
            $validated = $_POST; // Assumes JSON-decoded input or form data

            $start      = $validated['date_range']['start'] ?? null;
            $end        = $validated['date_range']['end'] ?? null;
            $format     = $validated['format'] ?? null;
            $reportType = $validated['report_type'] ?? null;
            $userId     = $_SESSION['user_id'] ?? null;

            if (!$start || !$end || !$format || !$reportType) {
                http_response_code(400);
                echo json_encode(['status' => 'error', 'message' => 'Missing required parameters']);
                exit;
            }

            switch ($reportType) {
                case 'bookings':
                    $data = Booking::with(['user', 'vehicle'])
                        ->whereBetween('created_at', [$start, $end])
                        ->get()
                        ->toArray();
                    break;
                case 'payments':
                    $data = Payment::whereBetween('created_at', [$start, $end])
                        ->get()
                        ->toArray();
                    break;
                case 'users':
                    $data = User::whereBetween('created_at', [$start, $end])
                        ->get()
                        ->toArray();
                    break;
                default:
                    http_response_code(400);
                    echo json_encode(['status' => 'error', 'message' => 'Invalid report type']);
                    exit;
            }
            
            // Log report generation in audit logs
            $this->auditService->logEvent(
                'report_generated',
                "Admin generated {$reportType} report",
                [
                    'report_type' => $reportType,
                    'format' => $format,
                    'date_range' => ['start' => $start, 'end' => $end]
                ],
                $userId,
                null,
                'report'
            );

            $filename = "{$reportType}_report_" . date('YmdHis');
            if ($format === 'csv') {
                // Assuming Excel::download now returns file content in native PHP
                return Excel::download(new \App\Exports\ReportExport($data), $filename . ".csv");
            } elseif ($format === 'pdf') {
                $pdf = PDF::loadView('reports.template', ['data' => $data]);
                return $pdf->download($filename . ".pdf");
            } else {
                http_response_code(400);
                echo json_encode(['status' => 'error', 'message' => 'Unsupported format']);
                exit;
            }
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
        }
    }

    /**
     * User Report Dashboard View
     */
    public function userReports()
    {
        try {
            $data = ['view' => 'user/reports'];
            http_response_code(200);
            echo json_encode(['status' => 'success', 'message' => 'User report dashboard loaded', 'data' => $data]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
        }
    }

    /**
     * Generate Report for a User using Eloquent ORM.
     */
    public function generateUserReport()
    {
        try {
            $validated = $_POST;
            $userId     = $validated['user_id'] ?? null;
            $start      = $validated['date_range']['start'] ?? null;
            $end        = $validated['date_range']['end'] ?? null;
            $format     = $validated['format'] ?? null;
            $reportType = $validated['report_type'] ?? null;

            if (!$userId || !$start || !$end || !$format || !$reportType) {
                http_response_code(400);
                echo json_encode(['status' => 'error', 'message' => 'Missing required parameters']);
                exit;
            }

            switch ($reportType) {
                case 'bookings':
                    $data = Booking::with(['user', 'vehicle'])
                        ->where('user_reference', $userId)
                        ->whereBetween('created_at', [$start, $end])
                        ->get()
                        ->toArray();
                    break;
                case 'payments':
                    $data = Payment::where('user_id', $userId)
                        ->whereBetween('created_at', [$start, $end])
                        ->get()
                        ->toArray();
                    break;
                default:
                    http_response_code(400);
                    echo json_encode(['status' => 'error', 'message' => 'Invalid report type']);
                    exit;
            }

            $filename = "user_{$userId}_{$reportType}_report_" . date('YmdHis');
            if ($format === 'csv') {
                return Excel::download(new \App\Exports\ReportExport($data), $filename . ".csv");
            } elseif ($format === 'pdf') {
                $pdf = PDF::loadView('reports.template', ['data' => $data]);
                return $pdf->download($filename . ".pdf");
            } else {
                http_response_code(400);
                echo json_encode(['status' => 'error', 'message' => 'Unsupported format']);
                exit;
            }
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
        }
    }

    /**
     * Download a Report
     */
    public function downloadReport(string $filePath): void
    {
        try {
            if (!file_exists($filePath)) {
                http_response_code(404);
                echo json_encode(['status' => 'error', 'message' => 'Report not found', 'data' => []]);
                return;
            }

            header('Content-Description: File Transfer');
            header('Content-Type: application/octet-stream');
            header('Content-Disposition: attachment; filename=' . basename($filePath));
            header('Expires: 0');
            header('Cache-Control: must-revalidate');
            header('Pragma: public');
            header('Content-Length: ' . filesize($filePath));
            readfile($filePath);
            exit;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
        }
    }
}
=== App/Controllers/ApiController.php ===
<?php

namespace App\Controllers;

use App\Helpers\ExceptionHandler;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Log\LoggerInterface;
use App\Services\AuditService;

/**
 * Base API Controller
 * 
 * Provides common functionality for all API controllers including
 * standardized JSON responses, error handling, and shared utilities.
 */
class ApiController extends Controller
{
    protected ResponseFactoryInterface $responseFactory;
    protected ExceptionHandler $exceptionHandler;
    protected AuditService $auditService;
    
    /**
     * Constructor
     */
    public function __construct(
        LoggerInterface $logger,
        ResponseFactoryInterface $responseFactory,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->responseFactory = $responseFactory;
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    /**
     * Create standardized PSR-7 JSON response
     */
    protected function jsonResponse(array $data, int $status = 200): ResponseInterface
    {
        $response = $this->responseFactory->createResponse($status);
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    /**
     * Create a success response
     */
    protected function success($message, $data = [], int $status = 200): ResponseInterface
    {
        return $this->jsonResponse([
            'status' => 'success',
            'message' => $message,
            'data' => $data
        ], $status);
    }

    /**
     * Create an error response
     */
    protected function error($message, $errors = [], int $status = 400): ResponseInterface
    {
        return $this->jsonResponse([
            'status' => 'error',
            'message' => $message,
            'errors' => $errors
        ], $status);
    }

    /**
     * Safe handling of exceptions in API controllers
     */
    protected function safeExecute(callable $action): ResponseInterface
    {
        try {
            return $action();
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // This line won't be reached if the exception handler exits
            return $this->error('An unexpected error occurred', [], 500);
        }
    }

    /**
     * Log audit event with proper context
     */
    protected function logAuditEvent(
        string $eventType,
        string $message,
        array $context = [],
        ?int $userId = null,
        ?int $resourceId = null,
        string $category = 'api'
    ): void {
        $this->auditService->logEvent(
            $eventType,
            $message,
            $context,
            $userId,
            $resourceId,
            $category
        );
    }
}
=== App/Controllers/AuditController.php ===
<?php

namespace App\Controllers;

use App\Services\AuditService;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

/**
 * AuditController - Handles viewing and retrieving audit logs.
 */
class AuditController extends Controller
{
    protected LoggerInterface $logger;
    private AuditService $auditService;
    protected ExceptionHandler $exceptionHandler;
    
    /**
     * Constructor with dependency injection
     */
    public function __construct(
        LoggerInterface $logger, 
        AuditService $auditService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->auditService = $auditService;
        $this->exceptionHandler = $exceptionHandler;
    }
    
    /**
     * ✅ Get audit logs data for admin dashboard
     */
    public function index()
    {
        try {
            // Check if user has admin role
            if (!$this->hasAdminAccess()) {
                return $this->jsonResponse('error', 'Admin access required', 403);
            }
            
            // Process filters from request
            $filters = $this->processFilters($_POST);
            
            // Get logs using the audit service
            $logs = $this->auditService->getLogs($filters);
            
            return $this->jsonResponse('success', ['logs' => $logs], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', 'Failed to retrieve audit logs', 500);
        }
    }

    /**
     * ✅ API Endpoint: Fetch logs based on filters.
     */
    public function fetchLogs()
    {
        try {
            // Check if user has admin role
            if (!$this->hasAdminAccess()) {
                return $this->jsonResponse('error', 'Admin access required', 403);
            }
            
            // Process filters from request
            $filters = $this->processFilters($_POST);
            
            // Get logs using the audit service
            $logs = $this->auditService->getLogs($filters);
            
            return $this->jsonResponse('success', ['logs' => $logs], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', 'Failed to fetch logs', 500);
        }
    }
    
    /**
     * API Endpoint: Get log details by ID
     */
    public function getLog($id)
    {
        try {
            // Check if user has admin role
            if (!$this->hasAdminAccess()) {
                return $this->jsonResponse('error', 'Admin access required', 403);
            }
            
            $log = $this->auditService->getLogById((int)$id);
            
            return $this->jsonResponse('success', ['log' => $log], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', 'Failed to retrieve log', 500);
        }
    }
    
    /**
     * Process and validate incoming filters
     */
    private function processFilters(array $rawFilters): array
    {
        $filters = [];
        
        // Category filter (unified log type)
        if (!empty($rawFilters['category'])) {
            $filters['category'] = $rawFilters['category'];
        }
        
        // Action filter (for backward compatibility)
        if (!empty($rawFilters['action'])) {
            $filters['action'] = $rawFilters['action'];
        }
        
        // User ID filter
        if (!empty($rawFilters['user_id'])) {
            $filters['user_id'] = (int)$rawFilters['user_id'];
        }
        
        // Booking ID filter
        if (!empty($rawFilters['booking_id'])) {
            $filters['booking_id'] = (int)$rawFilters['booking_id'];
        }
        
        // Date range filters
        if (!empty($rawFilters['start_date'])) {
            $filters['start_date'] = $rawFilters['start_date'];
        }
        
        if (!empty($rawFilters['end_date'])) {
            $filters['end_date'] = $rawFilters['end_date'];
        }
        
        return $filters;
    }
    
    /**
     * Check if current user has admin access
     */
    private function hasAdminAccess(): bool
    {
        // Replace with your actual authentication logic
        return isset($_SESSION['user_role']) && $_SESSION['user_role'] === 'admin';
    }
}
=== App/Models/Booking.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Booking Model
 *
 * Represents a booking and handles database interactions.
 */
class Booking extends BaseModel
{
    protected $table = 'bookings';
    protected $resourceName = 'booking';
    protected $useTimestamps = true;
    protected $useSoftDeletes = true;
    
    /**
     * Constructor
     *
     * @param DatabaseHelper|null $dbHelper
     * @param AuditService|null $auditService
     */
    public function __construct(DatabaseHelper $dbHelper = null, AuditService $auditService = null)
    {
        parent::__construct($dbHelper, $auditService);
    }
    
    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'user_id' => 'required|exists:users,id',
        'vehicle_id' => 'required|exists:vehicles,id',
        'pickup_date' => 'required|date',
        'dropoff_date' => 'required|date|after_or_equal:pickup_date',
        'status' => 'required|string|in:pending,confirmed,cancelled,completed',
    ];

    /**
     * Create a new booking
     * 
     * @param array $data
     * @return int|string
     */
    public function create(array $data): int|string
    {
        $id = parent::create($data);
        
        // Custom audit logging
        if ($id && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'booking_created', [
                'booking_id' => $id,
                'user_id' => $data['user_id'] ?? null,
                'vehicle_id' => $data['vehicle_id'] ?? null,
                'status' => $data['status'] ?? null
            ]);
        }
        
        return $id;
    }

    /**
     * Update a booking
     * 
     * @param int|string $id
     * @param array $data
     * @return bool
     */
    public function update(int|string $id, array $data): bool
    {
        $result = parent::update($id, $data);
        
        // Custom audit logging
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'booking_updated', [
                'booking_id' => $id,
                'updated_fields' => array_keys($data)
            ]);
        }
        
        return $result;
    }

    /**
     * Update a booking's status
     * 
     * @param int|string $id
     * @param string $newStatus
     * @return bool
     */
    public function updateStatus(int|string $id, string $newStatus): bool
    {
        // Validate the status value
        $validStatuses = ['pending', 'confirmed', 'cancelled', 'completed', 'paid'];
        if (!in_array($newStatus, $validStatuses)) {
            if (isset($this->logger)) {
                $this->logger->error("Invalid booking status: {$newStatus}");
            }
            return false;
        }
        
        // Use the existing update method to update just the status field
        return $this->update($id, ['status' => $newStatus]);
    }

    /**
     * Get active bookings.
     *
     * @return array
     */
    public function getActive(): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE status = 'confirmed'
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query);
    }

    /**
     * Get bookings by user ID.
     *
     * @param int|string $userId
     * @return array
     */
    public function getByUser(int|string $userId): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE user_id = :user_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get bookings by status
     * 
     * @param string $status
     * @return array
     */
    public function getByStatus(string $status): array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE status = :status
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':status' => $status]);
    }

    /**
     * Get bookings by date range
     * 
     * @param string $startDate
     * @param string $endDate
     * @return array
     */
    public function getByDateRange(string $startDate, string $endDate): array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE pickup_date >= :start_date AND dropoff_date <= :end_date
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " ORDER BY pickup_date ASC";
        
        return $this->dbHelper->select($query, [
            ':start_date' => $startDate,
            ':end_date' => $endDate
        ]);
    }

    /**
     * Get user data for a booking.
     *
     * @param int|string $bookingId
     * @return array|null
     */
    public function getUser(int|string $bookingId): ?array
    {
        $query = "
            SELECT u.* FROM users u
            JOIN {$this->table} b ON u.id = b.user_id
            WHERE b.id = :booking_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND b.deleted_at IS NULL AND u.deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':booking_id' => $bookingId]);
        return $result ? $result[0] : null;
    }

    /**
     * Get vehicle data for a booking.
     *
     * @param int|string $bookingId
     * @return array|null
     */
    public function getVehicle(int|string $bookingId): ?array
    {
        $query = "
            SELECT v.* FROM vehicles v
            JOIN {$this->table} b ON v.id = b.vehicle_id
            WHERE b.id = :booking_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND b.deleted_at IS NULL AND v.deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':booking_id' => $bookingId]);
        return $result ? $result[0] : null;
    }

    /**
     * Get payment data for a booking.
     *
     * @param int|string $bookingId
     * @return array|null
     */
    public function getPayment(int|string $bookingId): ?array
    {
        $query = "
            SELECT p.* FROM payments p
            WHERE p.booking_id = :booking_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND p.deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':booking_id' => $bookingId]);
        return $result ? $result[0] : null;
    }
    
    /**
     * Check if a vehicle is available during a specific date range
     *
     * @param int|string $vehicleId
     * @param string $startDate
     * @param string $endDate
     * @param int|string|null $excludeBookingId Booking ID to exclude from check (for updates)
     * @return bool
     */
    public function isVehicleAvailable(int|string $vehicleId, string $startDate, string $endDate, int|string $excludeBookingId = null): bool
    {
        $query = "
            SELECT COUNT(*) as booking_count 
            FROM {$this->table}
            WHERE vehicle_id = :vehicle_id
            AND status IN ('pending', 'confirmed')
            AND NOT (
                dropoff_date < :start_date OR pickup_date > :end_date
            )
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        if ($excludeBookingId) {
            $query .= " AND id != :exclude_id";
        }
        
        $result = $this->dbHelper->select($query, [
            ':vehicle_id' => $vehicleId,
            ':start_date' => $startDate,
            ':end_date' => $endDate,
            ':exclude_id' => $excludeBookingId
        ]);
        
        return $result[0]['booking_count'] == 0;
    }
}
=== App/Models/TransactionLog.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;
use App\Services\EncryptionService;

/**
 * TransactionLog Model
 *
 * Represents a financial transaction and handles interactions with the `transaction_logs` table.
 */
class TransactionLog extends BaseModel
{
    protected $table = 'transaction_logs';
    protected $resourceName = 'transaction_log';
    protected $useTimestamps = true; // Transaction logs use timestamps
    protected $useSoftDeletes = false; // Transaction logs don't use soft deletes

    /**
     * Create a new transaction log.
     *
     * @param array $data
     * @return int
     */
    public function create(array $data): int
    {
        // Encrypt transaction details
        $data['amount'] = EncryptionService::encrypt($data['amount']);

        return parent::create($data);
    }

    /**
     * Log a transaction - convenience method that uses create().
     * This method is used for consistency with service calls.
     *
     * @param array $transactionData
     * @return int The ID of the logged transaction
     */
    public function logTransaction(array $transactionData): int
    {
        // Apply any specific transaction logging logic here
        if (!isset($transactionData['created_at'])) {
            $transactionData['created_at'] = date('Y-m-d H:i:s');
        }

        // If a description is not provided, generate a generic one
        if (!isset($transactionData['description'])) {
            $type = $transactionData['type'] ?? 'transaction';
            $transactionData['description'] = ucfirst($type) . ' processed';
        }

        // Log this transaction
        if ($this->auditService && isset($transactionData['type'])) {
            $this->auditService->logEvent(
                $this->resourceName,
                $transactionData['type'] . '_logged',
                [
                    'payment_id' => $transactionData['payment_id'] ?? null,
                    'booking_id' => $transactionData['booking_id'] ?? null,
                    'amount' => $transactionData['amount'] ?? null,
                    'status' => $transactionData['status'] ?? null
                ]
            );
        }

        // Use the create method to insert the transaction record
        return $this->create($transactionData);
    }

    /**
     * Get transactions by user ID.
     *
     * @param int $userId
     * @return array
     */
    public function getByUserId(int $userId): array
    {
        $query = "SELECT * FROM {$this->table} WHERE user_id = :user_id ORDER BY created_at DESC";
        $transactions = $this->dbHelper->select($query, [':user_id' => $userId]);

        // Decrypt transaction details
        foreach ($transactions as &$transaction) {
            $transaction['amount'] = EncryptionService::decrypt($transaction['amount']);
        }

        return $transactions;
    }

    /**
     * Get transaction by ID.
     *
     * @param int $id
     * @return array|null
     */
    public function getById(int $id): ?array
    {
        $query = "SELECT * FROM {$this->table} WHERE id = :id";
        $transaction = $this->dbHelper->select($query, [':id' => $id]);

        if ($transaction) {
            $transaction = $transaction[0] ?? null;
            // Decrypt transaction details
            $transaction['amount'] = EncryptionService::decrypt($transaction['amount']);
        }

        return $transaction ?: null;
    }

    /**
     * Update transaction status.
     *
     * @param int $id
     * @param string $status
     * @return bool
     */
    public function updateStatus(int $id, string $status): bool
    {
        $result = parent::update($id, ['status' => $status]);

        // Log the event
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'status_update', [
                'id' => $id,
                'status' => $status
            ]);
        }

        return $result;
    }

    /**
     * Get recent transactions.
     *
     * @param int $limit
     * @return array
     */
    public function getRecent(int $limit = 10): array
    {
        $query = "SELECT * FROM {$this->table} ORDER BY created_at DESC LIMIT :limit";
        $transactions = $this->dbHelper->select($query, [':limit' => $limit]);

        // Decrypt transaction details
        foreach ($transactions as &$transaction) {
            $transaction['amount'] = EncryptionService::decrypt($transaction['amount']);
        }

        return $transactions;
    }
}
=== App/Models/RefreshToken.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use Exception;

class RefreshToken
{
    private DatabaseHelper $dbHelper;
    private LoggerInterface $logger;
    private bool $useSecureDb = true;

    public function __construct(DatabaseHelper $dbHelper, LoggerInterface $logger)
    {
        $this->dbHelper = $dbHelper;
        $this->logger = $logger;
    }

    /**
     * Store a refresh token in the database
     * 
     * @param int $userId The user ID
     * @param string $refreshToken The unhashed token
     * @param int $expiresIn Expiry time in seconds
     * @return bool Success status
     */
    public function store(int $userId, string $refreshToken, int $expiresIn = 604800): bool
    {
        try {
            // Hash token for secure storage
            $hashedToken = hash('sha256', $refreshToken);
            
            // Store the token in the refresh_tokens table
            $this->dbHelper->insert('refresh_tokens', [
                'user_id' => $userId,
                'token' => $hashedToken,
                'expires_at' => date('Y-m-d H:i:s', time() + $expiresIn),
                'created_at' => date('Y-m-d H:i:s'),
                'ip_address' => $_SERVER['REMOTE_ADDR'] ?? null
            ], $this->useSecureDb);
            
            $this->logger->info("Refresh token stored", ['user_id' => $userId]);
            return true;
        } catch (Exception $e) {
            $this->logger->error("Failed to store refresh token: " . $e->getMessage());
            return false;
        }
    }

    /**
     * Check if a token has been revoked
     * 
     * @param string $token The unhashed token
     * @return bool True if revoked
     */
    public function isRevoked(string $token): bool
    {
        try {
            // Check cache first for performance
            if (apcu_exists("revoked_refresh_token_$token")) {
                return true;
            }
            
            // If not in cache, check secure database
            $hashedToken = hash('sha256', $token);
            $query = "SELECT 1 FROM refresh_tokens WHERE token = :token AND revoked = 1 LIMIT 1";
            $revoked = $this->dbHelper->select($query, [':token' => $hashedToken], $this->useSecureDb);
                
            // If revoked in database, store in cache for next time
            if ($revoked) {
                apcu_store("revoked_refresh_token_$token", true, 604800);
            }
            
            return !empty($revoked);
        } catch (Exception $e) {
            $this->logger->warning("Error checking if token is revoked: " . $e->getMessage());
            // Default to not revoked if there's an error checking, but log it
            return false;
        }
    }

    /**
     * Find token data by the token string
     * 
     * @param string $token The unhashed token
     * @return array|null Token data or null if not found
     */
    public function findByToken(string $token): ?array
    {
        try {
            $hashedToken = hash('sha256', $token);
            $query = "SELECT * FROM refresh_tokens WHERE token = :token LIMIT 1";
            $result = $this->dbHelper->select($query, [':token' => $hashedToken], $this->useSecureDb);
            
            return $result[0] ?? null;
        } catch (Exception $e) {
            $this->logger->error("Error finding token: " . $e->getMessage());
            return null;
        }
    }

    /**
     * Revoke a token
     * 
     * @param string $token The unhashed token
     * @return bool Success status
     */
    public function revoke(string $token): bool
    {
        try {
            // Store in cache for quick lookups
            apcu_store("revoked_refresh_token_$token", true, 604800);
            
            // Store in secure database for persistence
            $hashedToken = hash('sha256', $token);
            
            // Update the token status in secure database
            $result = $this->dbHelper->update(
                'refresh_tokens', 
                [
                    'revoked' => 1,
                    'revoked_at' => date('Y-m-d H:i:s')
                ], 
                ['token' => $hashedToken], 
                $this->useSecureDb
            );
                
            return $result;
        } catch (Exception $e) {
            $this->logger->error("Failed to revoke token: " . $e->getMessage());
            return false;
        }
    }

    /**
     * Purge all expired tokens
     * 
     * @return int Number of tokens purged
     */
    public function purgeExpired(): int
    {
        try {
            $count = $this->dbHelper->delete(
                'refresh_tokens', 
                ['expires_at < ' => date('Y-m-d H:i:s')], 
                false,
                $this->useSecureDb
            );
                
            $this->logger->info("Purged {$count} expired tokens");
            return $count;
        } catch (Exception $e) {
            $this->logger->error("Failed to purge expired tokens: " . $e->getMessage());
            return 0;
        }
    }

    /**
     * Get all active tokens for a user
     * 
     * @param int $userId The user ID
     * @return array List of token records
     */
    public function getActiveForUser(int $userId): array
    {
        try {
            $query = "SELECT * FROM refresh_tokens WHERE user_id = :user_id AND revoked = 0 AND expires_at > :now";
            $tokens = $this->dbHelper->select(
                $query, 
                [
                    ':user_id' => $userId,
                    ':now' => date('Y-m-d H:i:s')
                ], 
                $this->useSecureDb
            );
                
            return $tokens ?? [];
        } catch (Exception $e) {
            $this->logger->error("Failed to get active tokens: " . $e->getMessage());
            return [];
        }
    }

    /**
     * Get user ID associated with a token
     * 
     * @param string $token The unhashed token
     * @return int|null User ID or null if not found
     */
    public function getUserId(string $token): ?int
    {
        $tokenData = $this->findByToken($token);
        return $tokenData['user_id'] ?? null;
    }
}
=== App/Models/Payment.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Payment Model
 *
 * Represents a payment transaction in the system.
 *
 * @property int $id Primary key
 * @property int $user_id ID of the user who made the payment
 * @property int $booking_id ID of the associated booking
 * @property float $amount Transaction amount
 * @property string $method Payment method (credit_card, PayPal, etc.)
 * @property string $status Status of the payment (pending, completed, failed)
 * @property string|null $transaction_id Unique external transaction identifier
 * @property string $type Type of transaction ('payment' or 'refund')
 * @property string|null $refund_reason Reason for refund, if applicable
 * @property int|null $original_payment_id ID of the original payment (for refunds only)
 */
class Payment extends BaseModel
{
    protected $table = 'payments';
    protected $resourceName = 'payment';
    
    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'user_id' => 'required|exists:users,id',
        'booking_id' => 'required|exists:bookings,id',
        'amount' => 'required|numeric|min:0',
        'method' => 'required|string|in:credit_card,paypal,bank_transfer',
        'status' => 'required|string|in:pending,completed,failed',
        'transaction_id' => 'nullable|string|max:255',
        'type' => 'string|in:payment,refund',
        'refund_reason' => 'nullable|string|max:255',
        'original_payment_id' => 'nullable|integer|exists:payments,id',
    ];

    public function __construct(DatabaseHelper $dbHelper, AuditService $auditService = null)
    {
        $this->dbHelper = $dbHelper;
        $this->auditService = $auditService;
    }

    /**
     * Find a payment by ID.
     *
     * @param int $id
     * @return array|null
     */
    public function find(int $id): ?array
    {
        $query = "SELECT * FROM {$this->table} WHERE id = :id AND deleted_at IS NULL LIMIT 1";
        $result = $this->dbHelper->select($query, [':id' => $id]);
        return $result[0] ?? null; // Return first result or null
    }
    

    /**
     * Get all payments.
     *
     * @return array
     */
    public function all(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query);
    }

    /**
     * Create a new payment or refund.
     *
     * @param array $data
     * @return int|null ID of the created payment/refund, or null on failure
     */
    public function create(array $data): ?int
    {
        // Set default type to 'payment' if not specified
        $data['type'] = $data['type'] ?? 'payment';
        
        // Validate the data
        if (isset($this->validator)) {
            $validation = $this->validator->validate($data, self::$rules);
            if ($validation->fails()) {
                if (isset($this->logger)) {
                    $this->logger->error('Payment validation failed', $validation->errors()->all());
                }
                return null;
            }
        }
        
        // For refunds, the amount should be negative (to represent money going out)
        if ($data['type'] === 'refund' && $data['amount'] > 0) {
            $data['amount'] = -1 * abs($data['amount']);
        }

        $data['created_at'] = $data['updated_at'] = date('Y-m-d H:i:s');
        $paymentId = $this->dbHelper->insert($this->table, $data);
        
        if (!$paymentId) {
            return null; // Return null if insertion fails
        }

        if ($this->auditService) {
            $eventType = ($data['type'] === 'refund') ? 'Created refund' : 'Created payment';
            
            $auditData = [
                'payment_id' => $paymentId,
                'user_id' => $data['user_id'],
                'booking_id' => $data['booking_id'],
                'amount' => $data['amount'],
                'method' => $data['method'],
                'type' => $data['type']
            ];
            
            // Add refund-specific data if applicable
            if ($data['type'] === 'refund') {
                $auditData['refund_reason'] = $data['refund_reason'] ?? null;
                $auditData['original_payment_id'] = $data['original_payment_id'] ?? null;
            }
            
            $this->auditService->logEvent($this->resourceName, $eventType, $auditData);
        }
        
        return (int) $paymentId; // Ensure ID is always an integer
    }

    /**
     * Create a refund record.
     * 
     * @param array $refundData Must contain: user_id, booking_id, amount, method, original_payment_id
     * @return int|null ID of the created refund, or null on failure
     */
    public function createRefund(array $refundData): ?int
    {
        // Ensure the type is set to refund
        $refundData['type'] = 'refund';
        
        // Set status to completed by default if not specified
        if (!isset($refundData['status'])) {
            $refundData['status'] = 'completed';
        }
        
        // Ensure refund reason is set
        if (!isset($refundData['refund_reason'])) {
            $refundData['refund_reason'] = 'Refund processed';
        }
        
        // Validate required fields specific to refunds
        if (!isset($refundData['original_payment_id'])) {
            if (isset($this->logger)) {
                $this->logger->error('Refund creation failed: original_payment_id is required');
            }
            return null;
        }
        
        // Check if original payment exists
        $originalPayment = $this->find($refundData['original_payment_id']);
        if (!$originalPayment) {
            if (isset($this->logger)) {
                $this->logger->error('Refund creation failed: original payment not found', [
                    'original_payment_id' => $refundData['original_payment_id']
                ]);
            }
            return null;
        }
        
        // Ensure original payment is a payment, not a refund
        if ($originalPayment['type'] === 'refund') {
            if (isset($this->logger)) {
                $this->logger->error('Refund creation failed: cannot refund a refund', [
                    'original_payment_id' => $refundData['original_payment_id']
                ]);
            }
            return null;
        }
        
        // Check if original payment is already fully refunded
        $refundedAmount = $this->getRefundedAmount($refundData['original_payment_id']);
        $originalAmount = abs($originalPayment['amount']);
        $requestedRefundAmount = abs($refundData['amount']);
        
        if (($refundedAmount + $requestedRefundAmount) > $originalAmount) {
            if (isset($this->logger)) {
                $this->logger->error('Refund creation failed: refund amount exceeds original payment', [
                    'original_payment_id' => $refundData['original_payment_id'],
                    'original_amount' => $originalAmount,
                    'already_refunded' => $refundedAmount,
                    'requested_refund' => $requestedRefundAmount
                ]);
            }
            return null;
        }
        
        // Ensure refund amount is stored as negative
        $refundData['amount'] = -1 * abs($refundData['amount']);
        
        // Use the create method to insert the refund record
        $refundId = $this->create($refundData);
        
        if ($refundId && $this->auditService) {
            // Add specialized refund audit log
            $this->auditService->logEvent(
                $this->resourceName, 
                'refund_processed', 
                [
                    'refund_id' => $refundId,
                    'original_payment_id' => $refundData['original_payment_id'],
                    'user_id' => $refundData['user_id'],
                    'booking_id' => $refundData['booking_id'],
                    'amount' => $refundData['amount'],
                    'reason' => $refundData['refund_reason'],
                    'remaining_balance' => $originalAmount - ($refundedAmount + abs($refundData['amount']))
                ]
            );
        }
        
        return $refundId;
    }

    /**
     * Update a payment.
     *
     * @param int $id
     * @param array $data
     * @return bool
     */
    public function update(int $id, array $data): bool
    {
        $data['updated_at'] = date('Y-m-d H:i:s');
        $result = $this->dbHelper->update($this->table, $data, ['id' => $id, 'deleted_at IS NULL']);
        
        // Log audit if service is available and update was successful
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'Updated payment', [
                'payment_id' => $id,
                'updated_fields' => array_keys($data)
            ]);
        }
        
        return $result;
    }

    /**
     * Soft delete a payment.
     *
     * @param int $id
     * @return bool
     */
    public function delete(int $id): bool
    {
        $result = $this->dbHelper->update($this->table, ['deleted_at' => date('Y-m-d H:i:s')], ['id' => $id]);
    
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'Deleted payment', ['payment_id' => $id]);
        }
        
        return $result;
    }
    

    /**
     * Get payments by user ID.
     * Replaces scopeByUser.
     *
     * @param int $userId
     * @return array
     */
    public function getByUser(int $userId): array
    {
        $query = "SELECT * FROM {$this->table} WHERE user_id = :user_id AND deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get completed payments.
     * Replaces scopeCompleted.
     *
     * @return array
     */
    public function getCompleted(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE status = 'completed' AND deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query);
    }

    /**
     * Get payments by status.
     * Replaces scopeByStatus.
     *
     * @param string $status
     * @return array
     */
    public function getByStatus(string $status): array
    {
        $query = "SELECT * FROM {$this->table} WHERE status = :status AND deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query, [':status' => $status]);
    }

    /**
     * Get payments within a date range.
     * Replaces scopeByDateRange.
     *
     * @param string $startDate
     * @param string $endDate
     * @return array
     */
    public function getByDateRange(string $startDate, string $endDate): array
    {
        $query = "SELECT * FROM {$this->table} WHERE created_at BETWEEN :start_date AND :end_date AND deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query, [':start_date' => $startDate, ':end_date' => $endDate]);
    }

    /**
     * Get user data for a payment.
     * Replaces user relationship.
     *
     * @param int $paymentId
     * @return array|null
     */
    public function getUser(int $paymentId): ?array
    {
        $query = "SELECT u.* FROM users u JOIN {$this->table} p ON u.id = p.user_id WHERE p.id = :payment_id AND p.deleted_at IS NULL";
        return $this->dbHelper->select($query, [':payment_id' => $paymentId]);
    }

    /**
     * Get booking data for a payment.
     * Replaces booking relationship.
     *
     * @param int $paymentId
     * @return array|null
     */
    public function getBooking(int $paymentId): ?array
    {
        $query = "SELECT b.* FROM bookings b JOIN {$this->table} p ON b.id = p.booking_id WHERE p.id = :payment_id AND p.deleted_at IS NULL AND b.deleted_at IS NULL";
        return $this->dbHelper->select($query, [':payment_id' => $paymentId]);
    }

    /**
     * Get payments by booking ID
     * 
     * @param int $bookingId
     * @return array
     */
    public function getByBooking(int $bookingId): array
    {
        $query = "SELECT * FROM {$this->table} WHERE booking_id = :booking_id AND deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query, [':booking_id' => $bookingId]);
    }

    /**
     * Get refunds for a specific payment
     *
     * @param int $paymentId
     * @return array
     */
    public function getRefundsForPayment(int $paymentId): array
    {
        $query = "SELECT * FROM {$this->table} 
                  WHERE original_payment_id = :payment_id 
                  AND type = 'refund' 
                  AND deleted_at IS NULL
                  ORDER BY created_at DESC";
                  
        return $this->dbHelper->select($query, [':payment_id' => $paymentId]);
    }

    /**
     * Get all refunds
     *
     * @return array
     */
    public function getAllRefunds(): array
    {
        $query = "SELECT * FROM {$this->table} 
                  WHERE type = 'refund' 
                  AND deleted_at IS NULL
                  ORDER BY created_at DESC";
                  
        return $this->dbHelper->select($query);
    }

    /**
     * Check if a payment has been refunded
     *
     * @param int $paymentId
     * @return bool
     */
    public function hasRefunds(int $paymentId): bool
    {
        $query = "SELECT COUNT(*) as refund_count 
                  FROM {$this->table} 
                  WHERE original_payment_id = :payment_id 
                  AND type = 'refund' 
                  AND deleted_at IS NULL";
                  
        $result = $this->dbHelper->select($query, [':payment_id' => $paymentId]);
        return (int)$result[0]['refund_count'] > 0;
    }

    /**
     * Get total refunded amount for a payment
     *
     * @param int $paymentId
     * @return float
     */
    public function getRefundedAmount(int $paymentId): float
    {
        $query = "SELECT SUM(ABS(amount)) as total_refunded 
                  FROM {$this->table} 
                  WHERE original_payment_id = :payment_id 
                  AND type = 'refund' 
                  AND status = 'completed' 
                  AND deleted_at IS NULL";
                  
        $result = $this->dbHelper->select($query, [':payment_id' => $paymentId]);
        return (float)($result[0]['total_refunded'] ?? 0);
    }
}
=== App/Models/Admin.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Admin Model - Manages system administrators.
 */
class Admin extends BaseModel
{
    protected $table = 'admins';
    protected $resourceName = 'admin';
    protected $useTimestamps = true;
    protected $useSoftDeletes = true;
    
    /**
     * Constructor
     *
     * @param DatabaseHelper $dbHelper
     * @param AuditService|null $auditService
     */
    public function __construct(DatabaseHelper $dbHelper = null, AuditService $auditService = null)
    {
        parent::__construct($dbHelper, $auditService);
    }
    
    /**
     * Hash a password.
     *
     * @param string $password
     * @return string
     */
    public static function hashPassword(string $password): string
    {
        return password_hash($password, PASSWORD_BCRYPT, ['cost' => 12]);
    }
    
    /**
     * Verify password.
     *
     * @param string $plainPassword
     * @param string $hashedPassword
     * @return bool
     */
    public static function verifyPassword(string $plainPassword, string $hashedPassword): bool
    {
        return password_verify($plainPassword, $hashedPassword);
    }
    
    /**
     * Create an admin.
     * Override to handle password hashing.
     *
     * @param array $data
     * @return int|string
     */
    public function create(array $data): int|string
    {
        if (isset($data['password'])) {
            $data['password'] = self::hashPassword($data['password']);
        }
        
        $id = parent::create($data);
        
        // Add custom audit logging if needed
        if ($this->auditService) {
            $this->auditService->logEvent('admin', 'admin_created', [
                'id' => $id,
                'name' => $data['name'] ?? null,
                'email' => $data['email'] ?? null,
                'role' => $data['role'] ?? null
            ]);
        }
        
        return $id;
    }
    
    /**
     * Update an admin.
     * Override to handle password hashing.
     *
     * @param int|string $id
     * @param array $data
     * @return bool
     */
    public function update(int|string $id, array $data): bool
    {
        if (isset($data['password'])) {
            $data['password'] = self::hashPassword($data['password']);
        }
        
        $result = parent::update($id, $data);
        
        // Add custom audit logging if needed
        if ($result && $this->auditService) {
            $this->auditService->logEvent('admin', 'admin_updated', [
                'id' => $id,
                'updated_fields' => array_keys($data)
            ]);
        }
        
        return $result;
    }
    
    /**
     * Get admin by email.
     *
     * @param string $email
     * @return array|null
     */
    public function getByEmail(string $email): ?array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE email = :email
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':email' => $email]);
        return $result ? $result[0] : null;
    }
    
    /**
     * Restore a soft deleted admin.
     *
     * @param int|string $id
     * @return bool
     */
    public function restore(int|string $id): bool
    {
        if (!$this->useSoftDeletes) {
            return false;
        }
        
        $result = $this->dbHelper->update($this->table, ['deleted_at' => null], ['id' => $id]);
        
        if ($result && $this->auditService) {
            $this->auditService->logEvent('admin', 'admin_restored', [
                'admin_id' => $id
            ]);
        }
        
        return $result;
    }
    
    /**
     * Get users managed by this admin.
     *
     * @param int|string $adminId
     * @return array
     */
    public function getManagedUsers(int|string $adminId): array
    {
        $query = "
            SELECT * FROM users
            WHERE managed_by = :admin_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " ORDER BY name ASC";
        
        return $this->dbHelper->select($query, [':admin_id' => $adminId]);
    }
    
    /**
     * Get admin permissions.
     *
     * @param int|string $adminId
     * @return array
     */
    public function getPermissions(int|string $adminId): array
    {
        $query = "
            SELECT p.* FROM permissions p
            JOIN admin_permissions ap ON p.id = ap.permission_id
            WHERE ap.admin_id = :admin_id
        ";
        
        return $this->dbHelper->select($query, [':admin_id' => $adminId]);
    }

    /**
     * Find admin by token
     */
    public function findByToken(string $token): ?array
    {
        $adminData = DatabaseHelper::select(
            "SELECT id, email, role FROM admins WHERE token = ? AND token_expiry > NOW()",
            [$token],
            true // Using secure database
        );
        
        return !empty($adminData) ? $adminData[0] : null;
    }

    /**
     * Get paginated list of all users with their roles
     */
    public function getPaginatedUsers(int $page, int $perPage): array
    {
        $offset = ($page - 1) * $perPage;
        
        $users = DatabaseHelper::select(
            "SELECT u.*, r.name as role_name 
             FROM users u 
             LEFT JOIN roles r ON u.role_id = r.id 
             ORDER BY u.created_at DESC 
             LIMIT ? OFFSET ?",
            [$perPage, $offset],
            false // Using application database
        );
        
        return $users;
    }

    /**
     * Get total user count
     */
    public function getTotalUserCount(): int
    {
        $result = DatabaseHelper::select(
            "SELECT COUNT(*) as count FROM users",
            [],
            false // Using application database
        );
        
        return (int)$result[0]['count'];
    }

    /**
     * Get user by ID
     */
    public function getUserById(int $userId): ?array
    {
        $user = DatabaseHelper::select(
            "SELECT id, email, role FROM users WHERE id = ?",
            [$userId],
            false // Using application database
        );
        
        return !empty($user) ? $user[0] : null;
    }

    /**
     * Update user role
     */
    public function updateUserRole(int $userId, string $role): bool
    {
        return DatabaseHelper::update(
            "users",
            ["role" => $role],
            ["id" => $userId],
            false // Using application database
        );
    }

    /**
     * Soft delete user
     */
    public function softDeleteUser(int $userId): bool
    {
        return DatabaseHelper::update(
            "users",
            ["deleted_at" => date('Y-m-d H:i:s')],
            ["id" => $userId],
            false // Using application database
        );
    }

    /**
     * Get dashboard statistics
     */
    public function getDashboardStatistics(): array
    {
        // Get total users count
        $totalUsers = DatabaseHelper::select(
            "SELECT COUNT(*) as count FROM users WHERE deleted_at IS NULL",
            [],
            false
        )[0]['count'];
        
        // Get total bookings count
        $totalBookings = DatabaseHelper::select(
            "SELECT COUNT(*) as count FROM bookings",
            [],
            false
        )[0]['count'];
        
        // Get total revenue
        $totalRevenue = DatabaseHelper::select(
            "SELECT SUM(amount) as total FROM payments WHERE status = 'completed'",
            [],
            false
        )[0]['total'] ?? 0;
        
        // Get latest 5 users
        $latestUsers = DatabaseHelper::select(
            "SELECT u.*, r.name as role_name 
             FROM users u 
             LEFT JOIN roles r ON u.role_id = r.id 
             WHERE u.deleted_at IS NULL 
             ORDER BY u.created_at DESC 
             LIMIT 5",
            [],
            false
        );
        
        // Get latest 5 transactions
        $latestTransactions = DatabaseHelper::select(
            "SELECT * FROM transaction_logs ORDER BY created_at DESC LIMIT 5",
            [],
            false
        );
        
        return [
            'total_users' => $totalUsers,
            'total_bookings' => $totalBookings,
            'total_revenue' => $totalRevenue,
            'latest_users' => $latestUsers,
            'latest_transactions' => $latestTransactions,
        ];
    }

    /**
     * Check if admin with email exists
     */
    public function findByEmail(string $email): ?array
    {
        $admin = DatabaseHelper::select(
            "SELECT id FROM admins WHERE email = ?",
            [$email],
            true // Using secure database
        );
        
        return !empty($admin) ? $admin[0] : null;
    }

    /**
     * Create new admin user
     * 
     * @param array $adminData
     * @return int|null
     */
    public function createAdmin(array $adminData): ?int
    {
        return DatabaseHelper::insert(
            "admins",
            $adminData,
            true // Using secure database
        );
    }

    /**
     * Get admin by ID
     */
    public function findById(int $adminId): ?array
    {
        $admin = DatabaseHelper::select(
            "SELECT id, name, email, role, created_at FROM admins WHERE id = ?",
            [$adminId],
            true // Using secure database
        );
        
        return !empty($admin) ? $admin[0] : null;
    }
}
=== App/Models/Notification.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Notification Model
 *
 * Represents a notification in the system.
 */
class Notification extends BaseModel
{
    protected $table = 'notifications';
    protected $resourceName = 'notification';
    protected $useTimestamps = false;  // We'll use sent_at instead of created_at
    protected $useSoftDeletes = false; // Notifications don't use soft deletes

    /**
     * Mark a notification as read.
     *
     * @param int $id
     * @return bool
     */
    public function markAsRead(int $id): bool
    {
        $result = $this->dbHelper->update($this->table, ['is_read' => 1], ['id' => $id]);
        
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'notification_read', [
                'id' => $id
            ]);
        }
        
        return $result;
    }

    /**
     * Create a new notification.
     *
     * @param array $data
     * @return int
     */
    public function create(array $data): int
    {
        // Set sent_at to now if not provided
        if (!isset($data['sent_at'])) {
            $data['sent_at'] = date('Y-m-d H:i:s');
        }
        
        // Default is_read to false if not provided
        if (!isset($data['is_read'])) {
            $data['is_read'] = 0;
        }
        
        return parent::create($data);
    }

    /**
     * Get notifications by user ID.
     *
     * @param int $userId
     * @return array
     */
    public function getByUserId(int $userId): array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE user_id = :user_id
            ORDER BY sent_at DESC
        ";
        
        $notifications = $this->dbHelper->select($query, [':user_id' => $userId]);
        return $notifications ?: [];
    }

    /**
     * Get unread notifications for a user.
     *
     * @param int $userId
     * @return array
     */
    public function getUnreadByUserId(int $userId): array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE user_id = :user_id AND is_read = 0
            ORDER BY sent_at DESC
        ";
        
        $notifications = $this->dbHelper->select($query, [':user_id' => $userId]);
        return $notifications ?: [];
    }

    /**
     * Mark all notifications as read for a user.
     *
     * @param int $userId
     * @return bool
     */
    public function markAllAsReadForUser(int $userId): bool
    {
        $result = $this->dbHelper->update($this->table, ['is_read' => 1], ['user_id' => $userId, 'is_read' => 0]);
        
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'all_notifications_read', [
                'user_id' => $userId
            ]);
        }
        
        return $result;
    }

    /**
     * Get the user associated with a notification.
     *
     * @param int $notificationId
     * @return array|null
     */
    public function getUser(int $notificationId): ?array
    {
        $notification = $this->find($notificationId);
        
        if (!$notification || !isset($notification['user_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM users WHERE id = :user_id";
        $result = $this->dbHelper->select($query, [':user_id' => $notification['user_id']]);
        return $result[0] ?? null;
    }
}
=== App/Models/PaymentMethod.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;

/**
 * PaymentMethod Model
 *
 * Represents a payment method and handles interactions with the `payment_methods` table.
 */
class PaymentMethod extends BaseModel
{
    protected $table = 'payment_methods';
    protected $resourceName = 'payment_method';
    
    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'name' => 'required|string|max:255',
        'description' => 'nullable|string',
        'is_active' => 'boolean',
        'user_id' => 'required|exists:users,id',
        'payment_type' => 'required|string|in:credit_card,paypal,bank_transfer'
    ];

    public function __construct(DatabaseHelper $dbHelper)
    {
        $this->pdo = $dbHelper->getPdo();
    }

    /**
     * Get all available payment methods.
     */
    public function getAll(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE is_active = 1";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute();
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Get payment method by ID.
     */
    public function getById(int $id): ?array
    {
        $stmt = $this->pdo->prepare("SELECT * FROM payment_methods WHERE id = :id");
        $stmt->execute([':id' => $id]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }

    /**
     * Add a new payment method.
     */
    public function create(array $data): int
    {
        $validPaymentTypes = ['credit_card', 'paypal', 'bank_transfer'];
        if (!in_array($data['payment_type'], $validPaymentTypes)) {
            throw new \InvalidArgumentException("Invalid payment type.");
        }

        return parent::create($data);
    }
    
    /**
     * Update a payment method.
     */
    public function update(int $id, array $data): bool
    {
        $setClauses = [];
        $params = [':id' => $id];

        foreach ($data as $key => $value) {
            if (in_array($key, ['name', 'description', 'is_active', 'payment_type'])) {
                $setClauses[] = "$key = :$key";
                $params[":$key"] = $value;
            }
        }

        if (empty($setClauses)) {
            return false;
        }

        $setClauses[] = "updated_at = NOW()";
        $setClause = implode(', ', $setClauses);

        $stmt = $this->pdo->prepare("
            UPDATE payment_methods 
            SET $setClause 
            WHERE id = :id
        ");
        return $stmt->execute($params);
    }
    
    /**
     * Delete a payment method.
     */
    public function delete(int $id): bool
    {
        $stmt = $this->pdo->prepare("DELETE FROM payment_methods WHERE id = :id");
        return $stmt->execute([':id' => $id]);
    }

    /**
     * Get payment methods by user ID.
     * Replaces scopeByUser.
     */
    public function getByUser(int $userId): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE user_id = :user_id
            ORDER BY created_at DESC
        ";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':user_id' => $userId]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }
    
    /**
     * Get user data for a payment method.
     * Replaces user relationship.
     */
    public function getUser(int $paymentMethodId): ?array
    {
        $query = "
            SELECT u.* FROM users u
            JOIN {$this->table} pm ON u.id = pm.user_id
            WHERE pm.id = :payment_method_id
        ";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':payment_method_id' => $paymentMethodId]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }
}
=== App/Models/Document.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Document Model
 *
 * Represents documents stored in the system and provides methods
 * for managing and querying them.
 */
class Document extends BaseModel
{
    protected $table = 'documents';
    protected $resourceName = 'document';
    protected $useSoftDeletes = false; // Document model doesn't use soft deletes

    /**
     * Create a new document record.
     *
     * @param array $data Data including name, file_path, user_id, type
     * @return int The ID of the newly created document.
     */
    public function create(array $data): int
    {
        // Add created_at if using timestamps but not provided
        if ($this->useTimestamps && !isset($data['created_at'])) {
            $data['created_at'] = date('Y-m-d H:i:s');
        }
        
        $id = parent::create($data);
        
        // Add custom audit logging if needed
        if ($this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'document_created', [
                'id' => $id,
                'name' => $data['name'] ?? null,
                'type' => $data['type'] ?? null,
                'user_id' => $data['user_id'] ?? null
            ]);
        }
        
        return $id;
    }

    /**
     * Override find to add audit logging for views.
     *
     * @param int $id
     * @return array|null
     */
    public function find(int $id): ?array
    {
        $document = parent::find($id);
        
        // Log view event if document was found
        if ($document && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'document_viewed', [
                'id' => $id,
                'name' => $document['name'] ?? 'unknown'
            ]);
        }
        
        return $document;
    }

    /**
     * Retrieve documents associated with a user.
     *
     * @param int $userId The ID of the user.
     * @return array A list of documents associated with the user.
     */
    public function getByUserId(int $userId): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE user_id = :user_id 
            ORDER BY created_at DESC
        ";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':user_id' => $userId]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Retrieve documents by type.
     *
     * @param string $type The type of document (e.g., 'contract', 'terms').
     * @return array A list of documents matching the specified type.
     */
    public function getByType(string $type): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE type = :type 
            ORDER BY created_at DESC
        ";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':type' => $type]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Delete a document by its ID.
     *
     * @param int $id The ID of the document to delete.
     * @return bool True on success, false otherwise.
     */
    public function delete(int $id): bool
    {
        // First, get document details for audit log
        $document = $this->find($id);
        
        if (!$document) {
            return false;
        }
        
        $result = parent::delete($id);
        
        // Add custom audit log if needed
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'document_deleted', [
                'id' => $id,
                'name' => $document['name'] ?? 'unknown',
                'type' => $document['type'] ?? null
            ]);
        }
        
        return $result;
    }
    
    /**
     * Update a document's details.
     *
     * @param int $id The ID of the document to update.
     * @param array $data The data to update.
     * @return bool True on success, false otherwise.
     */
    public function update(int $id, array $data): bool
    {
        // Filter data to only include allowed fields
        $validData = array_filter($data, function($key) {
            return in_array($key, ['name', 'file_path', 'type']);
        }, ARRAY_FILTER_USE_KEY);
        
        if (empty($validData)) {
            return false;
        }
        
        $result = parent::update($id, $validData);
        
        // Add custom audit log if needed
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'document_updated', [
                'id' => $id,
                'updated_fields' => array_keys($validData)
            ]);
        }
        
        return $result;
    }
}
=== App/Models/Vehicle.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Vehicle Model
 *
 * Represents a vehicle in the system.
 */
class Vehicle extends BaseModel
{
    protected $table = 'vehicles';
    protected $resourceName = 'vehicle';
    protected $useSoftDeletes = false; // Vehicles use hard deletes

    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'registration_number' => 'required|string|unique:vehicles,registration_number',
        'type' => 'required|string',
        'status' => 'required|in:available,unavailable,maintenance',
        'make' => 'required|string|max:255',
        'model' => 'required|string|max:255',
        'year' => 'required|integer|min:1886|max:' . PHP_INT_MAX,
    ];

    /**
     * Create a new vehicle
     * 
     * @param array $data
     * @return int
     */
    public function create(array $data): int
    {
        // Ensure status is properly managed
        if (empty($data['status'])) {
            $data['status'] = 'available';
        }

        return parent::create($data);
    }

    /**
     * Find available vehicles
     *
     * @return array
     */
    public function findAvailable(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE status = :status";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':status' => 'available']);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Find vehicles by type
     *
     * @param string $type
     * @return array
     */
    public function findByType(string $type): array
    {
        $query = "SELECT * FROM {$this->table} WHERE type = :type";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':type' => $type]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Get vehicle's bookings
     *
     * @param int $vehicleId
     * @return array
     */
    public function getBookings(int $vehicleId): array
    {
        $query = "SELECT * FROM bookings WHERE vehicle_id = :vehicle_id";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':vehicle_id' => $vehicleId]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }
    
    /**
     * Set a vehicle to maintenance status
     *
     * @param int $id
     * @param string $reason
     * @return bool
     */
    public function setToMaintenance(int $id, string $reason = ''): bool
    {
        $result = $this->update($id, ['status' => 'maintenance']);
        
        // Add custom audit logging for maintenance status
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'vehicle_maintenance', [
                'vehicle_id' => $id,
                'reason' => $reason
            ]);
        }
        
        return $result;
    }
    
    /**
     * Set a vehicle to available status
     *
     * @param int $id
     * @return bool
     */
    public function setToAvailable(int $id): bool
    {
        return $this->update($id, ['status' => 'available']);
    }
}
=== App/Models/DocumentTemplate.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use App\Traits\Auditable;

/**
 * DocumentTemplate Model
 *
 * Manages templates for documents such as contracts, invoices, and Terms & Conditions.
 */
class DocumentTemplate extends Model
{
    use SoftDeletes, Auditable;

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'name',
        'content',
        'description'
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array
     */
    protected $casts = [
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Get the validation rules for the model.
     *
     * @return array
     */
    public static function validationRules(): array
    {
        return [
            'name' => 'required|string|max:255',
            'content' => 'required|string',
            'description' => 'nullable|string'
        ];
    }
}
=== App/Models/User.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use Exception;
use Psr\Log\LoggerInterface;
use Illuminate\Support\Facades\Hash;
use Ramsey\Uuid\Uuid;
use App\Services\AuditService;

/**
 * User Model
 * 
 * Represents a user in the system with their associated data and relationships.
 * 
 * @property string $id UUID of the user
 * @property string $name User's first name
 * @property string $surname User's last name
 * @property string $email User's email address
 * @property string $password_hash Hashed password
 * @property string $role User role (user, admin, super_admin)
 * @property string $phone Phone number
 * @property string $address Physical address
 * @property \DateTime $created_at
 * @property \DateTime $updated_at
 * @property \DateTime $deleted_at
 */
class User extends BaseModel
{
    protected $logger;

    public function __construct(DatabaseHelper $dbHelper = null, LoggerInterface $logger = null, AuditService $auditService = null)
    {
        parent::__construct($dbHelper, $auditService);
        $this->logger = $logger;
    }

    protected $table = 'users';
    protected $primaryKey = 'id';
    protected $resourceName = 'user';
    protected $useTimestamps = true;
    protected $useSoftDeletes = true;
    protected $useUuid = true;

    protected $fillable = [
        'name',
        'surname',
        'email',
        'password_hash',
        'role',
        'phone',
        'address',
    ];

    protected $hidden = [
        'password_hash',
        'remember_token',
        'deleted_at',
    ];

    public static array $rules = [
        'name' => 'required|string|max:255',
        'surname' => 'required|string|max:255',
        'email' => 'required|email|unique:users,email',
        'password' => 'required|min:8|regex:/^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/',
        'role' => 'required|in:user,admin,super_admin',
        'phone' => 'nullable|string|max:20',
        'address' => 'nullable|string|max:255',
    ];

    /**
     * Relationships
     */

    /**
     * Get user's bookings
     * 
     * @param string $userId
     * @return array
     */
    public function getBookings(string $userId): array
    {
        $query = "SELECT * FROM bookings WHERE user_id = :user_id";
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's payments
     * 
     * @param int $userId
     * @return array
     */
    public function getPayments(int $userId): array
    {
        $query = "SELECT p.* FROM payments p 
                 JOIN bookings b ON p.booking_id = b.id 
                 WHERE b.user_id = :user_id AND p.deleted_at IS NULL 
                 ORDER BY p.created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }
    
    /**
     * Get all transactions for a user
     * 
     * @param int $userId
     * @return array
     */
    public function getTransactions(int $userId): array
    {
        $query = "SELECT t.* FROM transaction_logs t 
                 WHERE t.user_id = :user_id 
                 ORDER BY t.created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's notifications
     * 
     * @param string $userId
     * @return array
     */
    public function getNotifications(string $userId): array
    {
        $query = "SELECT * FROM notifications WHERE user_id = :user_id";
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's logs
     * 
     * @param string $userId
     * @return array
     */
    public function getLogs(string $userId): array
    {
        $query = "SELECT * FROM logs WHERE user_reference = :user_id";
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's audit trails
     * 
     * @param string $userId
     * @return array
     */
    public function getAuditTrails(string $userId): array
    {
        $query = "SELECT * FROM audit_trails WHERE user_reference = :user_id";
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's contracts
     * 
     * @param string $userId
     * @return array
     */
    public function getContracts(string $userId): array
    {
        $query = "SELECT * FROM contracts WHERE user_reference = :user_id";
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Accessors & Helpers
     */
    
    /**
     * Get full name by combining first and last name
     * 
     * @param array $user User data
     * @return string
     */
    public static function getFullName(array $user): string
    {
        return "{$user['name']} {$user['surname']}";
    }

    /**
     * Check if user is an admin
     * 
     * @param array $user User data
     * @return bool
     */
    public static function isAdmin(array $user): bool
    {
        return in_array($user['role'], ['admin', 'super_admin']);
    }

    /**
     * Check if user is a super admin
     * 
     * @param array $user User data
     * @return bool
     */
    public static function isSuperAdmin(array $user): bool
    {
        return $user['role'] === 'super_admin';
    }

    /**
     * Check if user has a specific permission
     * 
     * @param array $user User data
     * @param string $permission
     * @return bool
     */
    public static function hasPermission(array $user, string $permission): bool
    {
        $rolePermissions = [
            'user' => ['read_own'],
            'admin' => ['read_own', 'read_all', 'write_all'],
            'super_admin' => ['read_own', 'read_all', 'write_all', 'delete_all'],
        ];

        return in_array($permission, $rolePermissions[$user['role']] ?? []);
    }

    /**
     * Password handling
     */
    
    /**
     * Hash a password
     * 
     * @param string $password
     * @return string
     */
    public static function hashPassword(string $password): string
    {
        return Hash::make($password);
    }
    
    /**
     * Verify a password
     * 
     * @param string $password
     * @param string $hash
     * @return bool
     */
    public static function verifyPassword(string $password, string $hash): bool
    {
        return Hash::check($password, $hash);
    }

    /**
     * Database operations
     */

    /**
     * Create a new user
     * 
     * @param array $data
     * @return int The ID of the created user (or UUID converted to integer if using UUID)
     */
    public function create(array $data): int
    {
        if (isset($data['password'])) {
            $data['password_hash'] = self::hashPassword($data['password']);
            unset($data['password']);
        }

        if ($this->useUuid && !isset($data['id'])) {
            $data['id'] = Uuid::uuid4()->toString();
        }

        if ($this->useTimestamps) {
            $now = date('Y-m-d H:i:s');
            $data['created_at'] = $now;
            $data['updated_at'] = $now;
        }

        $id = $this->dbHelper->insert($this->table, $data);
        
        // Log the creation if audit service is available
        if ($this->auditService) {
            $this->auditService->logEvent('user', 'created', [
                'id' => $id,
                'email' => $data['email'] ?? 'unknown'
            ]);
        }

        // Ensure we return an integer to match the parent class signature
        return is_numeric($id) ? (int)$id : crc32($id);
    }

    /**
     * Update user data
     * 
     * @param string|int $id
     * @param array $data
     * @return bool
     */
    public function update(string|int $id, array $data): bool
    {
        if (isset($data['password'])) {
            $data['password_hash'] = self::hashPassword($data['password']);
            unset($data['password']);
        }

        if ($this->useTimestamps) {
            $data['updated_at'] = date('Y-m-d H:i:s');
        }

        $conditions = ['id' => $id];
        if ($this->useSoftDeletes) {
            $conditions['deleted_at IS NULL'] = null;
        }

        $result = $this->dbHelper->update($this->table, $data, $conditions);
        
        // Log the update if audit service is available
        if ($result && $this->auditService) {
            $this->auditService->logEvent('user', 'updated', [
                'id' => $id,
                'updated_fields' => array_keys($data)
            ]);
        }

        return $result;
    }

    /**
     * Find a user by their email address
     * 
     * @param string $email
     * @return array|null
     */
    public function findByEmail(string $email): ?array
    {
        try {
            $stmt = $this->pdo->prepare("SELECT * FROM users WHERE email = ? AND active = 1");
            $stmt->execute([$email]);
            return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
        } catch (Exception $e) {
            $this->logger->error("Error finding user by email: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Find a user by their ID
     * 
     * @param string|int $id
     * @return array|null
     */
    public function find(string|int $id): ?array
    {
        try {
            $stmt = $this->pdo->prepare("SELECT * FROM users WHERE id = ? AND active = 1");
            $stmt->execute([$id]);
            return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
        } catch (Exception $e) {
            $this->logger->error("Error finding user by ID: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Validate a user's password
     */
    public function validatePassword(string $email, string $password): ?array
    {
        $user = $this->findByEmail($email);
        
        if (!$user || !password_verify($password, $user['password_hash'])) {
            return null;
        }
        
        return $user;
    }

    /**
     * Update a user's password
     */
    public function updatePassword(int $userId, string $newPassword): bool
    {
        try {
            $hashedPassword = $this->hashPassword($newPassword);
            return $this->update($userId, [
                'password_hash' => $hashedPassword,
                'updated_at' => date('Y-m-d H:i:s')
            ]);
        } catch (Exception $e) {
            $this->logger->error("Error updating password: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Create a password reset token
     */
    public function createPasswordReset(string $email, string $token, ?string $ipAddress, string $expiry): bool
    {
        try {
            $stmt = $this->pdo->prepare("INSERT INTO password_resets (email, token, ip_address, expires_at, created_at) VALUES (?, ?, ?, ?, ?)");
            return $stmt->execute([
                $email, 
                $token, 
                $ipAddress, 
                $expiry, 
                date('Y-m-d H:i:s')
            ]);
        } catch (Exception $e) {
            $this->logger->error("Error creating password reset: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Verify a password reset token
     */
    public function verifyResetToken(string $token): ?array
    {
        try {
            $stmt = $this->pdo->prepare(
                "SELECT * FROM password_resets 
                 WHERE token = ? AND used = 0 AND expires_at > ? 
                 ORDER BY created_at DESC LIMIT 1"
            );
            $stmt->execute([$token, date('Y-m-d H:i:s')]);
            return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
        } catch (Exception $e) {
            $this->logger->error("Error verifying reset token: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Mark a reset token as used
     */
    public function markResetTokenUsed(int $tokenId): bool
    {
        try {
            $stmt = $this->pdo->prepare("UPDATE password_resets SET used = 1, used_at = ? WHERE id = ?");
            return $stmt->execute([date('Y-m-d H:i:s'), $tokenId]);
        } catch (Exception $e) {
            $this->logger->error("Error marking reset token as used: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Get active users (not deleted)
     * 
     * @return array
     */
    public function getActive(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE deleted_at IS NULL";
        return $this->dbHelper->select($query);
    }

    /**
     * Get users with a specific role
     * 
     * @param string $role
     * @return array
     */
    public function getWithRole(string $role): array
    {
        $query = "SELECT * FROM {$this->table} WHERE role = :role";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        return $this->dbHelper->select($query, [':role' => $role]);
    }

    /**
     * Get a user by email
     * 
     * @param string $email
     * @return array|null
     */
    public function getUserByEmail(string $email): ?array
    {
        return $this->findByEmail($email);
    }

    /**
     * Update user profile
     * 
     * @param string|int $userId
     * @param array $profileData
     * @return bool
     */
    public function updateProfile(string|int $userId, array $profileData): bool
    {
        try {
            // Filter out sensitive fields that shouldn't be updated via profile update
            $allowedFields = ['name', 'surname', 'phone', 'address'];
            $filteredData = array_intersect_key($profileData, array_flip($allowedFields));
            
            return $this->update($userId, $filteredData);
        } catch (Exception $e) {
            $this->logger->error("Error updating user profile: " . $e->getMessage(), [
                'user_id' => $userId,
                'exception' => $e
            ]);
            throw $e;
        }
    }

    /**
     * Update user role
     * 
     * @param string|int $userId
     * @param string $newRole
     * @return bool
     * @throws Exception If role is invalid
     */
    public function updateUserRole(string|int $userId, string $newRole): bool
    {
        try {
            // Validate role
            $validRoles = ['user', 'admin', 'super_admin'];
            if (!in_array($newRole, $validRoles)) {
                throw new Exception("Invalid role: {$newRole}");
            }

            return $this->update($userId, ['role' => $newRole]);
        } catch (Exception $e) {
            $this->logger->error("Error updating user role: " . $e->getMessage(), [
                'user_id' => $userId,
                'new_role' => $newRole,
                'exception' => $e
            ]);
            throw $e;
        }
    }

    /**
     * Soft delete a user
     * 
     * @param string|int $userId
     * @return bool
     */
    public function deleteUser(string|int $userId): bool
    {
        try {
            // Fetch the user first to check role
            $user = $this->find($userId);
            
            // Return false if the user is a super admin
            if ($user && isset($user['role']) && $user['role'] === 'super_admin') {
                return false;
            }

            if (!$this->useSoftDeletes) {
                throw new Exception("Soft deletes not enabled for User model");
            }
            
            $data = ['deleted_at' => date('Y-m-d H:i:s')];
            $conditions = ['id' => $userId];
            
            $result = $this->dbHelper->update($this->table, $data, $conditions);
            
            if ($result && $this->auditService) {
                $this->auditService->logEvent('user', 'deleted', [
                    'id' => $userId
                ]);
            }
            
            return $result;
        } catch (Exception $e) {
            $this->logger->error("Error deleting user: " . $e->getMessage(), [
                'user_id' => $userId,
                'exception' => $e
            ]);
            throw $e;
        }
    }

    /**
     * Change user password
     * 
     * @param string|int $userId 
     * @param string $currentPassword
     * @param string $newPassword
     * @return bool
     * @throws Exception If current password is invalid
     */
    public function changePassword(string|int $userId, string $currentPassword, string $newPassword): bool
    {
        try {
            // Get user first to verify current password
            $user = $this->find($userId);
            
            if (!$user) {
                throw new Exception("User not found");
            }
            
            // Verify current password
            if (!self::verifyPassword($currentPassword, $user['password_hash'])) {
                throw new Exception("Current password is incorrect");
            }
            
            // Update password
            return $this->updatePassword($userId, $newPassword);
        } catch (Exception $e) {
            $this->logger->error("Error changing password: " . $e->getMessage(), [
                'user_id' => $userId,
                'exception' => $e
            ]);
            throw $e;
        }
    }
}
=== App/Models/BaseModel.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;
use PDO;

/**
 * BaseModel
 * 
 * Base class for all models that use the DatabaseHelper instead of Eloquent
 */
abstract class BaseModel
{
    /**
     * @var string The table associated with the model
     */
    protected $table;
    
    /**
     * @var string The name of the resource for audit logging
     */
    protected $resourceName;
    
    /**
     * @var bool Whether the model uses timestamps
     */
    protected $useTimestamps = true;
    
    /**
     * @var bool Whether the model uses soft deletes
     */
    protected $useSoftDeletes = false;
    
    /**
     * @var bool Whether the model uses UUID as primary key
     */
    protected $useUuid = false;
    
    /**
     * @var DatabaseHelper Database helper instance
     */
    protected $dbHelper;
    
    /**
     * @var AuditService|null Audit service instance
     */
    protected $auditService;
    
    /**
     * @var PDO PDO instance
     */
    protected $pdo;

    /**
     * Constructor
     *
     * @param DatabaseHelper|null $dbHelper
     * @param AuditService|null $auditService
     */
    public function __construct(DatabaseHelper $dbHelper = null, AuditService $auditService = null)
    {
        $this->dbHelper = $dbHelper ?? new DatabaseHelper();
        $this->auditService = $auditService;
        $this->pdo = $this->dbHelper->getPdo();
    }

    /**
     * Find a record by ID
     *
     * @param int $id
     * @return array|null
     */
    public function find(int|string $id): ?array
    {
        $query = "SELECT * FROM {$this->table} WHERE id = :id";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':id' => $id]);
        return $result ? $result[0] : null;
    }

    /**
     * Get all records from the table
     *
     * @return array
     */
    public function all(): array
    {
        $query = "SELECT * FROM {$this->table}";
        
        if ($this->useSoftDeletes) {
            $query .= " WHERE deleted_at IS NULL";
        }
        
        return $this->dbHelper->select($query);
    }

    /**
     * Create a new record
     *
     * @param array $data
     * @return int The ID of the created record
     */
    public function create(array $data): int
    {
        if ($this->useTimestamps && !isset($data['created_at'])) {
            $data['created_at'] = date('Y-m-d H:i:s');
        }
        
        if ($this->useTimestamps && !isset($data['updated_at'])) {
            $data['updated_at'] = date('Y-m-d H:i:s');
        }
        
        if ($this->useUuid && !isset($data['id'])) {
            $data['id'] = \Ramsey\Uuid\Uuid::uuid4()->toString();
        }
        
        $id = $this->dbHelper->insert($this->table, $data);
        
        // Log audit event if service is available
        if ($this->auditService && $this->resourceName) {
            $this->auditService->logEvent($this->resourceName, 'create', [
                'id' => $id,
                'data' => $data
            ]);
        }
        
        return $id;
    }

    /**
     * Update a record
     *
     * @param int $id
     * @param array $data
     * @return bool
     */
    public function update(int|string $id, array $data): bool
    {
        if ($this->useTimestamps) {
            $data['updated_at'] = date('Y-m-d H:i:s');
        }
        
        $conditions = ['id' => $id];
        
        if ($this->useSoftDeletes) {
            $conditions['deleted_at IS NULL'] = null;
        }
        
        $result = $this->dbHelper->update($this->table, $data, $conditions);
        
        // Log audit event if service is available
        if ($result && $this->auditService && $this->resourceName) {
            $this->auditService->logEvent($this->resourceName, 'update', [
                'id' => $id,
                'updated_fields' => array_keys($data)
            ]);
        }
        
        return $result;
    }

    /**
     * Delete a record (soft delete if enabled)
     *
     * @param int $id
     * @return bool
     */
    public function delete(int|string $id): bool
    {
        if ($this->useSoftDeletes) {
            $data = ['deleted_at' => date('Y-m-d H:i:s')];
            $result = $this->dbHelper->update($this->table, $data, ['id' => $id]);
        } else {
            $result = $this->dbHelper->delete($this->table, ['id' => $id]);
        }
        
        // Log audit event if service is available
        if ($result && $this->auditService && $this->resourceName) {
            $this->auditService->logEvent($this->resourceName, 'delete', [
                'id' => $id
            ]);
        }
        
        return $result;
    }
}
=== App/Models/Report.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Report Model
 *
 * Represents an admin report in the system.
 */
class Report extends BaseModel
{
    protected $table = 'reports';
    protected $resourceName = 'report';
    protected $useSoftDeletes = true;

    /**
     * Attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'admin_id',
        'title',
        'content',
        'status',
        'created_at',
        'updated_at'
    ];

    /**
     * Get reports within a date range.
     *
     * @param string $start
     * @param string $end
     * @return array
     */
    public function getByDateRange(string $start, string $end): array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE created_at BETWEEN :start AND :end
        ";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':start' => $start, ':end' => $end]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Get the admin who created the report.
     *
     * @param int $reportId
     * @return array|null
     */
    public function getAdmin(int $reportId): ?array
    {
        $report = $this->find($reportId);
        
        if (!$report || !isset($report['admin_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM admins WHERE id = :admin_id";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':admin_id' => $report['admin_id']]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }
}
=== App/Models/AuditTrail.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * AuditTrail Model
 *
 * Represents the audit trails stored in the database and provides methods
 * for accessing and filtering the logs.
 */
class AuditTrail extends BaseModel
{
    protected $table = 'audit_trails';
    protected $resourceName = 'audit_trail';
    protected $useTimestamps = true;
    protected $useSoftDeletes = false;

    /**
     * Retrieve audit trail records based on filters.
     *
     * @param array $filters An associative array of filters:
     *                       - 'user_id' (int): Filter by user ID.
     *                       - 'booking_id' (int): Filter by booking ID.
     *                       - 'action' (string): Filter by action type.
     *                       - 'start_date' (string): Filter by start date (YYYY-MM-DD).
     *                       - 'end_date' (string): Filter by end date (YYYY-MM-DD).
     * @return array An array of matching audit trail records.
     */
    public function getLogs(array $filters = []): array
    {
        $query = "SELECT * FROM {$this->table} WHERE 1=1";
        $params = [];

        if (!empty($filters['user_id'])) {
            $query .= " AND user_id = :user_id";
            $params[':user_id'] = $filters['user_id'];
        }

        if (!empty($filters['booking_id'])) {
            $query .= " AND booking_id = :booking_id";
            $params[':booking_id'] = $filters['booking_id'];
        }

        if (!empty($filters['action'])) {
            $query .= " AND action = :action";
            $params[':action'] = $filters['action'];
        }

        if (!empty($filters['start_date'])) {
            $query .= " AND created_at >= :start_date";
            $params[':start_date'] = $filters['start_date'];
        }

        if (!empty($filters['end_date'])) {
            $query .= " AND created_at <= :end_date";
            $params[':end_date'] = $filters['end_date'];
        }

        $query .= " ORDER BY created_at DESC";

        return $this->dbHelper->select($query, $params);
    }
}
=== App/Models/RefundLog.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * RefundLog Model
 *
 * Represents a refund and handles interactions with the `refund_logs` table.
 */
class RefundLog extends BaseModel
{
    protected $table = 'refund_logs';
    protected $resourceName = 'refund_log';
    protected $useTimestamps = true;
    protected $useSoftDeletes = true;

    /**
     * Get the user associated with the refund.
     *
     * @param int $refundId
     * @return array|null
     */
    public function getUser(int $refundId): ?array
    {
        $refund = $this->find($refundId);
        
        if (!$refund || !isset($refund['user_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM users WHERE id = :user_id";
        $result = $this->dbHelper->select($query, [':user_id' => $refund['user_id']]);
        return $result[0] ?? null;
    }

    /**
     * Get the payment associated with the refund.
     *
     * @param int $refundId
     * @return array|null
     */
    public function getPayment(int $refundId): ?array
    {
        $refund = $this->find($refundId);
        
        if (!$refund || !isset($refund['payment_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM payments WHERE id = :payment_id";
        $result = $this->dbHelper->select($query, [':payment_id' => $refund['payment_id']]);
        return $result[0] ?? null;
    }
}=== App/Models/Signature.php ===
namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;
use App\Services\EncryptionService;

class Signature extends BaseModel
{
    protected $table = 'signatures';
    protected $resourceName = 'signature';
    protected $useTimestamps = true;
    protected $useSoftDeletes = false;

    /**
     * Create a new signature.
     *
     * @param array $data
     * @return int
     */
    public function create(array $data): int
    {
        if (isset($data['signature'])) {
            $data['signature'] = EncryptionService::encrypt($data['signature']);
        }

        return parent::create($data);
    }

    /**
     * Update a signature.
     *
     * @param int $id
     * @param array $data
     * @return bool
     */
    public function update(int $id, array $data): bool
    {
        if (isset($data['signature'])) {
            $data['signature'] = EncryptionService::encrypt($data['signature']);
        }

        return parent::update($id, $data);
    }

    /**
     * Get the signature.
     *
     * @param int $signatureId
     * @return string|null
     */
    public function getSignature(int $signatureId): ?string
    {
        $signature = $this->find($signatureId);

        if ($signature && isset($signature['signature'])) {
            return EncryptionService::decrypt($signature['signature']);
        }

        return null;
    }

    /**
     * Get the user associated with the signature.
     *
     * @param int $signatureId
     * @return array|null
     */
    public function getUser(int $signatureId): ?array
    {
        $signature = $this->find($signatureId);
        
        if (!$signature || !isset($signature['user_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM users WHERE id = :user_id";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':user_id' => $signature['user_id']]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }
}
=== App/Models/PasswordReset.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * PasswordReset Model
 *
 * Represents a password reset request.
 */
class PasswordReset extends BaseModel
{
    protected $table = 'password_resets';
    protected $resourceName = 'password_reset';
    protected $useTimestamps = true;
    protected $useSoftDeletes = false;

    /**
     * Find a password reset by token.
     *
     * @param string $token
     * @return array|null
     */
    public function findByToken(string $token): ?array
    {
        $query = "SELECT * FROM {$this->table} WHERE token = :token";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':token' => $token]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }

    /**
     * Create a new password reset.
     *
     * @param array $data
     * @return int
     */
    public function create(array $data): int
    {
        // Generate a token if not provided
        if (!isset($data['token'])) {
            $data['token'] = bin2hex(random_bytes(32));
        }

        $id = parent::create($data);

        // Add custom audit logging if needed
        if ($this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'password_reset_created', [
                'id' => $id,
                'email' => $data['email'] ?? null
            ]);
        }

        return $id;
    }
}
=== App/Queues/DocumentQueue.php ===
<?php

namespace App\Queues;

use DocumentManager\Services\FileStorage;
use Psr\Log\LoggerInterface;

class DocumentQueue
{
    private FileStorage $fileStorage;
    private string $queueFile;
    private LoggerInterface $logger;
    private const MAX_RETRY_ATTEMPTS = 3;

    public function __construct(LoggerInterface $logger, FileStorage $fileStorage, string $queueFile)
    {
        $this->logger = $logger;
        $this->fileStorage = $fileStorage;
        $this->queueFile = $queueFile;
    }

    public function push(array $document): void
    {
        $queue = $this->getQueue();
        $document['attempts'] = 0;
        $queue[] = $document;
        $this->saveQueue($queue);
        $this->logger->info('Document added to queue', $document);
    }

    public function process(): void
    {
        $queue = $this->getQueue();
        foreach ($queue as $index => $document) {
            try {
                $success = $this->fileStorage->storeFile($document['file_path'], $document['destination']);

                if ($success) {
                    unset($queue[$index]);
                    $this->logger->info('Document processed successfully', $document);
                } else {
                    $queue[$index]['attempts']++;
                    $this->logger->warning('Document processing failed, retrying...', [
                        'document' => $document,
                        'attempts' => $queue[$index]['attempts'],
                    ]);
                }

                if ($queue[$index]['attempts'] >= self::MAX_RETRY_ATTEMPTS) {
                    $this->logger->error('Max retry attempts reached for document', $document);
                    unset($queue[$index]);
                }
            } catch (\Exception $e) {
                $this->logger->error('Error processing document', [
                    'document' => $document,
                    'error' => $e->getMessage(),
                ]);
            }
        }

        $this->saveQueue(array_values($queue));
    }

    private function getQueue(): array
    {
        if (!file_exists($this->queueFile)) {
            return [];
        }
        return json_decode(file_get_contents($this->queueFile), true) ?? [];
    }

    private function saveQueue(array $queue): void
    {
        file_put_contents($this->queueFile, json_encode($queue, JSON_PRETTY_PRINT));
    }
}
=== App/Queues/NotificationQueue.php ===
<?php

namespace App\Queues;

use App\Services\NotificationService;
use Psr\Log\LoggerInterface;

class NotificationQueue
{
    private string $queueFile;
    private NotificationService $notificationService;
    private LoggerInterface $logger;
    private const MAX_RETRY_ATTEMPTS = 3;

    public function __construct(
        LoggerInterface $logger,
        NotificationService $notificationService,
        string $queueFile
    ) {
        $this->logger = $logger;
        $this->notificationService = $notificationService;
        $this->queueFile = $queueFile;
    }

    /**
     * Push a notification onto the queue
     */
    public function push(array $notification): void
    {
        $queue = $this->getQueue();
        $notification['attempts'] = 0; // Initialize retry attempts
        $queue[] = $notification;
        $this->saveQueue($queue);
        $this->logger->info('Notification added to queue', $notification);
    }

    /**
     * Process the notification queue
     */
    public function process(): void
    {
        $queue = $this->getQueue();
        foreach ($queue as $index => $notification) {
            try {
                $success = $this->notificationService->sendNotification(
                    $notification['user_id'],
                    $notification['type'],
                    $notification['message'],
                    $notification['options']
                );

                if ($success) {
                    unset($queue[$index]); // Remove notification on success
                    $this->logger->info('Notification processed successfully', $notification);
                } else {
                    $queue[$index]['attempts']++;
                    $this->logger->warning('Notification failed, retrying...', [
                        'notification' => $notification,
                        'attempts' => $queue[$index]['attempts'],
                    ]);
                }

                // Remove notifications that exceed retry attempts
                if ($queue[$index]['attempts'] >= self::MAX_RETRY_ATTEMPTS) {
                    $this->logger->error('Max retry attempts reached for notification', $notification);
                    unset($queue[$index]);
                }
            } catch (\Exception $e) {
                $this->logger->error('Error processing notification', [
                    'notification' => $notification,
                    'error' => $e->getMessage(),
                ]);
            }
        }

        $this->saveQueue(array_values($queue)); // Reindex and save the queue
    }

    /**
     * Retrieve the current queue
     */
    private function getQueue(): array
    {
        if (!file_exists($this->queueFile)) {
            return [];
        }
        return json_decode(file_get_contents($this->queueFile), true) ?? [];
    }

    /**
     * Save the current queue to the file
     */
    private function saveQueue(array $queue): void
    {
        file_put_contents($this->queueFile, json_encode($queue, JSON_PRETTY_PRINT));
    }
}
=== App/Config/fraud_detection.php ===
<?php
/**
 * Fraud detection configuration
 */
return [
    // Risk thresholds for different risk levels
    'thresholds' => [
        'high' => 70,
        'medium' => 50,
        'low' => 30
    ],
    
    // Fraud indicator weights for scoring
    'indicator_weights' => [
        'high_amount' => 15,
        'multiple_attempts' => 20,
        'unusual_location' => 30,
        'address_mismatch' => 25,
        'card_country_mismatch' => 35,
        'rapid_transactions' => 18,
        'unusual_time' => 10,
        'ip_proxy_detected' => 40,
        'device_mismatch' => 28,
        'risky_email_domain' => 15
    ],
    
    // Rule parameters
    'rules' => [
        'high_amount_threshold' => 1000,
        'max_payment_attempts' => 3,
        'min_transaction_interval_minutes' => 5,
        'business_hours_start' => 6,
        'business_hours_end' => 23,
        'high_frequency_threshold' => 5 // transactions per hour
    ],
    
    // Risky email domains
    'risky_email_domains' => [
        'tempmail.com',
        'throwaway.com',
        'mailinator.com',
        'guerrillamail.com',
        'yopmail.com',
        'sharklasers.com',
        'dispostable.com',
        '10minutemail.com',
        'temp-mail.org'
    ],
    
    // Recommendations based on risk level
    'recommendations' => [
        'high' => 'block_transaction',
        'medium' => 'additional_verification',
        'low' => 'flag_for_review',
        'minimal' => 'proceed'
    ],
    
    // Custom rules can be added here
    'custom_rules' => [
        // Example of a custom rule:
        /*
        'suspicious_ip_range' => [
            'weight' => 25,
            'condition' => function($data) {
                // Check if IP is in suspicious range
                if (isset($data['ip_address'])) {
                    return strpos($data['ip_address'], '192.168.') === 0;
                }
                return false;
            }
        ]
        */
    ]
];
=== App/Services/TemplateService.php ===
<?php

namespace App\Services;

use Exception;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use App\Models\DocumentTemplate;
use App\Services\AuditService;

/**
 * Template Service
 *
 * Provides functionality for managing and rendering document templates.
 * Templates support placeholders for dynamic data injection.
 */
class TemplateService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private AuditService $auditService;

    /**
     * Constructor
     *
     * @param LoggerInterface $logger The logger instance.
     * @param ExceptionHandler $exceptionHandler The exception handler instance.
     * @param AuditService $auditService The audit service instance.
     */
    public function __construct(
        LoggerInterface $logger, 
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    /**
     * List all available templates.
     *
     * @return array List of templates.
     */
    public function listTemplates(): array
    {
        return DocumentTemplate::all()->toArray();
    }

    /**
     * Load the content of a template.
     *
     * @param int|string $templateId The ID or name of the template.
     * @return DocumentTemplate The template.
     * @throws Exception If the template cannot be found.
     */
    public function loadTemplate($templateId): DocumentTemplate
    {
        try {
            $template = is_numeric($templateId) 
                ? DocumentTemplate::findOrFail($templateId)
                : DocumentTemplate::where('name', $templateId)->firstOrFail();
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[system] Loaded template", ['template' => $template->name]);
            }
            
            $this->auditService->logEvent('template_loaded', [
                'template_id' => $template->id,
                'template_name' => $template->name
            ]);
            
            return $template;
        } catch (\Exception $e) {
            $this->logger->error("[system] ❌ Error loading template: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Render a template by replacing placeholders with data.
     *
     * @param int|string $templateId The ID or name of the template.
     * @param array $data Key-value pairs to replace placeholders.
     * @return string Rendered template with placeholders replaced.
     * @throws Exception If the template cannot be loaded.
     */
    public function renderTemplate($templateId, array $data): string
    {
        $template = $this->loadTemplate($templateId);
        $content = $template->content;

        foreach ($data as $key => $value) {
            $placeholder = '{{' . $key . '}}';
            $content = str_replace($placeholder, htmlspecialchars((string)$value, ENT_QUOTES, 'UTF-8'), $content);
        }

        $this->auditService->logEvent('template_rendered', [
            'template_id' => $template->id,
            'template_name' => $template->name
        ]);
        
        return $content;
    }

    /**
     * Save a new or updated template.
     *
     * @param string $templateName The name of the template.
     * @param string $content The template content to save.
     * @param int|null $templateId The template ID for updates (null for new templates).
     * @return DocumentTemplate The saved template.
     * @throws Exception If saving fails.
     */
    public function saveTemplate(string $templateName, string $content, ?int $templateId = null): DocumentTemplate
    {
        try {
            if ($templateId) {
                $template = DocumentTemplate::findOrFail($templateId);
                $template->name = $templateName;
                $template->content = $content;
                $template->save();
            } else {
                $template = DocumentTemplate::create([
                    'name' => $templateName,
                    'content' => $content
                ]);
            }
            
            return $template;
        } catch (\Exception $e) {
            $this->logger->error("Error saving template", ['template' => $templateName, 'error' => $e->getMessage()]);
            throw $e;
        }
    }

    /**
     * Delete a template.
     *
     * @param int $templateId The ID of the template to delete.
     * @return bool True if deleted successfully.
     * @throws Exception If the template cannot be found or deleted.
     */
    public function deleteTemplate(int $templateId): bool
    {
        try {
            $template = DocumentTemplate::findOrFail($templateId);
            $template->delete();
            
            return true;
        } catch (\Exception $e) {
            $this->logger->error("Error deleting template", ['template_id' => $templateId, 'error' => $e->getMessage()]);
            throw $e;
        }
    }
}
=== App/Services/MetricsService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use Exception;

class MetricsService
{
    public const DEBUG_MODE = true;
    private DatabaseHelper $db;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        DatabaseHelper $db
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->db = $db;
    }

    public function getDashboardMetrics(): array
    {
        try {
            $totalUsers        = $this->db->table('users')->count();
            $activeUsers       = $this->db->table('users')->where('active', true)->count();
            $totalBookings     = $this->db->table('bookings')->count();
            $completedBookings = $this->db->table('bookings')->where('status', 'completed')->count();
            $canceledBookings  = $this->db->table('bookings')->where('status', 'canceled')->count();
            $totalRevenue      = $this->db->table('payments')->where('status', 'completed')->sum('amount');
            $totalRefunds      = $this->db->table('payments')
                                          ->where('status', 'completed')
                                          ->where('type', 'refund')
                                          ->sum('amount');
            
            $metrics = [
                'total_users'         => $totalUsers,
                'active_users'        => $activeUsers,
                'total_bookings'      => $totalBookings,
                'completed_bookings'  => $completedBookings,
                'canceled_bookings'   => $canceledBookings,
                'total_revenue'       => $totalRevenue,
                'total_refunds'       => $totalRefunds,
            ];
            $metrics['net_revenue'] = $totalRevenue - $totalRefunds;
            if (self::DEBUG_MODE) {
                $this->logger->info("[Metrics] Dashboard metrics retrieved successfully");
            }
            return $metrics;
        } catch (Exception $e) {
            $this->logger->error("[DB] ❌ MetricsService error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return [];
        }
    }
}
=== App/Services/UserService.php ===
<?php

namespace App\Services;

use Psr\Log\LoggerInterface;
use Firebase\JWT\JWT;
use Exception;
use App\Helpers\DatabaseHelper;
use App\Helpers\ApiHelper;
use App\Helpers\ExceptionHandler;
use App\Models\User;

class UserService
{
    public const DEBUG_MODE = true;

    private DatabaseHelper $db;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private AuditService $auditService;
    private User $userModel;
    private string $jwtSecret;

    public function __construct(
        LoggerInterface $logger,
        DatabaseHelper $db,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService,
        User $userModel,
        string $jwtSecret = 'default_secret'
    ) {
        $this->logger = $logger;
        $this->db = $db;
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
        $this->userModel = $userModel;
        $this->jwtSecret = $jwtSecret;
        
        if (self::DEBUG_MODE) {
            $this->logger->info("[auth] UserService initialized", ['service' => 'UserService']);
        }
    }

    public function createUser(array $data): array
    {
        $rules = User::$rules;

        try {
            Validator::validate($data, $rules);
        } catch (Exception $e) {
            return ['status' => 'error', 'message' => $e->getMessage()];
        }

        try {
            // Use User model to create the user
            $userId = $this->userModel->create($data);
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[auth] ✅ User registered.", ['userId' => $userId]);
            }
            
            return ['status' => 'success', 'message' => 'User created successfully', 'data' => ['user_id' => $userId]];
        } catch (Exception $e) {
            $this->logger->error("[auth] ❌ User creation failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'User creation failed'];
        }
    }

    public function updateUser(int $id, array $data): array
    {
        try {
            // First check if user exists
            $user = $this->userModel->find($id);
            if (!$user) {
                $this->logger->error("User not found", ['userId' => $id]);
                return ['status' => 'error', 'message' => 'User not found', 'code' => 404];
            }
            
            // Use User model to update the user
            $result = $this->userModel->updateProfile($id, $data);
            
            if ($result) {
                // Changed from audit service to logger for profile updates
                $this->logger->info("✅ User profile updated", [
                    'userId' => $id,
                    'fields' => array_keys($data)
                ]);
                return ['status' => 'success', 'message' => 'User updated successfully', 'data' => ['user_id' => $id]];
            } else {
                return ['status' => 'error', 'message' => 'User update failed'];
            }
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'User update failed: ' . $e->getMessage()];
        }
    }

    public function updateUserRole(int $id, string $role): array
    {
        try {
            // First check if user exists
            $user = $this->userModel->find($id);
            if (!$user) {
                $this->logger->error("User not found", ['userId' => $id]);
                return ['status' => 'error', 'message' => 'User not found', 'code' => 404];
            }
            
            // Use User model to update role
            $result = $this->userModel->updateUserRole($id, $role);
            
            if ($result) {
                $this->logger->info("✅ User role updated.", ['userId' => $id, 'role' => $role]);
                
                // Keep audit logging for admin role updates
                $this->auditService->logEvent(
                    'user',
                    'Role changed',
                    [
                        'user_id' => $id, 
                        'previous_role' => $user['role'] ?? 'unknown',
                        'new_role' => $role
                    ],
                    $id,
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
                
                return ['status' => 'success', 'message' => 'User role updated successfully'];
            } else {
                return ['status' => 'error', 'message' => 'User role update failed'];
            }
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'Role update failed: ' . $e->getMessage()];
        }
    }

    public function deleteUser(int $id): array
    {
        try {
            // First check if user exists
            $user = $this->userModel->find($id);
            if (!$user) {
                $this->logger->error("User not found", ['userId' => $id]);
                return ['status' => 'error', 'message' => 'User not found', 'code' => 404];
            }
            
            // Check if user is a super admin (this prevents super admin deletion)
            if (isset($user['role']) && $user['role'] === 'super_admin') {
                $this->logger->warning("Attempted to delete super admin account", ['userId' => $id]);
                return ['status' => 'error', 'message' => 'Super admin accounts cannot be deleted', 'code' => 403];
            }
            
            // Use User model to delete user
            $result = $this->userModel->deleteUser($id);
            
            if ($result) {
                $this->logger->info("✅ User deleted.", ['userId' => $id]);
                
                // Keep audit log for user deletions
                $this->auditService->logEvent(
                    'user',
                    'User deleted',
                    [
                        'user_id' => $id,
                        'user_email' => $user['email'] ?? 'unknown',
                        'user_role' => $user['role'] ?? 'unknown'
                    ],
                    null,
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
                
                return ['status' => 'success', 'message' => 'User deleted successfully'];
            } else {
                return ['status' => 'error', 'message' => 'User deletion failed'];
            }
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'User deletion failed: ' . $e->getMessage()];
        }
    }

    public function changePassword(int $id, string $currentPassword, string $newPassword): array
    {
        try {
            // Use User model to change password
            $result = $this->userModel->changePassword($id, $currentPassword, $newPassword);
            
            if ($result) {
                $this->logger->info("✅ Password changed.", ['userId' => $id]);
                
                // Log password change through audit service
                $this->auditService->logEvent(
                    'user',
                    'Password changed',
                    ['user_id' => $id],
                    $id,
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
                
                return ['status' => 'success', 'message' => 'Password changed successfully'];
            } else {
                return ['status' => 'error', 'message' => 'Password change failed'];
            }
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'Password change failed: ' . $e->getMessage()];
        }
    }

    public function authenticate(string $email, string $password): array
    {
        try {
            $user = $this->userModel->getUserByEmail($email);
            
            if (!$user || !$this->userModel->verifyPassword($password, $user['password_hash'])) {
                $this->logger->error("Authentication failed", ['email' => $email]);
                
                // Use logger instead of audit service for failed authentication
                $this->logger->warning("Failed authentication attempt", [
                    'email' => $email,
                    'ip' => $_SERVER['REMOTE_ADDR'] ?? null
                ]);
                
                return ['status' => 'error', 'message' => 'Authentication failed', 'code' => 401];
            }
            
            $this->logger->info("✅ Authentication successful.", ['userId' => $user['id']]);
            
            // Use logger instead of audit service for successful authentication
            $this->logger->info("User authenticated successfully", [
                'userId' => $user['id'],
                'email' => $email,
                'ip' => $_SERVER['REMOTE_ADDR'] ?? null
            ]);
            
            $jwt = $this->generateJWT($user);
            return ['status' => 'success', 'message' => 'Authentication successful', 'data' => ['token' => $jwt]];
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'Authentication error: ' . $e->getMessage()];
        }
    }

    private function generateJWT($user): string
    {
        $payload = [
            'sub' => $user['id'],
            'email' => $user['email'],
            'role' => $user['role'],
            'iat' => time(),
            'exp' => time() + 3600,
        ];

        return JWT::encode($payload, $this->jwtSecret, 'HS256');
    }

    public function requestPasswordReset(string $email): array
    {
        try {
            $user = $this->userModel->getUserByEmail($email);
            
            if (!$user) {
                $this->logger->error("Password reset request failed", ['email' => $email]);
                return ['status' => 'error', 'message' => 'User not found', 'code' => 404];
            }
            
            $token = bin2hex(random_bytes(32));
            $expiresAt = date('Y-m-d H:i:s', strtotime('+1 hour'));
            
            // Use User model's createPasswordReset method
            $result = $this->userModel->createPasswordReset($email, $token, $_SERVER['REMOTE_ADDR'] ?? null, $expiresAt);
            
            if ($result) {
                $this->logger->info("✅ Password reset requested.", [
                    'userId' => $user['id'],
                    'email' => $email,
                    'ip' => $_SERVER['REMOTE_ADDR'] ?? null
                ]);
                
                // Keep audit logging for password reset requests
                $this->auditService->logEvent(
                    'auth',
                    'Password reset requested',
                    ['email' => $email],
                    $user['id'],
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
                
                return [
                    'status' => 'success',
                    'message' => 'Password reset requested',
                    'data' => ['reset_token' => $token]
                ];
            } else {
                return ['status' => 'error', 'message' => 'Password reset request failed'];
            }
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'Password reset request error: ' . $e->getMessage()];
        }
    }
}
=== App/Services/Validator.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

/**
 * Validator Service
 *
 * Validates input data against defined rules.
 */
class Validator
{
    public const DEBUG_MODE = true;
    private array $errors = [];
    private LoggerInterface $logger;
    private DatabaseHelper $db;
    private ExceptionHandler $exceptionHandler;

    // Updated constructor for Dependency Injection
    public function __construct(LoggerInterface $logger, DatabaseHelper $db, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->db = $db;
        $this->exceptionHandler = $exceptionHandler;
        $this->logger->debug("Validator initialized with database connection");
    }

    /**
     * Validate data against rules.
     */
    public function validate(array $data, array $rules): bool
    {
        $this->logger->debug("Starting validation with rules", ['rules' => $rules]);
        $this->errors = [];
        
        foreach ($rules as $field => $ruleSet) {
            $rulesArray = explode('|', $ruleSet);
            foreach ($rulesArray as $rule) {
                $this->applyRule($field, $data[$field] ?? null, $rule, $data);
            }
        }

        if (!empty($this->errors)) {
            if (self::DEBUG_MODE) {
                $this->logger->warning("Validation failed", ['errors' => $this->errors]);
            }

            // Throw an exception to prevent further execution
            throw new \InvalidArgumentException(json_encode(['errors' => $this->errors]));
        }

        $this->logger->debug("Validation successful");
        return true;
    }

    /**
     * Get validation errors.
     */
    public function errors(): array
    {
        return $this->errors;
    }

    /**
     * Apply a validation rule to a field.
     */
    private function applyRule(string $field, $value, string $rule, array $data): void
    {
        try {
            if ($rule === 'required' && empty($value)) {
                $this->errors[$field][] = "The {$field} field is required.";
            } elseif (strpos($rule, 'max:') === 0) {
                $maxLength = (int)explode(':', $rule)[1];
                if (!empty($value) && strlen($value) > $maxLength) {
                    $this->errors[$field][] = "The {$field} must not exceed {$maxLength} characters.";
                }
            } elseif (strpos($rule, 'min:') === 0) {
                $minLength = (int)explode(':', $rule)[1];
                if (!empty($value) && strlen($value) < $minLength) {
                    $this->errors[$field][] = "The {$field} must be at least {$minLength} characters.";
                }
            } elseif ($rule === 'email' && !empty($value) && !filter_var($value, FILTER_VALIDATE_EMAIL)) {
                $this->errors[$field][] = "The {$field} must be a valid email address.";
            } elseif (strpos($rule, 'regex:') === 0) {
                $pattern = substr($rule, 6);
                if (!empty($value) && !preg_match($pattern, $value)) {
                    $this->errors[$field][] = "The {$field} format is invalid.";
                }
            } elseif (strpos($rule, 'same:') === 0) {
                $otherField = substr($rule, 5);
                if (!empty($value) && isset($data[$otherField]) && $value !== $data[$otherField]) {
                    $this->errors[$field][] = "The {$field} and {$otherField} must match.";
                }
            } elseif (strpos($rule, 'unique:') === 0) {
                [$table, $column] = explode(',', substr($rule, 7));
                
                $this->logger->debug("Checking uniqueness", [
                    'field' => $field,
                    'table' => $table,
                    'column' => $column,
                    'value' => $value
                ]);
                
                if (!empty($value)) {
                    $pdo = $this->db->getPdo(); // Get PDO instance from DatabaseHelper
                    $stmt = $pdo->prepare("SELECT COUNT(*) FROM {$table} WHERE {$column} = ?");
                    $stmt->execute([$value]);
                    $count = (int)$stmt->fetchColumn();
                    
                    if ($count > 0) {
                        $this->errors[$field][] = "The {$field} has already been taken.";
                    }
                }
            }
        } catch (\Exception $e) {
            $this->logger->error("Validation error: " . $e->getMessage(), [
                'field' => $field,
                'rule' => $rule
            ]);
            
            // Add a generic error and continue validation
            $this->errors[$field][] = "An error occurred while validating {$field}.";
        }
    }
}=== App/Services/AdminService.php ===
<?php

namespace App\Services;

use App\Models\Admin;
use App\Services\Auth\TokenService;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class AdminService
{
    private Admin $adminModel;
    private AuditService $auditService;
    private LoggerInterface $logger;
    private TokenService $tokenService;
    private ExceptionHandler $exceptionHandler;

    public function __construct(
        Admin $adminModel,
        AuditService $auditService,
        LoggerInterface $logger,
        TokenService $tokenService,
        ExceptionHandler $exceptionHandler
    ) {
        $this->adminModel = $adminModel;
        $this->auditService = $auditService;
        $this->logger = $logger;
        $this->tokenService = $tokenService;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Validate admin token and return admin data
     */
    public function validateAdmin(ServerRequestInterface $request): ?array
    {
        $this->logger->debug("Validating admin token using secure database");
        
        // Use TokenService to extract the token
        $token = $this->tokenService->extractToken($request);
        
        if (empty($token)) {
            $this->logger->info("No authorization token provided");
            return null;
        }
        
        // Validate token and fetch admin details
        $admin = $this->adminModel->findByToken($token);
            
        if (empty($admin) || $admin['role'] !== 'admin') {
            $this->logger->info("Invalid admin token or insufficient permissions");
            return null;
        }
        
        $this->logger->info("Admin validated successfully", ['admin_id' => $admin['id']]);
        return $admin;
    }

    /**
     * Get all users with pagination
     */
    public function getAllUsers(int $page, int $adminId): array
    {
        try {
            $perPage = 10;
            
            $this->logger->debug("Fetching users with pagination");
            
            $users = $this->adminModel->getPaginatedUsers($page, $perPage);
            $totalUsers = $this->adminModel->getTotalUserCount();
            
            $this->auditService->logEvent(
                'user_list_viewed',
                'Admin viewed user list',
                ['admin_id' => $adminId, 'page' => $page],
                $adminId,
                null,
                'admin'
            );
            
            return [
                'users' => $users,
                'pagination' => [
                    'total' => $totalUsers,
                    'per_page' => $perPage,
                    'current_page' => $page,
                    'last_page' => ceil($totalUsers / $perPage)
                ]
            ];
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            throw $e; // Re-throw so controller can handle response
        }
    }

    /**
     * Update a user's role
     */
    public function updateUserRole(int $userId, string $role, int $adminId): bool
    {
        try {
            $this->logger->debug("Fetching user data for role update", [
                'user_id' => $userId
            ]);
            
            // Get user and their current role
            $user = $this->adminModel->getUserById($userId);
            
            if (empty($user)) {
                return false;
            }
            
            $oldRole = $user['role'];
            
            $this->logger->debug("Updating user role", [
                'user_id' => $userId,
                'old_role' => $oldRole,
                'new_role' => $role
            ]);
            
            // Update role
            $result = $this->adminModel->updateUserRole($userId, $role);
            
            if ($result) {
                $this->auditService->logEvent(
                    'user_role_updated',
                    "User role updated from {$oldRole} to {$role}",
                    [
                        'user_id' => $userId,
                        'old_role' => $oldRole,
                        'new_role' => $role,
                        'admin_id' => $adminId
                    ],
                    $adminId,
                    null,
                    'admin'
                );
            }
            
            return $result;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Delete a user (Soft delete)
     */
    public function deleteUser(int $userId, int $adminId): ?array
    {
        try {
            $this->logger->debug("Fetching user data for deletion", [
                'user_id' => $userId
            ]);
            
            // Get user data for audit log
            $user = $this->adminModel->getUserById($userId);
            
            if (empty($user)) {
                return null;
            }
            
            $userEmail = $user['email'];
            $userRole = $user['role'];
            
            // Check if user is a super admin
            if ($userRole === 'super_admin') {
                $this->logger->info("Attempted to delete a super_admin account", [
                    'user_id' => $userId,
                    'admin_id' => $adminId
                ]);
                return ['error' => 'Super admins cannot be deleted'];
            }
            
            $this->logger->debug("Soft deleting user", [
                'user_id' => $userId,
                'user_email' => $userEmail
            ]);
            
            // Soft delete by setting deleted_at timestamp
            $result = $this->adminModel->softDeleteUser($userId);
            
            if ($result) {
                $this->auditService->logEvent(
                    'user_deleted',
                    "User {$userEmail} was deleted",
                    [
                        'user_id' => $userId,
                        'user_email' => $userEmail,
                        'admin_id' => $adminId
                    ],
                    $adminId,
                    null,
                    'admin'
                );
            }
            
            return $result ? $user : null;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get dashboard statistics
     */
    public function getDashboardData(int $adminId): array
    {
        try {
            $this->logger->debug("Fetching dashboard statistics");
            
            $dashboardData = $this->adminModel->getDashboardStatistics();
            
            $this->auditService->logEvent(
                'dashboard_viewed',
                'Admin viewed dashboard',
                ['admin_id' => $adminId],
                $adminId,
                null,
                'admin'
            );
            
            return $dashboardData;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Create a new admin user
     */
    public function createAdmin(array $data, int $adminId): ?array
    {
        try {
            $this->logger->debug("Checking for existing admin email", [
                'email' => $data['email']
            ]);
            
            // Check if email already exists
            $existingAdmin = $this->adminModel->findByEmail($data['email']);
            
            if ($existingAdmin) {
                return null;
            }
            
            // Create new admin
            $hashedPassword = password_hash($data['password'], PASSWORD_DEFAULT);
            
            $this->logger->debug("Creating new admin user");
            
            // Insert new admin record
            $newAdminId = $this->adminModel->create([
                "name" => $data['name'],
                "email" => $data['email'],
                "password" => $hashedPassword,
                "role" => 'admin',
                "created_at" => date('Y-m-d H:i:s')
            ]);
            
            if (!$newAdminId) {
                return null;
            }
            
            $this->logger->debug("Fetching created admin details", [
                'new_admin_id' => $newAdminId
            ]);
            
            // Get created admin details for response
            $newAdmin = $this->adminModel->findById($newAdminId);
            
            $this->auditService->logEvent(
                'admin_created',
                "New admin user created: {$data['email']}",
                [
                    'created_by' => $adminId,
                    'new_admin_id' => $newAdminId,
                    'new_admin_email' => $data['email']
                ],
                $adminId,
                null,
                'admin'
            );
            
            return $newAdmin;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
}
=== App/Services/BookingService.php ===
<?php

namespace App\Services;

use App\Models\Booking;
use Exception;
use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class BookingService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private DatabaseHelper $db;
    private Booking $bookingModel;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        DatabaseHelper $db,
        Booking $bookingModel
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->db = $db;
        $this->bookingModel = $bookingModel;
    }

    /**
     * Get booking details by ID
     */
    public function getBookingById(int $id): array
    {
        try {
            $booking = $this->bookingModel->find($id);
            if (!$booking) {
                throw new Exception("Booking not found.");
            }
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved booking id: {$id}");
            }
            return (array)$booking;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getBookingById error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Reschedule a booking
     */
    public function rescheduleBooking(int $id, string $pickupDate, string $dropoffDate): void
    {
        try {
            $booking = $this->bookingModel->find($id);
            if (!$booking) {
                throw new Exception("Booking not found.");
            }

            $updated = $this->bookingModel->update($id, [
                'pickup_date'  => $pickupDate,
                'dropoff_date' => $dropoffDate,
                'status'       => 'rescheduled'
            ]);

            if (!$updated) {
                throw new Exception("Failed to update booking.");
            }
            
            // Business-level logging (keep it as it's not just a record change)
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Rescheduled booking id: {$id}");
            }
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ rescheduleBooking error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Cancel a booking and calculate refund amount
     */
    public function cancelBooking(int $id): float
    {
        try {
            $booking = $this->bookingModel->find($id);
            if (!$booking) {
                throw new Exception("Booking not found.");
            }

            $updated = $this->bookingModel->update($id, ['status' => 'canceled']);

            if (!$updated) {
                throw new Exception("Failed to update booking status.");
            }
            
            // Business-level logging (keep it as it's not just a record change)
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Canceled booking id: {$id}");
            }
            
            return isset($booking['refund_amount']) ? (float)$booking['refund_amount'] : 0.0;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ cancelBooking error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get user ID associated with a booking
     */
    public function getUserIdByBooking(int $id): int
    {
        try {
            $booking = $this->bookingModel->find($id);
            if (!$booking) {
                throw new Exception("Booking not found.");
            }
            
            $userId = $this->bookingModel->getUserId($id);
            
            if (!$userId) {
                throw new Exception("User not found for booking.");
            }
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved user id for booking id: {$id}");
            }
            
            return (int)$userId;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getUserIdByBooking error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get monthly booking trends for the current year
     */
    public function getMonthlyBookingTrends(): array
    {
        try {
            $trends = $this->bookingModel->getMonthlyTrends();
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved monthly booking trends.");
            }
            
            return $trends;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getMonthlyBookingTrends error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get total number of bookings
     */
    public function getTotalBookings(): int
    {
        try {
            $total = $this->bookingModel->getTotalBookings();
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved total bookings.");
            }
            
            return $total;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getTotalBookings error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get the number of completed bookings
     */
    public function getCompletedBookings(): int
    {
        try {
            $completed = $this->bookingModel->getCompletedBookings();
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved completed bookings.");
            }
            
            return $completed;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getCompletedBookings error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get the number of canceled bookings
     */
    public function getCanceledBookings(): int
    {
        try {
            $canceled = $this->bookingModel->getCanceledBookings();
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved canceled bookings.");
            }
            
            return $canceled;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getCanceledBookings error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get booking logs for a specific booking ID
     */
    public function getBookingLogs(int $bookingId): array
    {
        try {
            $logs = $this->bookingModel->getLogs($bookingId);
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved logs for booking id: {$bookingId}");
            }
            
            return $logs;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getBookingLogs error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Check booking availability
     */
    private function isBookingAvailable(int $vehicleId, string $pickupDate, string $dropoffDate): bool
    {
        try {
            $available = $this->bookingModel->isAvailable($vehicleId, $pickupDate, $dropoffDate);
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Checked availability for vehicle id: {$vehicleId}");
            }
            
            return $available;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ isBookingAvailable error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Create a new booking
     */
    public function createBooking(int $userId, int $vehicleId, string $pickupDate, string $dropoffDate): array
    {
        if (!$this->isBookingAvailable($vehicleId, $pickupDate, $dropoffDate)) {
            $this->logger->error("[Booking] ❌ Vehicle not available for booking (vehicle id: {$vehicleId})");
            return ['status' => 'error', 'message' => 'Vehicle not available for the selected dates'];
        }

        try {
            $bookingData = [
                'user_id'     => $userId,
                'vehicle_id'  => $vehicleId,
                'pickup_date' => $pickupDate,
                'dropoff_date'=> $dropoffDate,
                'status'      => 'booked',
                'created_at'  => date('Y-m-d H:i:s'),
                'updated_at'  => date('Y-m-d H:i:s')
            ];
            
            $booking = $this->bookingModel->create($bookingData);

            // Business-level logging (keep it as it's not just a record change)
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Booking created for user {$userId}");
            }

            return ['status' => 'success', 'message' => 'Booking created successfully'];
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ createBooking error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'Failed to create booking'];
        }
    }
    
    /**
     * Get all bookings for a user
     */
    public function getUserBookings(int $userId): array
    {
        try {
            $bookings = $this->bookingModel->getByUser($userId);
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved bookings for user id: {$userId}");
            }
            
            return $bookings;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getUserBookings error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
    
    /**
     * Delete a booking (soft delete if model supports it)
     */
    public function deleteBooking(int $id): bool
    {
        try {
            $deleted = $this->bookingModel->delete($id);
            
            if (!$deleted) {
                throw new Exception("Failed to delete booking.");
            }
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Deleted booking id: {$id}");
            }
            
            return true;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ deleteBooking error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
}
=== App/Services/Auth/TokenService.php ===
<?php

namespace App\Services\Auth;

use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use App\Helpers\DatabaseHelper;
use App\Services\AuditService;
use App\Models\RefreshToken;
use App\Models\User;
use Exception;
use RuntimeException;

class TokenService
{
    public const DEBUG_MODE = true;

    private array $encryptionConfig;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private DatabaseHelper $db;
    private AuditService $auditService;
    private RefreshToken $refreshTokenModel;
    private User $userModel;

    public function __construct(
        array $encryptionConfig,
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        DatabaseHelper $appDb,
        AuditService $auditService,
        RefreshToken $refreshTokenModel,
        User $userModel
    ) {
        $this->encryptionConfig = $encryptionConfig;
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->db = $appDb;
        $this->auditService = $auditService;
        $this->refreshTokenModel = $refreshTokenModel;
        $this->userModel = $userModel;
        
        // Validate encryption config
        $this->validateEncryptionConfig();
        
        if (self::DEBUG_MODE) {
            $this->logger->info("[auth] TokenService initialized.");
        }
    }
    
    /**
     * Validate that all required encryption config values are present
     */
    private function validateEncryptionConfig(): void
    {
        $requiredKeys = ['jwt_secret', 'jwt_refresh_secret', 'encryption_key', 'issuer', 'audience'];
        
        foreach ($requiredKeys as $key) {
            if (empty($this->encryptionConfig[$key] ?? null)) {
                $errorMsg = "❌ Required encryption config value '$key' is missing or empty.";
                $this->logger->error($errorMsg);
                throw new RuntimeException($errorMsg);
            }
        }
        
        // Validate key lengths
        if (strlen($this->encryptionConfig['jwt_secret']) < 32) {
            throw new RuntimeException('JWT secret key must be at least 32 characters long.');
        }
        
        if (strlen($this->encryptionConfig['jwt_refresh_secret']) < 32) {
            throw new RuntimeException('JWT refresh secret key must be at least 32 characters long.');
        }
        
        if (strlen($this->encryptionConfig['encryption_key']) < 32) {
            throw new RuntimeException('Encryption key must be at least 32 characters long.');
        }
    }

    /**
     * Generate a JWT token for a user
     */
    public function generateToken($user): string
    {
        // Extract user ID safely from either array or object
        $userId = is_array($user) ? $user['id'] : $user->id;

        $payload = [
            'iss' => $this->encryptionConfig['issuer'],
            'aud' => $this->encryptionConfig['audience'],
            'iat' => time(),
            'exp' => time() + 3600, // 1 hour
            'sub' => $userId,
            'data' => [
                'id' => $userId,
                'email' => is_array($user) ? $user['email'] : $user->email,
                'role' => is_array($user) ? ($user['role'] ?? 'user') : ($user->role ?? 'user')
            ]
        ];
        
        try {
            $token = JWT::encode($payload, $this->encryptionConfig['jwt_secret'], 'HS256');
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[auth] ✅ Token generated.", ['userId' => $userId]);
            }
            
            // Log JWT creation as a business-level event in audit trail
            $this->auditService->logEvent(
                'auth',
                'jwt_created',
                ['user_id' => $userId],
                $userId,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return $token;
        } catch (Exception $e) {
            $this->logger->error("[auth] ❌ Token generation failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Generate a refresh token for a user
     */
    public function generateRefreshToken($user): string
    {
        // Extract user ID safely from either array or object
        $userId = is_array($user) ? $user['id'] : $user->id;

        $payload = [
            'iss' => $this->encryptionConfig['issuer'],
            'aud' => $this->encryptionConfig['audience'],
            'iat' => time(),
            'exp' => time() + 604800, // 7 days
            'sub' => $userId,
        ];
        
        try {
            $refreshToken = JWT::encode($payload, $this->encryptionConfig['jwt_refresh_secret'], 'HS256');
            
            // Store the refresh token using the RefreshToken model
            $this->refreshTokenModel->store($userId, $refreshToken, 604800);
            
            // Log refresh token creation
            $this->auditService->logEvent(
                'auth',
                'refresh_token_created',
                ['user_id' => $userId],
                $userId,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return $refreshToken;
        } catch (Exception $e) {
            $this->logger->error("[auth] ❌ Refresh token generation failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Verify/decode a JWT token
     */
    public function verifyToken(string $token): array
    {
        try {
            $decoded = JWT::decode($token, new Key($this->encryptionConfig['jwt_secret'], 'HS256'));
            
            if ($decoded->exp < time()) {
                // Log token expiration
                $this->auditService->logEvent(
                    'auth',
                    'token_expired',
                    ['sub' => $decoded->sub],
                    $decoded->sub,
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
                
                $errorMsg = "Token has expired.";
                $this->logger->warning($errorMsg);
                throw new Exception($errorMsg);
            }
            
            $this->logger->info("✅ Token verified.", ['userId' => $decoded->sub]);
            
            // Log successful verification
            $this->auditService->logEvent(
                'auth',
                'token_verified',
                ['user_id' => $decoded->sub],
                $decoded->sub,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return (array)$decoded;
        } catch (Exception $e) {
            $this->logger->warning("Token verification failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Decode and validate a refresh token
     */
    public function decodeRefreshToken(string $refreshToken)
    {
        try {
            // Check if token has been revoked using RefreshToken model
            if ($this->refreshTokenModel->isRevoked($refreshToken)) {
                // Log revoked token attempt
                $userId = $this->refreshTokenModel->getUserId($refreshToken);
                if ($userId) {
                    $this->auditService->logEvent(
                        'auth',
                        'revoked_token_use_attempt',
                        [],
                        $userId,
                        null,
                        $_SERVER['REMOTE_ADDR'] ?? null
                    );
                }
                
                $errorMsg = "Refresh token has been revoked.";
                $this->logger->warning($errorMsg);
                throw new Exception($errorMsg);
            }
            
            $decoded = JWT::decode($refreshToken, new Key($this->encryptionConfig['jwt_refresh_secret'], 'HS256'));
            
            if ($decoded->exp < time()) {
                // Log expired token attempt
                $this->auditService->logEvent(
                    'auth',
                    'expired_token_use_attempt',
                    ['sub' => $decoded->sub],
                    $decoded->sub,
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
                
                $errorMsg = "Refresh token has expired.";
                $this->logger->warning($errorMsg);
                throw new Exception($errorMsg);
            }
            
            $this->logger->debug("Refresh token decoded successfully", ['sub' => $decoded->sub]);
            return $decoded;
        } catch (Exception $e) {
            $this->logger->error("Failed to decode refresh token: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Refresh an access token using a refresh token
     */
    public function refreshToken(string $refreshToken): string
    {
        try {
            $decoded = $this->decodeRefreshToken($refreshToken);
            
            // Generate a new access token
            $user = $this->userModel->find($decoded->sub);
            if (!$user) {
                throw new Exception("User not found for token");
            }
            
            $newToken = $this->generateToken((object)$user);
            
            // Log token refresh as a business event
            $this->auditService->logEvent(
                'auth',
                'jwt_refreshed',
                ['user_id' => $decoded->sub],
                $decoded->sub,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return $newToken;
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Revoke a refresh token
     */
    public function revokeToken(string $token): void
    {
        try {
            // Get user ID for audit logging before revocation
            $userId = $this->refreshTokenModel->getUserId($token);
            
            // Revoke the token using RefreshToken model
            $this->refreshTokenModel->revoke($token);
            
            // Log token revocation as a business event
            if ($userId) {
                $this->auditService->logEvent(
                    'auth',
                    'token_revoked',
                    [],
                    $userId,
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
            }
            
            $this->logger->info("✅ [TokenService] Revoked refresh token.");
        } catch (Exception $e) {
            $this->logger->error("Failed to revoke token: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
        }
    }
    
    /**
     * Remove expired tokens from the database
     */
    public function purgeExpiredTokens(): int
    {
        try {
            // Use RefreshToken model to purge expired tokens
            $count = $this->refreshTokenModel->purgeExpired();
            
            // Log the maintenance action
            $this->auditService->logEvent(
                'system',
                'expired_tokens_purged',
                ['count' => $count],
                null,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return $count;
        } catch (Exception $e) {
            $this->logger->error("Failed to purge expired tokens: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return 0;
        }
    }
    
    /**
     * Get all active tokens for a user
     */
    public function getActiveTokensForUser(int $userId): array
    {
        try {
            // Use RefreshToken model to get active tokens
            return $this->refreshTokenModel->getActiveForUser($userId);
        } catch (Exception $e) {
            $this->logger->error("Failed to get active tokens: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return [];
        }
    }

    /**
     * Validate token and get user data in a single operation
     */
    public function validateRequest($request): ?array
    {
        $token = $this->extractToken($request);
        if (!$token) {
            return null;
        }
        
        try {
            $decoded = $this->verifyToken($token);
            return $this->userModel->find($decoded['sub']);
        } catch (Exception $e) {
            $this->logger->warning('Token validation failed during request', ['error' => $e->getMessage()]);
            
            // Log invalid token attempt
            $this->auditService->logEvent(
                'auth',
                'invalid_token_use',
                ['error' => $e->getMessage()],
                null,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return null;
        }
    }
    
    /**
     * Extract token from Authorization header or cookie
     */
    public function extractToken($request): ?string
    {
        // Handle different request formats
        if (is_string($request)) {
            // Assume $request is directly the Authorization header
            $authHeader = $request;
        } elseif (is_array($request) && isset($request['Authorization'])) {
            // Handle array format (e.g. from getHeader)
            $authHeader = $request['Authorization'];
        } elseif (is_object($request) && method_exists($request, 'getHeaderLine')) {
            // Handle PSR-7 request object
            $authHeader = $request->getHeaderLine('Authorization');
        } elseif (is_object($request) && method_exists($request, 'headers')) {
            // Handle Laravel/Symfony style request
            $authHeader = $request->headers->get('Authorization');
        } else {
            $authHeader = null;
        }
        
        // Extract token from Bearer format
        $token = null;
        if ($authHeader && strpos($authHeader, 'Bearer ') === 0) {
            $token = substr($authHeader, 7);
        }
        
        // If not found in Authorization header, check cookies
        if (!$token && isset($_COOKIE['jwt'])) {
            $token = $_COOKIE['jwt'];
        }
        
        return $token;
    }
}
=== App/Services/Auth/AuthService.php ===
<?php

namespace App\Services\Auth;

use App\Models\User;
use App\Helpers\DatabaseHelper;
use Firebase\JWT\JWT;
use App\Helpers\ExceptionHandler;
use Firebase\JWT\Key;
use Exception;
use Psr\Log\LoggerInterface;
use App\Helpers\ApiHelper;
use App\Services\Validator;
use App\Services\AuditService;


class AuthService
{
    private $pdo;
    private TokenService $tokenService;
    private ExceptionHandler $exceptionHandler;
    private LoggerInterface $logger;
    private AuditService $auditService;
    private array $encryptionConfig;
    private Validator $validator;
    private User $userModel;

    public function __construct(
        DatabaseHelper $dbHelper,
        TokenService $tokenService,
        ExceptionHandler $exceptionHandler,
        LoggerInterface $logger,
        AuditService $auditService,
        array $encryptionConfig,
        Validator $validator,
        User $userModel
    ) {
        $this->pdo = $dbHelper->getPdo();
        $this->tokenService = $tokenService;
        $this->exceptionHandler = $exceptionHandler;
        $this->logger = $logger;
        $this->auditService = $auditService;
        $this->encryptionConfig = $encryptionConfig;
        $this->validator = $validator;
        $this->userModel = $userModel;

        $this->logger->info("AuthService initialized with app_database connection");
    }

    public function login(array $data)
    {
        try {
            // Use the User model to validate password
            $user = $this->userModel->validatePassword($data['email'], $data['password']);
            $this->logger->debug("Executing login query for user email: {$data['email']}");
            
            if (!$user) {
                $this->logger->warning("Authentication failed", ['email' => $data['email']]);
                $this->auditService->logEvent(
                    'auth',
                    'Authentication failed',
                    ['email' => $data['email']],
                    null,
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
                
                throw new Exception("Invalid email or password", 401);
            }

            // Cast user array to object for TokenService
            $userObject = (object)$user;
            $this->logger->debug("User data converted to object", ['type' => gettype($userObject)]);

            $token = $this->tokenService->generateToken($userObject);
            $refreshToken = $this->tokenService->generateRefreshToken($userObject);

            // Store access token in application database
            $this->storeAccessToken($userObject->id, $token);

            // Keep audit log for successful login (security-critical)
            $this->auditService->logEvent(
                'auth',
                'Authentication successful',
                ['email' => $user['email'], 'user_id' => $user['id']],
                $user['id'],
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            // Include minimal user information in the result
            return [
                'token'         => $token,
                'refresh_token' => $refreshToken,
                'user_id'       => $user['id'],
                'name'          => $user['name'],
                'email'         => $user['email']
            ];
        } catch (Exception $e) {
            $this->logger->error("[auth] ❌ Login error: " . $e->getMessage());
            $this->exceptionHandler->handle($e); // Use handle() instead of handleException()
            throw $e;
        }
    }

    public function register(array $data)
    {
        try {
            $this->logger->info("Starting registration process", ['email' => $data['email'] ?? 'unknown']);
            
            // Define the validation rules, ensuring surname and confirm_password are required
            $rules = [
                'email'           => 'required|email|unique:users,email',
                'password'        => 'required|min:8',
                'confirm_password'=> 'required|same:password',
                'name'            => 'required|string',
                'surname'         => 'required|string', // Ensure surname is required
                'phone'           => 'string|nullable',
                'address'         => 'string|nullable',
                'pesel_or_id'     => 'string|nullable'
            ];

            // Log sanitized input data (without passwords)
            $logData = $data;
            if (isset($logData['password'])) unset($logData['password']);
            if (isset($logData['confirm_password'])) unset($logData['confirm_password']);
            $this->logger->debug("Registration input data", ['data' => $logData]);
            
            // Validate input data
            $this->validator->validate($data, $rules);
            
            // Check passwords match (redundant with validation but keeping as a double-check)
            if (!isset($data['password']) || !isset($data['confirm_password']) || $data['password'] !== $data['confirm_password']) {
                $this->logger->warning("Passwords don't match during registration");
                throw new Exception("Passwords do not match", 400);
            }
            
            // Prepare user data for creation via model
            $userData = [
                'name' => $data['name'],
                'surname' => $data['surname'],
                'email' => $data['email'],
                'password' => $data['password'], // User model will hash this
                'phone' => $data['phone'] ?? null,
                'address' => $data['address'] ?? null,
                'pesel_or_id' => $data['pesel_or_id'] ?? null,
                'role' => 'user', // Default role, only override if admin is creating the user
                'email_notifications' => $data['email_notifications'] ?? 0,
                'sms_notifications' => $data['sms_notifications'] ?? 0,
                'active' => 1,
                'created_at' => date('Y-m-d H:i:s'),
                'updated_at' => date('Y-m-d H:i:s')
            ];
            
            // Log prepared data (without password)
            $logUserData = $userData;
            unset($logUserData['password']);
            $this->logger->debug("Prepared user data for database", ['data' => $logUserData]);
            
            // Use the User model to create the user
            $userId = $this->userModel->create($userData);
            
            $this->logger->info("User registered successfully", ['user_id' => $userId, 'email' => $data['email']]);
            
            // Registration is not a security-critical event, so use logger instead of audit
            $this->logger->info("User registration completed", [
                'user_id' => $userId,
                'email' => $data['email'],
                'ip' => $_SERVER['REMOTE_ADDR'] ?? null
            ]);
            
            return ['user_id' => $userId];
        } catch (\InvalidArgumentException $e) {
            $this->logger->warning("Validation error during registration", ['error' => $e->getMessage()]);
            throw $e;
        } catch (Exception $e) {
            $this->logger->error("Registration error: " . $e->getMessage());
            $this->exceptionHandler->handle($e); // Use handle() instead of handleException()
            throw $e;
        }
    }

    public function refresh(array $data)
    {
        try {
            // Use the TokenService to decode the refresh token
            $decoded = $this->tokenService->decodeRefreshToken($data['refresh_token']);
            
            // Use the User model to find user by ID
            $user = $this->userModel->find($decoded->sub);
            $this->logger->debug("Executing refresh query for user ID: {$decoded->sub}");
            
            if (!$user) {
                $this->logger->warning("Invalid refresh token", ['token_sub' => $decoded->sub]);
                throw new Exception("Invalid refresh token", 400);
            }

            // Cast user array to object for TokenService
            $userObject = (object)$user;
            $this->logger->debug("User data converted to object for token refresh", ['type' => gettype($userObject)]);

            $token = $this->tokenService->generateToken($userObject);
            $this->logger->info("Token refreshed successfully", ['user_id' => $user['id']]);
            
            // Store new access token in application database
            $this->storeAccessToken($decoded->sub, $token);

            // Use logger instead of audit for token refresh (not security-critical)
            $this->logger->info("Token refreshed", [
                'user_id' => $user['id'],
                'ip' => $_SERVER['REMOTE_ADDR'] ?? null
            ]);
            
            return ['token' => $token];
        } catch (Exception $e) {
            $this->logger->error("Refresh token error: " . $e->getMessage());
            $this->exceptionHandler->handle($e); // Use handle() instead of handleException()
            throw $e;
        }
    }

    public function logout(array $data)
    {
        // Extract user ID from token if available
        $userId = null;
        if (!empty($data['user_id'])) {
            $userId = (int)$data['user_id'];
        }
        
        // Keep audit log for logout (security-critical event)
        $this->auditService->logEvent(
            'auth',
            'User logged out',
            [],
            $userId,
            null,
            $_SERVER['REMOTE_ADDR'] ?? null
        );
        
        return ["message" => "Logged out successfully"];
    }

    public function updateProfile($userId, array $data)
    {
        try {
            // Get current user data
            $user = $this->userModel->find($userId);
            if (!$user) {
                throw new Exception("User not found", 404);
            }
            
            // Prepare update data
            $updateData = [];
            
            // Handle fields that can be updated
            if (isset($data['name'])) {
                $updateData['name'] = $data['name'];
            }
            if (isset($data['surname'])) {
                $updateData['surname'] = $data['surname'];
            }
            if (isset($data['phone'])) {
                $updateData['phone'] = $data['phone'];
            }
            if (isset($data['address'])) {
                $updateData['address'] = $data['address'];
            }
            if (isset($data['email_notifications'])) {
                $updateData['email_notifications'] = (int)$data['email_notifications'];
            }
            if (isset($data['sms_notifications'])) {
                $updateData['sms_notifications'] = (int)$data['sms_notifications'];
            }
            
            // Only update if we have data
            if (!empty($updateData)) {
                $updateData['updated_at'] = date('Y-m-d H:i:s');
                
                // Update the user via model
                $this->userModel->update($userId, $updateData);
                
                // Use logger instead of audit for profile updates (not security-critical)
                $this->logger->info("Profile updated", [
                    'user_id' => $userId,
                    'fields_updated' => array_keys($updateData),
                    'ip' => $_SERVER['REMOTE_ADDR'] ?? null
                ]);
                
                return ["message" => "Profile updated successfully"];
            }
            
            return ["message" => "No changes to update"];
        } catch (Exception $e) {
            $this->logger->error("Update profile error: " . $e->getMessage());
            $this->exceptionHandler->handle($e); // Use handle() instead of handleException()
            throw $e;
        }
    }

    /**
     * Initiates the password reset process
     */
    public function resetPasswordRequest(array $data): array
    {
        try {
            if (!isset($data['email'])) {
                throw new Exception("Email is required", 400);
            }
            
            // Validate email format
            if (!filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
                throw new Exception("Invalid email format", 400);
            }
            
            // Use the User model to find user by email
            $user = $this->userModel->findByEmail($data['email']);
            $this->logger->debug("Executing password reset request query for email: {$data['email']}");
            
            if (!$user) {
                // Don't reveal that the email doesn't exist (security best practice)
                $this->logger->info("Password reset requested for non-existent email", ['email' => $data['email']]);
                return ["message" => "If your email is registered, you will receive a password reset link"];
            }
            
            // Generate a secure reset token
            $resetToken = bin2hex(random_bytes(32));
            $tokenExpiry = date('Y-m-d H:i:s', time() + 3600); // Token valid for 1 hour
            $ipAddress = $_SERVER['REMOTE_ADDR'] ?? null;
            
            // Store the token using a model method
            $this->userModel->createPasswordReset($user['email'], $resetToken, $ipAddress, $tokenExpiry);
            
            // Keep audit log for password reset request (security-critical)
            $this->auditService->logEvent(
                'auth',
                'Password reset requested',
                ['email' => $user['email']],
                $user['id'],
                null,
                $ipAddress
            );
            
            // In a real application, you would send an email here
            // For this example, we'll just return the token (not secure for production)
            return [
                "message" => "Password reset email sent",
                "debug_token" => $resetToken // Remove this in production!
            ];
        } catch (Exception $e) {
            $this->logger->error("Password reset request error: " . $e->getMessage());
            $this->exceptionHandler->handle($e); // Use handle() instead of handleException()
            throw $e;
        }
    }

    /**
     * Completes the password reset process
     */
    public function resetPassword(array $data): array
    {
        try {
            // Validate required fields
            if (!isset($data['token']) || !isset($data['password']) || !isset($data['confirm_password'])) {
                throw new Exception("Token, password and confirmation are required", 400);
            }
            
            // Validate password
            if (strlen($data['password']) < 8) {
                throw new Exception("Password must be at least 8 characters", 400);
            }
            
            // Check passwords match
            if ($data['password'] !== $data['confirm_password']) {
                throw new Exception("Passwords do not match", 400);
            }
            
            // Verify token using the User model
            $tokenRecord = $this->userModel->verifyResetToken($data['token']);
            $this->logger->debug("Verifying reset token: {$data['token']}");
            
            if (!$tokenRecord) {
                throw new Exception("Invalid or expired token", 400);
            }
            
            // Get user via model
            $user = $this->userModel->findByEmail($tokenRecord['email']);
            $this->logger->debug("Retrieving user for password reset, email: {$tokenRecord['email']}");
            
            if (!$user) {
                throw new Exception("User not found", 404);
            }
            
            // Update the password via User model
            $this->userModel->updatePassword($user['id'], $data['password']);
            $this->logger->debug("Updating password for user ID: {$user['id']}");
            
            // Mark token as used via model
            $this->userModel->markResetTokenUsed($tokenRecord['id']);
            
            // Keep audit log for password reset completion (security-critical)
            $this->auditService->logEvent(
                'auth',
                'Password reset completed',
                ['email' => $user['email']],
                $user['id'],
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return ["message" => "Password has been reset successfully"];
        } catch (Exception $e) {
            $this->logger->error("Password reset error: " . $e->getMessage());
            $this->exceptionHandler->handle($e); // Use handle() instead of handleException()
            throw $e;
        }
    }

    /**
     * Validate a token from the request
     */
    public function validateRequest(?string $authHeader = null): ?object
    {
        return $this->tokenService->validateRequest($authHeader);
    }

    private function storeAccessToken(int $userId, string $accessToken): void
    {
        try {
            // Store the token in the access_tokens table using app db helper
            $appDb = DatabaseHelper::getInstance();
            $appDb->insert('access_tokens', [
                'user_id' => $userId,
                'token' => hash('sha256', $accessToken), // Store hashed token for security
                'expires_at' => date('Y-m-d H:i:s', time() + 3600),
                'created_at' => date('Y-m-d H:i:s')
            ]);
            
            $this->logger->info("[auth] Access token stored in application database", ['user_id' => $userId]);
        } catch (\Exception $e) {
            $this->logger->error("[auth] Failed to store access token: " . $e->getMessage());
            $this->exceptionHandler->handle($e); // Use handle() instead of handleException()
            // Continue without failing - JWT will still work even if storage fails
        }
    }
}
?>
=== App/Services/DocumentService.php ===
<?php

namespace DocumentManager\Services;

use Exception;
use App\Helpers\DatabaseHelper;
use AuditManager\Services\AuditService;
use DocumentManager\Services\FileStorage;
use DocumentManager\Services\TemplateService;
use App\Services\EncryptionService;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use App\Models\Document;
use App\Models\DocumentTemplate;
use App\Models\Contract;
use App\Models\User;
use App\Models\Booking;

/**
 * Document Service
 *
 * Manages documents including templates, contracts, and Terms & Conditions (T&C).
 * Supports encryption, secure storage, logging, and dynamic document generation.
 */
class DocumentService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private DatabaseHelper $db;
    private AuditService $auditService;
    private FileStorage $fileStorage;
    private EncryptionService $encryptionService;
    private TemplateService $templateService;
    private Document $documentModel;
    private DocumentTemplate $templateModel;
    private Contract $contractModel;
    private User $userModel;
    private Booking $bookingModel;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        DatabaseHelper $db,
        AuditService $auditService,
        FileStorage $fileStorage,
        EncryptionService $encryptionService,
        TemplateService $templateService,
        Document $documentModel,
        DocumentTemplate $templateModel,
        Contract $contractModel,
        User $userModel,
        Booking $bookingModel
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->db = $db;
        $this->auditService = $auditService;
        $this->fileStorage = $fileStorage;
        $this->encryptionService = $encryptionService;
        $this->templateService = $templateService;
        $this->documentModel = $documentModel;
        $this->templateModel = $templateModel;
        $this->contractModel = $contractModel;
        $this->userModel = $userModel;
        $this->bookingModel = $bookingModel;
    }

    /**
     * Upload a document template.
     */
    public function uploadTemplate(string $name, string $content): void
    {
        $this->processTemplate($name, $content, 'template_uploaded');
    }

    /**
     * Upload the Terms & Conditions document.
     */
    public function uploadTerms(string $content): void
    {
        $this->processTemplate('terms_and_conditions', $content, 'terms_uploaded');
    }

    /**
     * Process template storage and logging.
     */
    private function processTemplate(string $name, string $content, string $logAction): void
    {
        try {
            if (self::DEBUG_MODE) {
                $this->logger->info("[Document] Uploading template: {$name}");
            }
            
            $encryptedContent = $this->encryptionService->encrypt($content);
            $filePath = $this->fileStorage->storeFile("templates", "{$name}.html", $encryptedContent);
            
            // Use template model instead of direct DB access
            $existingTemplate = $this->templateModel->findByName($name);
            
            if ($existingTemplate) {
                // Update existing template
                $this->templateModel->update($existingTemplate['id'], [
                    'content' => $encryptedContent,
                    'file_path' => $filePath,
                    'updated_at' => date('Y-m-d H:i:s')
                ]);
            } else {
                // Create new template
                $this->templateModel->create([
                    'name' => $name,
                    'content' => $encryptedContent,
                    'file_path' => $filePath,
                    'created_at' => date('Y-m-d H:i:s'),
                    'updated_at' => date('Y-m-d H:i:s')
                ]);
            }
            
            // Business-level audit logging - template operations are important business events
            $this->auditService->log($logAction, ['template' => $name]);
            
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Upload template exception: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to upload template: {$name} " . $e->getMessage());
        }
    }

    /**
     * Generate a rental contract document dynamically.
     */
    public function generateContract(int $bookingId, int $userId): string
    {
        try {
            if (self::DEBUG_MODE) {
                $this->logger->info("[Document] Generating contract for booking {$bookingId}");
            }

            // Load the contract template using template model
            $templateData = $this->templateModel->findByName('rental_contract');
            if (!$templateData) {
                throw new Exception("Contract template not found");
            }
            
            // Get user and booking data using models
            $userData = $this->userModel->find($userId);
            $bookingData = $this->bookingModel->find($bookingId);
            
            if (!$userData || !$bookingData) {
                throw new Exception("User or booking data not found");
            }

            // Prepare data for template rendering
            $data = array_merge($userData, $bookingData);
            
            // Decrypt template content and render with data
            $templateContent = $this->encryptionService->decrypt($templateData['content']);
            $renderedContent = $this->templateService->renderTemplateContent($templateContent, $data);

            // Encrypt the rendered content
            $encryptedContract = $this->encryptionService->encrypt($renderedContent);
            
            // Store the file
            $filePath = $this->fileStorage->storeFile("contracts", "contract_{$bookingId}.pdf", $encryptedContract);

            // Store contract record using contract model
            $this->contractModel->create([
                'booking_id'  => $bookingId,
                'user_id'     => $userId,
                'contract_pdf'=> $filePath,
                'created_at'  => date('Y-m-d H:i:s')
            ]);

            // Business-level audit log for contract generation - important business event
            $this->auditService->log('contract_generated', [
                'booking_id' => $bookingId, 
                'user_id' => $userId
            ]);

            return $filePath;
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Contract generation error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Retrieve and decrypt a document.
     */
    public function retrieveDocument(string $filePath): string
    {
        try {
            if (self::DEBUG_MODE) {
                $this->logger->info("[Document] Retrieving document from {$filePath}");
            }

            $encryptedContent = $this->fileStorage->retrieveFile($filePath);
            $decryptedContent = $this->encryptionService->decrypt($encryptedContent);

            // Business-level audit log for document retrieval - security-sensitive event
            $this->auditService->log('document_retrieved', ['file_path' => $filePath]);

            return $decryptedContent;
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Retrieve document error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to retrieve document " . $e->getMessage());
        }
    }

    /**
     * Delete a document.
     */
    public function deleteDocument(int $documentId): void
    {
        try {
            if (self::DEBUG_MODE) {
                $this->logger->info("[Document] Deleting document ID {$documentId}");
            }

            // Get document using model
            $document = $this->documentModel->find($documentId);

            if (!$document) {
                throw new Exception("Document not found.");
            }

            // Delete the physical file
            $this->fileStorage->deleteFile($document['file_path']);
            
            // Delete the document record using model
            $this->documentModel->delete($documentId);

            // Business-level audit log for document deletion - security-sensitive event
            $this->auditService->log('document_deleted', ['document_id' => $documentId]);
            
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Delete document error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to delete document " . $e->getMessage());
        }
    }

    /**
     * Get a list of available templates.
     */
    public function getTemplates(): array
    {
        try {
            // Use template model to get all templates
            $templates = $this->templateModel->getAll();
            
            // Return only necessary information, not the entire model
            return array_map(function($template) {
                return [
                    'id' => $template['id'],
                    'name' => $template['name'],
                    'created_at' => $template['created_at'],
                    'updated_at' => $template['updated_at']
                ];
            }, $templates);
            
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Get templates error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
    
    /**
     * Get a specific template by ID.
     */
    public function getTemplateById(int $templateId): array
    {
        try {
            // Use template model to get template by ID
            $template = $this->templateModel->find($templateId);
            
            if (!$template) {
                throw new Exception("Template not found.");
            }
            
            // Decrypt the content for use
            $template['content'] = $this->encryptionService->decrypt($template['content']);
            
            return $template;
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Get template error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
    
    /**
     * Get contracts for a specific user.
     */
    public function getUserContracts(int $userId): array
    {
        try {
            // Use contract model to get user contracts
            $contracts = $this->contractModel->getByUserId($userId);
            
            return $contracts;
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Get user contracts error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
    
    /**
     * Get contract for a specific booking.
     */
    public function getBookingContract(int $bookingId): array
    {
        try {
            // Use contract model to get booking contract
            $contract = $this->contractModel->getByBookingId($bookingId);
            
            if (!$contract) {
                throw new Exception("Contract not found for booking.");
            }
            
            return $contract;
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Get booking contract error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
}
=== App/Services/NotificationService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use App\Models\Notification;
use Psr\Log\LoggerInterface;
use PHPMailer\PHPMailer\PHPMailer;
use PHPMailer\PHPMailer\Exception;
use App\Helpers\ExceptionHandler;

/**
 * NotificationService
 *
 * Handles various notification types (email, SMS, webhook, push notifications).
 */
class NotificationService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private array $config;
    private DatabaseHelper $db;
    private Notification $notificationModel;

    public function __construct(
        LoggerInterface $logger, 
        ExceptionHandler $exceptionHandler, 
        DatabaseHelper $db, 
        Notification $notificationModel,
        array $config
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->db = $db;
        $this->notificationModel = $notificationModel;
        $this->config = $config;
    }

    /**
     * Send a notification
     */
    public function sendNotification(int $userId, string $type, string $message, array $options = []): bool
    {
        try {
            $this->storeNotification($userId, $type, $message);
            // Log notification preparation
            if (self::DEBUG_MODE) {
                $this->logger->info('Notification prepared for dispatch', ['user_id' => $userId, 'type' => $type]);
            }
            return $this->dispatchNotification($userId, $type, $message, $options);
        } catch (\Exception $e) {
            $this->logger->error('Failed to send notification', ['error' => $e->getMessage()]);
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Store notification in the database
     */
    private function storeNotification(int $userId, string $type, string $message): void
    {
        try {
            // Create the notification record
            $this->notificationModel->create([
                'user_id' => $userId,
                'type'    => $type,
                'message' => $message,
                'sent_at' => date('Y-m-d H:i:s'),
                'is_read' => false,
            ]);
            
            if (self::DEBUG_MODE) {
                $this->logger->info("Notification stored in database", [
                    'user_id' => $userId, 
                    'type' => $type
                ]);
            }
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ storeNotification error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function getUserNotifications(int $userId): array
    {
        try {
            // Get user notifications
            $notifications = $this->notificationModel->getByUserId($userId);
            
            // Log retrieval
            if (self::DEBUG_MODE) {
                $this->logger->info("[Notification] Retrieved notifications for user {$userId}");
            }
            
            return $notifications;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ getUserNotifications error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function markAsRead(int $notificationId): bool
    {
        try {
            // Mark notification as read
            $result = $this->notificationModel->markAsRead($notificationId);
            
            // Log the action
            if (self::DEBUG_MODE && $result) {
                $this->logger->info("[Notification] Marked notification {$notificationId} as read");
            }
            
            return $result;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ markAsRead error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function deleteNotification(int $notificationId): bool
    {
        try {
            // Delete notification
            $result = $this->notificationModel->delete($notificationId);
            
            // Log the deletion
            if (self::DEBUG_MODE && $result) {
                $this->logger->info("[Notification] Deleted notification {$notificationId}");
            }
            
            return $result;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ deleteNotification error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function markAllAsRead(int $userId): bool
    {
        try {
            // Mark all notifications as read
            $result = $this->notificationModel->markAllAsRead($userId);
            
            // Log the action
            if (self::DEBUG_MODE && $result) {
                $this->logger->info("[Notification] Marked all notifications as read for user {$userId}");
            }
            
            return $result;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ markAllAsRead error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Dispatch the appropriate notification method
     */
    private function dispatchNotification(int $userId, string $type, string $message, array $options): bool
    {
        $result = false;
        
        try {
            $result = match ($type) {
                'email' => $this->sendEmail($options['email'] ?? '', $message, $options['subject'] ?? 'Notification'),
                'sms' => $this->sendSMS($options['phone'] ?? '', $message),
                'webhook' => $this->sendWebhook($options['url'] ?? '', $message),
                'push' => $this->sendPushNotification($options['device_token'] ?? '', $message),
                default => throw new \InvalidArgumentException("Unsupported notification type: $type"),
            };
            
            // Business-level logging of success/failure
            if (self::DEBUG_MODE) {
                if ($result) {
                    $this->logger->info("[Notification] Successfully sent {$type} notification to user {$userId}");
                } else {
                    $this->logger->warning("[Notification] Failed to send {$type} notification to user {$userId}");
                }
            }
            
            return $result;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ Dispatch error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Send an email using PHPMailer
     */
    private function sendEmail(string $to, string $message, string $subject): bool
    {
        if (empty($to)) return false;

        try {
            $mail = new PHPMailer(true);
            $mail->isSMTP();
            $mail->Host = $this->config['smtp_host'];
            $mail->SMTPAuth = true;
            $mail->Username = $this->config['smtp_user'];
            $mail->Password = $this->config['smtp_password'];
            $mail->SMTPSecure = $this->config['smtp_secure'] ?? 'tls';
            $mail->Port = $this->config['smtp_port'];
            $mail->setFrom($this->config['from_email'], $this->config['from_name']);
            $mail->addAddress($to);
            $mail->Subject = $subject;
            $mail->isHTML(true);
            $mail->Body = "<p>$message</p>";
            $mail->send();

            // Business-level logging only - no need for audit here
            if (self::DEBUG_MODE) {
                $this->logger->info("[Notification] Email sent to {$to}");
            }

            return true;
        } catch (Exception $e) {
            $this->logger->error("[Notification] ❌ Email error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Send an SMS
     */
    private function sendSMS(string $phone, string $message): bool
    {
        if (empty($phone)) return false;

        try {
            // SMS implementation code would go here
            
            // Business-level logging only
            if (self::DEBUG_MODE) {
                $this->logger->info("[Notification] SMS sent to {$phone}");
            }
            return true;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ SMS error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Send a webhook notification
     */
    private function sendWebhook(string $url, string $message): bool
    {
        if (empty($url)) return false;

        try {
            $ch = curl_init($url);
            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
            curl_setopt($ch, CURLOPT_POST, true);
            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode(['message' => $message]));
            curl_setopt($ch, CURLOPT_HTTPHEADER, ['Content-Type: application/json']);
            $response = curl_exec($ch);
            curl_close($ch);

            // Business-level logging only
            if (self::DEBUG_MODE && $response !== false) {
                $this->logger->info("[Notification] Webhook sent to {$url}");
            }

            return $response !== false;
        } catch (\Exception $e) {
            $this->logger->error('[Notification] ❌ Webhook error: ' . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Send a push notification
     */
    private function sendPushNotification(string $deviceToken, string $message): bool
    {
        if (empty($deviceToken)) return false;

        try {
            $payload = [
                'to' => $deviceToken,
                'notification' => ['title' => 'Notification', 'body' => $message],
            ];
            
            $result = $this->sendFCMRequest($payload);
            
            // Business-level logging only
            if (self::DEBUG_MODE && $result) {
                $this->logger->info("[Notification] Push notification sent to device {$deviceToken}");
            }
            
            return $result;
        } catch (\Exception $e) {
            $this->logger->error('[Notification] ❌ Push notification error: ' . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Send Firebase Cloud Messaging (FCM) request
     */
    private function sendFCMRequest(array $payload): bool
    {
        $ch = curl_init('https://fcm.googleapis.com/fcm/send');
        curl_setopt($ch, CURLOPT_HTTPHEADER, [
            'Content-Type: application/json',
            'Authorization: key=' . $this->config['fcm_api_key'],
        ]);
        curl_setopt($ch, CURLOPT_POST, true);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($payload));
        $response = curl_exec($ch);

        curl_close($ch);
        return $response !== false;
    }
    
    /**
     * Get notification by ID
     */
    public function getNotificationById(int $id): ?array
    {
        try {
            $notification = $this->notificationModel->find($id);
            
            if (self::DEBUG_MODE && $notification) {
                $this->logger->info("[Notification] Retrieved notification by ID", ['id' => $id]);
            }
            
            return $notification;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ getNotificationById error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }
    
    /**
     * Get unread notifications count for user
     */
    public function getUnreadCount(int $userId): int
    {
        try {
            $count = $this->notificationModel->getUnreadCount($userId);
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Notification] Retrieved unread count for user", [
                    'user_id' => $userId, 
                    'count' => $count
                ]);
            }
            
            return $count;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ getUnreadCount error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return 0;
        }
    }
}
=== App/Services/AuditService.php ===
<?php

namespace App\Services;

use Exception;
use DateTimeImmutable;
use Ramsey\Uuid\Uuid;
use App\Helpers\DatabaseHelper;
use App\Helpers\LogLevelFilter;
use App\Helpers\ExceptionHandler;
use App\Helpers\SecurityHelper;
use App\Services\Audit\LogManagementService;
use App\Services\Audit\UserAuditService;
use App\Services\Audit\TransactionAuditService;
use Psr\Log\LoggerInterface;

class AuditService
{
    // Categories and log levels remain unchanged
    public const CATEGORY_SYSTEM       = 'system';
    public const CATEGORY_AUTH         = 'auth';
    public const CATEGORY_TRANSACTION  = 'transaction';
    public const CATEGORY_BOOKING      = 'booking';
    public const CATEGORY_USER         = 'user';
    public const CATEGORY_ADMIN        = 'admin';
    public const CATEGORY_DOCUMENT     = 'document';
    public const CATEGORY_API          = 'api';
    public const CATEGORY_SECURITY     = 'security';
    public const CATEGORY_PAYMENT      = 'payment';
    
    public const LOG_LEVEL_DEBUG       = 'debug';
    public const LOG_LEVEL_INFO        = 'info';
    public const LOG_LEVEL_WARNING     = 'warning';
    public const LOG_LEVEL_ERROR       = 'error';
    public const LOG_LEVEL_CRITICAL    = 'critical';
    
    private const VALID_CATEGORIES = [
        self::CATEGORY_SYSTEM, self::CATEGORY_AUTH, self::CATEGORY_TRANSACTION,
        self::CATEGORY_BOOKING, self::CATEGORY_USER, self::CATEGORY_ADMIN,
        self::CATEGORY_DOCUMENT, self::CATEGORY_API, self::CATEGORY_SECURITY,
        self::CATEGORY_PAYMENT,
    ];
    
    // Define which categories should be stored in the audit database
    private const AUDIT_CATEGORIES = [
        self::CATEGORY_AUTH, 
        self::CATEGORY_SECURITY, 
        self::CATEGORY_PAYMENT,
        self::CATEGORY_TRANSACTION,
        self::CATEGORY_BOOKING,
        self::CATEGORY_USER,
        self::CATEGORY_ADMIN
    ];
    
    private const CATEGORY_MAP = [
        self::CATEGORY_AUTH       => 'user',
        self::CATEGORY_USER       => 'user',
        self::CATEGORY_SYSTEM     => 'user',
        self::CATEGORY_API        => 'user',
        self::CATEGORY_SECURITY   => 'user', 
        self::CATEGORY_TRANSACTION=> 'transaction',
        self::CATEGORY_PAYMENT    => 'transaction'
    ];
    
    // Configuration constants
    public const DEBUG_MODE = true;
    
    // Injected services
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private LogLevelFilter $logLevelFilter;
    private string $requestId;
    
    // Injected subservices
    private LogManagementService $logManager;
    private UserAuditService $userAuditService;
    private TransactionAuditService $transactionAuditService;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        LogManagementService $logManager,
        UserAuditService $userAuditService,
        TransactionAuditService $transactionAuditService,
        LogLevelFilter $logLevelFilter = null
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->logManager = $logManager;
        $this->userAuditService = $userAuditService;
        $this->transactionAuditService = $transactionAuditService;
        $this->logLevelFilter = $logLevelFilter ?? new LogLevelFilter();
        $this->requestId = Uuid::uuid4()->toString();
        
        if (self::DEBUG_MODE) {
            $this->logger->debug("[Audit] Service initialized", [
                'request_id' => $this->requestId
            ]);
        }
    }
    
    /**
     * Get the request ID for this instance
     */
    public function getRequestId(): string
    {
        return $this->requestId;
    }
    
    /**
     * Main entry point to log an event.
     * Routes events either to general logger or audit database based on category.
     */
    public function logEvent(
        string $category, 
        string $message, 
        array $context = [], 
        ?int $userId = null, 
        ?int $bookingId = null, 
        ?string $ipAddress = null,
        string $logLevel = self::LOG_LEVEL_INFO
    ): ?int {
        if (!$this->logLevelFilter->shouldLog($logLevel)) {
            return null;
        }
        
        try {
            $normalizedCat = $this->normalizeCategory($category);
            $context = $this->sanitizeContext($context);
            $context['request_id'] = $this->requestId;
            
            // For system events unrelated to security/payments/auth, use general logger only
            if (!in_array($normalizedCat, self::AUDIT_CATEGORIES, true)) {
                $logMethod = strtolower($logLevel);
                $this->logger->$logMethod("[{$normalizedCat}] {$message}", $context);
                return null;
            }
            
            // Route to appropriate subservice based on category
            $serviceKey = self::CATEGORY_MAP[$normalizedCat] ?? null;
            
            if ($serviceKey === 'user') {
                // Use UserAuditService for user-related events
                return $this->userAuditService->logUserEvent(
                    $normalizedCat, 
                    $context['action'] ?? $normalizedCat,
                    $message, 
                    $context,
                    $userId, 
                    $logLevel
                );
            }
            
            if ($serviceKey === 'transaction') {
                // Use TransactionAuditService for transaction-related events
                return $this->transactionAuditService->logEvent(
                    $normalizedCat, 
                    $message, 
                    $context, 
                    $userId, 
                    $bookingId, 
                    $logLevel
                );
            }
            
            // Default path for audit events that don't have specialized handlers
            return $this->logManager->createLogEntry(
                $normalizedCat,
                $message,
                $context,
                $userId,
                $bookingId,
                $ipAddress,
                $logLevel
            );
            
        } catch (Exception $e) {
            $this->logger->error("[Audit] Logging failed: " . $e->getMessage(), [
                'request_id' => $this->requestId,
                'category' => $category,
                'error' => $e->getMessage()
            ]);
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }
    
    /**
     * Normalize and validate a category
     */
    private function normalizeCategory(string $category): string {
        $normalizedCat = strtolower(trim($category));
        if (!in_array($normalizedCat, self::VALID_CATEGORIES, true)) {
            $normalizedCat = self::CATEGORY_SYSTEM;
            if (self::DEBUG_MODE) {
                $this->logger->warning("[Audit] Invalid category", [
                    'request_id' => $this->requestId,
                    'invalid' => $category,
                    'default' => $normalizedCat
                ]);
            }
        }
        return $normalizedCat;
    }
    
    /**
     * Legacy method - remains for backward compatibility
     */
    public function recordEvent(
        string $category,
        string $action,
        string $message,
        array $context = [],
        ?int $userId = null,
        ?int $objectId = null,
        string $logLevel = self::LOG_LEVEL_INFO
    ): ?int {
        $eventContext = array_merge($context, [
            'action' => $action,
            'timestamp' => (new DateTimeImmutable())->format('Y-m-d H:i:s'),
            'object_id' => $objectId
        ]);
        return $this->logEvent(
            $category,
            $message,
            $eventContext,
            $userId,
            $category === self::CATEGORY_BOOKING ? $objectId : null,
            null,
            $logLevel
        );
    }
    
    /**
     * Record a successful payment
     */
    public function recordPaymentSuccess(array $paymentData): ?int {
        return $this->transactionAuditService->recordPaymentSuccess($paymentData);
    }
    
    /**
     * Log an authentication event
     */
    public function logAuthEvent(string $action, string $message, array $context = [], ?int $userId = null, string $logLevel = self::LOG_LEVEL_INFO): ?int {
        return $this->userAuditService->logAuthEvent($action, $message, $context, $userId, $logLevel);
    }
    
    // Delegate log management operations to LogManagementService
    public function getLogs(array $filters = []): array {
        return $this->logManager->getLogs($filters);
    }
    
    public function deleteLogs(array $filters, bool $forceBulkDelete = false): int {
        return $this->logManager->deleteLogs($filters, $forceBulkDelete);
    }
    
    public function exportLogs(array $filters): array {
        return $this->logManager->exportLogs($filters);
    }
    
    public function getLogById(int $logId): ?array {
        return $this->logManager->getLogById($logId);
    }
    
    /**
     * Helper method to sanitize context arrays
     */
    private function sanitizeContext(array $context): array {
        $sensitiveKeys = ['password', 'secret', 'token', 'auth', 'key', 'apiKey', 'api_key', 'credential', 'credit_card', 'card_number', 'cvv', 'ssn'];
        $sanitized = [];
        
        foreach ($context as $key => $value) {
            if ($value === null) {
                continue;
            }
            
            $keyLower = strtolower($key);
            $isSensitive = false;
            foreach ($sensitiveKeys as $sensitiveKey) {
                if (strpos($keyLower, $sensitiveKey) !== false) {
                    $isSensitive = true;
                    break;
                }
            }
            
            if ($isSensitive) {
                $sanitized[$key] = '[REDACTED]';
            } elseif (is_array($value)) {
                $sanitized[$key] = $this->sanitizeContext($value);
            } else {
                $sanitized[$key] = $value;
            }
        }
        
        return $sanitized;
    }
}
=== App/Services/Payment/PaymentProcessingService.php ===
<?php

namespace App\Services\Payment;

use App\Helpers\DatabaseHelper;
use App\Models\Payment;
use App\Models\Booking;
use App\Models\TransactionLog;
use App\Services\AuditService;
use Psr\Log\LoggerInterface;
use Exception;

class PaymentProcessingService
{
    /**
     * Handles payment initiation, validation, database transactions,
     * and logging for successful or failed payments.
     *
     * @author 
     * @version 1.0
     * @description
     *   - PaymentValidation & Payment Initiation
     *   - Transaction handling (beginTransaction, commit/rollback)
     *   - Stores payment record in Payment model
     *   - Updates booking status in Booking model
     *   - Logs transaction in TransactionLog model
     *   - Uses AuditService for successful payment and fraud validation
     *   - Uses LoggerInterface for API failures and debugging
     */
    private DatabaseHelper $dbHelper;
    private Payment $paymentModel;
    private Booking $bookingModel;
    private TransactionLog $transactionLogModel;
    private AuditService $auditService;
    private LoggerInterface $logger;

    /**
     * Constructor injects all necessary dependencies for payment processing.
     */
    public function __construct(
        DatabaseHelper $dbHelper,
        Payment $paymentModel,
        Booking $bookingModel,
        TransactionLog $transactionLogModel,
        AuditService $auditService,
        LoggerInterface $logger
    ) {
        $this->dbHelper = $dbHelper;
        $this->paymentModel = $paymentModel;
        $this->bookingModel = $bookingModel;
        $this->transactionLogModel = $transactionLogModel;
        $this->auditService = $auditService;
        $this->logger = $logger;
    }

    /**
     * Main method for processing a payment.
     * 
     * @param array $paymentData
     *   Example structure: [
     *       'booking_id' => 123,
     *       'amount'     => 500.00,
     *       'currency'   => 'USD',
     *       'payment_method' => 'stripe',
     *       'customer_id' => 456,
     *       // Other relevant data...
     *   ]
     * @return array
     *   Return a standardized response, e.g. ['status' => 'success', 'payment_id' => XYZ]
     * @throws Exception
     *   In case of transaction failure or invalid data
     */
    public function processPayment(array $paymentData): array
    {
        // Perform comprehensive fraud validation before processing
        $fraudCheckResult = $this->performFraudValidation($paymentData);
        if (!$fraudCheckResult['valid']) {
            $this->logger->error('Payment rejected: Potential fraud detected', [
                'payment_data' => $paymentData,
                'fraud_indicators' => $fraudCheckResult['indicators']
            ]);
            
            // Log the fraud attempt with detailed information for investigation
            $this->auditService->logEvent(
                'security', 
                'fraud_attempt', 
                [
                    'payment_data' => $paymentData,
                    'fraud_indicators' => $fraudCheckResult['indicators'],
                    'risk_score' => $fraudCheckResult['risk_score'] ?? null,
                    'ip_address' => $_SERVER['REMOTE_ADDR'] ?? null,
                    'timestamp' => date('Y-m-d H:i:s')
                ],
                $paymentData['user_id'] ?? null,
                $paymentData['booking_id'] ?? null
            );
            
            throw new Exception('Payment rejected due to fraud indicators: ' . 
                implode(', ', $fraudCheckResult['indicators']));
        }

        // Start DB transaction
        $this->dbHelper->beginTransaction();

        try {
            // 1. Create Payment record
            $paymentId = $this->paymentModel->createPayment($paymentData);

            // 2. Update Booking status using the updateStatus method
            $this->bookingModel->updateStatus($paymentData['booking_id'], 'paid');

            // 3. Insert Transaction Log entry
            $this->transactionLogModel->logTransaction([
                'payment_id' => $paymentId,
                'booking_id' => $paymentData['booking_id'],
                'amount' => $paymentData['amount'],
                'currency' => $paymentData['currency'],
                'status' => 'completed',
                'description' => 'Payment processed successfully.',
            ]);

            // 4. Commit transaction
            $this->dbHelper->commit();

            // 5. Audit successful payment with enhanced audit data
            $auditPaymentData = array_merge($paymentData, [
                'payment_id' => $paymentId,
                'timestamp' => date('Y-m-d H:i:s'),
                'status' => 'completed',
                'ip_address' => $_SERVER['REMOTE_ADDR'] ?? null
            ]);
            
            $this->auditService->recordPaymentSuccess($auditPaymentData);

            // Return success response
            return [
                'status' => 'success',
                'payment_id' => $paymentId,
                'message' => 'Payment processed successfully.'
            ];
        } catch (Exception $e) {
            // Roll back on any failure
            $this->dbHelper->rollback();

            // Log the error
            $this->logger->error('Payment processing failed', [
                'error' => $e->getMessage(),
                'data'  => $paymentData
            ]);

            // Rethrow or handle exception
            throw $e;
        }
    }

    /**
     * Perform comprehensive fraud validation on payment data
     * 
     * @param array $paymentData
     * @return array Result with validation status and fraud indicators
     */
    private function performFraudValidation(array $paymentData): array
    {
        $fraudIndicators = [];
        $riskScore = 0;
        
        // 1. Required field validation
        if (empty($paymentData['booking_id'])) {
            $fraudIndicators[] = 'missing_booking_id';
            $riskScore += 25;
        }
        
        if (empty($paymentData['amount']) || !is_numeric($paymentData['amount']) || $paymentData['amount'] <= 0) {
            $fraudIndicators[] = 'invalid_amount';
            $riskScore += 25;
        }
        
        if (empty($paymentData['currency'])) {
            $fraudIndicators[] = 'missing_currency';
            $riskScore += 15;
        }
        
        // 2. Velocity checks - too many transactions in short period
        if (!empty($paymentData['user_id'])) {
            $recentTransactions = $this->getRecentUserTransactions(
                $paymentData['user_id'], 
                15  // Look back 15 minutes
            );
            
            if (count($recentTransactions) > 5) {
                $fraudIndicators[] = 'transaction_velocity';
                $riskScore += 30;
            }
        }
        
        // 3. Amount threshold checks
        if (!empty($paymentData['amount'])) {
            // Unusually large payment
            if ($paymentData['amount'] > 10000) {
                $fraudIndicators[] = 'large_amount';
                $riskScore += 20;
            }
            
            // Round amount (often used in testing fraud)
            if ($paymentData['amount'] == round($paymentData['amount'])) {
                $fraudIndicators[] = 'round_amount';
                $riskScore += 5;
            }
        }
        
        // 4. IP address reputation check (pseudocode - implement with actual service)
        if (!empty($_SERVER['REMOTE_ADDR'])) {
            $ipReputation = $this->checkIpReputation($_SERVER['REMOTE_ADDR']);
            if ($ipReputation === 'suspicious') {
                $fraudIndicators[] = 'suspicious_ip';
                $riskScore += 40;
            } elseif ($ipReputation === 'high_risk') {
                $fraudIndicators[] = 'high_risk_ip';
                $riskScore += 70;
            }
        }
        
        // 5. Check if user account is flagged for suspicious activity
        if (!empty($paymentData['user_id'])) {
            $userFlags = $this->getUserFlags($paymentData['user_id']);
            if (in_array('suspicious_activity', $userFlags)) {
                $fraudIndicators[] = 'flagged_account';
                $riskScore += 50;
            }
        }
        
        // Determine validation result based on risk score and critical indicators
        $isValid = $riskScore < 50 && count($fraudIndicators) < 2;
        
        // Log for troubleshooting/tuning
        if ($riskScore > 30) {
            $this->logger->info('Elevated risk score in payment', [
                'risk_score' => $riskScore,
                'indicators' => $fraudIndicators,
                'user_id' => $paymentData['user_id'] ?? null
            ]);
        }
        
        return [
            'valid' => $isValid,
            'indicators' => $fraudIndicators,
            'risk_score' => $riskScore
        ];
    }
    
    /**
     * Get recent transactions from a specific user
     * 
     * @param int $userId User ID
     * @param int $minutesBack Minutes to look back
     * @return array Recent transactions
     */
    private function getRecentUserTransactions(int $userId, int $minutesBack = 15): array
    {
        $timestamp = date('Y-m-d H:i:s', time() - ($minutesBack * 60));
        
        $query = "SELECT * FROM transaction_logs 
                 WHERE user_id = :user_id 
                 AND created_at > :timestamp";
                 
        return $this->dbHelper->select($query, [
            ':user_id' => $userId,
            ':timestamp' => $timestamp
        ]);
    }
    
    /**
     * Check IP address reputation
     * 
     * @param string $ipAddress IP address to check
     * @return string Reputation score (safe, suspicious, high_risk)
     */
    private function checkIpReputation(string $ipAddress): string
    {
        // In a production environment, this would call an IP reputation service
        // such as MaxMind, IPQualityScore, or similar
        
        // For now, return safe for most IPs, with some randomized suspicious ones
        if (substr($ipAddress, 0, 3) === '10.' || substr($ipAddress, 0, 4) === '192.') {
            return 'safe'; // Most internal IPs are safe
        }
        
        // Very basic sample implementation - replace with actual service
        $ipHash = crc32($ipAddress);
        if ($ipHash % 100 < 3) {
            return 'high_risk';
        } elseif ($ipHash % 100 < 10) {
            return 'suspicious';
        }
        
        return 'safe';
    }
    
    /**
     * Get user account flags from security system
     * 
     * @param int $userId User ID
     * @return array List of user flags
     */
    private function getUserFlags(int $userId): array
    {
        // In production, fetch from user_security_flags table or similar
        // For now, we'll return empty array for most users
        
        // Example implementation - check if user has had chargebacks
        $query = "SELECT COUNT(*) as count FROM transaction_logs 
                 WHERE user_id = :user_id AND type = 'chargeback'";
                 
        $result = $this->dbHelper->select($query, [':user_id' => $userId]);
        if (isset($result[0]['count']) && $result[0]['count'] > 0) {
            return ['chargeback_history'];
        }
        
        return [];
    }

    /**
     * Basic check to ensure payment data meets minimal criteria.
     * This could be extended for additional fraud checks or data validation.
     * @deprecated Use performFraudValidation instead
     */
    private function isValidPaymentData(array $data): bool
    {
        if (empty($data['booking_id']) || empty($data['amount']) || empty($data['currency'])) {
            return false;
        }
        return true;
    }
}
=== App/Services/Payment/TransactionService.php ===
<?php

namespace App\Services\Payment;

use App\Models\TransactionLog;
use App\Services\AuditService;
use Psr\Log\LoggerInterface;
use Exception;

class TransactionService
{
    /**
     * Handles transaction consistency, logging, and history retrieval.
     *
     * Responsibilities:
     *  - Log all transactions in `TransactionLog` (both payments and refunds)
     *  - Provide a method for retrieving transaction histories for users/admins
     *  - Use AuditService for security-sensitive transactions
     *  - Use LoggerInterface for debugging and general transaction info
     *
     * @author
     * @version 1.0
     */
    private TransactionLog $transactionLogModel;
    private AuditService $auditService;
    private LoggerInterface $logger;

    /**
     * Constructor to inject the `TransactionLog` model, `AuditService`, and `LoggerInterface`.
     */
    public function __construct(
        TransactionLog $transactionLogModel,
        AuditService $auditService,
        LoggerInterface $logger
    ) {
        $this->transactionLogModel = $transactionLogModel;
        $this->auditService = $auditService;
        $this->logger = $logger;
    }

    /**
     * Logs a transaction in the system (payments, refunds, chargebacks, etc.).
     *
     * @param array $transactionData
     *   Example:
     *   [
     *       'payment_id'    => 123,
     *       'booking_id'    => 555,
     *       'refund_id'     => null,
     *       'amount'        => 100.00,
     *       'currency'      => 'USD',
     *       'status'        => 'completed',
     *       'description'   => 'Test transaction log.',
     *       'type'          => 'payment', // or 'refund', 'chargeback', etc.
     *   ]
     * @return array
     *   Confirmation data about the logged transaction
     */
    public function logTransaction(array $transactionData): array
    {
        try {
            $logId = $this->transactionLogModel->logTransaction($transactionData);

            // If the transaction is security-sensitive, record it in the audit trail as well
            if (isset($transactionData['type']) && $this->isSecuritySensitive($transactionData['type'])) {
                $this->auditService->recordTransaction($transactionData);
            }

            // Optional: debug log
            $this->logger->info('Transaction logged successfully', [
                'transaction_log_id' => $logId,
                'transaction_data'   => $transactionData,
            ]);

            return [
                'status' => 'success',
                'log_id' => $logId,
                'message' => 'Transaction logged successfully.'
            ];
        } catch (Exception $e) {
            $this->logger->error('Error logging transaction', [
                'error' => $e->getMessage(),
                'transaction_data' => $transactionData,
            ]);
            throw $e;
        }
    }

    /**
     * Retrieves transaction history for a specific user.
     *
     * @param int $userId
     * @return array
     *   An array of transaction records
     */
    public function getHistoryByUser(int $userId): array
    {
        try {
            $history = $this->transactionLogModel->getTransactionsByUser($userId);

            // Debug log
            $this->logger->info("Retrieved transaction history for user {$userId}", [
                'history_count' => count($history)
            ]);

            return $history;
        } catch (Exception $e) {
            $this->logger->error('Error retrieving transaction history', [
                'userId' => $userId,
                'error'  => $e->getMessage()
            ]);
            throw $e;
        }
    }

    /**
     * Retrieves transaction history for an admin view, possibly with filters.
     *
     * @param array $filters
     *   Example: ['date_from' => '2024-01-01', 'date_to' => '2024-01-31', 'type' => 'refund']
     * @return array
     */
    public function getHistoryAdmin(array $filters): array
    {
        try {
            $history = $this->transactionLogModel->getTransactionsAdmin($filters);

            $this->logger->info('Retrieved admin transaction history', [
                'filters' => $filters,
                'history_count' => count($history)
            ]);

            return $history;
        } catch (Exception $e) {
            $this->logger->error('Error retrieving admin transaction history', [
                'filters' => $filters,
                'error'   => $e->getMessage()
            ]);
            throw $e;
        }
    }

    /**
     * Decide whether a particular transaction type is security-sensitive.
     *
     * @param string $transactionType
     * @return bool
     */
    private function isSecuritySensitive(string $transactionType): bool
    {
        // Example: mark refunds, chargebacks, or large payments as sensitive
        $sensitiveTypes = ['refund', 'chargeback'];
        return in_array($transactionType, $sensitiveTypes, true);
    }
}
=== App/Services/Payment/RefundService.php ===
<?php

namespace App\Services\Payment;

use App\Helpers\DatabaseHelper;
use App\Models\Payment;
use App\Models\TransactionLog;
use App\Services\AuditService;
use Psr\Log\LoggerInterface;
use Exception;

class RefundService
{
    /**
     * Handles all refund-related operations.
     * 
     * Responsibilities:
     *  - Securely process refund requests
     *  - Verify that original payment exists and is refundable
     *  - Log refund transactions in TransactionLog
     *  - Use AuditService for approved refunds and chargebacks
     *  - Use LoggerInterface for refund API failures and debugging
     *
     * @author 
     * @version 1.0
     * @description
     *   - Refund request handling
     *   - Database transaction with beginTransaction/commit/rollback
     *   - Verification of original Payment record
     *   - Logging successful or failed refunds
     */
    private DatabaseHelper $dbHelper;
    private Payment $paymentModel;
    private TransactionLog $transactionLogModel;
    private AuditService $auditService;
    private LoggerInterface $logger;

    /**
     * Constructor injects all necessary dependencies for refund operations.
     */
    public function __construct(
        DatabaseHelper $dbHelper,
        Payment $paymentModel,
        TransactionLog $transactionLogModel,
        AuditService $auditService,
        LoggerInterface $logger
    ) {
        $this->dbHelper = $dbHelper;
        $this->paymentModel = $paymentModel;
        $this->transactionLogModel = $transactionLogModel;
        $this->auditService = $auditService;
        $this->logger = $logger;
    }

    /**
     * Main method for processing a refund.
     *
     * @param array $refundData
     *   Example structure: [
     *       'payment_id'  => 123,
     *       'amount'      => 100.00,
     *       'reason'      => 'Product defective',
     *       'initiated_by'=> 'admin' or 'customer',
     *       // Other relevant data...
     *   ]
     * @return array
     *   Return a standardized response, e.g. ['status' => 'success', 'refund_id' => XYZ]
     * @throws Exception
     *   When refund cannot be processed
     */
    public function refund(array $refundData): array
    {
        // Check if refund data is valid
        if (!$this->isValidRefundData($refundData)) {
            $this->logger->error('Invalid refund data provided', $refundData);
            throw new Exception('Refund data is invalid.');
        }

        // Fetch and verify original payment
        $originalPayment = $this->paymentModel->find($refundData['payment_id']);
        if (!$originalPayment) {
            $this->logger->warning('No original payment found for refund', $refundData);
            throw new Exception('Original payment not found.');
        }

        // Check if the payment is eligible for refund
        if (!$this->isRefundable($originalPayment, $refundData)) {
            $this->logger->warning('Payment not eligible for refund', [
                'originalPayment' => $originalPayment,
                'refundRequest'   => $refundData
            ]);
            throw new Exception('Payment is not eligible for a refund.');
        }

        // Begin transaction
        $this->dbHelper->beginTransaction();
        try {
            // 1. Create a refund record (implementation depends on your Payment model's structure)
            //    You might track refunds in a separate 'refunds' table or as negative Payment entries.
            $refundId = $this->paymentModel->createRefund($refundData);

            // 2. Log the refund in the transaction log
            $this->transactionLogModel->logTransaction([
                'payment_id'    => $refundData['payment_id'],
                'refund_id'     => $refundId,
                'amount'        => $refundData['amount'],
                'status'        => 'refunded',
                'description'   => "Refund processed: {$refundData['reason']}",
            ]);

            // 3. Commit transaction
            $this->dbHelper->commit();

            // 4. Audit the approved refund or chargeback
            //    (You could distinguish between normal refunds and chargebacks if needed)
            $this->auditService->recordRefundSuccess($refundData);

            // Return success response
            return [
                'status' => 'success',
                'refund_id' => $refundId,
                'message' => 'Refund processed successfully.'
            ];
        } catch (Exception $e) {
            // Rollback transaction
            $this->dbHelper->rollback();

            // Log error
            $this->logger->error('Refund processing failed', [
                'error' => $e->getMessage(),
                'refundData' => $refundData
            ]);

            throw $e;
        }
    }

    /**
     * Validate minimal refund data.
     */
    private function isValidRefundData(array $refundData): bool
    {
        return (!empty($refundData['payment_id']) && !empty($refundData['amount']));
    }

    /**
     * Checks whether the original payment is eligible for a refund.
     * This can involve checking payment status, refund policies, etc.
     *
     * @param array $originalPayment Payment record from the DB
     * @param array $refundData
     * @return bool
     */
    private function isRefundable(array $originalPayment, array $refundData): bool
    {
        // Example checks:
        //  - Payment must be 'completed'
        //  - Refund amount <= original payment amount
        //  - Payment is within refundable time window, etc.
        if ($originalPayment['status'] !== 'completed') {
            return false;
        }

        if ($refundData['amount'] > $originalPayment['amount']) {
            return false;
        }

        // More sophisticated checks can go here
        return true;
    }
}
=== App/Services/Payment/PaymentGatewayService.php ===
<?php

namespace App\Services\Payment;

use Psr\Log\LoggerInterface;
use Exception;

class PaymentGatewayService
{
    /**
     * Handles external gateway payments, including:
     *  - Initiating payment requests to Stripe, PayU, or other providers
     *  - Handling responses and mapping them to a standard format
     *  - Fraud detection/authorization logic (if the gateway doesn’t already do it)
     *  - Handling webhooks or callback data to confirm payment status
     *  - Logging relevant details for debugging
     *
     * @author 
     * @version 1.0
     * @description
     *   - External API calls to payment gateways
     *   - Securely handling API keys/credentials (from .env or config)
     *   - Logging errors, warnings, or debug info via LoggerInterface
     */

    private LoggerInterface $logger;

    /**
     * Depending on your actual gateway usage, you might need:
     *  - Guzzle or another HTTP client
     *  - Gateway-specific SDKs
     *  - Configuration values for API keys, secrets, etc.
     *
     * @param LoggerInterface $logger
     */
    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }

    /**
     * Orchestrates payment with the specified gateway.
     *
     * @param string $gatewayName  E.g. "stripe", "payu", etc.
     * @param array  $paymentData  [
     *       'amount'     => 120.00,
     *       'currency'   => 'USD',
     *       'card_token' => 'tok_abc123', // Stripe example
     *       // Possibly customer info, etc...
     * ]
     * @return array
     *   Typically includes a standardized response: ['status' => 'success', 'gateway_id' => 'XYZ']
     */
    public function processPayment(string $gatewayName, array $paymentData): array
    {
        try {
            // Example: Switch or strategy pattern for different gateways
            switch (strtolower($gatewayName)) {
                case 'stripe':
                    return $this->processStripePayment($paymentData);

                case 'payu':
                    return $this->processPayUPayment($paymentData);

                default:
                    throw new Exception("Unsupported payment gateway: {$gatewayName}");
            }
        } catch (Exception $e) {
            $this->logger->error('Payment gateway error', [
                'gateway' => $gatewayName,
                'data'    => $paymentData,
                'error'   => $e->getMessage()
            ]);
            throw $e;
        }
    }

    /**
     * Generic handler for gateway webhook callbacks.
     * Gateways typically send POST requests to a URL you define.
     *
     * @param string $gatewayName
     * @param array  $callbackData e.g. JSON payload from Stripe/PayU
     * @return array
     *   Provide a response that your app can use to confirm payment status, etc.
     */
    public function handleCallback(string $gatewayName, array $callbackData): array
    {
        try {
            // You might do signature verification or event type checks here
            // For example, with Stripe: verify the event using a secret key

            switch (strtolower($gatewayName)) {
                case 'stripe':
                    return $this->handleStripeCallback($callbackData);

                case 'payu':
                    return $this->handlePayUCallback($callbackData);

                default:
                    throw new Exception("Unsupported payment gateway callback: {$gatewayName}");
            }
        } catch (Exception $e) {
            $this->logger->error('Payment gateway callback error', [
                'gateway' => $gatewayName,
                'data'    => $callbackData,
                'error'   => $e->getMessage()
            ]);
            // In practice, you’d respond with an HTTP error or a structured JSON error
            throw $e;
        }
    }

    /**
     * Example: Implementation detail for Stripe payment
     *
     * @param array $paymentData
     * @return array
     */
    private function processStripePayment(array $paymentData): array
    {
        // Pseudocode for Stripe integration
        // You’d typically use Stripe’s PHP SDK or an HTTP call
        // $stripe = new \Stripe\StripeClient($this->stripeApiKey);
        // $charge = $stripe->charges->create([...]);
        // return some standardized format

        $this->logger->info('Processing Stripe payment', $paymentData);

        // Placeholder return
        return [
            'status'     => 'success',
            'gateway_id' => 'stripe_charge_ABC123',
            'message'    => 'Stripe payment completed.'
        ];
    }

    /**
     * Example: Implementation detail for PayU payment
     *
     * @param array $paymentData
     * @return array
     */
    private function processPayUPayment(array $paymentData): array
    {
        $this->logger->info('Processing PayU payment', $paymentData);

        // Pseudocode for PayU
        // $response = $this->httpClient->post('https://api.payu.com/v2/payments', [...]);
        // parse response, handle success/failure

        // Placeholder return
        return [
            'status'     => 'success',
            'gateway_id' => 'payu_transaction_ABC123',
            'message'    => 'PayU payment completed.'
        ];
    }

    /**
     * Example method for handling Stripe webhook data
     *
     * @param array $callbackData
     * @return array
     */
    private function handleStripeCallback(array $callbackData): array
    {
        // E.g., verify signature, parse event, check payment_intent status, etc.
        $this->logger->info('Handling Stripe webhook callback', $callbackData);

        // Return standardized response
        return [
            'status'  => 'received',
            'message' => 'Stripe webhook processed.'
        ];
    }

    /**
     * Example method for handling PayU webhook data
     *
     * @param array $callbackData
     * @return array
     */
    private function handlePayUCallback(array $callbackData): array
    {
        $this->logger->info('Handling PayU webhook callback', $callbackData);

        // Return standardized response
        return [
            'status'  => 'received',
            'message' => 'PayU webhook processed.'
        ];
    }
}
=== App/Services/README.md ===
# Token Validation Changes

## TokenValidator Deprecation

The `TokenValidator` class has been deprecated in favor of the more robust `TokenService` class. This change centralizes all token-related functionality into a single service class, making the codebase more maintainable and testable.

## Migration Guide

### Before

```php
use App\Helpers\TokenValidator;

// In controllers
$user = TokenValidator::validateToken($request->getHeader('Authorization'));
if (!$user) {
    // Handle unauthorized access
}
```

### After

```php
use App\Services\Auth\TokenService;

// In constructor
private TokenService $tokenService;

public function __construct(TokenService $tokenService, /* other dependencies */) {
    $this->tokenService = $tokenService;
    // ...
}

// In controller methods
$user = $this->tokenService->validateTokenFromHeader($request->getHeader('Authorization')[0] ?? null);
// or
$user = $this->tokenService->validateRequest($request);

if (!$user) {
    // Handle unauthorized access
}
```

## New TokenService Methods

- `validateTokenFromHeader($tokenHeader)` - Validates a token from an Authorization header
- `extractToken($request)` - Extracts a token from various request formats
- `validateRequest($request)` - Validates a token and returns user data in one step
- `verifyToken($token)` - Verifies JWT token and returns decoded payload

## Benefits

1. **Centralized Logic**: All token operations are now in one service
2. **Dependency Injection**: The service can be properly injected, allowing for easier testing
3. **Consistent Error Handling**: All token errors are handled consistently
4. **Audit Logging**: Token validations are now logged in the audit trail

## Automatic Compatibility

To ease migration, a compatibility layer has been added to the old `TokenValidator` class that delegates to `TokenService`. However, you should update your code to use `TokenService` directly, as the compatibility layer will be removed in a future release.
=== App/Services/EncryptionService.php ===
<?php

namespace App\Services;

use Illuminate\Support\Facades\Crypt;
use Illuminate\Support\Facades\Storage;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class EncryptionService
{
    public const DEBUG_MODE = true;

    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private string $encryptionKey;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        string $encryptionKey
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->encryptionKey = $encryptionKey;
    }

    public function encrypt(string $data): string
    {
        try {
            return Crypt::encryptString($data);
        } catch (\Exception $e) {
            $this->logger->error("[Encryption] ❌ Encryption failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function decrypt(string $encryptedData): ?string
    {
        try {
            return Crypt::decryptString($encryptedData);
        } catch (\Exception $e) {
            $this->logger->error("[Encryption] ❌ Decryption failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }

    public function encryptFile(string $inputFile, string $outputFile): bool
    {
        try {
            $data = file_get_contents($inputFile);
            if ($data === false) {
                throw new \RuntimeException("Failed to read file: $inputFile");
            }
            $encrypted = Crypt::encryptString($data);
            Storage::put($outputFile, $encrypted);
            return true;
        } catch (\Exception $e) {
            $this->logger->error("File encryption failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    public function decryptFile(string $inputFile, string $outputFile): bool
    {
        try {
            $encryptedData = Storage::get($inputFile);
            $decrypted = Crypt::decryptString($encryptedData);
            Storage::put($outputFile, $decrypted);
            return true;
        } catch (\Exception $e) {
            $this->logger->error("File decryption failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    public function sign(string $data): string
    {
        return hash_hmac('sha256', $data, $this->encryptionKey);
    }

    public function verify(string $data, string $signature): bool
    {
        return hash_equals($this->sign($data), $signature);
    }
}
=== App/Services/FileStorage.php ===
<?php

namespace App\Services;

use Exception;
use App\Services\EncryptionService;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class FileStorage
{
    public const DEBUG_MODE = true;
    private string $basePath;
    private array $config;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private EncryptionService $encryptionService;

    public function __construct(
        array $config,
        EncryptionService $encryptionService,
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->config = $config;
        $this->encryptionService = $encryptionService;
        $this->basePath = rtrim($config['base_directory'], DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;

        if (!is_dir($this->basePath) || !is_writable($this->basePath)) {
            throw new Exception("Invalid storage base path or insufficient permissions: {$this->basePath}");
        }
    }

    public function storeFile(string $directory, string $fileName, string $content, bool $encrypt = false): string
    {
        $safeDirectory = $this->getDirectoryPath($directory);
        $safeFileName = $this->sanitizeFileName($fileName);
        $filePath = $safeDirectory . $safeFileName;

        if ($encrypt) {
            $content = $this->encryptionService->encrypt($content);
        }

        try {
            if (file_put_contents($filePath, $content) === false) {
                throw new Exception("Failed to store file: $fileName");
            }

            chmod($filePath, $this->config['security']['permissions']['default']);
            if (self::DEBUG_MODE) {
                $this->logger->info("[FileStorage] File stored: {$fileName}");
            }

            return $filePath;
        } catch (\Exception $e) {
            $this->logger->error("[FileStorage] ❌ Failed to store file: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function retrieveFile(string $filePath, bool $decrypt = false): string
    {
        try {
            if (!file_exists($filePath) || !is_readable($filePath)) {
                throw new Exception("File not found or not readable: $filePath");
            }

            $content = file_get_contents($filePath);
            if ($content === false) {
                throw new Exception("Failed to retrieve file: $filePath");
            }

            if ($decrypt) {
                $content = $this->encryptionService->decrypt($content);
                if ($content === null) {
                    throw new Exception("Failed to decrypt file: $filePath");
                }
            }

            if (self::DEBUG_MODE) {
                $this->logger->info("[FileStorage] File retrieved: {$filePath}");
            }
            return $content;
        } catch (\Exception $e) {
            $this->logger->error("[FileStorage] ❌ Failed to retrieve file: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function deleteFile(string $filePath): void
    {
        try {
            if (!file_exists($filePath)) {
                throw new Exception("File not found: $filePath");
            }

            if (!unlink($filePath)) {
                throw new Exception("Failed to delete file: $filePath");
            }

            if (self::DEBUG_MODE) {
                $this->logger->info("[FileStorage] File deleted: {$filePath}");
            }
        } catch (\Exception $e) {
            $this->logger->error("[FileStorage] ❌ Failed to delete file: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    private function sanitizeFileName(string $fileName): string
    {
        return preg_replace('/[^a-zA-Z0-9_\.-]/', '_', $fileName);
    }

    private function getDirectoryPath(string $directory): string
    {
        $path = $this->basePath . trim($directory, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;

        if (!is_dir($path) && !mkdir($path, 0755, true)) {
            $this->logger->error("❌ Failed to create directory.", ['path' => $path, 'trace' => debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS)]);
            throw new Exception("Failed to create directory: $path");
        }

        if (!is_writable($path)) {
            $this->logger->error("❌ Directory is not writable.", ['path' => $path, 'trace' => debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS)]);
            throw new Exception("Directory is not writable: $path");
        }

        return $path;
    }
}
=== App/Services/RateLimiter.php ===
<?php

namespace App\Services;

use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

/**
 * Rate Limiter Service
 *
 * Implements IP-based rate limiting.
 */
class RateLimiter
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    public function __construct(LoggerInterface $logger, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
    }

    public function isRateLimited(string $ip): bool
    {
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }
        if (!isset($_SESSION['rate_limit'])) {
            $_SESSION['rate_limit'] = [];
        }
        $attempts = $_SESSION['rate_limit'][$ip] ?? 0;
        if ($attempts >= 5) {
            if (self::DEBUG_MODE) {
                $this->logger->warning("[security] Rate limit exceeded for IP: {$ip}", ['category' => 'security']);
            }
            return true;
        }
        return false;
    }

    public function recordFailedAttempt(string $ip): void
    {
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }
        if (!isset($_SESSION['rate_limit'])) {
            $_SESSION['rate_limit'] = [];
        }
        $_SESSION['rate_limit'][$ip] = ($_SESSION['rate_limit'][$ip] ?? 0) + 1;
        if (self::DEBUG_MODE) {
            $this->logger->info("[security] Recorded failed attempt for IP: {$ip}", ['category' => 'security']);
        }
    }
}
=== App/Services/RevenueService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use App\Models\Payment;
use App\Models\TransactionLog;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class RevenueService
{
    public const DEBUG_MODE = true;
    private $db;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    // Assume dependency injection now supplies the logger.
    public function __construct(LoggerInterface $logger, DatabaseHelper $db, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->db = $db;
        $this->exceptionHandler = $exceptionHandler;
    }

    public function getMonthlyRevenueTrends(): array
    {
        try {
            $data = $this->db->table('payments')
                ->where('status', 'completed')
                ->selectRaw('DATE_FORMAT(created_at, "%Y-%m") as month, SUM(amount) as revenue')
                ->groupBy('month')
                ->orderBy('month')
                ->get();
            $labels = array_column($data, 'month');
            $amounts = array_column($data, 'revenue');
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Retrieved monthly revenue trends", ['category' => 'revenue']);
            }
            return [
                'labels' => $labels,
                'data'   => $amounts,
            ];
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function getTotalRevenue(): float
    {
        try {
            $total = $this->db->table('transaction_logs')
                ->where('type', 'payment')
                ->sum('amount');
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Retrieved total revenue", ['category' => 'revenue']);
            }
            return (float) $total;
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function getTotalRefunds(): float
    {
        try {
            $total = $this->db->table('transaction_logs')
                ->where('type', 'refund')
                ->sum('amount');
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Retrieved total refunds", ['category' => 'revenue']);
            }
            return (float) $total;
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function getNetRevenue(): float
    {
        return $this->getTotalRevenue() - $this->getTotalRefunds();
    }
}
=== App/Services/Security/FraudDetectionService.php ===
<?php

namespace App\Services\Security;

use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;
use Exception;

/**
 * FraudDetectionService - Centralized fraud detection system
 * 
 * This service is responsible for analyzing transactions to detect potential fraud
 * and calculating risk scores based on configurable fraud indicators.
 */
class FraudDetectionService
{
    /**
     * Default risk thresholds if not in config
     */
    private const DEFAULT_RISK_THRESHOLD_HIGH = 70;
    private const DEFAULT_RISK_THRESHOLD_MEDIUM = 50;
    private const DEFAULT_RISK_THRESHOLD_LOW = 30;
    
    /**
     * Default fraud indicator weights if not in config
     */
    private const DEFAULT_INDICATOR_WEIGHTS = [
        'high_amount' => 15,
        'multiple_attempts' => 20,
        'unusual_location' => 30,
        'address_mismatch' => 25,
        'card_country_mismatch' => 35,
        'rapid_transactions' => 18,
        'unusual_time' => 10,
        'ip_proxy_detected' => 40,
        'device_mismatch' => 28,
        'risky_email_domain' => 15
    ];
    
    /**
     * Default risky email domains if not in config
     */
    private const DEFAULT_RISKY_EMAIL_DOMAINS = [
        'tempmail.com', 'throwaway.com', 'mailinator.com',
        'guerrillamail.com', 'yopmail.com', 'sharklasers.com',
        'dispostable.com', '10minutemail.com', 'temp-mail.org'
    ];
    
    /**
     * Configuration cache
     */
    private array $config;
    private array $indicatorWeights;
    private array $riskThresholds;
    private array $riskyDomains;
    
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private string $requestId;
    
    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        array $config, // Inject configuration
        string $requestId = null
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->requestId = $requestId ?? uniqid('fraud_');
        
        // Load configuration
        $this->loadConfig($config);
    }
    
    /**
     * Load fraud detection configuration
     */
    private function loadConfig(array $config): void
    {
        try {
            // Use provided config
            $this->config = $config;
            
            // Set risk thresholds from config or use defaults
            $this->riskThresholds = [
                'high' => $this->config['thresholds']['high'] ?? self::DEFAULT_RISK_THRESHOLD_HIGH,
                'medium' => $this->config['thresholds']['medium'] ?? self::DEFAULT_RISK_THRESHOLD_MEDIUM,
                'low' => $this->config['thresholds']['low'] ?? self::DEFAULT_RISK_THRESHOLD_LOW
            ];
            
            // Set indicator weights from config or use defaults
            $this->indicatorWeights = $this->config['indicator_weights'] ?? self::DEFAULT_INDICATOR_WEIGHTS;
            
            // Set risky email domains from config or use defaults
            $this->riskyDomains = $this->config['risky_email_domains'] ?? self::DEFAULT_RISKY_EMAIL_DOMAINS;
            
            $this->logger->debug("[FraudDetection] Configuration loaded", [
                'request_id' => $this->requestId
            ]);
        } catch (Exception $e) {
            $this->logger->error("[FraudDetection] Failed to load configuration: " . $e->getMessage(), [
                'request_id' => $this->requestId
            ]);
            // Use default values if config loading fails
            $this->riskThresholds = [
                'high' => self::DEFAULT_RISK_THRESHOLD_HIGH,
                'medium' => self::DEFAULT_RISK_THRESHOLD_MEDIUM,
                'low' => self::DEFAULT_RISK_THRESHOLD_LOW
            ];
            $this->indicatorWeights = self::DEFAULT_INDICATOR_WEIGHTS;
            $this->riskyDomains = self::DEFAULT_RISKY_EMAIL_DOMAINS;
        }
    }
    
    /**
     * Main entry point - analyze a transaction for fraud indicators
     * 
     * @param array $transactionData Complete transaction data
     * @param array $options Optional analysis options
     * @return array Analysis results with indicators, score and risk level
     */
    public function analyzeTransaction(array $transactionData, array $options = []): array
    {
        try {
            // Get time of analysis
            $analysisTime = time();
            
            // Detect fraud indicators
            $indicators = $this->detectFraudIndicators($transactionData, $options);
            
            // Calculate risk score based on indicators
            $riskScore = $this->calculateRiskScore($indicators);
            
            // Determine risk level based on score
            $riskLevel = $this->getRiskLevel($riskScore);
            
            // Determine appropriate log level
            $logLevel = $this->getLogLevelForRisk($riskScore);
            
            // Build recommendation based on risk level
            $recommendation = $this->generateRecommendation($riskLevel, $riskScore, $indicators);
            
            // Log high-risk transactions
            if ($riskScore >= $this->riskThresholds['medium']) {
                $this->logger->warning("[FraudDetection] High risk transaction detected", [
                    'request_id' => $this->requestId,
                    'transaction_id' => $transactionData['id'] ?? 'unknown',
                    'risk_score' => $riskScore,
                    'risk_level' => $riskLevel,
                    'indicators' => array_keys(array_filter($indicators))
                ]);
            }
            
            // Return complete analysis
            return [
                'indicators' => $indicators,
                'risk_score' => $riskScore,
                'risk_level' => $riskLevel,
                'log_level' => $logLevel,
                'recommendation' => $recommendation,
                'analysis_time' => $analysisTime,
                'request_id' => $this->requestId
            ];
        } catch (Exception $e) {
            $this->logger->error("[FraudDetection] Analysis failed: " . $e->getMessage(), [
                'request_id' => $this->requestId,
                'transaction' => isset($transactionData['id']) ? $transactionData['id'] : 'unknown'
            ]);
            $this->exceptionHandler->handleException($e);
            
            // Return safe default values
            return [
                'indicators' => [],
                'risk_score' => 0,
                'risk_level' => 'error',
                'log_level' => 'error',
                'recommendation' => 'review_manually',
                'error' => 'Analysis failed: ' . $e->getMessage(),
                'analysis_time' => time(),
                'request_id' => $this->requestId
            ];
        }
    }
    
    /**
     * Analyze transaction data to detect potential fraud indicators
     *
     * @param array $data Transaction data
     * @param array $options Optional detection options 
     * @return array Detected fraud indicators (indicator name => boolean)
     */
    public function detectFraudIndicators(array $data, array $options = []): array
    {
        $indicators = [];
        $rules = $this->config['rules'] ?? [];
        
        // Check for high amount transactions
        $highAmountThreshold = $rules['high_amount_threshold'] ?? 1000;
        if (isset($data['amount']) && $data['amount'] > $highAmountThreshold) {
            $indicators['high_amount'] = true;
        }
        
        // Check for multiple payment attempts
        $maxAttempts = $rules['max_payment_attempts'] ?? 3;
        if (isset($data['attempts']) && $data['attempts'] > $maxAttempts) {
            $indicators['multiple_attempts'] = true;
        }
        
        // Check for location mismatches
        if (isset($data['location'], $data['expected_location']) && 
            $data['location'] !== $data['expected_location']) {
            $indicators['unusual_location'] = true;
        }
        
        // Check for address mismatches between billing and shipping
        if (isset($data['billing_country'], $data['shipping_country']) && 
            $data['billing_country'] !== $data['shipping_country']) {
            $indicators['address_mismatch'] = true;
        }
        
        // Check for card country mismatch
        if (isset($data['card_country'], $data['user_country']) && 
            $data['card_country'] !== $data['user_country']) {
            $indicators['card_country_mismatch'] = true;
        }
        
        // Check for rapid transactions from the same user
        $minTransactionInterval = $rules['min_transaction_interval_minutes'] ?? 5;
        if (isset($data['last_transaction_minutes']) && 
            $data['last_transaction_minutes'] < $minTransactionInterval) {
            $indicators['rapid_transactions'] = true;
        }
        
        // Check for unusual transaction times
        $startBusinessHour = $rules['business_hours_start'] ?? 6;
        $endBusinessHour = $rules['business_hours_end'] ?? 23;
        if (isset($data['hour']) && ($data['hour'] < $startBusinessHour || $data['hour'] > $endBusinessHour)) {
            $indicators['unusual_time'] = true;
        }
        
        // Check for IP proxy usage
        if (isset($data['ip_is_proxy']) && $data['ip_is_proxy'] === true) {
            $indicators['ip_proxy_detected'] = true;
        }
        
        // Check for device mismatch with previous session
        if (isset($data['device_changed']) && $data['device_changed'] === true) {
            $indicators['device_mismatch'] = true;
        }
        
        // Check for risky email domains
        if (isset($data['email']) && $this->isRiskyEmailDomain($data['email'])) {
            $indicators['risky_email_domain'] = true;
        }
        
        // Run custom rules from config if defined
        if (isset($this->config['custom_rules']) && is_array($this->config['custom_rules'])) {
            foreach ($this->config['custom_rules'] as $ruleName => $ruleData) {
                if (isset($ruleData['condition']) && is_callable($ruleData['condition'])) {
                    try {
                        $result = call_user_func($ruleData['condition'], $data, $options);
                        if ($result === true) {
                            $indicators[$ruleName] = true;
                        }
                    } catch (Exception $e) {
                        $this->logger->warning("[FraudDetection] Custom rule failed: {$ruleName}", [
                            'request_id' => $this->requestId,
                            'error' => $e->getMessage()
                        ]);
                    }
                }
            }
        }
        
        return $indicators;
    }
    
    /**
     * Calculate a risk score based on detected fraud indicators
     *
     * @param array $indicators Detected fraud indicators
     * @return int Risk score (0-100)
     */
    public function calculateRiskScore(array $indicators): int
    {
        $score = 0;
        
        foreach ($indicators as $key => $flag) {
            if ($flag && isset($this->indicatorWeights[$key])) {
                $score += $this->indicatorWeights[$key];
            }
        }
        
        // Cap the score at 100
        return min($score, 100);
    }
    
    /**
     * Get risk level description based on score
     *
     * @param int $score Risk score
     * @return string Risk level (high, medium, low, minimal)
     */
    public function getRiskLevel(int $score): string
    {
        if ($score >= $this->riskThresholds['high']) return 'high';
        if ($score >= $this->riskThresholds['medium']) return 'medium';
        if ($score >= $this->riskThresholds['low']) return 'low';
        return 'minimal';
    }
    
    /**
     * Get appropriate log level based on risk score
     *
     * @param int $score Risk score
     * @return string Log level (critical, error, warning, info)
     */
    public function getLogLevelForRisk(int $score): string
    {
        if ($score >= $this->riskThresholds['high']) return 'critical';
        if ($score >= $this->riskThresholds['medium']) return 'error';
        if ($score >= $this->riskThresholds['low']) return 'warning';
        return 'info';
    }
    
    /**
     * Generate recommendation based on risk assessment
     *
     * @param string $riskLevel Risk level
     * @param int $riskScore Risk score
     * @param array $indicators Detected indicators
     * @return string Recommendation code
     */
    public function generateRecommendation(string $riskLevel, int $riskScore, array $indicators): string
    {
        // Use configured recommendations or fallback to defaults
        $recommendations = $this->config['recommendations'] ?? [
            'high' => 'block_transaction',
            'medium' => 'additional_verification',
            'low' => 'flag_for_review',
            'minimal' => 'proceed'
        ];
        
        // Special cases based on specific indicators
        if (isset($indicators['ip_proxy_detected']) && $indicators['ip_proxy_detected']) {
            return 'additional_verification';
        }
        
        if (isset($indicators['card_country_mismatch']) && $indicators['card_country_mismatch']) {
            return $riskLevel === 'high' ? 'block_transaction' : 'additional_verification';
        }
        
        // Default recommendation based on risk level
        return $recommendations[$riskLevel] ?? 'review_manually';
    }
    
    /**
     * Check if an email domain is considered risky
     *
     * @param string $email Email address to check
     * @return bool True if the domain is risky
     */
    private function isRiskyEmailDomain(string $email): bool
    {
        $parts = explode('@', $email);
        if (count($parts) != 2) {
            return false;
        }
        
        $domain = strtolower($parts[1]);
        return in_array($domain, $this->riskyDomains);
    }
    
    /**
     * Get a copy of the current configuration
     *
     * @return array Current configuration
     */
    public function getConfig(): array
    {
        return [
            'risk_thresholds' => $this->riskThresholds,
            'indicator_weights' => $this->indicatorWeights,
            'risky_domains' => $this->riskyDomains,
            'rules' => $this->config['rules'] ?? []
        ];
    }
}
=== App/Services/Security/KeyManager.php ===
<?php

namespace App\Services\Security;

use Exception;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class KeyManager
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private array $keys;

    public function __construct(
        array $keys,
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->keys = $keys;
    }

    public function getKey(string $identifier): string
    {
        $keyName = 'encryption_key_' . strtolower($identifier);

        if (!isset($this->keys[$keyName]) || empty($this->keys[$keyName])) {
            $this->logger->error("[security] ❌ Encryption key for {$identifier} not found.", ['identifier' => $identifier]);
            throw new Exception("Encryption key for {$identifier} not found.");
        }

        return $this->keys[$keyName];
    }

    public function generateKey(): string
    {
        try {
            $key = base64_encode(random_bytes(32)); // AES-256 key
            $this->logger->info('Key generated', ['key_data' => $key]);
            return $key;
        } catch (Exception $e) {
            $this->logger->error('Failed to generate key', ['error' => $e->getMessage()]);
            throw $e;
        }
    }

    public function storeKey(string $identifier, string $key): void
    {
        if (self::DEBUG_MODE) {
            $this->logger->info("[security] Storing key for {$identifier}");
        }
        $this->logger->info("[security] ✅ Storing key for {$identifier}", ['identifier' => $identifier]);
        // Implementation for storing key securely (e.g., database, key vault)
    }

    public function rotateKey(string $identifier): void
    {
        $newKey = $this->generateKey();
        $this->storeKey($identifier, $newKey);
        $this->logger->info("[security] ✅ Rotated key for {$identifier}", ['identifier' => $identifier]);
    }

    public function revokeKey(string $identifier): void
    {
        $this->logger->info("[security] ✅ Revoking key for {$identifier}", ['identifier' => $identifier]);
        // Implementation for revoking key securely
    }
}
=== App/Services/SignatureService.php ===
<?php

namespace App\Services;

use Exception;
use GuzzleHttp\Client;
use Psr\Log\LoggerInterface;
use App\Services\FileStorage;
use App\Services\EncryptionService;
use App\Helpers\DatabaseHelper;
use App\Helpers\ExceptionHandler;

/**
 * Signature Service
 *
 * Manages electronic signatures both locally and via an external AES API.
 */
class SignatureService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private DatabaseHelper $db;
    private string $apiEndpoint;
    private string $apiKey;
    private FileStorage $fileStorage;
    private EncryptionService $encryptionService;
    private ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        DatabaseHelper $db,
        array $config,
        FileStorage $fileStorage,
        EncryptionService $encryptionService,
        ExceptionHandler $exceptionHandler
    ) {
        if (empty($config['api_endpoint']) || empty($config['api_key'])) {
            throw new Exception('AES API configuration is incomplete.');
        }

        $this->logger = $logger;
        $this->db = $db;
        $this->apiEndpoint = $config['api_endpoint'];
        $this->apiKey = $config['api_key'];
        $this->fileStorage = $fileStorage;
        $this->encryptionService = $encryptionService;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Upload a local signature securely.
     */
    public function uploadSignature(string $filePath, int $userId): string
    {
        $this->validateFileType($filePath);

        $encryptedContent = $this->encryptionService->encrypt(file_get_contents($filePath));
        $fileName = uniqid() . '.' . pathinfo($filePath, PATHINFO_EXTENSION);
        $storagePath = $this->fileStorage->storeFile("signatures/{$userId}", $fileName, $encryptedContent, false);

        try {
            $this->db->table('signatures')->insert([
                'user_id'   => $userId,
                'file_path' => $storagePath,
                'encrypted' => true,
                'created_at'=> date('Y-m-d H:i:s'),
            ]);
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Signature record created", ['userId' => $userId, 'storagePath' => $storagePath]);
            }
        } catch (Exception $e) {
            $this->logger->error("[db] ❌ Database error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
        if (self::DEBUG_MODE) {
            $this->logger->info("[system] Signature uploaded", ['userId' => $userId, 'storagePath' => $storagePath]);
        }
        return $storagePath;
    }

    /**
     * Send a document for AES signature.
     */
    public function sendForAdvancedSignature(string $filePath, int $userId, string $callbackUrl): array
    {
        try {
            $documentHash = hash_file('sha256', $filePath);

            $client = new Client();
            $response = $client->post("{$this->apiEndpoint}/sign-aes", [
                'headers' => $this->getAuthHeaders(),
                'multipart' => [
                    ['name' => 'file', 'contents' => fopen($filePath, 'r')],
                    ['name' => 'user_id', 'contents' => $userId],
                    ['name' => 'document_hash', 'contents' => $documentHash],
                    ['name' => 'callback_url', 'contents' => $callbackUrl],
                ],
            ]);

            return json_decode($response->getBody()->getContents(), true);
        } catch (Exception $e) {
            $this->logger->error("[api] Failed to send document for AES signing: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to send document for AES signing: " . $e->getMessage());
        }
    }

    /**
     * Verify an AES signature using Laravel HTTP client.
     */
    public function verifySignature(string $signedFilePath, string $originalFilePath): bool
    {
        try {
            $originalHash = hash_file('sha256', $originalFilePath);
            $signedHash = hash_file('sha256', $signedFilePath);
            
            $client = new Client();
            $response = $client->post("{$this->apiEndpoint}/verify-aes", [
                'headers' => $this->getAuthHeaders(),
                'json' => [
                    'original_hash' => $originalHash,
                    'signed_hash'   => $signedHash,
                ],
            ]);

            $result = json_decode($response->getBody()->getContents(), true);
            if (self::DEBUG_MODE) {
                $this->logger->info("[api] Signature verification", ['result' => $result]);
            }
            return $result['verified'] ?? false;
        } catch (Exception $e) {
            $this->logger->error("[api] Failed to verify signature: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to verify signature: " . $e->getMessage());
        }
    }

    /**
     * Retrieve stored local signatures for a user.
     */
    public function getSignatures(int $userId): array
    {
        $storedSignatures = $this->fileStorage->retrieveFiles("signatures/{$userId}");

        if (empty($storedSignatures)) {
            throw new Exception('No signatures found.');
        }

        return array_map(fn($path) => $this->encryptionService->decrypt($this->fileStorage->retrieveFile($path, false)), $storedSignatures);
    }

    /**
     * Check the status of an AES signature request.
     */
    public function checkAdvancedSignatureStatus(string $requestId): array
    {
        try {
            $client = new Client();
            $response = $client->get("{$this->apiEndpoint}/status/{$requestId}", [
                'headers' => $this->getAuthHeaders(),
            ]);

            return json_decode($response->getBody()->getContents(), true);
        } catch (Exception $e) {
            $this->logger->error("[api] Failed to check AES signature status: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to check AES signature status: " . $e->getMessage());
        }
    }

    /**
     * Download a signed AES document.
     */
    public function downloadSignedDocument(string $requestId, string $outputPath): bool
    {
        try {
            $client = new Client();
            $response = $client->get("{$this->apiEndpoint}/download/{$requestId}", [
                'headers' => $this->getAuthHeaders(),
                'sink' => $outputPath,
            ]);

            return $response->getStatusCode() === 200;
        } catch (Exception $e) {
            $this->logger->error("[api] Failed to download AES signed document: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to download AES signed document: " . $e->getMessage());
        }
    }

    /**
     * Get authentication headers for API requests.
     */
    private function getAuthHeaders(): array
    {
        return [
            'Authorization' => "Bearer {$this->apiKey}",
            'Content-Type'  => 'application/json',
        ];
    }

    /**
     * Validate allowed file types.
     */
    private function validateFileType(string $filePath): void
    {
        $allowedExtensions = ['png', 'jpg', 'svg'];
        if (!in_array(pathinfo($filePath, PATHINFO_EXTENSION), $allowedExtensions)) {
            throw new Exception('Invalid file type.');
        }
    }

    /**
     * Log error and throw exception.
     */
    private function logAndThrow(string $message, Exception $e): void
    {
        $this->logger->error($message, ['error' => $e->getMessage()]);
        throw new Exception("$message: " . $e->getMessage());
    }
}
=== App/Services/ReportService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use App\Models\Booking;
use App\Models\Payment;
use App\Models\User;
use Dompdf\Dompdf;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class ReportService
{
    public const DEBUG_MODE = true;
    private DatabaseHelper $db;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    public function __construct(LoggerInterface $logger, DatabaseHelper $db, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->db = $db;
        $this->exceptionHandler = $exceptionHandler;
    }    

    public function generateReport(string $reportType, array $dateRange, string $format, array $filters = []): string
    {
        $start = $dateRange['start'];
        $end   = $dateRange['end'];
        $data = match ($reportType) {
            'bookings' => $this->getBookingReportData($dateRange, $filters),
            'payments' => $this->getPaymentReportData($dateRange, $filters),
            'users'    => $this->getUserReportData($dateRange, $filters),
            default    => throw new \InvalidArgumentException("Invalid report type: $reportType"),
        };
        return $this->exportReport($data, "{$reportType}_" . date('YmdHis'), $format);
    }

    public function generateUserReport(int $userId, string $reportType, array $dateRange, string $format): string
    {
        $start = $dateRange['start'];
        $end   = $dateRange['end'];
        $data = match ($reportType) {
            'bookings' => Booking::with('user')
                         ->where('user_id', $userId)
                         ->whereBetween('created_at', [$start, $end])
                         ->get()
                         ->toArray(),
            'payments' => Payment::where('user_id', $userId)
                         ->whereBetween('created_at', [$start, $end])
                         ->get()
                         ->toArray(),
            default    => throw new \InvalidArgumentException("Invalid report type: $reportType"),
        };
        return $this->exportReport($data, "{$reportType}_user_{$userId}", $format);
    }

    private function getBookingReportData(array $dateRange, array $filters): array
    {
        try {
            $query = $this->db->table('bookings')->whereBetween('created_at', [$dateRange['start'], $dateRange['end']]);
            if (!empty($filters['status'])) {
                $query->where('status', $filters['status']);
            }
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Fetched booking report data", ['category' => 'report']);
            }
            return $query->get();
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error (booking): " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    private function getPaymentReportData(array $dateRange, array $filters): array
    {
        try {
            $query = $this->db->table('payments')->whereBetween('created_at', [$dateRange['start'], $dateRange['end']]);
            if (!empty($filters['type'])) {
                $query->where('type', $filters['type']);
            }
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Fetched payment report data", ['category' => 'report']);
            }
            return $query->get();
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error (payments): " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    private function getUserReportData(array $dateRange, array $filters): array
    {
        try {
            $data = $this->db->table('users')
                         ->whereBetween('created_at', [$dateRange['start'], $dateRange['end']])
                         ->get();
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Fetched user report data");
            }
            return $data;
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error (users): " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    private function exportReport(array $data, string $reportName, string $format): string
    {
        $filePath = __DIR__ . "/../../storage/reports/{$reportName}_" . date('YmdHis') . ".{$format}";

        if ($format === 'csv') {
            $file = fopen($filePath, 'w');
            if (!empty($data)) {
                fputcsv($file, array_keys($data[0])); // headers
                foreach ($data as $row) {
                    fputcsv($file, $row);
                }
            }
            fclose($file);
        } elseif ($format === 'pdf') {
            $dompdf = new Dompdf();
            $html = '<table border="1"><tr>';
            if (!empty($data)) {
                foreach (array_keys($data[0]) as $header) {
                    $html .= "<th>$header</th>";
                }
                $html .= "</tr>";
                foreach ($data as $row) {
                    $html .= "<tr>";
                    foreach ($row as $cell) {
                        $html .= "<td>$cell</td>";
                    }
                    $html .= "</tr>";
                }
            }
            $html .= "</table>";
            $dompdf->loadHtml($html);
            $dompdf->render();
            file_put_contents($filePath, $dompdf->output());
        } else {
            throw new \InvalidArgumentException("Unsupported format: $format");
        }
        if (self::DEBUG_MODE) {
            $this->logger->info("[system] Exported report: {$filePath}");
        }
        return $filePath;
    }
}
=== App/Services/Audit/UserAuditService.php ===
<?php

namespace App\Services\Audit;

use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;
use Psr\Log\NullLogger;
use Exception;

class UserAuditService
{
    private LogManagementService $logManager;
    private ExceptionHandler $exceptionHandler;
    private LoggerInterface $logger;
    
    /**
     * User event categories
     */
    private const CATEGORY_AUTH = 'auth';
    private const CATEGORY_USER = 'user';
    private const CATEGORY_SYSTEM = 'system';
    private const CATEGORY_SECURITY = 'security';
    private const CATEGORY_API = 'api';
    
    public function __construct(
        LogManagementService $logManager, 
        ExceptionHandler $exceptionHandler,
        LoggerInterface $logger = null
    ) {
        $this->logManager = $logManager;
        $this->exceptionHandler = $exceptionHandler;
        $this->logger = $logger ?? $logManager->getLogger() ?? new NullLogger();
    }
    
    /**
     * Main method for logging any user-related event
     * All other logging methods route through this one
     *
     * @param string $category Event category
     * @param string $action Specific action being performed
     * @param string $message Log message
     * @param array $context Additional context data
     * @param int|null $userId Associated user ID
     * @param string $logLevel Log level
     * @return int|null Log entry ID if successful
     */
    public function logUserEvent(
        string $category,
        string $action,
        string $message,
        array $context = [],
        ?int $userId = null,
        string $logLevel = 'info'
    ): ?int {
        try {
            // Enrich context with user-specific data
            $enrichedContext = $this->enrichUserContext($action, $context);
            
            // Route through LogManagementService
            return $this->logManager->createLogEntry(
                $category, 
                $message, 
                $enrichedContext, 
                $userId, 
                null, 
                null, 
                $logLevel
            );
        } catch (Exception $e) {
            $this->logger->error("[UserAudit] Failed to log user event: " . $e->getMessage(), [
                'category' => $category,
                'action' => $action,
                'user_id' => $userId
            ]);
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }
    
    /**
     * Log an authentication event
     */
    public function logAuthEvent(
        string $action,
        string $message,
        array $context = [],
        ?int $userId = null,
        string $logLevel = 'info'
    ): ?int {
        return $this->logUserEvent(self::CATEGORY_AUTH, $action, $message, $context, $userId, $logLevel);
    }
    
    /**
     * Log a user action
     */
    public function logUserAction(
        string $action,
        string $message,
        array $context = [],
        ?int $userId = null,
        string $logLevel = 'info'
    ): ?int {
        return $this->logUserEvent(self::CATEGORY_USER, $action, $message, $context, $userId, $logLevel);
    }
    
    /**
     * Log a system event
     */
    public function logSystemEvent(
        string $action,
        string $message,
        array $context = [],
        ?int $userId = null,
        string $logLevel = 'info'
    ): ?int {
        return $this->logUserEvent(self::CATEGORY_SYSTEM, $action, $message, $context, $userId, $logLevel);
    }
    
    /**
     * Log a security event
     */
    public function logSecurityEvent(
        string $action,
        string $message,
        array $context = [],
        ?int $userId = null,
        string $logLevel = 'warning'
    ): ?int {
        return $this->logUserEvent(self::CATEGORY_SECURITY, $action, $message, $context, $userId, $logLevel);
    }
    
    /**
     * Log an API request
     */
    public function logApiRequest(
        string $endpoint,
        string $method,
        string $message,
        array $context = [],
        ?int $userId = null,
        string $logLevel = 'info'
    ): ?int {
        $apiContext = array_merge($context, [
            'endpoint' => $endpoint,
            'method' => $method
        ]);
        
        return $this->logUserEvent(self::CATEGORY_API, 'api_request', $message, $apiContext, $userId, $logLevel);
    }
    
    /**
     * Enrich context with user-specific data
     */
    private function enrichUserContext(string $action, array $context): array
    {
        $enrichedContext = array_merge($context, [
            'action' => $action,
            'user_agent' => $context['user_agent'] ?? $_SERVER['HTTP_USER_AGENT'] ?? 'Unknown'
        ]);
        
        // Add IP address if not already in context
        if (!isset($enrichedContext['ip_address'])) {
            $enrichedContext['ip_address'] = $this->getClientIp();
        }
        
        // Add timestamp if not already in context
        if (!isset($enrichedContext['timestamp'])) {
            $enrichedContext['timestamp'] = date('Y-m-d H:i:s');
        }
        
        return $enrichedContext;
    }
    
    /**
     * Get client IP address
     */
    private function getClientIp(): string
    {
        foreach (['HTTP_X_FORWARDED_FOR', 'HTTP_CLIENT_IP'] as $header) {
            if (!empty($_SERVER[$header])) {
                $ips = explode(',', $_SERVER[$header]);
                $ip = trim($ips[0]);
                if (filter_var($ip, FILTER_VALIDATE_IP)) {
                    return $ip;
                }
            }
        }
        return $_SERVER['REMOTE_ADDR'] ?? '0.0.0.0';
    }
}
=== App/Services/Audit/TransactionAuditService.php ===
<?php

namespace App\Services\Audit;

use App\Services\Audit\LogManagementService;
use App\Services\Security\FraudDetectionService;
use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;
use Exception;

class TransactionAuditService
{
    private LogManagementService $logManager;
    private FraudDetectionService $fraudDetector;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    
    public function __construct(
        LogManagementService $logManager, 
        FraudDetectionService $fraudDetector,
        ExceptionHandler $exceptionHandler,
        LoggerInterface $logger = null
    ) {
        $this->logManager = $logManager;
        $this->fraudDetector = $fraudDetector;
        $this->exceptionHandler = $exceptionHandler;
        $this->logger = $logger ?? $logManager->getLogger();
    }
    
    /**
     * Generic transaction event logger
     */
    public function logEvent(
        string $category,
        string $message,
        array $context,
        ?int $userId = null,
        ?int $bookingId = null,
        string $logLevel = 'info'
    ): ?int {
        try {
            // Ensure we have transaction type if not specified
            if (!isset($context['transaction_type']) && !isset($context['event_type'])) {
                $context['transaction_type'] = $category;
            }
            
            return $this->logManager->createLogEntry($category, $message, $context, $userId, $bookingId, null, $logLevel);
        } catch (Exception $e) {
            $this->logger->error("[TransactionAudit] Failed to log event: " . $e->getMessage(), [
                'category' => $category,
                'user_id' => $userId,
                'booking_id' => $bookingId
            ]);
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }
    
    /**
     * Record a successful payment transaction
     */
    public function recordPaymentSuccess(array $paymentData): ?int {
        try {
            $message = "Payment processed successfully";
            if (isset($paymentData['amount'])) {
                $message .= sprintf(" for %.2f %s", $paymentData['amount'], $paymentData['currency'] ?? '');
            }
            
            $paymentData['payment_status'] = 'completed';
            
            return $this->logEvent(
                'payment', 
                $message, 
                $paymentData, 
                $paymentData['user_id'] ?? null,
                $paymentData['booking_id'] ?? null, 
                'info'
            );
        } catch (Exception $e) {
            $this->logger->error("[TransactionAudit] Failed to record payment: " . $e->getMessage(), [
                'payment_id' => $paymentData['id'] ?? 'unknown'
            ]);
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }
    
    /**
     * Record a fraud validation failure using FraudDetectionService
     */
    public function recordFraudValidationFailure(
        array $paymentData, 
        array $fraudIndicators = []
    ): ?int {
        try {
            // Use FraudDetectionService to analyze the transaction
            $fraudAnalysis = $this->fraudDetector->analyzeTransaction($paymentData);
            
            $message = sprintf(
                "Potential fraud detected (%s risk) with score %d", 
                $fraudAnalysis['risk_level'], 
                $fraudAnalysis['risk_score']
            );
            
            $context = array_merge($paymentData, [
                'fraud_indicators' => $fraudAnalysis['indicators'],
                'risk_score' => $fraudAnalysis['risk_score'],
                'risk_level' => $fraudAnalysis['risk_level'],
                'event_type' => 'fraud_attempt'
            ]);
            
            return $this->logEvent(
                'security', 
                $message, 
                $context,
                $paymentData['user_id'] ?? null,
                $paymentData['booking_id'] ?? null,
                $fraudAnalysis['log_level']
            );
        } catch (Exception $e) {
            $this->logger->error("[TransactionAudit] Failed to record fraud validation: " . $e->getMessage(), [
                'payment_id' => $paymentData['id'] ?? 'unknown'
            ]);
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }
    
    /**
     * Record a transaction
     */
    public function recordTransaction(
        string $transactionType, 
        array $transactionData, 
        string $status, 
        ?string $message = null
    ): ?int {
        try {
            if ($message === null) {
                $message = ucfirst($transactionType) . " transaction " . $status;
                if (isset($transactionData['amount'])) {
                    $message .= sprintf(" for %.2f %s", $transactionData['amount'], $transactionData['currency'] ?? '');
                }
            }
            
            $context = array_merge($transactionData, [
                'transaction_type' => $transactionType,
                'status' => $status
            ]);
            
            // Define log level based on transaction status
            $logLevel = $this->getLogLevelForStatus($status);
            
            return $this->logEvent(
                'transaction', 
                $message, 
                $context,
                $transactionData['user_id'] ?? null,
                $transactionData['booking_id'] ?? null,
                $logLevel
            );
        } catch (Exception $e) {
            $this->logger->error("[TransactionAudit] Failed to record transaction: " . $e->getMessage(), [
                'transaction_type' => $transactionType,
                'status' => $status
            ]);
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }
    
    /**
     * Record a refund event
     */
    public function recordRefund(array $refundData, string $status): ?int {
        try {
            $message = sprintf(
                "Refund %s for payment ID %s", 
                $status,
                $refundData['payment_id'] ?? 'unknown'
            );
            
            if (isset($refundData['amount'])) {
                $message .= sprintf(" (%.2f %s)", $refundData['amount'], $refundData['currency'] ?? '');
            }
            
            return $this->recordTransaction('refund', $refundData, $status, $message);
        } catch (Exception $e) {
            $this->logger->error("[TransactionAudit] Failed to record refund: " . $e->getMessage(), [
                'payment_id' => $refundData['payment_id'] ?? 'unknown',
                'status' => $status
            ]);
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }
    
    /**
     * Get log level for transaction status
     */
    private function getLogLevelForStatus(string $status): string
    {
        $map = [
            'completed' => 'info', 'success' => 'info', 'pending' => 'info', 'processing' => 'info',
            'failed' => 'warning', 'declined' => 'warning', 'error' => 'error', 'fraud' => 'error',
            'cancelled' => 'info', 'refunded' => 'info'
        ];
        
        $s = strtolower($status);
        return $map[$s] ?? 'info';
    }
}
=== App/Services/Audit/LogManagementService.php ===
<?php

namespace App\Services\Audit;

use App\Helpers\DatabaseHelper;
use App\Helpers\LogQueryBuilder;
use App\Helpers\SecurityHelper;
use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;
use Exception;
use DateTime;
use DateTimeImmutable;

class LogManagementService
{
    // Configuration constants
    private const MAX_EXPORT_ROWS = 10000;
    private const BATCH_DELETE_SIZE = 1000;
    private const EXPORT_EXPIRY_HOURS = 24;
    
    private LoggerInterface $logger;
    private string $requestId;
    private ExceptionHandler $exceptionHandler;
    
    public function __construct(
        LoggerInterface $logger, 
        string $requestId, 
        ExceptionHandler $exceptionHandler
    ) {
        $this->logger = $logger;
        $this->requestId = $requestId;
        $this->exceptionHandler = $exceptionHandler;
    }
    
    /**
     * CENTRALIZED LOG INSERTION - All log writes go through this method
     *
     * @param string $category The category of the event
     * @param string $message The log message
     * @param array $context Additional context data
     * @param int|null $userId Associated user ID
     * @param int|null $bookingId Associated booking ID
     * @param string|null $ipAddress Client IP address
     * @param string $logLevel Log level
     * @return int|null ID of the created log entry
     */
    public function createLogEntry(
        string $category, 
        string $message, 
        array $context = [], 
        ?int $userId = null, 
        ?int $bookingId = null, 
        ?string $ipAddress = null,
        string $logLevel = 'info'
    ): ?int {
        try {
            // Sanitize inputs
            $message = SecurityHelper::sanitizeString($message);
            $context = $this->sanitizeContext($context);
            
            // Ensure request_id is included
            $context['request_id'] = $this->requestId;
            
            // Add client IP if not provided
            if (empty($ipAddress)) {
                $ipAddress = $this->getClientIp();
            }
            
            // Capture current time
            $timestamp = new DateTimeImmutable();
            
            // Prepare data for insertion
            $data = [
                'action'             => $category,
                'message'            => $message,
                'details'            => json_encode($context, JSON_UNESCAPED_UNICODE | JSON_PARTIAL_OUTPUT_ON_ERROR),
                'user_reference'     => $userId,
                'booking_reference'  => $bookingId,
                'ip_address'         => $ipAddress,
                'created_at'         => $timestamp->format('Y-m-d H:i:s'),
                'log_level'          => $logLevel,
                'request_id'         => $this->requestId,
            ];
            
            // Insert with secure database and prepared statements
            return DatabaseHelper::insert('audit_logs', $data, true);
        } catch (Exception $e) {
            $this->logger->error("[LogManager] Failed to create log entry: " . $e->getMessage(), [
                'request_id' => $this->requestId,
                'category' => $category
            ]);
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }
    
    /**
     * Retrieve logs from the audit_logs table with applied filters and pagination
     *
     * @param array $filters Various filters to apply (category, user_id, etc.)
     * @return array Paginated result containing logs and pagination metadata
     */
    public function getLogs(array $filters = []): array
    {
        try {
            // Get the query parts from LogQueryBuilder
            $query = LogQueryBuilder::buildSelectQuery($filters);
            
            // Execute the count query if pagination is needed
            $totalItems = 0;
            $totalPages = 0;
            
            if (!($filters['skip_pagination'] ?? false)) {
                $countResult = DatabaseHelper::select(
                    $query['countSql'],
                    $query['params'],
                    true
                );
                $totalItems = $countResult[0]['total'] ?? 0;
                $perPage = $query['perPage'];
                $totalPages = ceil($totalItems / $perPage);
            }
            
            // Execute the main query using DatabaseHelper
            $logs = DatabaseHelper::select(
                $query['mainSql'],
                $query['params'],
                true
            );
            
            // Process results - parse JSON and format dates
            foreach ($logs as &$log) {
                if (isset($log['details']) && is_string($log['details'])) {
                    $log['details'] = json_decode($log['details'], true) ?? [];
                }
                
                if (!empty($log['created_at'])) {
                    $date = new DateTime($log['created_at']);
                    $log['formatted_date'] = $date->format('Y-m-d H:i:s');
                }
            }
            
            // Build the result array
            $result = ['data' => $logs];
            
            // Add pagination data if needed
            if (!($filters['skip_pagination'] ?? false)) {
                $result['pagination'] = [
                    'total' => $totalItems,
                    'per_page' => $query['perPage'],
                    'current_page' => $query['page'],
                    'last_page' => $totalPages,
                    'from' => (($query['page'] - 1) * $query['perPage']) + 1,
                    'to' => min(($query['page'] * $query['perPage']), $totalItems),
                ];
            }
            
            return $result;
        } catch (Exception $e) {
            $this->logger->error("[LogManager] Failed to get logs: " . $e->getMessage(), [
                'request_id' => $this->requestId,
                'filters' => $filters
            ]);
            $this->exceptionHandler->handleException($e);
            return ['data' => [], 'pagination' => ['total' => 0]];
        }
    }
    
    /**
     * Delete logs from the audit_logs table based on specific filters
     * Uses batch processing with configurable batch size
     *
     * @param array $filters Filters to determine which logs to delete
     * @param bool $forceBulkDelete Set to true to bypass safeguards for bulk deletion
     * @return int Number of logs deleted
     */
    public function deleteLogs(array $filters, bool $forceBulkDelete = false): int
    {
        try {
            // Use LogQueryBuilder to build the where clause
            list($whereClause, $params) = LogQueryBuilder::buildWhereClause($filters);
            
            // Safety check: prevent accidental deletion of all logs
            if (empty($whereClause) || $whereClause === "1=1" && count($params) === 0 && !$forceBulkDelete) {
                $this->logger->warning("[LogManager] Attempted to delete all logs without confirmation", [
                    'request_id' => $this->requestId
                ]);
                throw new Exception('Attempted to delete all logs without explicit confirmation');
            }
            
            // Get IDs to delete for batch processing using DatabaseHelper
            $sql = "SELECT id FROM audit_logs WHERE {$whereClause}";
            
            // Add limit for safety if not forced bulk delete
            if (!$forceBulkDelete) {
                $sql .= " LIMIT " . self::MAX_EXPORT_ROWS;
            }
            
            $logIds = DatabaseHelper::select($sql, $params, true);
            $ids = array_column($logIds, 'id');
            
            if (empty($ids)) {
                return 0; // No matching logs to delete
            }
            
            // Log the deletion attempt
            $this->logger->info("[LogManager] Deleting logs", [
                'request_id' => $this->requestId,
                'count' => count($ids)
            ]);
            
            // Use batch processing to delete with optimized batch size
            $totalDeleted = 0;
            $batches = array_chunk($ids, self::BATCH_DELETE_SIZE);
            
            foreach ($batches as $batch) {
                $placeholders = implode(',', array_fill(0, count($batch), '?'));
                $deleteSql = "DELETE FROM audit_logs WHERE id IN ({$placeholders})";
                $rowsDeleted = DatabaseHelper::execute($deleteSql, $batch, true);
                $totalDeleted += $rowsDeleted;
            }
            
            return $totalDeleted;
        } catch (Exception $e) {
            $this->logger->error("[LogManager] Failed to delete logs: " . $e->getMessage(), [
                'request_id' => $this->requestId,
                'filters' => $filters
            ]);
            $this->exceptionHandler->handleException($e);
            return 0;
        }
    }
    
    /**
     * Export logs to a CSV file based on provided filters
     *
     * @param array $filters Filters to determine which logs to export
     * @return array Path info for the exported file
     */
    public function exportLogs(array $filters): array
    {
        try {
            // Create export file information
            $exportId = date('Ymd_His') . '_' . substr(uniqid(), -8);
            $filename = 'audit_logs_export_' . $exportId . '.csv';
            $exportDir = rtrim(sys_get_temp_dir(), '/') . '/secure_exports';
            
            // Ensure export directory exists with proper permissions
            if (!is_dir($exportDir)) {
                mkdir($exportDir, 0750, true);
            }
            
            $filepath = $exportDir . '/' . $filename;
            
            // Get export query from LogQueryBuilder
            $exportQuery = LogQueryBuilder::buildExportQuery($filters);
            
            // Execute export query through DatabaseHelper
            $rowsExported = DatabaseHelper::executeExport($exportQuery['sql'], $exportQuery['params'], $filepath);
            
            // Set appropriate permissions for the file
            chmod($filepath, 0640);
            
            // Calculate expiry time
            $expiryTime = time() + (self::EXPORT_EXPIRY_HOURS * 3600);
            
            // Return export information
            return [
                'file_path' => $filepath,
                'file_name' => $filename,
                'export_id' => $exportId,
                'row_count' => $rowsExported,
                'expiry_time' => $expiryTime,
                'expiry_formatted' => date('Y-m-d H:i:s', $expiryTime)
            ];
        } catch (Exception $e) {
            $this->logger->error("[LogManager] Failed to export logs: " . $e->getMessage(), [
                'request_id' => $this->requestId,
                'filters' => $filters
            ]);
            $this->exceptionHandler->handleException($e);
            throw $e; // Re-throw as this is a user-requested export operation
        }
    }
    
    /**
     * Get a single log entry by ID
     *
     * @param int $logId Log ID
     * @return array|null Log data or null if not found
     */
    public function getLogById(int $logId): ?array
    {
        try {
            $sql = "SELECT * FROM audit_logs WHERE id = ? LIMIT 1";
            $logs = DatabaseHelper::select($sql, [$logId], true);
            
            if (empty($logs)) {
                return null;
            }
            
            $log = $logs[0];
            
            // Parse JSON details if present
            if (isset($log['details']) && is_string($log['details'])) {
                $log['details'] = json_decode($log['details'], true) ?? [];
            }
            
            // Format timestamp
            if (!empty($log['created_at'])) {
                $date = new DateTime($log['created_at']);
                $log['formatted_date'] = $date->format('Y-m-d H:i:s');
            }
            
            return $log;
        } catch (Exception $e) {
            $this->logger->error("[LogManager] Failed to get log by ID: " . $e->getMessage(), [
                'request_id' => $this->requestId,
                'log_id' => $logId
            ]);
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }
    
    /**
     * Sanitize context array to prevent sensitive data storage
     */
    private function sanitizeContext(array $context): array
    {
        $sensitiveKeys = ['password', 'secret', 'token', 'auth', 'key', 'apiKey', 'api_key', 'credential', 'credit_card', 'card_number', 'cvv', 'ssn'];
        $sanitized = [];
        
        foreach ($context as $key => $value) {
            if ($value === null) continue;
            
            $lower = strtolower($key);
            $isSensitive = false;
            
            foreach ($sensitiveKeys as $sKey) {
                if (strpos($lower, $sKey) !== false) {
                    $isSensitive = true;
                    break;
                }
            }
            
            $sanitized[$key] = $isSensitive 
                ? '[REDACTED]' 
                : (is_array($value) ? $this->sanitizeContext($value) : $value);
        }
        
        return $sanitized;
    }
    
    /**
     * Get client IP address
     */
    private function getClientIp(): string
    {
        foreach (['HTTP_X_FORWARDED_FOR', 'HTTP_CLIENT_IP'] as $header) {
            if (!empty($_SERVER[$header])) {
                $ips = explode(',', $_SERVER[$header]);
                $ip = trim($ips[0]);
                if (filter_var($ip, FILTER_VALIDATE_IP)) {
                    return $ip;
                }
            }
        }
        return $_SERVER['REMOTE_ADDR'] ?? '0.0.0.0';
    }
}
=== App/Services/PaymentService.php ===
<?php

namespace App\Services;

use App\Services\Payment\PaymentProcessingService;
use App\Services\Payment\RefundService;
use App\Services\Payment\PaymentGatewayService;
use App\Services\Payment\TransactionService;

class PaymentService
{
    /**
     * PaymentService acts as a facade:
     *  - Delegates payment processing to PaymentProcessingService
     *  - Delegates refund handling to RefundService
     *  - Delegates external gateway calls to PaymentGatewayService
     *  - Delegates transaction logging/history to TransactionService
     *
     * Controllers (and other parts of your codebase) continue to call PaymentService
     * without knowing about the underlying subservices, avoiding any breaking changes.
     */

    private PaymentProcessingService $paymentProcessingService;
    private RefundService $refundService;
    private PaymentGatewayService $paymentGatewayService;
    private TransactionService $transactionService;

    /**
     * Constructor injects the four subservices, which are then used to delegate
     * the responsibilities away from this facade class.
     */
    public function __construct(
        PaymentProcessingService $paymentProcessingService,
        RefundService $refundService,
        PaymentGatewayService $paymentGatewayService,
        TransactionService $transactionService
    ) {
        $this->paymentProcessingService = $paymentProcessingService;
        $this->refundService = $refundService;
        $this->paymentGatewayService = $paymentGatewayService;
        $this->transactionService = $transactionService;
    }

    /**
     * Wrapper for handling a payment. Delegates the core logic to PaymentProcessingService.
     *
     * @param array $paymentData
     * @return array
     */
    public function processPayment(array $paymentData): array
    {
        return $this->paymentProcessingService->processPayment($paymentData);
    }

    /**
     * Wrapper for handling a refund. Delegates the core logic to RefundService.
     *
     * @param array $refundData
     * @return array
     */
    public function refundPayment(array $refundData): array
    {
        return $this->refundService->refund($refundData);
    }

    /**
     * For direct interactions with external gateways (e.g., if you need to manually
     * initiate a gateway payment step or retrieve gateway-specific responses).
     *
     * @param string $gatewayName  E.g. "stripe", "payu", etc.
     * @param array  $paymentData  Payment details to pass to the gateway
     * @return array
     */
    public function processPaymentGateway(string $gatewayName, array $paymentData): array
    {
        return $this->paymentGatewayService->processPayment($gatewayName, $paymentData);
    }

    /**
     * For handling gateway callback/webhook data. Delegates to PaymentGatewayService.
     *
     * @param string $gatewayName
     * @param array  $callbackData
     * @return array
     */
    public function handlePaymentCallback(string $gatewayName, array $callbackData): array
    {
        return $this->paymentGatewayService->handleCallback($gatewayName, $callbackData);
    }

    /**
     * For logging transactions directly through PaymentService, if needed.
     *
     * @param array $transactionData
     * @return array
     */
    public function logTransaction(array $transactionData): array
    {
        return $this->transactionService->logTransaction($transactionData);
    }

    /**
     * Retrieves transaction history for a specific user.
     *
     * @param int $userId
     * @return array
     */
    public function getTransactionHistory(int $userId): array
    {
        return $this->transactionService->getHistoryByUser($userId);
    }

    /**
     * Retrieves transaction history with admin filters (date range, type, etc.).
     *
     * @param array $filters
     * @return array
     */
    public function getTransactionHistoryAdmin(array $filters): array
    {
        return $this->transactionService->getHistoryAdmin($filters);
    }
}
=== App/Middleware/EncryptionMiddleware.php ===
<?php

namespace App\Middleware;

// Removed: use Illuminate\Http\Request;
// Removed: use Illuminate\Support\Facades\Log;
use Psr\Log\LoggerInterface;
use App\Services\EncryptionService;

class EncryptionMiddleware
{
    private LoggerInterface $logger;
    
    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }
    
    // Modified handle() to use native PHP request handling without Closure
    public function handle(array $request)
    {
        $uri = $_SERVER['REQUEST_URI'] ?? '/';
        if ($this->isSensitiveEndpoint($uri)) {
            $this->encryptRequestData($request);
        }

        // Process request (replace with your actual request processing)
        // ...existing code or processRequest($request)...
        $response = []; // Placeholder for processed response
        
        if ($this->isSensitiveEndpoint($uri)) {
            $response = $this->encryptResponseData(json_encode($response));
        }
        
        echo json_encode($response);
        exit;
    }
    
    // Modified to encrypt response data and return a string
    private function encryptResponseData(string $data): string
    {
        return EncryptionService::encrypt($data);
    }

    // Handle encryption on native request arrays (e.g., $_POST or $_GET)
    private function encryptRequestData(array &$request)
    {
        foreach ($request as $key => $value) {
            if ($this->isSensitiveField($key)) {
                $request[$key] = EncryptionService::encrypt($value);
            }
        }
    }

    // Load sensitive fields dynamically from configuration file
    private function isSensitiveField(string $field): bool
    {
        $configPath = __DIR__ . '/../../config/sensitive_fields.json';
        $config = file_exists($configPath) ? json_decode(file_get_contents($configPath), true) : [];
        $sensitiveFields = $config['sensitive_fields'] ?? ['password', 'email', 'phone'];
        return in_array($field, $sensitiveFields);
    }

    // Load sensitive endpoints dynamically from configuration file
    private function isSensitiveEndpoint(string $endpoint): bool
    {
        $configPath = __DIR__ . '/../../config/sensitive_endpoints.json';
        $config = file_exists($configPath) ? json_decode(file_get_contents($configPath), true) : [];
        $sensitiveEndpoints = $config['sensitive_endpoints'] ?? ['/user/profile-data'];
        return in_array($endpoint, $sensitiveEndpoints);
    }
    
    // Log events using injected LoggerInterface
    private function logEvent(string $message)
    {
        $this->logger->info("[EncryptionMiddleware] $message");
    }
}
=== App/Middleware/AuthMiddleware.php ===
<?php

namespace App\Middleware;

use App\Services\Auth\TokenService;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface as RequestHandler;
use Psr\Log\LoggerInterface;
use App\Helpers\DatabaseHelper;

class AuthMiddleware implements MiddlewareInterface
{
    private TokenService $tokenService;
    private LoggerInterface $logger;
    private $pdo;
    private bool $required;

    public function __construct(
        TokenService $tokenService, 
        LoggerInterface $logger,
        DatabaseHelper $dbHelper,
        bool $required = false
    ) {
        $this->tokenService = $tokenService;
        $this->logger = $logger;
        $this->pdo = $dbHelper->getPdo();
        $this->required = $required;
    }

    public function process(Request $request, RequestHandler $handler): Response
    {
        $this->logger->debug("AuthMiddleware processing request", [
            'required_auth' => $this->required ? 'yes' : 'no'
        ]);
        
        // Try to get token from Authorization header
        $token = null;
        $authHeader = $request->getHeaderLine('Authorization');
        if (strpos($authHeader, 'Bearer ') === 0) {
            $token = substr($authHeader, 7);
            $this->logger->debug("Found token in Authorization header");
        }
        
        // If not in header, try cookies
        if (!$token) {
            $cookies = $request->getCookieParams();
            $token = $cookies['jwt'] ?? null;
            if ($token) {
                $this->logger->debug("Found token in cookies");
            }
        }
        
        $authenticated = false;
        
        if ($token) {
            try {
                // Verify and decode the token
                $decoded = $this->tokenService->verifyToken($token);
                $userId = $decoded['sub'];
                $this->logger->debug("Token verified successfully", ['userId' => $userId]);
                
                // Fetch user from application database
                $stmt = $this->pdo->prepare("
                    SELECT id, name, surname, email, phone, role, address, 
                           pesel_or_id, created_at, email_notifications, sms_notifications 
                    FROM users WHERE id = ? AND active = 1
                ");
                $stmt->execute([$userId]);
                $user = $stmt->fetch();
                
                if ($user) {
                    // Attach user to request
                    $this->logger->debug("User attached to request", ['userId' => $user['id']]);
                    $request = $request->withAttribute('user', $user);
                    $authenticated = true;
                } else {
                    $this->logger->warning("User not found or inactive", ['userId' => $userId]);
                }
            } catch (\Exception $e) {
                $this->logger->warning("Token validation failed: " . $e->getMessage());
                // We'll proceed without setting the user attribute
            }
        } else {
            $this->logger->debug("No token found in request");
        }
        
        // If authentication is required but failed, return 401 Unauthorized
        if ($this->required && !$authenticated) {
            $this->logger->warning("Authentication required but failed or missing");
            $response = new \Slim\Psr7\Response();
            $response->getBody()->write(json_encode([
                'error' => 'Authentication required',
                'status' => 401
            ]));
            return $response
                ->withHeader('Content-Type', 'application/json')
                ->withStatus(401);
        }
        
        return $handler->handle($request);
    }
}
?>
=== App/Middleware/RequireAuthMiddleware.php ===
<?php

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface as RequestHandler;
use Psr\Log\LoggerInterface;

/**
 * Middleware that ensures a user is authenticated
 * To be used after AuthMiddleware has processed the request
 */
class RequireAuthMiddleware implements MiddlewareInterface
{
    private LoggerInterface $logger;

    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }

    public function process(Request $request, RequestHandler $handler): Response
    {
        $user = $request->getAttribute('user');
        
        if (!$user) {
            $this->logger->warning("Access attempt to protected route without authentication");
            
            $response = new \Slim\Psr7\Response();
            $response->getBody()->write(json_encode([
                'error' => 'Authentication required',
                'status' => 401
            ]));
            
            return $response
                ->withHeader('Content-Type', 'application/json')
                ->withStatus(401);
        }
        
        $this->logger->debug("User authenticated for protected route", ['user_id' => $user['id']]);
        return $handler->handle($request);
    }
}
=== App/Middleware/TokenValidationMiddleware.php ===
<?php

namespace App\Middleware;

use App\Services\Auth\AuthService;
use App\Services\Auth\TokenService;
use App\Helpers\ApiHelper;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Server\RequestHandlerInterface as RequestHandler;
use Psr\Log\LoggerInterface;

class TokenValidationMiddleware
{
    private AuthService $authService;
    private LoggerInterface $logger;
    private TokenService $tokenService;

    public function __construct(
        AuthService $authService, 
        LoggerInterface $logger,
        TokenService $tokenService
    ) {
        $this->authService = $authService;
        $this->logger = $logger;
        $this->tokenService = $tokenService;
    }

    public function __invoke(Request $request, RequestHandler $handler): Response
    {
        // Use TokenService to extract and validate the token
        $user = $this->tokenService->validateRequest($request);

        if (!$user) {
            $this->logger->warning("Invalid or missing token", ['ip' => $request->getServerParams()['REMOTE_ADDR']]);
            return ApiHelper::sendJsonResponse('error', 'Unauthorized', [], 401);
        }

        $request = $request->withAttribute('user', $user);

        return $handler->handle($request);
    }
}
?>
=== App/Middleware/AuditTrailMiddleware.php ===
<?php

namespace App\Middleware;

use App\Services\AuditService;
use Psr\Log\LoggerInterface;

/**
 * @deprecated This middleware is deprecated and will be removed in a future version. 
 * Use AuditService methods directly in your controllers instead.
 * 
 * AuditTrailMiddleware - Logs user actions for audit tracking.
 */
class AuditTrailMiddleware
{
    private AuditService $auditService;
    private LoggerInterface $logger;

    public function __construct(AuditService $auditService, LoggerInterface $logger)
    {
        $this->auditService = $auditService;
        $this->logger = $logger;
        
        // Log a warning about using deprecated middleware
        $this->logger->warning(
            'AuditTrailMiddleware is deprecated. Use AuditService methods directly in controllers instead.',
            ['trace' => debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 2)]
        );
    }

    /**
     * Handle an incoming request and log relevant details.
     *
     * @param array $request The request data.
     * @param callable $next The next middleware function.
     * @deprecated Use AuditService methods directly in your controllers instead
     */
    public function handle(array $request, callable $next)
    {
        try {
            // Extract request details
            $requestInfo = AuditService::getRequestInfo();
            $userId = $_SESSION['user_id'] ?? null;
            
            // Use the new API logging method
            $this->auditService->logApiRequest(
                $requestInfo['uri'],
                $requestInfo['method'],
                $this->sanitizeRequestData($request),
                [], // Response not available here
                200, // Status code not available yet
                $userId
            );

            // Continue to the next middleware/controller
            return $next($request);
        } catch (\Exception $e) {
            $this->logger->error('[AuditTrail] Failed to log action', ['error' => $e->getMessage()]);
            return $next($request); // Allow the request to proceed even if logging fails
        }
    }

    /**
     * Sanitize request data before logging.
     *
     * @param array $request The raw request data.
     * @return array The sanitized request data.
     */
    private function sanitizeRequestData(array $request): array
    {
        unset($request['password'], $request['token'], $request['credit_card'], $request['cvv']);
        return $request;
    }
}
=== App/Helpers/ViewHelper.php ===
<?php

function view($viewName, $data = [])
{
    $viewPath = BASE_PATH . "/App/Views/{$viewName}.php";

    if (!file_exists($viewPath)) {
        die("❌ View not found: {$viewName}");
    }

    extract($data); // Extract data for use inside views
    require $viewPath;
}
=== App/Helpers/SecurityHelper.php ===
<?php

namespace App\Helpers;

use Psr\Log\LoggerInterface;
use Firebase\JWT\JWT;

class SecurityHelper
{
    // Security Configuration
    const SESSION_CONFIG = [
        'use_only_cookies'        => 1,
        'use_strict_mode'         => 1,
        'cookie_httponly'         => 1,
        'cookie_samesite'         => 'Lax',
        'gc_maxlifetime'          => 3600,
        'cookie_lifetime'         => 0,
        'use_trans_sid'           => 0,
        'sid_bits_per_character'  => 6
    ];

    // Standardized Logging Function
    public static function securityLog(LoggerInterface $logger, $message, $level = 'info', $category = 'Security')
    {
        if ($logger && method_exists($logger, 'log')) {
            $logger->log($level, "[$category] $message");
        } else {
            error_log("[$category][$level] $message");
        }
    }

    // Log authentication events
    public static function logAuthEvent($message, $level = 'info')
    {
        self::securityLog(null, $message, $level, 'Auth');
    }

    // Helper to log authentication failures
    public static function logAuthFailure($message)
    {
        self::securityLog(null, $message, 'error', 'Auth');
    }

    // Secure Session Handling using native PHP sessions
    public static function startSecureSession()
    {
        if (session_status() === PHP_SESSION_NONE) {
            ini_set('session.use_only_cookies', 1);
            ini_set('session.use_strict_mode', 1);
            ini_set('session.cookie_httponly', 1);
            ini_set('session.cookie_samesite', 'Lax');
            session_start();
        }
        return true;
    }

    // Refresh session to extend its duration
    public static function refreshSession()
    {
        $logFile = __DIR__ . '/../../logs/security.log';
        $timestamp = date('Y-m-d H:i:s');

        try {
            if (session_status() === PHP_SESSION_ACTIVE) {
                $_SESSION['last_activity'] = time();
                session_regenerate_id(true);
                error_log("[$timestamp][info] Session refreshed\n", 3, $logFile);
            }
        } catch (Exception $e) {
            error_log("[$timestamp][error] Session refresh failed: " . $e->getMessage() . "\n", 3, $logFile);
        }
    }

    // Replace Laravel session calls with native PHP for session expiry enforcement
    public static function enforceSessionExpiry(LoggerInterface $logger)
    {
        if (!isset($_SESSION['last_activity'])) {
            $_SESSION['last_activity'] = time();
            return;
        }
        if (time() - $_SESSION['last_activity'] > 1800) { // 30 min timeout
            self::securityLog($logger, 'Session expired due to inactivity', 'info');
            $_SESSION = [];
            if (ini_get('session.use_cookies')) {
                setcookie(session_name(), '', time() - 42000, '/');
            }
            session_destroy();
        }
    }

    // Fingerprint-Based Session Integrity Check
    public static function validateSessionIntegrity(LoggerInterface $logger)
    {
        $currentIp = hash('sha256', $_SERVER['REMOTE_ADDR']);
        $currentAgent = hash('sha256', $_SERVER['HTTP_USER_AGENT']);

        if (!isset($_SESSION['client_ip'])) {
            $_SESSION['client_ip'] = $currentIp;
            $_SESSION['user_agent'] = $currentAgent;
            return true;
        }
        if ($_SESSION['client_ip'] !== $currentIp || $_SESSION['user_agent'] !== $currentAgent) {
            self::securityLog($logger, 'Session integrity check failed: Mismatch detected', 'warning');
            $_SESSION = [];
            if (ini_get('session.use_cookies')) {
                setcookie(session_name(), '', time() - 42000, '/');
            }
            session_destroy();
            return false;
        }
        return true;
    }

    // Sanitize user input to prevent XSS
    public static function sanitizeInput($data)
    {
        if (!isset($data) || $data === null) {
            $data = ''; // Default to empty string to prevent undefined variable errors
        }
        $cleanedData = trim((string)$data);
        return htmlspecialchars($cleanedData, ENT_QUOTES, 'UTF-8');
    }

    // Generate secure random string (for password resets, API keys, etc.)
    public static function generateSecureToken($length = 64)
    {
        return bin2hex(random_bytes($length / 2));
    }

    // Secure Session Destruction using native PHP
    public static function destroySession(LoggerInterface $logger)
    {
        self::securityLog($logger, 'Destroying session', 'info');
        $_SESSION = [];
        if (ini_get('session.use_cookies')) {
            setcookie(session_name(), '', time() - 42000, '/');
        }
        session_destroy();
        self::securityLog($logger, 'Session destroyed successfully', 'info');
    }

    // Check if a user is logged in
    public static function isUserLoggedIn()
    {
        return isset($_SESSION['user_id']);
    }

    // Get the logged-in user's role
    public static function getUserRole()
    {
        return isset($_SESSION['user_id']) ? ($_SESSION['user_role'] ?? 'guest') : 'guest';
    }

    // Get session data safely
    public static function getSessionData($key)
    {
        return $_SESSION[$key] ?? null;
    }

    // Set session data safely
    public static function setSessionData($key, $value)
    {
        $_SESSION[$key] = $value;
    }

    // Validate JWT token
    public static function validateJWT($token)
    {
        // Replace Laravel's authentication with a native JWT approach or session check.
        // For example, decode using firebase/php-jwt, here we simply check session.
        return $_SESSION['user_id'] ?? null;
    }

    // Enforce authentication for protected pages
    public static function requireUserAuth()
    {
        return self::requireAuth();
    }

    // Custom Authentication Enforcement
    public static function requireAuth($allowGuest = false)
    {
        if (isset($_SESSION['user_id'])) {
            return $_SESSION['user_id'];
        }
        if ($allowGuest) {
            return null;
        }
        header('Content-Type: application/json');
        http_response_code(401);
        echo json_encode(['error' => 'Unauthorized']);
        exit;
    }

    // CSRF Token Generation
    public static function generateCsrfToken()
    {
        if (!isset($_SESSION['csrf_token'])) {
            $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
        }
        return $_SESSION['csrf_token'];
    }

    // Validate CSRF token in POST requests
    public static function validateCsrfToken($token)
    {
        return isset($_SESSION['csrf_token']) && $_SESSION['csrf_token'] === $token;
    }

    // Return structured JSON response
    public static function jsonResponse($data, $statusCode = 200)
    {
        header('Content-Type: application/json');
        http_response_code($statusCode);
        echo json_encode($data);
        exit;
    }
}

// Initialize secure session when the file is included
if (!SecurityHelper::startSecureSession()) {
    SecurityHelper::securityLog(null, 'Critical: Failed to initialize secure session', 'critical');
}
?>
=== App/Helpers/ExceptionHandler.php ===
<?php
namespace App\Helpers;

use PDOException;
use Exception;
use InvalidArgumentException;
use Psr\Log\LoggerInterface;

class ExceptionHandler
{
    private LoggerInterface $dbLogger;
    private LoggerInterface $authLogger;
    private LoggerInterface $systemLogger;

    public function __construct(
        LoggerInterface $dbLogger,
        LoggerInterface $authLogger,
        LoggerInterface $systemLogger
    ) {
        $this->dbLogger = $dbLogger;
        $this->authLogger = $authLogger;
        $this->systemLogger = $systemLogger;
    }

    /**
     * Handle exceptions centrally with consistent logging and JSON responses.
     */
    public function handleException(Exception $e): void
    {
        // Extract status code if available or use default
        $statusCode = method_exists($e, 'getCode') && is_numeric($e->getCode()) && $e->getCode() >= 400 && $e->getCode() < 600 
            ? $e->getCode() 
            : 500;
            
        // Database-related exceptions
        if ($e instanceof PDOException) {
            $errorCode = $e->getCode();
            $this->dbLogger->error("❌ Database Error: " . $e->getMessage(), [
                'code' => $errorCode,
                'trace' => $e->getTraceAsString(),
                'file' => $e->getFile(),
                'line' => $e->getLine()
            ]);
            
            // Handle specific database errors
            if ($errorCode == '23000') { // Integrity constraint violation
                ApiHelper::sendJsonResponse('error', 'Duplicate entry or constraint violation', ['error' => $this->sanitizeErrorMessage($e->getMessage())], 400);
            } elseif ($errorCode == '42S02') { // Table not found
                ApiHelper::sendJsonResponse('error', 'Database table error', ['error' => 'Requested table not found'], 500);
            } else {
                ApiHelper::sendJsonResponse('error', 'Database error', ['error' => $this->sanitizeErrorMessage($e->getMessage())], 500);
            }
        }
        // Validation exceptions
        elseif ($e instanceof InvalidArgumentException) {
            $this->systemLogger->warning("⚠️ Validation Error: " . $e->getMessage());
            ApiHelper::sendJsonResponse('error', 'Validation error', ['errors' => json_decode($e->getMessage(), true) ?? ['validation' => $e->getMessage()]], 400);
        }
        // Authentication exceptions - We'll uncomment and implement when needed
        elseif (strpos($e->getMessage(), 'Invalid credentials') !== false || strpos($e->getMessage(), 'Unauthorized') !== false) {
            $this->authLogger->error("🔒 Authentication Error: " . $e->getMessage(), [
                'trace' => $e->getTraceAsString(),
                'file' => $e->getFile(),
                'line' => $e->getLine()
            ]);
            ApiHelper::sendJsonResponse('error', 'Authentication error', ['error' => $e->getMessage()], 401);
        }
        // Other exceptions
        else {
            $this->systemLogger->error("❌ System Error: " . $e->getMessage(), [
                'code' => $e->getCode(),
                'trace' => $e->getTraceAsString(),
                'file' => $e->getFile(),
                'line' => $e->getLine()
            ]);
            
            // Use provided status code or default to 500
            ApiHelper::sendJsonResponse(
                'error', 
                'Unexpected error occurred', 
                ['error' => $this->sanitizeErrorMessage($e->getMessage())], 
                $statusCode
            );
        }
        exit();
    }
    
    /**
     * Sanitize error messages to remove sensitive information
     */
    private function sanitizeErrorMessage(string $message): string
    {
        // Remove potentially sensitive information (like SQL queries, passwords, etc)
        $message = preg_replace('/password\s*=\s*[^\s,)]+/i', 'password=*****', $message);
        
        // For production, you might want to return generic messages instead of actual DB errors
        if (getenv('APP_ENV') === 'production') {
            if (strpos($message, 'SQL') !== false) {
                return 'A database error occurred';
            }
        }
        
        return $message;
    }
}
?>=== App/Helpers/ApiHelper.php ===
<?php

namespace App\Helpers;

/**
 * API Helper Functions
 */
class ApiHelper
{
    /**
     * ✅ Log API Events for Debugging
     */
    public static function logApiEvent($message)
    {
        $timestamp = date('Y-m-d H:i:s');
        $logFile = __DIR__ . '/../../logs/api.log';
        file_put_contents($logFile, "{$timestamp} - {$message}\n", FILE_APPEND);
    }

    /**
     * ✅ Standardized JSON Response Function
     */
    public static function sendJsonResponse($status, $message, $data = [], $httpCode = 200)
    {
        http_response_code($httpCode);
        header('Content-Type: application/json');
        echo json_encode(['status' => $status, 'message' => $message, 'data' => $data]);
        exit();
    }

    /**
     * ✅ Extract JWT from Authorization Header or Cookie
     */
    public static function getJWT()
    {
        $headers = getallheaders();
        if (isset($headers['Authorization']) && preg_match('/Bearer\s(\S+)/', $headers['Authorization'], $matches)) {
            return $matches[1];
        }
        return $_COOKIE['jwt'] ?? null;
    }
}
=== App/Helpers/SetupHelper.php ===
<?php

namespace App\Helpers;

use Psr\Log\LoggerInterface;
use App\Helpers\DatabaseHelper;

/**
 * Helper class to setup and verify the application environment
 */
class SetupHelper
{
    private $pdo;
    private LoggerInterface $logger;
    
    public function __construct(DatabaseHelper $dbHelper, LoggerInterface $logger)
    {
        $this->pdo = $dbHelper->getPdo();
        $this->logger = $logger;
    }
    
    /**
     * Add required indexes to database tables if they don't exist
     */
    public function ensureIndexes(): void
    {
        try {
            // Check for email index on users table
            $stmt = $this->pdo->prepare("
                SELECT COUNT(*) as count
                FROM information_schema.statistics
                WHERE table_schema = DATABASE()
                AND table_name = 'users'
                AND index_name = 'idx_users_email'
            ");
            $stmt->execute();
            $result = $stmt->fetch();
            
            if ($result['count'] == 0) {
                $this->logger->info("Creating index on users.email");
                $this->pdo->exec("CREATE INDEX idx_users_email ON users(email)");
            }
            
            // Check for other important indexes
            $this->logger->info("Database indexes verified");
        } catch (\Exception $e) {
            $this->logger->error("Failed to ensure indexes: " . $e->getMessage());
            throw $e;
        }
    }
    
    /**
     * Verify that the application is running in a secure environment
     */
    public function verifySecureEnvironment(): array
    {
        $issues = [];
        
        // Check if we're running over HTTPS
        $isSecure = (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off') 
                  || (isset($_SERVER['SERVER_PORT']) && $_SERVER['SERVER_PORT'] == 443);
                  
        if (!$isSecure) {
            $issues[] = "Application is not running over HTTPS. This is insecure for production.";
            $this->logger->warning("Security warning: Not running over HTTPS");
        }
        
        // Check PHP version
        if (version_compare(PHP_VERSION, '7.4.0', '<')) {
            $issues[] = "PHP version is below 7.4. Please upgrade for security.";
            $this->logger->warning("Security warning: PHP version below 7.4", ['version' => PHP_VERSION]);
        }
        
        // Return issues found
        return $issues;
    }
}
=== App/Helpers/LogLevelFilter.php ===
<?php

namespace App\Helpers;

/**
 * Helper class to filter log entries based on their severity level
 */
class LogLevelFilter
{
    /**
     * PSR-3 log levels mapped to their severity (higher number = higher severity)
     */
    private const LOG_LEVEL_MAP = [
        'debug'     => 100,
        'info'      => 200,
        'notice'    => 250,
        'warning'   => 300,
        'error'     => 400,
        'critical'  => 500,
        'alert'     => 550,
        'emergency' => 600
    ];

    /**
     * The minimum log level that should be processed
     */
    private string $minLevel;

    /**
     * Constructor
     *
     * @param string $minLevel Minimum log level to process, defaults to 'debug' (process all)
     */
    public function __construct(string $minLevel = 'debug')
    {
        $this->minLevel = strtolower($minLevel);
        
        // Fallback to 'debug' if an invalid log level is provided
        if (!isset(self::LOG_LEVEL_MAP[$this->minLevel])) {
            $this->minLevel = 'debug';
        }
    }

    /**
     * Determine if a log entry with the specified level should be processed
     *
     * @param string $level The log level to check
     * @return bool True if the log should be processed, false otherwise
     */
    public function shouldLog(string $level): bool
    {
        $level = strtolower($level);
        
        // Default to highest severity if an invalid level is provided
        $levelValue = self::LOG_LEVEL_MAP[$level] ?? PHP_INT_MAX;
        $minLevelValue = self::LOG_LEVEL_MAP[$this->minLevel];
        
        return $levelValue >= $minLevelValue;
    }

    /**
     * Set the minimum log level
     *
     * @param string $level The new minimum log level
     * @return self
     */
    public function setMinLevel(string $level): self
    {
        if (isset(self::LOG_LEVEL_MAP[strtolower($level)])) {
            $this->minLevel = strtolower($level);
        }
        return $this;
    }

    /**
     * Get the current minimum log level
     *
     * @return string The current minimum log level
     */
    public function getMinLevel(): string
    {
        return $this->minLevel;
    }
}
=== App/Helpers/DatabaseHelper.php ===
<?php

namespace App\Helpers;

use PDO;
use Exception;
use Psr\Log\LoggerInterface;
use App\Helpers\ApiHelper;

class DatabaseHelper
{
    protected static ?DatabaseHelper $instance = null;
    protected static ?DatabaseHelper $secureInstance = null;
    private PDO $pdo;
    private static LoggerInterface $logger;

    private function __construct(array $config)
    {
        try {
            $dsn = "mysql:host={$config['host']};dbname={$config['database']};charset={$config['charset']}";
            $this->pdo = new PDO($dsn, $config['username'], $config['password'], [
                PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
                PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
                PDO::ATTR_EMULATE_PREPARES => false,
            ]);

            self::$logger->info("✅ Database connection initialized successfully.");
        } catch (Exception $e) {
            self::$logger->critical("❌ Database connection failed: " . $e->getMessage());
            die("Database connection failed. Check logs for details.");
        }
    }

    public static function setLogger(LoggerInterface $logger)
    {
        if (!isset(self::$logger)) {
            self::$logger = $logger;
        }
    }

    private static function getDatabaseConfig(string $type = 'default'): array
    {
        $config = require __DIR__ . '/../../config/database.php';
    
        if (!isset($config['secure_database']) || !isset($config['app_database'])) {
            throw new Exception("Database configuration is missing required keys.");
        }
    
        return $type === 'secure' ? $config['secure_database'] : $config['app_database'];
    }
    
    public static function getInstance(): DatabaseHelper
    {
        if (self::$instance === null) {
            if (!isset(self::$logger)) {
                throw new Exception("Logger must be set before initializing the database.");
            }
            try {
                $dbConfig = self::getDatabaseConfig('default');
                self::$instance = new DatabaseHelper($dbConfig);
                self::$logger->info("✅ Application database initialized successfully.");
            } catch (Exception $e) {
                self::$logger->critical("❌ Application database initialization failed: " . $e->getMessage());
                die("Application database initialization failed.");
            }
        }
    
        return self::$instance;
    }
    
    public static function getSecureInstance(): DatabaseHelper
    {
        if (self::$secureInstance === null) {
            if (!isset(self::$logger)) {
                throw new Exception("Logger must be set before initializing the database.");
            }
            try {
                $dbConfig = self::getDatabaseConfig('secure');
                self::$secureInstance = new DatabaseHelper($dbConfig);
                self::$logger->info("✅ Secure database initialized successfully.");
            } catch (Exception $e) {
                self::$logger->critical("❌ Secure database initialization failed: " . $e->getMessage());
                die("Secure database initialization failed.");
            }
        }
    
        return self::$secureInstance;
    }

    public static function getAppInstance(): ?DatabaseHelper
    {
        return self::$instance;
    }

    public static function getSecureDbInstance(): ?DatabaseHelper
    {
        return self::$secureInstance;
    }
    
    public function getPdo(): PDO
    {
        return $this->pdo;
    }

    public function getConnection()
    {
        try {
            return $this->pdo;
        } catch (Exception $e) {
            if (self::$logger) {
                self::$logger->error("❌ Failed to get database connection: " . $e->getMessage());
            }
            return null;
        }
    }

    /**
     * Execute a database query safely with comprehensive logging and error handling
     * 
     * @param callable $query Function containing the query to execute
     * @param string $queryDescription Description of the query for logging
     * @param bool $useSecureDb Whether to use the secure database
     * @param array $context Additional context information for logging
     * @return mixed Query result or error response
     */
    public static function safeQuery(
        callable $query, 
        string $queryDescription = 'Database Query', 
        bool $useSecureDb = false,
        array $context = []
    ) {
        $startTime = microtime(true);
        $dbInstance = $useSecureDb ? self::getSecureInstance() : self::getInstance();
        $dbType = $useSecureDb ? "secure" : "application";
        
        try {
            // Get database name for logging
            $databaseName = $dbInstance->getPdo()->query("SELECT DATABASE()")->fetchColumn();
            
            // Log query execution start with sanitized parameters
            $logContext = array_merge($context, [
                'database' => $databaseName,
                'database_type' => $dbType,
                'timestamp_start' => date('Y-m-d H:i:s.u'),
            ]);
            
            // Sanitize any sensitive data in context
            $sanitizedContext = self::sanitizeLogContext($logContext);
            self::$logger->info("🔍 Executing {$queryDescription} on {$dbType} database: {$databaseName}", $sanitizedContext);
            
            // Execute the query
            $result = $query($dbInstance->getPdo());
            
            // Calculate execution time
            $executionTime = round((microtime(true) - $startTime) * 1000, 2);
            
            // Log successful query completion
            self::$logger->info("✅ {$queryDescription} completed successfully", [
                'database' => $databaseName,
                'execution_time_ms' => $executionTime,
                'database_type' => $dbType,
                'timestamp_end' => date('Y-m-d H:i:s.u'),
            ]);
            
            return $result;
            
        } catch (\PDOException $e) {
            $executionTime = round((microtime(true) - $startTime) * 1000, 2);
            $errorCode = $e->getCode();
            
            // Log detailed error information
            self::$logger->error("❌ {$queryDescription} failed with PDO error {$errorCode}", [
                'error_message' => $e->getMessage(),
                'database_type' => $dbType,
                'execution_time_ms' => $executionTime,
                'error_code' => $errorCode,
                'trace' => $e->getTraceAsString(),
                'context' => $sanitizedContext ?? [],
            ]);
            
            // Return appropriate error responses based on error type
            if ($errorCode == "23000") {
                return ApiHelper::sendJsonResponse('error', 'Database constraint violation: Duplicate or invalid data', [], 400);
            } elseif ($errorCode == "42S02") {
                return ApiHelper::sendJsonResponse('error', 'Table not found error', [], 500);
            } elseif ($errorCode == "42000") {
                return ApiHelper::sendJsonResponse('error', 'SQL syntax error', [], 500);
            } else {
                return ApiHelper::sendJsonResponse('error', 'Database query failed: ' . self::getSafeErrorMessage($e->getMessage()), [], 500);
            }
            
        } catch (\Exception $e) {
            $executionTime = round((microtime(true) - $startTime) * 1000, 2);
            
            // Log general exceptions
            self::$logger->error("❌ {$queryDescription} failed with exception", [
                'error_message' => $e->getMessage(),
                'database_type' => $dbType,
                'execution_time_ms' => $executionTime,
                'trace' => $e->getTraceAsString(),
                'context' => $sanitizedContext ?? [],
            ]);
            
            return ApiHelper::sendJsonResponse('error', 'Database operation failed: ' . self::getSafeErrorMessage($e->getMessage()), [], 500);
        }
    }

    /**
     * Sanitize log context to remove sensitive data
     */
    private static function sanitizeLogContext(array $context): array
    {
        $sensitiveKeys = ['password', 'token', 'secret', 'credit_card', 'card_number', 'cvv'];
        
        foreach ($context as $key => $value) {
            if (is_array($value)) {
                $context[$key] = self::sanitizeLogContext($value);
            } elseif (is_string($value) && self::containsSensitiveData($key, $sensitiveKeys)) {
                $context[$key] = '***REDACTED***';
            }
        }
        
        return $context;
    }
    
    /**
     * Check if a key contains sensitive data
     */
    private static function containsSensitiveData(string $key, array $sensitiveKeys): bool
    {
        $key = strtolower($key);
        foreach ($sensitiveKeys as $sensitiveKey) {
            if (strpos($key, $sensitiveKey) !== false) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Get a safe error message that doesn't expose sensitive information
     */
    private static function getSafeErrorMessage(string $originalMessage): string
    {
        // Remove potentially sensitive details from error messages
        $safeMessage = preg_replace('/SQLSTATE\[\w+\]: .+?: /', '', $originalMessage);
        $safeMessage = preg_replace('/near \'(.+?)\'/', 'near [SQL]', $safeMessage);
        
        return $safeMessage;
    }

    /**
     * Insert data into a table
     * 
     * @param string $table Table name
     * @param array $data Data to insert (column => value)
     * @param bool $useSecureDb Whether to use the secure database
     * @param array $context Additional context information for logging
     * @return string|mixed Last insert ID or error response
     */
    public static function insert(
        string $table, 
        array $data, 
        bool $useSecureDb = false,
        array $context = []
    ): string {
        $queryContext = array_merge($context, [
            'operation' => 'INSERT',
            'table' => $table,
            'field_count' => count($data),
        ]);
        
        return self::safeQuery(function ($pdo) use ($table, $data) {
            $columns = implode(", ", array_keys($data));
            $placeholders = implode(", ", array_fill(0, count($data), "?"));
            $sql = "INSERT INTO {$table} ({$columns}) VALUES ({$placeholders})";
            
            $stmt = $pdo->prepare($sql);
            $stmt->execute(array_values($data));
            $lastInsertId = $pdo->lastInsertId();
            
            return $lastInsertId;
        }, "Insert into {$table}", $useSecureDb, $queryContext);
    }

    /**
     * Update data in a table
     * 
     * @param string $table Table name
     * @param array $data Data to update (column => value)
     * @param array $where Where conditions (column => value)
     * @param bool $useSecureDb Whether to use the secure database 
     * @param array $context Additional context information for logging
     * @return int|mixed Number of affected rows or error response
     */
    public static function update(
        string $table, 
        array $data, 
        array $where, 
        bool $useSecureDb = false,
        array $context = []
    ): int {
        $queryContext = array_merge($context, [
            'operation' => 'UPDATE',
            'table' => $table,
            'field_count' => count($data),
            'condition_count' => count($where),
        ]);
        
        return self::safeQuery(function ($pdo) use ($table, $data, $where) {
            $set = implode(", ", array_map(fn($key) => "{$key} = ?", array_keys($data)));
            $whereClause = implode(" AND ", array_map(fn($key) => "{$key} = ?", array_keys($where)));
            $sql = "UPDATE {$table} SET {$set} WHERE {$whereClause}";
            
            $stmt = $pdo->prepare($sql);
            $params = array_merge(array_values($data), array_values($where));
            $stmt->execute($params);
            $rowCount = $stmt->rowCount();
            
            // Log affected rows count
            self::$logger->info("Updated {$rowCount} rows in table {$table}");
            
            return $rowCount;
        }, "Update {$table}", $useSecureDb, $queryContext);
    }

    /**
     * Delete data from a table
     * 
     * @param string $table Table name
     * @param array $where Where conditions (column => value)
     * @param bool $softDelete Whether to perform a soft delete
     * @param bool $useSecureDb Whether to use the secure database
     * @param array $context Additional context information for logging
     * @return int|mixed Number of affected rows or error response
     */
    public static function delete(
        string $table, 
        array $where, 
        bool $softDelete = false, 
        bool $useSecureDb = false,
        array $context = []
    ): int {
        $operation = $softDelete ? 'SOFT_DELETE' : 'DELETE';
        $queryContext = array_merge($context, [
            'operation' => $operation,
            'table' => $table,
            'condition_count' => count($where),
        ]);
        
        return self::safeQuery(function ($pdo) use ($table, $where, $softDelete) {
            if ($softDelete) {
                $sql = "UPDATE {$table} SET deleted_at = NOW() WHERE " . implode(" AND ", array_map(fn($key) => "{$key} = ?", array_keys($where)));
            } else {
                $sql = "DELETE FROM {$table} WHERE " . implode(" AND ", array_map(fn($key) => "{$key} = ?", array_keys($where)));
            }
            
            $stmt = $pdo->prepare($sql);
            $stmt->execute(array_values($where));
            $rowCount = $stmt->rowCount();
            
            // Log affected rows count
            self::$logger->info(($softDelete ? "Soft deleted" : "Deleted") . " {$rowCount} rows from table {$table}");
            
            return $rowCount;
        }, ($softDelete ? "Soft delete from" : "Delete from") . " {$table}", $useSecureDb, $queryContext);
    }

    /**
     * Select data from the database
     * 
     * @param string $query SQL query
     * @param array $params Query parameters
     * @param bool $useSecureDb Whether to use the secure database
     * @param array $context Additional context information for logging
     * @return array|mixed Query results or error response
     */
    public static function select(
        string $query, 
        array $params = [], 
        bool $useSecureDb = false,
        array $context = []
    ): array {
        $queryContext = array_merge($context, [
            'operation' => 'SELECT',
            'param_count' => count($params),
            'query_hash' => md5($query), // For tracking unique queries
        ]);
        
        return self::safeQuery(function ($pdo) use ($query, $params) {
            $stmt = $pdo->prepare($query);
            $stmt->execute($params);
            $results = $stmt->fetchAll();
            
            // Log result count
            self::$logger->debug("Query returned " . count($results) . " rows");
            
            return $results;
        }, "Select query", $useSecureDb, $queryContext);
    }
    
    /**
     * Execute a raw query with enhanced logging
     * 
     * @param string $query SQL query
     * @param array $params Query parameters
     * @param bool $useSecureDb Whether to use the secure database
     * @param array $context Additional context information for logging
     * @return mixed Query result or error response
     */
    public static function rawQuery(
        string $query, 
        array $params = [], 
        bool $useSecureDb = false,
        array $context = []
    ) {
        $operation = strtoupper(trim(explode(' ', $query)[0]));
        $queryContext = array_merge($context, [
            'operation' => $operation,
            'param_count' => count($params),
            'query_hash' => md5($query),
        ]);
        
        return self::safeQuery(function ($pdo) use ($query, $params, $operation) {
            $stmt = $pdo->prepare($query);
            $stmt->execute($params);
            
            if ($operation === 'SELECT') {
                $results = $stmt->fetchAll();
                return $results;
            } else {
                $rowCount = $stmt->rowCount();
                self::$logger->debug("{$operation} affected {$rowCount} rows");
                return $rowCount;
            }
        }, "{$operation} raw query", $useSecureDb, $queryContext);
    }
}
=== App/Helpers/LogQueryBuilder.php ===
<?php

namespace App\Helpers;

use DateTime;
use DateInterval;
use Exception;
use InvalidArgumentException;

/**
 * LogQueryBuilder - Generates SQL queries for audit log operations
 * 
 * This class serves as the single source of truth for all audit log queries,
 * providing standardized methods for building SQL with consistent parameter binding.
 */
class LogQueryBuilder
{
    /**
     * Default pagination values
     */
    private const DEFAULT_PAGE = 1;
    private const DEFAULT_PER_PAGE = 20;
    private const MAX_PER_PAGE = 100;
    
    /**
     * Maximum limits for various operations
     */
    private const MAX_EXPORT_ROWS = 10000;
    private const MAX_BULK_ROWS = 5000;
    
    /**
     * Tables
     */
    private const TABLE_NAME = 'audit_logs';
    
    /**
     * Valid sort fields
     */
    private const VALID_SORT_FIELDS = [
        'id', 'action', 'message', 'user_reference', 
        'booking_reference', 'created_at', 'log_level'
    ];
    
    /**
     * Valid date formats
     */
    private const DATE_FORMATS = [
        'Y-m-d',
        'Y-m-d H:i:s',
        'Y/m/d',
        'Y/m/d H:i:s'
    ];
    
    /**
     * Build WHERE clause and parameters for audit log queries
     *
     * @param array $filters Query filters
     * @return array [whereClause, params]
     */
    public static function buildWhereClause(array $filters): array
    {
        $whereClause = "1=1";
        $params = [];
        
        // User reference filter
        if (!empty($filters['user_id'])) {
            $whereClause .= " AND user_reference = ?";
            $params[] = (int)$filters['user_id'];
        }
        
        // Booking reference filter
        if (!empty($filters['booking_id'])) {
            $whereClause .= " AND booking_reference = ?";
            $params[] = (int)$filters['booking_id'];
        }
        
        // Category/action filter (support both naming conventions)
        if (!empty($filters['category'])) {
            $whereClause .= " AND action = ?";
            $params[] = $filters['category'];
        } elseif (!empty($filters['action'])) {
            $whereClause .= " AND action = ?";
            $params[] = $filters['action'];
        }
        
        // Multi-category filter
        if (!empty($filters['categories']) && is_array($filters['categories'])) {
            $placeholders = implode(',', array_fill(0, count($filters['categories']), '?'));
            $whereClause .= " AND action IN ({$placeholders})";
            foreach ($filters['categories'] as $category) {
                $params[] = $category;
            }
        }
        
        // Log level filter
        if (!empty($filters['log_level'])) {
            $whereClause .= " AND log_level = ?";
            $params[] = $filters['log_level'];
        }
        
        // Multiple log levels filter
        if (!empty($filters['log_levels']) && is_array($filters['log_levels'])) {
            $placeholders = implode(',', array_fill(0, count($filters['log_levels']), '?'));
            $whereClause .= " AND log_level IN ({$placeholders})";
            foreach ($filters['log_levels'] as $level) {
                $params[] = $level;
            }
        }
        
        // Date range filters with better validation
        if (!empty($filters['start_date'])) {
            $startDate = self::validateAndFormatDate($filters['start_date']);
            if ($startDate) {
                $whereClause .= " AND created_at >= ?";
                $params[] = $startDate;
            }
        }
        
        if (!empty($filters['end_date'])) {
            $endDate = self::validateAndFormatDate($filters['end_date'], true);
            if ($endDate) {
                $whereClause .= " AND created_at <= ?";
                $params[] = $endDate;
            }
        }
        
        // Relative date filter (e.g., last 7 days, last month)
        if (!empty($filters['relative_date'])) {
            $dateRange = self::calculateRelativeDateRange($filters['relative_date']);
            if ($dateRange) {
                $whereClause .= " AND created_at >= ? AND created_at <= ?";
                $params[] = $dateRange['start'];
                $params[] = $dateRange['end'];
            }
        }
        
        // Message/details text search
        if (!empty($filters['search'])) {
            $whereClause .= " AND (message LIKE ? OR details LIKE ?)";
            $searchTerm = '%' . SecurityHelper::sanitizeString($filters['search']) . '%';
            $params[] = $searchTerm;
            $params[] = $searchTerm;
        }
        
        // Request ID filter for correlation
        if (!empty($filters['request_id'])) {
            $whereClause .= " AND request_id = ?";
            $params[] = $filters['request_id'];
        }
        
        // IP address filter
        if (!empty($filters['ip_address'])) {
            $whereClause .= " AND ip_address = ?";
            $params[] = $filters['ip_address'];
        }
        
        // Custom WHERE clause (for advanced filtering)
        if (!empty($filters['custom_where']) && !empty($filters['custom_params']) && is_array($filters['custom_params'])) {
            $whereClause .= " AND ({$filters['custom_where']})";
            foreach ($filters['custom_params'] as $param) {
                $params[] = $param;
            }
        }

        return [$whereClause, $params];
    }
    
    /**
     * Build SQL queries for log retrieval with pagination
     *
     * @param array $filters Various filters to apply
     * @return array Query parts including SQL and parameters
     */
    public static function buildSelectQuery(array $filters): array
    {
        // Build WHERE clause and parameters
        list($whereClause, $params) = self::buildWhereClause($filters);
        
        // Calculate pagination values
        $page = isset($filters['page']) ? max(1, (int)$filters['page']) : self::DEFAULT_PAGE;
        $perPage = isset($filters['per_page']) ? 
                  min(max(1, (int)$filters['per_page']), self::MAX_PER_PAGE) : self::DEFAULT_PER_PAGE;
        
        // Build count query
        $countSql = "SELECT COUNT(*) as total FROM " . self::TABLE_NAME . " WHERE {$whereClause}";
        
        // Handle sorting
        $sortField = isset($filters['sort_field']) && in_array($filters['sort_field'], self::VALID_SORT_FIELDS) ? 
                    $filters['sort_field'] : 'created_at';
        
        $sortOrder = isset($filters['sort_order']) && strtoupper($filters['sort_order']) === 'ASC' ? 'ASC' : 'DESC';
        
        // Define fields to select
        $fieldList = self::getFieldList($filters);
        
        // Build main query
        $mainSql = "SELECT {$fieldList} FROM " . self::TABLE_NAME . " WHERE {$whereClause} ORDER BY {$sortField} {$sortOrder}";
        
        // Add pagination limits if not explicitly disabled
        if (!isset($filters['skip_pagination']) || !$filters['skip_pagination']) {
            $offset = ($page - 1) * $perPage;
            $mainSql .= " LIMIT {$perPage} OFFSET {$offset}";
        } else {
            // If pagination disabled, still enforce a reasonable limit
            $limit = min($filters['limit'] ?? self::MAX_BULK_ROWS, self::MAX_BULK_ROWS);
            $mainSql .= " LIMIT {$limit}";
        }
        
        return [
            'countSql' => $countSql,
            'mainSql' => $mainSql,
            'params' => $params,
            'page' => $page,
            'perPage' => $perPage
        ];
    }
    
    /**
     * Build SQL query for direct export to CSV file
     *
     * @param array $filters Filters to apply
     * @param string|null $filepath Optional file path for direct export
     * @return array Export query information
     */
    public static function buildExportQuery(array $filters, ?string $filepath = null): array
    {
        // Get WHERE clause and parameters
        list($whereClause, $params) = self::buildWhereClause($filters);
        
        // Define CSV format options
        $csvOptions = "
            FIELDS TERMINATED BY ',' 
            OPTIONALLY ENCLOSED BY '\"' 
            LINES TERMINATED BY '\\n'";
        
        // Build field list with proper formatting for export
        $selectFields = [
            'id',
            'action as category',
            'log_level',
            'message',
            'user_reference as user_id',
            'booking_reference as booking_id',
            'ip_address',
            'created_at',
            'request_id',
            'details'
        ];
        
        // Allow custom field selection for export
        if (!empty($filters['export_fields']) && is_array($filters['export_fields'])) {
            $selectFields = $filters['export_fields'];
        }
        
        $fieldList = implode(', ', $selectFields);
        
        // Build the main SQL query for export
        $sql = "SELECT {$fieldList} FROM " . self::TABLE_NAME . " WHERE {$whereClause} ";
        
        // Add order by
        $sortField = isset($filters['sort_field']) && in_array($filters['sort_field'], self::VALID_SORT_FIELDS) ? 
                    $filters['sort_field'] : 'created_at';
        $sortOrder = isset($filters['sort_order']) && strtoupper($filters['sort_order']) === 'ASC' ? 'ASC' : 'DESC';
        $sql .= "ORDER BY {$sortField} {$sortOrder} ";
        
        // Add reasonable limit to prevent excessive exports
        $limit = min($filters['limit'] ?? self::MAX_EXPORT_ROWS, self::MAX_EXPORT_ROWS);
        $sql .= "LIMIT {$limit}";
        
        // If filepath is provided, add INTO OUTFILE clause
        if ($filepath) {
            // Escape filepath for SQL
            $escapedPath = str_replace('\\', '\\\\', $filepath);
            
            // Add header row as first line
            $headerNames = [
                'ID', 'Category', 'Log Level', 'Message', 'User ID',
                'Booking ID', 'IP Address', 'Created At', 'Request ID', 'Details'
            ];
            
            // Use custom header names if provided
            if (!empty($filters['header_names']) && is_array($filters['header_names']) && 
                count($filters['header_names']) === count($selectFields)) {
                $headerNames = $filters['header_names'];
            }
            
            $headerRow = '"' . implode('","', $headerNames) . '"';
            
            $sql = "SELECT '{$headerRow}' AS header
                    UNION ALL
                    {$sql}
                    INTO OUTFILE '{$escapedPath}'
                    {$csvOptions}";
        }
        
        return [
            'sql' => $sql,
            'params' => $params,
            'limit' => $limit
        ];
    }
    
    /**
     * Build SQL and params for deleting logs
     *
     * @param array $filters Filters to determine which logs to delete
     * @param bool $forceBulkDelete Whether to allow bulk deletion without ID restrictions
     * @return array Delete query information
     */
    public static function buildDeleteQuery(array $filters, bool $forceBulkDelete = false): array
    {
        // Get WHERE clause and parameters
        list($whereClause, $params) = self::buildWhereClause($filters);
        
        // Safeguard: If no specific WHERE conditions and not forcing bulk delete, throw exception
        if (($whereClause === "1=1" || empty(array_filter($params))) && !$forceBulkDelete) {
            throw new InvalidArgumentException('Cannot delete all logs without explicit confirmation');
        }
        
        // Build the select query to get IDs for batch deletion
        $selectSql = "SELECT id FROM " . self::TABLE_NAME . " WHERE {$whereClause}";
        
        // Limit rows for safety if not forced bulk delete
        if (!$forceBulkDelete) {
            $selectSql .= " LIMIT " . self::MAX_EXPORT_ROWS;
        }
        
        // Return query info
        return [
            'select_sql' => $selectSql,
            'params' => $params,
            'where_clause' => $whereClause,
        ];
    }
    
    /**
     * Build SQL for batch deletion of logs
     *
     * @param array $ids Array of log IDs to delete
     * @return string SQL for deletion
     */
    public static function buildBatchDeleteQuery(array $ids): string
    {
        if (empty($ids)) {
            throw new InvalidArgumentException('No IDs provided for deletion');
        }
        
        $placeholders = implode(',', array_fill(0, count($ids), '?'));
        return "DELETE FROM " . self::TABLE_NAME . " WHERE id IN ({$placeholders})";
    }
    
    /**
     * Build SQL for retrieving a single log by ID
     *
     * @param int $logId Log ID
     * @return array Query and parameters
     */
    public static function buildGetByIdQuery(int $logId): array
    {
        $sql = "SELECT * FROM " . self::TABLE_NAME . " WHERE id = ? LIMIT 1";
        return [
            'sql' => $sql,
            'params' => [$logId]
        ];
    }
    
    /**
     * Validate and format a date string
     *
     * @param string $dateStr Date string to validate
     * @param bool $isEndDate Whether this is an end date (add time if needed)
     * @return string|null Formatted date string or null if invalid
     */
    private static function validateAndFormatDate(string $dateStr, bool $isEndDate = false): ?string
    {
        try {
            // Try to create DateTime object from the string
            $date = new DateTime($dateStr);
            
            // For end dates, if time component is missing, set it to end of day
            if ($isEndDate && strlen($dateStr) <= 10) { // Simple check for date-only format
                $date->setTime(23, 59, 59);
            }
            
            return $date->format('Y-m-d H:i:s');
        } catch (Exception $e) {
            // Try common date formats if the auto-detection fails
            foreach (self::DATE_FORMATS as $format) {
                $dateObj = DateTime::createFromFormat($format, $dateStr);
                if ($dateObj !== false) {
                    // For end dates without time, set to end of day
                    if ($isEndDate && strlen($format) <= 10) {
                        $dateObj->setTime(23, 59, 59);
                    }
                    return $dateObj->format('Y-m-d H:i:s');
                }
            }
            
            return null; // Invalid date format
        }
    }
    
    /**
     * Calculate a relative date range from a string like "last_7_days"
     *
     * @param string $relativeDate Relative date string ("last_7_days", "last_month", etc.)
     * @return array|null Date range with 'start' and 'end' dates or null if invalid
     */
    private static function calculateRelativeDateRange(string $relativeDate): ?array
    {
        $now = new DateTime();
        $end = $now->format('Y-m-d H:i:s');
        $start = null;
        
        switch ($relativeDate) {
            case 'today':
                $start = (new DateTime())->setTime(0, 0, 0)->format('Y-m-d H:i:s');
                break;
            
            case 'yesterday':
                $start = (new DateTime('yesterday'))->setTime(0, 0, 0)->format('Y-m-d H:i:s');
                $end = (new DateTime('yesterday'))->setTime(23, 59, 59)->format('Y-m-d H:i:s');
                break;
                
            case 'this_week':
                $startWeek = new DateTime('monday this week');
                $start = $startWeek->format('Y-m-d 00:00:00');
                break;
                
            case 'last_week':
                $startWeek = new DateTime('monday last week');
                $endWeek = new DateTime('sunday last week');
                $start = $startWeek->format('Y-m-d 00:00:00');
                $end = $endWeek->format('Y-m-d 23:59:59');
                break;
                
            case 'this_month':
                $start = (new DateTime('first day of this month'))->format('Y-m-d 00:00:00');
                break;
                
            case 'last_month':
                $startMonth = new DateTime('first day of last month');
                $endMonth = new DateTime('last day of last month');
                $start = $startMonth->format('Y-m-d 00:00:00');
                $end = $endMonth->format('Y-m-d 23:59:59');
                break;
                
            case 'last_24_hours':
                $past = clone $now;
                $past->sub(new DateInterval('PT24H'));
                $start = $past->format('Y-m-d H:i:s');
                break;
                
            case 'last_7_days':
                $past = clone $now;
                $past->sub(new DateInterval('P7D'));
                $start = $past->format('Y-m-d H:i:s');
                break;
                
            case 'last_30_days':
                $past = clone $now;
                $past->sub(new DateInterval('P30D'));
                $start = $past->format('Y-m-d H:i:s');
                break;
                
            case 'last_90_days':
                $past = clone $now;
                $past->sub(new DateInterval('P90D'));
                $start = $past->format('Y-m-d H:i:s');
                break;
                
            default:
                // Check for pattern like "last_X_days"
                if (preg_match('/^last_(\d+)_days$/', $relativeDate, $matches)) {
                    $days = (int)$matches[1];
                    if ($days > 0 && $days <= 366) { // Reasonable limit
                        $past = clone $now;
                        $past->sub(new DateInterval("P{$days}D"));
                        $start = $past->format('Y-m-d H:i:s');
                    }
                }
                break;
        }
        
        return $start ? ['start' => $start, 'end' => $end] : null;
    }
    
    /**
     * Get field list for SELECT queries
     *
     * @param array $filters Filter options
     * @return string SQL field list
     */
    private static function getFieldList(array $filters): string
    {
        // If custom fields are specified, use them
        if (!empty($filters['fields']) && is_array($filters['fields'])) {
            return implode(', ', $filters['fields']);
        }
        
        // Default to all fields
        return '*';
    }
}
=== App/Helpers/LoggingHelper.php ===
<?php
namespace App\Helpers;

use Psr\Log\LoggerInterface;

/**
 * @deprecated This class is deprecated. Use global functions from logger.php instead:
 * - getLogger(string $category): LoggerInterface
 * - getDefaultLogger(): LoggerInterface
 */
class LoggingHelper
{
    /**
     * @deprecated Use getDefaultLogger() function from logger.php instead
     */
    public static function getDefaultLogger(): LoggerInterface
    {
        trigger_error('LoggingHelper is deprecated. Use getDefaultLogger() function directly.', E_USER_DEPRECATED);
        return \getDefaultLogger();
    }

    /**
     * @deprecated Use getLogger($category) function from logger.php instead
     */
    public static function getLoggerByCategory(string $category): LoggerInterface
    {
        trigger_error('LoggingHelper is deprecated. Use getLogger(category) function directly.', E_USER_DEPRECATED);
        return \getLogger($category);
    }
}
=== App/api.php ===
<?php

require_once __DIR__ . '/../vendor/autoload.php';
require_once __DIR__ . '/../App/Helpers/SecurityHelper.php';

use Firebase\JWT\JWT;
use Firebase\JWT\Key;

// ✅ Load encryption keys
$config = require_once __DIR__ . '/encryption.php';
$jwtSecret = $config['jwt_secret'] ?? '';

header('Content-Type: application/json');

// ✅ Log Incoming Headers and Cookies
$tmpHeaders = getallheaders();
if (isset($tmpHeaders['X-Auth-Token'])) {
    $tmpHeaders['X-Auth-Token'] = 'Bearer <redacted>';
}
$tmpCookies = $_COOKIE;
if (isset($tmpCookies['jwt'])) {
    $tmpCookies['jwt'] = '<redacted>';
}
error_log("[API DEBUG] " . date('Y-m-d H:i:s') . " - Headers: " . json_encode($tmpHeaders) . "\n", 3, __DIR__ . '/../logs/debug.log');
error_log("[API DEBUG] " . date('Y-m-d H:i:s') . " - Cookies: " . json_encode($tmpCookies) . "\n", 3, __DIR__ . '/../logs/debug.log');

// ✅ Extract JWT from X-Auth-Token Header or Cookie
function getJWT() {
    $headers = getallheaders();
    if (isset($headers['X-Auth-Token']) && preg_match('/Bearer\s+(\S+)/', $headers['X-Auth-Token'], $matches)) {
        return trim($matches[1]);
    }
    return isset($_COOKIE['jwt']) ? trim($_COOKIE['jwt']) : null;
}

// ✅ Validate JWT and Decode User Info
function validateToken() {
    global $jwtSecret;

    $jwt = getJWT();
    if (!$jwt) {
        logApiError("Missing JWT");
        http_response_code(401);
        echo json_encode(["error" => "Unauthorized: Missing token"]);
        exit;
    }

    try {
        return (array) JWT::decode($jwt, new Key($jwtSecret, 'HS256'));
    } catch (Exception $e) {
        logApiError("Invalid JWT: " . $e->getMessage());
        http_response_code(401);
        echo json_encode(["error" => "Unauthorized: Invalid token"]);
        exit;
    }
}

// ✅ Log API Errors for Debugging
function logApiError($message) {
    error_log("[API] " . date('Y-m-d H:i:s') . " - {$message}\n", 3, __DIR__ . '/../logs/debug.log');
}

// ✅ CORS Handling (Apply to All Requests)
header('Access-Control-Allow-Origin: *');
header('Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, X-Auth-Token');

// ✅ Handle CORS Preflight Requests
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    exit;
}

// ✅ Parse API request
$requestUri = $_SERVER['REQUEST_URI'];
$apiPath = trim(str_replace('/api/', '', parse_url($requestUri, PHP_URL_PATH)), '/');

// ✅ Hardcoded Public API Routes
$publicApiRoutes = [
    'auth/login' => '/../public/api/auth/login.php',
    'auth/logout' => '/../public/api/auth/logout.php',
    'auth/register' => '/../public/api/auth/register.php',
    'auth/reset_request' => '/../public/api/auth/reset_request.php',
    'home' => '/../public/api/home.php',
    'vehicles' => '/../public/api/vehicles.php',
];

// ✅ Hardcoded Protected API Routes (Require Authentication)
$protectedApiRoutes = [
    'user/dashboard' => '/../public/api/user/dashboard.php',
    'user/profile' => '/../public/api/user/profile.php',
    'user/reports' => '/../public/api/user/reports.php',
    'user/notifications' => '/../public/api/user/notifications.php',
    'user/documents' => '/../public/api/user/documents.php',
    'payments/history' => '/../public/api/payments/history.php',
    'payments/make_payment' => '/../public/api/payments/make_payment.php',
    'payments/methods' => '/../public/api/payments/methods.php',
    'payments/refund' => '/../public/api/payments/refund.php',
];

// ✅ Ensure API Route Exists
if (isset($protectedApiRoutes[$apiPath])) {
    validateToken();
    $apiFile = __DIR__ . $protectedApiRoutes[$apiPath];
} elseif (isset($publicApiRoutes[$apiPath])) {
    $apiFile = __DIR__ . $publicApiRoutes[$apiPath];
} else {
    logApiError("API Endpoint Not Found: $apiPath");
    http_response_code(404);
    echo json_encode(['error' => 'API not found']);
    exit;
}

// ✅ Include API File
if (file_exists($apiFile)) {
    logApiError("Processing API endpoint: $apiPath");
    require_once $apiFile;
} else {
    logApiError("API File Not Found: $apiFile");
    http_response_code(404);
    echo json_encode(['error' => 'API file not found']);
}
