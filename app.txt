=== App/Controllers/UserController.php ===
<?php

namespace App\Controllers;

use App\Helpers\ApiHelper;
use App\Helpers\DatabaseHelper;
use App\Services\Validator;
use App\Services\Auth\TokenService;
use App\Services\AuditService;
use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;
use App\Services\Auth\AuthService;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;

/**
 * User Management Controller
 *
 * Handles profile management, password resets, and dashboard access.
 */
class UserController extends Controller
{
    private Validator $validator;
    private TokenService $tokenService;
    protected ExceptionHandler $exceptionHandler;
    protected LoggerInterface $logger;
    private AuthService $authService;
    private AuditService $auditService;

    public function __construct(
        LoggerInterface $logger,
        Validator $validator,
        TokenService $tokenService,
        ExceptionHandler $exceptionHandler,
        AuthService $authService,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->validator = $validator;
        $this->tokenService = $tokenService;
        $this->exceptionHandler = $exceptionHandler;
        $this->authService = $authService;
        $this->auditService = $auditService;
    }

    /**
     * Register a new user.
     */
    public function registerUser(Request $request, Response $response)
    {
        try {
            $data = json_decode($request->getBody()->getContents(), true);
            $this->logger->info("Processing user registration", ['email' => $data['email'] ?? 'not provided']);
            
            // Validate input data
            $rules = [
                'email'    => 'required|email',
                'password' => 'required|min:6',
                'name'     => 'required|string',
            ];
            
            $this->validator->validate($data, $rules);
            
            // Check if email is already in use
            $existingUser = DatabaseHelper::select(
                "SELECT id FROM users WHERE email = ?",
                [$data['email']],
                false // Using application database
            );
            
            if (!empty($existingUser)) {
                return ApiHelper::sendJsonResponse('error', 'Email already in use', [], 400);
            }
            
            // Hash password and prepare user data
            $userData = [
                'email' => $data['email'],
                'name' => $data['name'],
                'password' => password_hash($data['password'], PASSWORD_BCRYPT),
                'created_at' => date('Y-m-d H:i:s'),
                'role' => 'user',
                'status' => 'active'
            ];
            
            // Insert new user using application database
            $userId = DatabaseHelper::insert(
                'users',
                $userData,
                false, // Use application database
                ['operation' => 'user_registration']
            );
            
            // Log the registration in audit logs
            $this->auditService->logEvent(
                'user_registered',
                'User registered successfully',
                ['email' => $data['email']],
                $userId,
                null,
                'user'
            );
            
            $this->logger->info("User registered successfully", [
                'user_id' => $userId,
                'email' => $data['email']
            ]);
            
            return ApiHelper::sendJsonResponse('success', 'User registered successfully', ['user_id' => $userId], 201);
            
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ApiHelper::sendJsonResponse('error', 'Registration failed', [], 500);
        }
    }

    /**
     * Retrieve current user profile.
     */
    public function getUserProfile(Request $request, Response $response)
    {
        try {
            // Get user from TokenService validation
            $user = $this->tokenService->validateRequest($request);
            if (!$user) {
                return ApiHelper::sendJsonResponse('error', 'User not authenticated', [], 401);
            }
            
            $userId = $user['id'];
            $this->logger->info("Fetching user profile", ['user_id' => $userId]);
            
            // Fetch user data with a single optimized query
            $userData = DatabaseHelper::select(
                "SELECT u.id, u.name, u.email, u.created_at, u.role, 
                        u.status, u.last_login, p.bio, p.avatar_url, p.location
                 FROM users u
                 LEFT JOIN user_profiles p ON u.id = p.user_id
                 WHERE u.id = ? AND u.deleted_at IS NULL",
                [$userId],
                false // Using application database
            );
            
            if (empty($userData)) {
                return ApiHelper::sendJsonResponse('error', 'User not found', [], 404);
            }
            
            // Log profile view in audit logs
            $this->auditService->logEvent(
                'profile_viewed',
                'User viewed their profile',
                ['user_id' => $userId],
                $userId,
                null,
                'user'
            );
            
            return ApiHelper::sendJsonResponse('success', 'User profile retrieved', $userData[0], 200);
            
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ApiHelper::sendJsonResponse('error', 'Failed to retrieve profile', [], 500);
        }
    }

    /**
     * Update user profile.
     */
    public function updateProfile(Request $request, Response $response)
    {
        try {
            // Get user from TokenService validation
            $user = $this->tokenService->validateRequest($request);
            if (!$user) {
                return ApiHelper::sendJsonResponse('error', 'User not authenticated', [], 401);
            }
            
            $userId = $user['id'];
            
            $data = json_decode($request->getBody()->getContents(), true);
            $this->logger->info("Updating user profile", ['user_id' => $userId]);
            
            // Validate input data
            $rules = [
                'name'     => 'string|max:100',
                'bio'      => 'string|max:500',
                'location' => 'string|max:100',
                'avatar_url' => 'url|max:255'
            ];
            
            $this->validator->validate($data, $rules);
            
            // Separate user table fields from profile fields
            $userData = array_intersect_key($data, array_flip(['name']));
            $profileData = array_intersect_key($data, array_flip(['bio', 'location', 'avatar_url']));
            
            // Start transaction for updating both tables
            DatabaseHelper::rawQuery(
                "START TRANSACTION",
                [],
                false // Using application database
            );
            
            // Update user main data if needed
            if (!empty($userData)) {
                DatabaseHelper::update(
                    'users',
                    $userData,
                    ['id' => $userId],
                    false, // Using application database
                    ['operation' => 'profile_update', 'user_id' => $userId]
                );
            }
            
            // Update or insert profile data if needed
            if (!empty($profileData)) {
                // Check if profile exists
                $existingProfile = DatabaseHelper::select(
                    "SELECT user_id FROM user_profiles WHERE user_id = ?",
                    [$userId],
                    false // Using application database
                );
                
                if (empty($existingProfile)) {
                    // Create new profile entry
                    $profileData['user_id'] = $userId;
                    $profileData['created_at'] = date('Y-m-d H:i:s');
                    
                    DatabaseHelper::insert(
                        'user_profiles',
                        $profileData,
                        false, // Using application database
                        ['operation' => 'profile_create', 'user_id' => $userId]
                    );
                } else {
                    // Update existing profile
                    $profileData['updated_at'] = date('Y-m-d H:i:s');
                    
                    DatabaseHelper::update(
                        'user_profiles',
                        $profileData,
                        ['user_id' => $userId],
                        false, // Using application database
                        ['operation' => 'profile_update', 'user_id' => $userId]
                    );
                }
            }
            
            // Commit the transaction
            DatabaseHelper::rawQuery(
                "COMMIT",
                [],
                false // Using application database
            );
            
            // Log profile update in audit logs
            $this->auditService->logEvent(
                'profile_updated',
                'User updated their profile',
                [
                    'user_id' => $userId, 
                    'fields_updated' => array_merge(array_keys($userData), array_keys($profileData))
                ],
                $userId,
                null,
                'user'
            );
            
            // Get updated profile
            $updatedProfile = DatabaseHelper::select(
                "SELECT u.id, u.name, u.email, u.role, u.created_at, 
                        p.bio, p.location, p.avatar_url
                 FROM users u
                 LEFT JOIN user_profiles p ON u.id = p.user_id
                 WHERE u.id = ?",
                [$userId],
                false // Using application database
            );
            
            return ApiHelper::sendJsonResponse('success', 'Profile updated successfully', $updatedProfile[0], 200);
            
        } catch (\Exception $e) {
            // Rollback transaction on error
            DatabaseHelper::rawQuery(
                "ROLLBACK",
                [],
                false // Using application database
            );
            
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ApiHelper::sendJsonResponse('error', 'Failed to update profile', [], 500);
        }
    }

    /**
     * Request password reset.
     */
    public function requestPasswordReset(Request $request, Response $response)
    {
        try {
            $data = json_decode($request->getBody()->getContents(), true);
            
            if (!isset($data['email']) || !filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
                return ApiHelper::sendJsonResponse('error', 'Valid email is required', [], 400);
            }
            
            $this->logger->info("Processing password reset request", ['email' => $data['email']]);
            
            // Check if user exists
            $user = DatabaseHelper::select(
                "SELECT id, email FROM users WHERE email = ? AND deleted_at IS NULL",
                [$data['email']],
                false // Using application database
            );
            
            if (empty($user)) {
                // Don't reveal that the email doesn't exist, but log it
                $this->logger->info("Password reset requested for non-existent email", [
                    'email' => $data['email']
                ]);
                return ApiHelper::sendJsonResponse('success', 'If your email is in our system, you will receive reset instructions shortly', [], 200);
            }
            
            // Generate a secure token
            $token = bin2hex(random_bytes(30));
            $expiresAt = date('Y-m-d H:i:s', strtotime('+1 hour'));
            
            // Store token in secure database
            DatabaseHelper::insert(
                'password_resets',
                [
                    'email' => $data['email'],
                    'token' => $token,
                    'expires_at' => $expiresAt,
                    'created_at' => date('Y-m-d H:i:s')
                ],
                true, // Use secure database
                ['operation' => 'password_reset_request', 'user_id' => $user[0]['id']]
            );
            
            // Log password reset request in audit logs
            $this->auditService->logEvent(
                'password_reset_requested',
                'Password reset requested',
                ['email' => $data['email'], 'expires_at' => $expiresAt],
                $user[0]['id'],
                null,
                'user'
            );
            
            return ApiHelper::sendJsonResponse('success', 'Password reset instructions sent to your email', [], 200);
            
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ApiHelper::sendJsonResponse('error', 'Failed to process password reset request', [], 500);
        }
    }

    /**
     * Reset password with token.
     */
    public function resetPassword(Request $request, Response $response)
    {
        try {
            $data = json_decode($request->getBody()->getContents(), true);
            
            // Validate input
            if (!isset($data['token']) || !isset($data['password']) || strlen($data['password']) < 6) {
                return ApiHelper::sendJsonResponse('error', 'Token and password (min 6 chars) required', [], 400);
            }
            
            $this->logger->info("Processing password reset with token");
            
            // Check if token is valid and not expired using secure database
            $resetRequest = DatabaseHelper::select(
                "SELECT email, token, expires_at FROM password_resets 
                 WHERE token = ? AND expires_at > NOW()",
                [$data['token']],
                true // Use secure database
            );
            
            if (empty($resetRequest)) {
                $this->logger->warning("Invalid or expired password reset token used");
                return ApiHelper::sendJsonResponse('error', 'Invalid or expired token', [], 400);
            }
            
            $email = $resetRequest[0]['email'];
            
            // Get user ID
            $user = DatabaseHelper::select(
                "SELECT id FROM users WHERE email = ?",
                [$email]
            );
            
            if (empty($user)) {
                $this->logger->warning("User not found for password reset", ['email' => $email]);
                return ApiHelper::sendJsonResponse('error', 'User not found', [], 404);
            }
            
            $userId = $user[0]['id'];
            
            // Update the password
            $hashedPassword = password_hash($data['password'], PASSWORD_BCRYPT);
            
            DatabaseHelper::update(
                'users',
                [
                    'password' => $hashedPassword,
                    'updated_at' => date('Y-m-d H:i:s')
                ],
                ['id' => $userId],
                false,
                ['operation' => 'password_reset', 'user_id' => $userId]
            );
            
            // Delete the used token using secure database
            DatabaseHelper::delete(
                'password_resets',
                ['token' => $data['token']],
                false,
                true // Use secure database
            );
            
            $this->logger->info("Password reset successful", [
                'user_id' => $userId,
                'email' => $email
            ]);
            
            return ApiHelper::sendJsonResponse('success', 'Password has been reset successfully', [], 200);
            
        } catch (\Exception $e) {
            $this->logger->error("Failed to reset password", [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            return ApiHelper::sendJsonResponse('error', 'Failed to reset password', [], 500);
        }
    }

    /**
     * User dashboard access.
     */
    public function userDashboard(Request $request, Response $response)
    {
        try {
            // Get user from TokenService validation
            $user = $this->tokenService->validateRequest($request);
            if (!$user) {
                return ApiHelper::sendJsonResponse('error', 'User not authenticated', [], 401);
            }
            
            $userId = $user['id'];
            
            $this->logger->info("User accessing dashboard", ['user_id' => $userId]);
            
            // Get user data
            $user = DatabaseHelper::select(
                "SELECT id, name, email, role FROM users WHERE id = ? AND deleted_at IS NULL",
                [$userId]
            );
            
            if (empty($user)) {
                return ApiHelper::sendJsonResponse('error', 'User not found', [], 404);
            }
            
            // Get user's recent activity in a single query
            $userActivity = DatabaseHelper::select(
                "SELECT activity_type, description, created_at 
                 FROM user_activities 
                 WHERE user_id = ? 
                 ORDER BY created_at DESC LIMIT 5",
                [$userId]
            );
            
            // Build dashboard data
            $dashboardData = [
                'user' => $user[0],
                'recent_activity' => $userActivity,
                'account_age_days' => $this->calculateAccountAge($userId)
            ];
            
            // Log dashboard access
            DatabaseHelper::insert(
                'user_activities',
                [
                    'user_id' => $userId,
                    'activity_type' => 'dashboard_access',
                    'description' => 'User accessed their dashboard',
                    'created_at' => date('Y-m-d H:i:s'),
                    'ip_address' => $_SERVER['REMOTE_ADDR'] ?? null
                ]
            );
            
            return ApiHelper::sendJsonResponse('success', 'User Dashboard', $dashboardData, 200);
            
        } catch (\Exception $e) {
            $this->logger->error("Failed to load user dashboard", [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
                'user_id' => $request->getAttribute('user_id') ?? 'unknown'
            ]);
            return ApiHelper::sendJsonResponse('error', 'Failed to load dashboard', [], 500);
        }
    }
    
    /**
     * Calculate user account age in days
     */
    private function calculateAccountAge(int $userId): int
    {
        $creationDate = DatabaseHelper::select(
            "SELECT created_at FROM users WHERE id = ?",
            [$userId]
        );
        
        if (empty($creationDate)) {
            return 0;
        }
        
        $createdTimestamp = strtotime($creationDate[0]['created_at']);
        $currentTimestamp = time();
        return floor(($currentTimestamp - $createdTimestamp) / (60 * 60 * 24));
    }
}
=== App/Controllers/BookingController.php ===
<?php

namespace App\Controllers;

use App\Models\Booking;
use App\Models\RefundLog;
use App\Services\AuthService;
use App\Services\AuditService;
use App\Services\Auth\TokenService;
use App\Helpers\DatabaseHelper;
use App\Helpers\ExceptionHandler;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Log\LoggerInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

/**
 * Booking Controller
 *
 * Handles booking operations, including creating, rescheduling,
 * canceling bookings, and fetching booking details or logs.
 */
class BookingController extends Controller
{
    private BookingService $bookingService;
    private PaymentService $paymentService;
    private Validator $validator;
    private AuditService $auditService;
    private NotificationService $notificationService;
    private ResponseFactoryInterface $responseFactory;
    protected LoggerInterface $logger;
    private TokenService $tokenService;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        BookingService $bookingService,
        PaymentService $paymentService,
        Validator $validator,
        AuditService $auditService,
        NotificationService $notificationService,
        ResponseFactoryInterface $responseFactory,
        TokenService $tokenService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->bookingService = $bookingService;
        $this->paymentService = $paymentService;
        $this->validator = $validator;
        $this->auditService = $auditService;
        $this->notificationService = $notificationService;
        $this->responseFactory = $responseFactory;
        $this->tokenService = $tokenService;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Create standardized PSR-7 JSON response
     */
    protected function jsonResponse(array $data, int $status = 200): ResponseInterface
    {
        $response = $this->responseFactory->createResponse($status);
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    /**
     * View Booking Details
     */
    public function viewBooking(int $id): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $booking = Booking::with('logs')->findOrFail($id);
            
            // Audit log for viewing booking
            $this->auditService->logEvent(
                'booking_viewed',
                "Booking #{$id} details viewed",
                ['booking_id' => $id, 'user_id' => $user['id']],
                $user['id'],
                $id,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking details fetched',
                'data' => ['booking' => $booking]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch booking details'
            ], 500);
        }
    }

    /**
     * Reschedule Booking
     */
    public function rescheduleBooking(int $id): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $data = $_POST; // minimal custom validation assumed
            
            $booking = Booking::findOrFail($id);
            $oldPickup = $booking->pickup_date;
            $oldDropoff = $booking->dropoff_date;
            
            $booking->update([
                'pickup_date'  => $data['pickup_date'],
                'dropoff_date' => $data['dropoff_date'],
            ]);
            
            // Audit the rescheduling action
            $this->auditService->logEvent(
                'booking_rescheduled',
                "Booking #{$id} rescheduled",
                [
                    'booking_id' => $id,
                    'user_id' => $user['id'],
                    'old_pickup' => $oldPickup,
                    'new_pickup' => $data['pickup_date'],
                    'old_dropoff' => $oldDropoff,
                    'new_dropoff' => $data['dropoff_date']
                ],
                $user['id'],
                $id,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking rescheduled successfully'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to reschedule booking'
            ], 500);
        }
    }

    /**
     * Cancel Booking
     */
    public function cancelBooking(int $id): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $booking = Booking::findOrFail($id);
            $oldStatus = $booking->status;
            $booking->update(['status' => 'canceled']);

            // Process refund if applicable.
            $refundAmount = $booking->calculateRefund(); // Assumes a calculateRefund() method exists.
            if ($refundAmount > 0) {
                $refund = RefundLog::create([
                    'booking_id' => $id,
                    'amount'     => $refundAmount,
                    'status'     => 'processed'
                ]);
                
                // Audit the refund processed
                $this->auditService->logEvent(
                    'refund_processed',
                    "Refund processed for booking #{$id}",
                    [
                        'booking_id' => $id,
                        'user_id' => $user['id'],
                        'refund_amount' => $refundAmount,
                        'refund_id' => $refund->id
                    ],
                    $user['id'],
                    $id,
                    'payment'
                );
            }
            
            // Audit the cancellation
            $this->auditService->logEvent(
                'booking_canceled',
                "Booking #{$id} canceled",
                [
                    'booking_id' => $id,
                    'user_id' => $user['id'],
                    'old_status' => $oldStatus,
                    'refund_amount' => $refundAmount ?? 0
                ],
                $user['id'],
                $id,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking canceled successfully'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to cancel booking'
            ], 500);
        }
    }

    /**
     * Fetch Booking Logs
     */
    public function getBookingLogs(int $bookingId): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            // Instead of getting booking logs directly from a logs table,
            // fetch audit events related to this booking from the audit service
            $logs = $this->auditService->getEventsByReference('booking_reference', $bookingId);
            
            // Log this access to audit logs
            $this->auditService->logEvent(
                'booking_logs_viewed',
                "Booking #{$bookingId} logs accessed",
                [
                    'booking_id' => $bookingId,
                    'user_id' => $user['id']
                ],
                $user['id'],
                $bookingId,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking logs fetched successfully',
                'data' => ['logs' => $logs]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch booking logs'
            ], 500);
        }
    }

    /**
     * List All Bookings for a User
     */
    public function getUserBookings(): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $bookings = Booking::where('user_id', $user['id'])->latest()->get();
            
            // Log the fetch operation
            $this->auditService->logEvent(
                'user_bookings_listed',
                "User retrieved their booking list",
                ['user_id' => $user['id']],
                $user['id'],
                null,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'User bookings fetched successfully',
                'data' => ['bookings' => $bookings]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch user bookings'
            ], 500);
        }
    }

    /**
     * Create New Booking
     */
    public function createBooking(): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $data = $_POST; // assuming custom validation is performed elsewhere
            
            // Check vehicle availability using an assumed Booking::isAvailable() scope.
            if (!Booking::isAvailable($data['vehicle_id'], $data['pickup_date'], $data['dropoff_date'])) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Vehicle is not available for the selected dates'
                ], 400);
            }
            
            $booking = Booking::create($data);
            
            // Log the booking creation to the audit logs
            $this->auditService->logEvent(
                'booking_created',
                "New booking #{$booking->id} created",
                [
                    'booking_id' => $booking->id,
                    'user_id' => $user['id'],
                    'vehicle_id' => $data['vehicle_id'],
                    'pickup_date' => $data['pickup_date'], 
                    'dropoff_date' => $data['dropoff_date']
                ],
                $user['id'],
                $booking->id,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking created successfully',
                'data' => ['booking_id' => $booking->id]
            ], 201);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to create booking'
            ], 500);
        }
    }
}
=== App/Controllers/NotificationController.php ===
<?php

namespace App\Controllers;

use App\Models\Notification;
use App\Services\AuthService;
use App\Helpers\JsonResponse;
use App\Helpers\TokenValidator;
use App\Helpers\ExceptionHandler;
use App\Services\AuditService;
use Psr\Log\LoggerInterface;
use Psr\Http\Message\ResponseInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

/**
 * Notification Controller
 *
 * Handles notification management, including sending notifications,
 * marking notifications as read, deleting notifications, and
 * fetching user notifications for display.
 */
class NotificationController extends Controller
{
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;
    private AuditService $auditService;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    /**
     * Display user notifications.
     */
    public function viewNotifications(): ResponseInterface
    {
        try {
            $userId = AuthService::getUserIdFromToken();
            
            $notifications = Notification::with('user')
                ->where('user_id', $userId)
                ->latest()
                ->get();
                
            // Log notification view in audit logs
            $this->auditService->logEvent(
                'notifications_viewed',
                "User viewed their notifications",
                ['user_id' => $userId],
                $userId,
                null,
                'notification'
            );
                
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Notifications loaded',
                'data'    => ['notifications' => $notifications]
            ], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'An error occurred while fetching notifications'
            ], 500);
        }
    }

    /**
     * Fetch all notifications for the authenticated user.
     */
    public function getUserNotifications(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $notifications = Notification::with('user')
                ->where('user_id', $user->id)
                ->latest()
                ->get();
                
            // Log in audit logs
            $this->auditService->logEvent(
                'user_notifications_fetched',
                "User fetched their notifications via API",
                ['user_id' => $user->id],
                $user->id,
                null,
                'notification'
            );
                
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notifications retrieved successfully',
                'data' => ['notifications' => $notifications]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch user notifications'
            ], 500);
        }
    }

    /**
     * Fetch unread notifications via AJAX.
     */
    public function fetchNotificationsAjax(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $notifications = Notification::with('user')
                ->where('user_id', $user->id)
                ->where('is_read', false)
                ->latest()
                ->get();
                
            // Log notification fetch in audit logs
            $this->auditService->logEvent(
                'unread_notifications_fetched',
                "User fetched unread notifications",
                ['user_id' => $user->id, 'count' => $notifications->count()],
                $user->id,
                null,
                'notification'
            );
                
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notifications retrieved successfully',
                'data' => ['notifications' => $notifications]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch notifications'
            ], 500);
        }
    }

    /**
     * Mark a notification as read.
     */
    public function markNotificationAsRead(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $data = $this->validateRequest($_POST, [
                'notification_id' => 'required|integer'
            ]);

            $notification = Notification::findOrFail($data['notification_id']);
            
            // Ensure user owns this notification
            if ($notification->user_id != $user->id) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized'
                ], 403);
            }

            $notification->update(['is_read' => true]);
            
            // Log in audit logs
            $this->auditService->logEvent(
                'notification_marked_as_read',
                "User marked a notification as read",
                ['user_id' => $user->id, 'notification_id' => $data['notification_id']],
                $user->id,
                null,
                'notification'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notification marked as read'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to mark notification as read'
            ], 500);
        }
    }

    /**
     * Delete a notification.
     */
    public function deleteNotification(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $data = $this->validateRequest($_POST, [
                'notification_id' => 'required|integer'
            ]);

            $notification = Notification::findOrFail($data['notification_id']);
            
            // Ensure user owns this notification
            if ($notification->user_id != $user->id) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized'
                ], 403);
            }

            $notification->delete();
            
            // Log in audit logs
            $this->auditService->logEvent(
                'notification_deleted',
                "User deleted a notification",
                ['user_id' => $user->id, 'notification_id' => $data['notification_id']],
                $user->id,
                null,
                'notification'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notification deleted'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to delete notification'
            ], 500);
        }
    }

    /**
     * Send a notification.
     */
    public function sendNotification(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $data = $this->validateRequest($_POST, [
                'user_id' => 'required|integer',
                'type'    => 'required|in:email,sms,webhook,push',
                'message' => 'required|string|max:1000',
                'options' => 'nullable|array',
            ]);

            // Store notification via Eloquent
            $notification = Notification::create([
                'user_id' => $data['user_id'],
                'type'    => $data['type'],
                'message' => $data['message'],
                'sent_at' => date('Y-m-d H:i:s'),
                'is_read' => false,
            ]);
            
            // Log in audit logs
            $this->auditService->logEvent(
                'notification_sent',
                "User sent a notification",
                ['user_id' => $data['user_id'], 'notification_id' => $notification->id],
                $user->id,
                null,
                'notification'
            );
            
            // Optionally dispatch via queue or any external channel here.
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notification sent successfully',
                'data' => ['notification' => $notification]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to send notification'
            ], 500);
        }
    }
}
=== App/Controllers/AdminController.php ===
<?php

namespace App\Controllers;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;
use App\Services\Auth\TokenService;
use App\Helpers\JsonResponse;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

/**
 * AdminController - Handles admin user management and dashboard operations.
 */
class AdminController extends Controller
{
    private AuditService $auditService;
    private ResponseFactoryInterface $responseFactory;
    protected LoggerInterface $logger;
    private TokenService $tokenService;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        AuditService $auditService,
        ResponseFactoryInterface $responseFactory,
        TokenService $tokenService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->auditService = $auditService;
        $this->responseFactory = $responseFactory;
        $this->tokenService = $tokenService;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Create standardized PSR-7 JSON response
     */
    protected function jsonResponse(array $data, int $status = 200): ResponseInterface
    {
        $response = $this->responseFactory->createResponse($status);
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }
    
    /**
     * Validate admin token and return admin data
     */
    protected function validateAdmin(): ?array
    {
        $this->logger->debug("Validating admin token using secure database");
        
        // Use TokenService to extract the token
        $token = $this->tokenService->extractToken($this->request);
        
        if (empty($token)) {
            $this->logger->info("No authorization token provided");
            return null;
        }
        
        // Validate token and fetch admin details - using secure database
        $adminData = DatabaseHelper::select(
            "SELECT id, email, role FROM admins WHERE token = ? AND token_expiry > NOW()", 
            [$token],
            true // Explicitly using secure database
        );
            
        if (empty($adminData) || $adminData[0]['role'] !== 'admin') {
            $this->logger->info("Invalid admin token or insufficient permissions");
            return null;
        }
        
        $this->logger->info("Admin validated successfully", ['admin_id' => $adminData[0]['id']]);
        return $adminData[0];
    }

    /**
     * ✅ Get a paginated list of all users with their roles.
     */
    public function getAllUsers(): ResponseInterface
    {
        try {
            $admin = $this->validateAdmin();
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }

            $this->logger->debug("Fetching users with pagination using application database");
            
            // Get pagination parameters
            $page = (int) ($this->request->getQueryParams()['page'] ?? 1);
            $perPage = 10;
            $offset = ($page - 1) * $perPage;
            
            // Get users with pagination - using application database
            $users = DatabaseHelper::select(
                "SELECT u.*, r.name as role_name 
                 FROM users u 
                 LEFT JOIN roles r ON u.role_id = r.id 
                 ORDER BY u.created_at DESC 
                 LIMIT ? OFFSET ?",
                [$perPage, $offset],
                false // Explicitly using application database
            );
            
            // Get total count for pagination
            $totalUsers = DatabaseHelper::select(
                "SELECT COUNT(*) as count FROM users", 
                [],
                false // Explicitly using application database
            )[0]['count'];
            
            $this->auditService->logEvent(
                'user_list_viewed',
                'Admin viewed user list',
                ['admin_id' => $admin['id'], 'page' => $page],
                $admin['id'],
                null,
                'admin'
            );
            
            return $this->jsonResponse([
                'status' => 'success', 
                'message' => 'User list retrieved successfully', 
                'data' => [
                    'users' => $users,
                    'pagination' => [
                        'total' => $totalUsers,
                        'per_page' => $perPage,
                        'current_page' => $page,
                        'last_page' => ceil($totalUsers / $perPage)
                    ]
                ]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to retrieve users'], 500);
        }
    }

    /**
     * ✅ Update a user's role.
     */
    public function updateUserRole($userId): ResponseInterface
    {
        try {
            $admin = $this->validateAdmin();
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }

            $data = $this->request->getParsedBody();
            $role = $data['role'] ?? '';
            $allowedRoles = ['user', 'admin', 'manager'];
            if (!$role || !in_array($role, $allowedRoles)) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid role'
                ], 400);
            }
            
            $this->logger->debug("Fetching user data for role update using application database", [
                'user_id' => $userId
            ]);
            
            // Get user and their current role - using application database
            $user = DatabaseHelper::select(
                "SELECT id, role FROM users WHERE id = ?", 
                [(int)$userId],
                false // Explicitly using application database
            );
            
            if (empty($user)) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'User not found'
                ], 404);
            }
            
            $oldRole = $user[0]['role'];
            
            $this->logger->debug("Updating user role using application database", [
                'user_id' => $userId,
                'old_role' => $oldRole,
                'new_role' => $role
            ]);
            
            // Update role - using application database
            DatabaseHelper::update(
                "users", 
                ["role" => $role], 
                ["id" => (int)$userId],
                false // Explicitly using application database
            );
            
            $this->auditService->logEvent(
                'user_role_updated',
                "User role updated from {$oldRole} to {$role}",
                [
                    'user_id' => $userId,
                    'old_role' => $oldRole,
                    'new_role' => $role,
                    'admin_id' => $admin['id']
                ],
                $admin['id'],
                null,
                'admin'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'User role updated successfully'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to update user role'], 500);
        }
    }

    /**
     * ✅ Delete a user (Soft delete).
     */
    public function deleteUser($userId): ResponseInterface
    {
        try {
            $admin = $this->validateAdmin();
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }

            $this->logger->debug("Fetching user data for deletion using application database", [
                'user_id' => $userId
            ]);
            
            // Get user data for audit log - using application database
            $user = DatabaseHelper::select(
                "SELECT id, email, role FROM users WHERE id = ?", 
                [(int)$userId],
                false // Explicitly using application database
            );
            
            if (empty($user)) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'User not found'
                ], 404);
            }
            
            $userEmail = $user[0]['email'];
            $userRole = $user[0]['role'];
            
            // Check if user is a super admin
            if ($userRole === 'super_admin') {
                $this->logger->info("Attempted to delete a super_admin account", [
                    'user_id' => $userId,
                    'admin_id' => $admin['id']
                ]);
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Super admins cannot be deleted'
                ], 403);
            }
            
            $this->logger->debug("Soft deleting user using application database", [
                'user_id' => $userId,
                'user_email' => $userEmail
            ]);
            
            // Soft delete by setting deleted_at timestamp - using application database
            DatabaseHelper::update(
                "users", 
                ["deleted_at" => date('Y-m-d H:i:s')], 
                ["id" => (int)$userId],
                false // Explicitly using application database
            );
            
            $this->auditService->logEvent(
                'user_deleted',
                "User {$userEmail} was deleted",
                [
                    'user_id' => $userId,
                    'user_email' => $userEmail,
                    'admin_id' => $admin['id']
                ],
                $admin['id'],
                null,
                'admin'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'User deleted successfully'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to delete user'], 500);
        }
    }

    /**
     * ✅ Fetch admin dashboard statistics.
     */
    public function getDashboardData(): ResponseInterface
    {
        try {
            $admin = $this->validateAdmin();
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }

            $this->logger->debug("Fetching dashboard statistics using application database");
            
            // Get total users count - using application database
            $totalUsers = DatabaseHelper::select(
                "SELECT COUNT(*) as count FROM users WHERE deleted_at IS NULL", 
                [],
                false // Explicitly using application database
            )[0]['count'];
            
            // Get total bookings count - using application database
            $totalBookings = DatabaseHelper::select(
                "SELECT COUNT(*) as count FROM bookings", 
                [],
                false // Explicitly using application database
            )[0]['count'];
            
            // Get total revenue - using application database
            $totalRevenue = DatabaseHelper::select(
                "SELECT SUM(amount) as total FROM payments WHERE status = 'completed'", 
                [],
                false // Explicitly using application database
            )[0]['total'] ?? 0;
            
            // Get latest 5 users - using application database
            $latestUsers = DatabaseHelper::select(
                "SELECT u.*, r.name as role_name 
                 FROM users u 
                 LEFT JOIN roles r ON u.role_id = r.id 
                 WHERE u.deleted_at IS NULL 
                 ORDER BY u.created_at DESC 
                 LIMIT 5",
                [],
                false // Explicitly using application database
            );
            
            // Get latest 5 transactions - using application database
            $latestTransactions = DatabaseHelper::select(
                "SELECT * FROM transaction_logs ORDER BY created_at DESC LIMIT 5",
                [],
                false // Explicitly using application database
            );
            
            $dashboardData = [
                'total_users' => $totalUsers,
                'total_bookings' => $totalBookings,
                'total_revenue' => $totalRevenue,
                'latest_users' => $latestUsers,
                'latest_transactions' => $latestTransactions,
            ];
            
            $this->auditService->logEvent(
                'dashboard_viewed',
                'Admin viewed dashboard',
                ['admin_id' => $admin['id']],
                $admin['id'],
                null,
                'admin'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Dashboard data retrieved successfully',
                'data' => $dashboardData
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to retrieve dashboard data'], 500);
        }
    }

    /**
     * ✅ Create a new admin user.
     */
    public function createAdmin(): ResponseInterface
    {
        try {
            $admin = $this->validateAdmin();
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }

            $data = $this->request->getParsedBody();
            
            // Validate input
            if (!isset($data['name'], $data['email'], $data['password']) ||
                !filter_var($data['email'], FILTER_VALIDATE_EMAIL) ||
                strlen($data['password']) < 8
            ) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid input. Email must be valid and password must be at least 8 characters'
                ], 400);
            }
            
            $this->logger->debug("Checking for existing admin email using secure database", [
                'email' => $data['email']
            ]);
            
            // Check if email already exists - using secure database
            $existingAdmin = DatabaseHelper::select(
                "SELECT id FROM admins WHERE email = ?", 
                [$data['email']],
                true // Explicitly using secure database
            );
            
            if (!empty($existingAdmin)) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Email already in use'
                ], 400);
            }
            
            // Create new admin - using secure database
            $hashedPassword = password_hash($data['password'], PASSWORD_DEFAULT);
            
            $this->logger->debug("Creating new admin user in secure database");
            
            // Insert new admin record - using secure database
            $newAdminId = DatabaseHelper::insert(
                "admins", 
                [
                    "name" => $data['name'],
                    "email" => $data['email'],
                    "password" => $hashedPassword,
                    "role" => 'admin',
                    "created_at" => date('Y-m-d H:i:s')
                ],
                true // Explicitly using secure database
            );
            
            if (!$newAdminId) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Failed to create admin user'
                ], 500);
            }
            
            $this->logger->debug("Fetching created admin details from secure database", [
                'new_admin_id' => $newAdminId
            ]);
            
            // Get created admin details for response - using secure database
            $newAdmin = DatabaseHelper::select(
                "SELECT id, name, email, role, created_at FROM admins WHERE id = ?", 
                [$newAdminId],
                true // Explicitly using secure database
            )[0];
            
            $this->auditService->logEvent(
                'admin_created',
                "New admin user created: {$data['email']}",
                [
                    'created_by' => $admin['id'],
                    'new_admin_id' => $newAdminId,
                    'new_admin_email' => $data['email']
                ],
                $admin['id'],
                null,
                'admin'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Admin created successfully',
                'data' => $newAdmin
            ], 201);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to create admin user'], 500);
        }
    }
}
=== App/Controllers/AuthController.php ===
<?php

namespace App\Controllers;

use App\Services\Auth\AuthService;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Log\LoggerInterface;
use App\Services\Auth\TokenService;
use App\Helpers\DatabaseHelper;
use App\Services\RateLimiter;
use App\Helpers\ExceptionHandler;

class AuthController extends Controller
{
    protected LoggerInterface $logger;
    private AuthService $authService;
    private TokenService $tokenService;
    private $pdo;
    private RateLimiter $rateLimiter;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        AuthService $authService,
        TokenService $tokenService,
        DatabaseHelper $dbHelper,
        RateLimiter $rateLimiter,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->authService = $authService;
        $this->tokenService = $tokenService;
        $this->pdo = $dbHelper->getPdo();
        $this->rateLimiter = $rateLimiter;
        $this->exceptionHandler = $exceptionHandler;
    }    

    public function login(Request $request, Response $response)
    {
        try {
            // Rewind the request body stream in case it was consumed
            $request->getBody()->rewind();
            
            // Use getParsedBody() for consistency with other endpoints
            $data = $request->getParsedBody();
            
            if (!is_array($data)) {
                $this->logger->error("Parsed body is not an array or is null in login.");
                return $this->jsonResponse($response, ["error" => "Invalid JSON input"], 400);
            }

            $this->logger->debug("Parsed request data in login: " . print_r($data, true));

            if (!isset($data['email']) || !isset($data['password'])) {
                $this->logger->warning("Missing required fields in login");
                return $this->jsonResponse($response, ["error" => "Email and password are required"], 400);
            }

            // Rate Limiting Logic
            $email = $data['email'];
            $ipAddress = $request->getServerParams()['REMOTE_ADDR'] ?? 'UNKNOWN';

        
            if ($this->rateLimiter->isRateLimited($email, $ipAddress, 'login')) {
                $this->logger->warning("Rate limit exceeded for login", ['email' => $email, 'ip' => $ipAddress]);
                return $this->jsonResponse($response, ["error" => "Too many login attempts. Please try again later."], 429);
            }

            $result = $this->authService->login($data);
            $this->logger->info('User login successful', ['email' => $data['email']]);
            
            // Set JWT token as a secure HttpOnly cookie
            setcookie('jwt', $result['token'], [
                'expires'  => time() + 3600,
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            // Set refresh token as a secure HttpOnly cookie with longer expiration
            setcookie('refresh_token', $result['refresh_token'], [
                'expires'  => time() + 604800,
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            // Return success message without exposing tokens in the response body
            return $this->jsonResponse($response, [
                "message" => "Login successful",
                "user_id" => $result['user_id'] ?? null,
                "name" => $result['name'] ?? null
            ]);
            
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Authentication failed"], 401);
        }
    }

    public function register(Request $request, Response $response)
    {
        try {
            // Use getParsedBody() since the parsed body was set in index.php
            $data = $request->getParsedBody();
            
            if (!is_array($data)) {
                $this->logger->error("Parsed body is not an array or is null.");
                return $this->jsonResponse($response, ["error" => "Invalid JSON input"], 400);
            }

            $this->logger->debug("Parsed request data in register: " . print_r($data, true));

            $requiredFields = ['name', 'surname', 'email', 'password'];
            $missingFields = array_diff($requiredFields, array_keys($data));

            if (!empty($missingFields)) {
                $this->logger->warning("Missing required fields in register: " . implode(', ', $missingFields));
                return $this->jsonResponse($response, ["error" => "Missing fields: " . implode(', ', $missingFields)], 400);
            }

            $result = $this->authService->register($data);
            $this->logger->info('User registration attempt', ['data' => $data]);

            return $this->jsonResponse($response, $result);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Registration failed"], 500);
        }
    }

    public function refresh(Request $request, Response $response)
    {
        try {
            // Try to get refresh token from cookie first
            $refreshToken = $_COOKIE['refresh_token'] ?? null;
            
            // If not in cookie, try to get from request body
            if (!$refreshToken) {
                $request->getBody()->rewind();
                $data = $request->getParsedBody();
                $refreshToken = $data['refresh_token'] ?? null;
            }
            
            if (!$refreshToken) {
                $this->logger->warning('Refresh token missing');
                return $this->jsonResponse($response, ["error" => "Refresh token is required"], 400);
            }
            
            $result = $this->authService->refresh(['refresh_token' => $refreshToken]);
            $this->logger->info('Token refreshed successfully');
            
            // Set the new JWT token as a cookie
            setcookie('jwt', $result['token'], [
                'expires'  => time() + 3600,
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            return $this->jsonResponse($response, ["message" => "Token refreshed successfully"]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Token refresh failed"], 401);
        }
    }

    public function logout(Request $request, Response $response)
    {
        try {
            // Clear both JWT and refresh token cookies
            setcookie('jwt', '', [
                'expires'  => time() - 3600, // Expire in the past
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            setcookie('refresh_token', '', [
                'expires'  => time() - 3600, // Expire in the past
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            // Log the logout action
            $this->logger->info('User logged out successfully');
            
            // Call the service logout method if needed (e.g., to revoke tokens server-side)
            $this->authService->logout([]);
            
            return $this->jsonResponse($response, ["message" => "Logout successful"]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Logout failed"], 500);
        }
    }

    /**
     * Get authenticated user details
     * 
     * This endpoint assumes AuthMiddleware is applied to the route.
     * For protected routes, use AuthMiddleware with required=true.
     */
    public function userDetails(Request $request, Response $response): Response
    {
        try {
            $user = $request->getAttribute('user');
            
            if (!$user) {
                $this->logger->error("User not authenticated");
                return $this->jsonResponse($response->withStatus(401), ['error' => 'Authentication required']);
            }
            
            // Remove sensitive fields
            $userDetails = array_diff_key($user, array_flip(['password_hash']));
            
            $this->logger->info("User details retrieved successfully", ['user_id' => $user['id']]);
            return $this->jsonResponse($response, ['user' => $userDetails]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Failed to get user details"], 500);
        }
    }

    public function resetPasswordRequest(Request $request, Response $response)
    {
        try {
            $request->getBody()->rewind();
            $data = $request->getParsedBody();
            
            if (!is_array($data)) {
                $this->logger->error("Invalid JSON input for password reset request");
                return $this->jsonResponse($response, ["error" => "Invalid JSON input"], 400);
            }
            
            if (!isset($data['email'])) {
                $this->logger->warning("Missing email in password reset request");
                return $this->jsonResponse($response, ["error" => "Email is required"], 400);
            }
            
            $result = $this->authService->resetPasswordRequest($data);
            $this->logger->info("Password reset requested", ['email' => $data['email']]);
            return $this->jsonResponse($response, ["message" => "Password reset email sent"]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Password reset request failed"], 500);
        }
    }

    public function resetPassword(Request $request, Response $response)
    {
        try {
            $request->getBody()->rewind();
            $data = $request->getParsedBody();
            
            if (!is_array($data)) {
                $this->logger->error("Invalid JSON input for password reset");
                return $this->jsonResponse($response, ["error" => "Invalid JSON input"], 400);
            }
            
            // Validate required fields
            $requiredFields = ['token', 'password', 'confirm_password'];
            $missingFields = array_diff($requiredFields, array_keys($data));
            
            if (!empty($missingFields)) {
                $this->logger->warning("Missing fields in password reset", ['missing' => $missingFields]);
                return $this->jsonResponse($response, [
                    "error" => "Missing required fields: " . implode(', ', $missingFields)
                ], 400);
            }
            
            // Check if passwords match
            if ($data['password'] !== $data['confirm_password']) {
                $this->logger->warning("Password mismatch in reset");
                return $this->jsonResponse($response, ["error" => "Passwords do not match"], 400);
            }
            
            $result = $this->authService->resetPassword($data);
            $this->logger->info("Password reset completed successfully");
            return $this->jsonResponse($response, ["message" => "Password has been reset successfully"]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Password reset failed"], 500);
        }
    }
}
=== App/Controllers/README.md ===
# Controller Audit Logging Guide

## Overview
This guide explains how to properly log audit events directly from controllers using the `AuditService`. The `AuditTrailMiddleware` is now deprecated and controllers should handle their own audit logging.

## Basic Usage

```php
// Inject AuditService in your controller
private AuditService $auditService;

public function __construct(AuditService $auditService) 
{
    $this->auditService = $auditService;
}

// Example usage in a controller method
public function login(Request $request)
{
    // Process login
    $success = $this->authService->authenticate($request->email, $request->password);
    
    if ($success) {
        // Log successful login
        $this->auditService->logAuthEvent(
            $user->id,
            'login',
            ['device' => $request->userAgent()]
        );
        
        return $this->response->json(['success' => true]);
    } else {
        // Log failed login attempt
        $this->auditService->logAuthEvent(
            0,  // No user ID for failed login
            'failed_login',
            ['email' => $request->email]
        );
        
        return $this->response->json(['error' => 'Invalid credentials'], 401);
    }
}
```

## Common Audit Scenarios

### Authentication Events
```php
// Login
$this->auditService->logAuthEvent($userId, 'login', $context);

// Logout
$this->auditService->logAuthEvent($userId, 'logout', $context);

// Password reset
$this->auditService->logAuthEvent($userId, 'password_reset', $context);
```

### User Actions
```php
// Create user
$this->auditService->logUserAction(
    $adminId,
    'create',
    'user',
    $newUserId,
    ['user_data' => $userData]
);

// Update user
$this->auditService->logUserAction(
    $userId,
    'update',
    'user',
    $userId,
    [
        'before' => $oldData,
        'after' => $newData
    ]
);

// Delete user
$this->auditService->logUserAction($adminId, 'delete', 'user', $deletedUserId);
```

### Booking Events
```php
// Create booking
$this->auditService->logBookingEvent(
    $bookingId,
    'created',
    $userId,
    ['amount' => $amount, 'details' => $bookingDetails]
);

// Update booking
$this->auditService->logBookingEvent(
    $bookingId,
    'updated',
    $userId,
    ['changes' => $changes]
);

// Cancel booking
$this->auditService->logBookingEvent(
    $bookingId,
    'cancelled',
    $userId,
    ['reason' => $reason]
);
```

### API Requests
```php
// In API controllers, after processing
$this->auditService->logApiRequest(
    '/api/v1/resource',
    'POST',
    $request->all(),
    $responseData,
    $statusCode,
    $userId
);
```

### Security Events
```php
// Failed login attempts
$this->auditService->logSecurityEvent(
    'failed_login',
    'Multiple failed login attempts',
    ['attempts' => $attempts, 'email' => $email],
    null
);

// Permission denied
$this->auditService->logSecurityEvent(
    'permission_denied',
    'User attempted to access restricted resource',
    ['resource' => $resource],
    $userId
);
```

## Best Practices

1. Always log at the outcome of an operation, not before it happens
2. Include relevant context but avoid sensitive information
3. Use the appropriate helper method for the type of action
4. For custom events, use the generic `logEvent()` method
5. Keep log messages concise and action-oriented
=== App/Controllers/SignatureController.php ===
<?php

namespace App\Controllers;

use App\Services\SignatureService;
use App\Services\AuditService;
use App\Helpers\TokenValidator;
use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

/**
 * Signature Controller
 *
 * Handles the management of user signatures, including uploading,
 * verifying, and retrieving signatures for documents.
 */
class SignatureController extends Controller
{
    private SignatureService $signatureService;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;
    private AuditService $auditService;

    public function __construct(
        LoggerInterface $logger,
        SignatureService $signatureService,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->signatureService = $signatureService;
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    /**
     * Upload a signature.
     *
     * @param array $data The uploaded signature file and associated metadata.
     * @return array Response indicating success or failure.
     */
    public function uploadSignature(array $data): array
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return ['status' => 'error', 'message' => 'Unauthorized access', 'code' => 401];
            }

            $rules = [
                'user_id' => 'required|integer',
                'file' => 'required|file|mimes:png,jpg,jpeg|max:2048', // Max 2MB
            ];

            $this->validator->validate($data, $rules);

            $signaturePath = $this->signatureService->uploadSignature($data['user_id'], $data['file']);
            
            // Log the signature upload event
            $this->auditService->logEvent(
                'signature_uploaded',
                "Signature uploaded successfully",
                ['user_id' => $data['user_id']],
                $user->id,
                null,
                'document'
            );
            
            return ['status' => 'success', 'message' => 'Signature uploaded successfully', 'data' => $signaturePath];
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ['status' => 'error', 'message' => 'Failed to upload signature', 'code' => 500];
        }
    }

    /**
     * Verify a signature.
     *
     * @param int $userId The ID of the user whose signature is to be verified.
     * @param string $documentHash The hash of the document to verify against the signature.
     * @return array Verification result.
     */
    public function verifySignature(int $userId, string $documentHash): array
    {
        try {
            $isValid = $this->signatureService->verifySignature($userId, $documentHash);
            
            // Log the signature verification attempt
            $this->auditService->logEvent(
                'signature_verified',
                "Signature verification " . ($isValid ? "successful" : "failed"),
                [
                    'user_id' => $userId,
                    'document_hash' => substr($documentHash, 0, 10) . '...',
                    'result' => $isValid ? 'valid' : 'invalid'
                ],
                null, // No authenticated user (system action)
                null,
                'document'
            );

            if ($isValid) {
                return ['status' => 'success', 'message' => 'Signature verified successfully'];
            }

            return ['status' => 'error', 'message' => 'Signature verification failed', 'code' => 400];
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ['status' => 'error', 'message' => 'Failed to verify signature', 'code' => 500];
        }
    }

    /**
     * Retrieve a user's signature.
     *
     * @param int $userId The ID of the user.
     * @return array Response containing the signature path or error message.
     */
    public function getSignature(int $userId): array
    {
        try {
            $requestingUser = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$requestingUser) {
                return ['status' => 'error', 'message' => 'Unauthorized access', 'code' => 401];
            }
            
            $signaturePath = $this->signatureService->getSignature($userId);
            
            // Log the signature retrieval
            $this->auditService->logEvent(
                'signature_retrieved',
                "Signature retrieved " . ($signaturePath ? "successfully" : "failed - not found"),
                [
                    'user_id' => $userId,
                    'requested_by' => $requestingUser->id
                ],
                $requestingUser->id,
                null,
                'document'
            );

            if ($signaturePath) {
                return ['status' => 'success', 'message' => 'Signature retrieved successfully', 'data' => $signaturePath];
            }

            return ['status' => 'error', 'message' => 'Signature not found', 'code' => 404];
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ['status' => 'error', 'message' => 'Failed to retrieve signature', 'code' => 500];
        }
    }
}
=== App/Controllers/DashboardController.php ===
<?php

namespace App\Controllers;

use App\Models\Booking;
use App\Models\Payment;
use App\Models\Notification;
use App\Models\User;
use App\Services\AuditService;
use App\Helpers\ExceptionHandler;
use Illuminate\Support\Facades\Cache;
use Psr\Log\LoggerInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

class DashboardController extends Controller
{
    private BookingService $bookingService;
    private StatisticsService $statisticsService;
    private NotificationService $notificationService;
    private UserService $userService;
    private AuditService $auditService;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        BookingService $bookingService,
        StatisticsService $statisticsService,
        NotificationService $notificationService,
        UserService $userService,
        AuditService $auditService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->bookingService = $bookingService;
        $this->statisticsService = $statisticsService;
        $this->notificationService = $notificationService;
        $this->userService = $userService;
        $this->auditService = $auditService;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Render user dashboard view.
     */
    public function userDashboard()
    {
        try {
            // Assume session_start() is already called.
            $user = (object)['id' => $_SESSION['user_id'] ?? null]; // Replace with native session retrieval
            // ...existing code for eager loading if needed...
            $statistics = Cache::remember('user_dashboard_' . $user->id, 60, function () use ($user) {
                return [
                    'total_bookings'     => Booking::where('user_id', $user->id)->count(),
                    'completed_bookings' => Booking::where('user_id', $user->id)->where('status', 'completed')->count(),
                    'total_payments'     => Payment::where('user_id', $user->id)->sum('amount'),
                ];
            });
            
            // Log dashboard access
            $this->auditService->logEvent(
                'dashboard_accessed',
                "User accessed their dashboard",
                ['user_id' => $user->id],
                $user->id,
                null,
                'user'
            );
            
            view('dashboard/user_dashboard', ['user' => $user, 'statistics' => $statistics]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    /**
     * Fetch user bookings.
     */
    public function getUserBookings(): void
    {
        try {
            $userId = $_SESSION['user_id'] ?? null;
            $bookings = Booking::where('user_id', $userId)->get();
            
            // Log bookings fetch
            $this->auditService->logEvent(
                'bookings_fetched',
                "User fetched their bookings",
                ['user_id' => $userId],
                $userId,
                null,
                'booking'
            );
            
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Bookings fetched',
                'data'    => ['bookings' => $bookings]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    /**
     * Fetch dashboard statistics.
     */
    public function fetchStatistics(): void
    {
        try {
            $userId = $_SESSION['user_id'] ?? null;
            
            $stats = Cache::remember('dashboard_statistics', 60, function () {
                return [
                    'total_bookings'     => Booking::count(),
                    'completed_bookings' => Booking::where('status', 'completed')->count(),
                    'total_revenue'      => Payment::sum('amount')
                ];
            });
            
            // Log statistics fetch
            $this->auditService->logEvent(
                'statistics_fetched',
                "User fetched dashboard statistics",
                ['user_id' => $userId],
                $userId,
                null,
                'user'
            );
            
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Statistics fetched',
                'data'    => $stats
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    /**
     * Fetch user notifications.
     */
    public function fetchNotifications(): void
    {
        try {
            $userId = $_SESSION['user_id'] ?? null;
            
            $notifications = Notification::where('user_id', $userId)
                ->latest()
                ->get();
                
            // Log notifications fetch
            $this->auditService->logEvent(
                'notifications_fetched',
                "User fetched their notifications",
                ['user_id' => $userId],
                $userId,
                null,
                'notification'
            );
            
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Notifications fetched',
                'data'    => ['notifications' => $notifications]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    /**
     * Fetch user profile.
     */
    public function fetchUserProfile(): void
    {
        try {
            $userId = $_SESSION['user_id'] ?? null;
            $profile = User::findOrFail($userId);
            
            // Log profile fetch
            $this->auditService->logEvent(
                'profile_fetched',
                "User fetched their profile",
                ['user_id' => $userId],
                $userId,
                null,
                'user'
            );
            
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'User profile fetched',
                'data'    => ['profile' => $profile]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }
}
=== App/Controllers/update_catch.sh ===
#!/bin/bash

# Define the ExceptionHandler include statement
EXCEPTION_HANDLER_INCLUDE="require_once '/../Helpers/ExceptionHandler.php';"

# Define the output file for constructor exports
CONSTRUCTS_EXPORT="constructs_export.txt"

# Clear the export file before starting
> "$CONSTRUCTS_EXPORT"

# Find all PHP files and process them
find . -type f -name "*.php" | while read -r file; do
    echo "Processing: $file"

    # Check if the file contains a try-catch block
    if grep -q "try\s*{" "$file"; then
        # Replace all try-catch blocks with ExceptionHandler usage
        sed -i -E 's|try\s*\{([^}]*)\}\s*catch\s*\((Exception\s+\$\w+)\)\s*\{([^}]*)\}|try {\1} catch (\2) {\n    ExceptionHandler::handle(\2);\n}|g' "$file"
        
        echo "Updated try-catch blocks in: $file"
    fi

    # Check if the ExceptionHandler is already included
    if ! grep -q "require_once 'path/to/ExceptionHandler.php';" "$file"; then
        # Add ExceptionHandler inclusion at the top of the file
        sed -i "1s|^|$EXCEPTION_HANDLER_INCLUDE\n|" "$file"
        echo "Added ExceptionHandler inclusion to: $file"
    fi

    # Extract and export all constructor methods
    if grep -q "function __construct" "$file"; then
        echo "Extracting constructor from: $file"
        echo -e "\n--- Constructor from $file ---" >> "$CONSTRUCTS_EXPORT"
        awk '/function __construct/,/}/{print}' "$file" >> "$CONSTRUCTS_EXPORT"
    fi
done

echo "✅ All files processed. Constructor exports saved to $CONSTRUCTS_EXPORT."
=== App/Controllers/AdminDashboardController.php ===
<?php

namespace App\Controllers;

use App\Models\User;
use App\Models\Booking;
use App\Models\Payment;
use Illuminate\Support\Facades\Cache;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use App\Services\AuditService;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

class AdminDashboardController extends Controller
{
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;
    private AuditService $auditService;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    public function index(): void
    {
        try {
            $metrics = Cache::remember('dashboard_metrics', 60, function () {
                $totalRevenue = Payment::where('status', 'completed')->sum('amount');
                $totalRefunds = Payment::where('status', 'completed')->where('type', 'refund')->sum('amount');
                return [
                    'total_users'        => User::count(),
                    'active_users'       => User::where('active', true)->count(),
                    'total_bookings'     => Booking::count(),
                    'completed_bookings' => Booking::where('status', 'completed')->count(),
                    'canceled_bookings'  => Booking::where('status', 'canceled')->count(),
                    'total_revenue'      => $totalRevenue,
                    'total_refunds'      => $totalRefunds,
                    'net_revenue'        => $totalRevenue - $totalRefunds,
                ];
            });
            $recentBookings = Booking::with('user')->latest()->limit(5)->get();

            // Log this dashboard view in audit logs
            $this->auditService->logEvent(
                'admin_dashboard_viewed',
                'Admin dashboard viewed',
                ['admin_id' => $_SESSION['user_id'] ?? 'unknown'],
                $_SESSION['user_id'] ?? null,
                null,
                'admin'
            );

            extract(compact('metrics', 'recentBookings'));
            include BASE_PATH . '/public/views/admin/dashboard.php';
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    public function getDashboardData(): void
    {
        try {
            requireAuth(); // ensure admin authentication is in place
            
            $metrics = Cache::remember('dashboard_metrics', 60, function () {
                $totalRevenue = Payment::where('status', 'completed')->sum('amount');
                $totalRefunds = Payment::where('status', 'completed')->where('type', 'refund')->sum('amount');
                return [
                    'total_users'        => User::count(),
                    'active_users'       => User::where('active', true)->count(),
                    'total_bookings'     => Booking::count(),
                    'completed_bookings' => Booking::where('status', 'completed')->count(),
                    'canceled_bookings'  => Booking::where('status', 'canceled')->count(),
                    'total_revenue'      => $totalRevenue,
                    'total_refunds'      => $totalRefunds,
                    'net_revenue'        => $totalRevenue - $totalRefunds,
                ];
            });
            $recentBookings = Booking::with('user')->latest()->limit(5)->get();

            // Log this API request in audit logs
            $this->auditService->logEvent(
                'admin_dashboard_data_api',
                'Admin dashboard data API requested',
                ['admin_id' => $_SESSION['user_id'] ?? 'unknown'],
                $_SESSION['user_id'] ?? null,
                null,
                'admin'
            );

            header('Content-Type: application/json');
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Dashboard data fetched',
                'data'    => [
                    'metrics'         => $metrics,
                    'recent_bookings' => $recentBookings,
                ]
            ]);
            exit;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }
}
=== App/Controllers/PaymentController.php ===
<?php

namespace App\Controllers;

use App\Models\Payment;
use App\Models\RefundLog;
use App\Models\TransactionLog;
use App\Models\InstallmentPlan;
use App\Services\AuditService;
use App\Helpers\TokenValidator;
use App\Helpers\ExceptionHandler;
use App\Helpers\DatabaseHelper;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Log\LoggerInterface;

/**
 * Payment Controller
 *
 * Handles payment processing, refunds, installment payments, and user transactions.
 */
class PaymentController extends Controller
{
    private PaymentService $paymentService;
    private Validator $validator;
    private NotificationService $notificationService;
    private AuditService $auditService;
    private ResponseFactoryInterface $responseFactory;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        PaymentService $paymentService,
        Validator $validator,
        NotificationService $notificationService,
        AuditService $auditService,
        ResponseFactoryInterface $responseFactory,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->paymentService = $paymentService;
        $this->validator = $validator;
        $this->notificationService = $notificationService;
        $this->auditService = $auditService;
        $this->responseFactory = $responseFactory;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Create standardized PSR-7 JSON response
     */
    protected function jsonResponse(array $data, int $status = 200): ResponseInterface
    {
        $response = $this->responseFactory->createResponse($status);
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    /**
     * Process a payment.
     */
    public function processPayment(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $data = $this->validateRequest($_POST, [
                'booking_id'       => 'required|integer',
                'amount'           => 'required|numeric|min:0.01',
                'payment_method_id' => 'required|integer',
            ]);
            
            $payment = Payment::create([
                'booking_id'     => $data['booking_id'],
                'user_id'        => $user->id,
                'amount'         => $data['amount'],
                'payment_method' => $data['payment_method_id'],
                'status'         => 'completed'
            ]);
            
            // Update related booking status via Eloquent relationship
            $payment->booking()->update(['status' => 'paid']);
            
            // Log the payment in the secure audit logs
            $this->auditService->logEvent(
                'payment_processed',
                "Payment of {$data['amount']} processed for booking #{$data['booking_id']}",
                [
                    'payment_id' => $payment->id,
                    'booking_id' => $data['booking_id'],
                    'user_id' => $user->id,
                    'amount' => $data['amount'],
                    'payment_method' => $data['payment_method_id']
                ],
                $user->id,
                $data['booking_id'],
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Payment processed',
                'data'    => ['payment' => $payment]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Payment processing failed'
            ], 500);
        }
    }

    /**
     * Refund a payment.
     */
    public function refundPayment(): ResponseInterface
    {
        try {
            $admin = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$admin || !$admin->isAdmin()) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized - admin rights required'
                ], 401);
            }
            
            $data = $this->validateRequest($_POST, [
                'transaction_id' => 'required|integer',
                'amount'         => 'required|numeric|min:0.01',
            ]);
            
            // Get the original transaction
            $transaction = TransactionLog::findOrFail($data['transaction_id']);
            
            $refund = RefundLog::create([
                'transaction_id' => $data['transaction_id'],
                'amount'         => $data['amount'],
                'status'         => 'processed'
            ]);
            
            // Log the refund in the secure audit logs
            $this->auditService->logEvent(
                'refund_processed',
                "Refund of {$data['amount']} processed for transaction #{$data['transaction_id']}",
                [
                    'refund_id' => $refund->id,
                    'transaction_id' => $data['transaction_id'],
                    'booking_id' => $transaction->booking_id,
                    'user_id' => $transaction->user_id,
                    'admin_id' => $admin->id,
                    'amount' => $data['amount']
                ],
                $admin->id,
                $transaction->booking_id,
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Refund processed',
                'data'    => ['refund' => $refund]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Refund processing failed'
            ], 500);
        }
    }

    /**
     * Set up installment payments.
     */
    public function setupInstallment(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $data = $this->validateRequest($_POST, [
                'total_amount'      => 'required|numeric|min:0.01',
                'installments'      => 'required|integer|min:2',
                'payment_method_id' => 'required|integer',
                'booking_id'        => 'required|integer',
            ]);
            
            $plan = InstallmentPlan::create([
                'user_id'        => $user->id,
                'booking_id'     => $data['booking_id'],
                'total_amount'   => $data['total_amount'],
                'installments'   => $data['installments'],
                'payment_method' => $data['payment_method_id'],
            ]);
            
            // Log the installment plan creation
            $this->auditService->logEvent(
                'installment_plan_created',
                "Installment plan created for user #{$user->id} with {$data['installments']} installments",
                [
                    'plan_id' => $plan->id,
                    'user_id' => $user->id,
                    'booking_id' => $data['booking_id'],
                    'total_amount' => $data['total_amount'],
                    'installments' => $data['installments']
                ],
                $user->id,
                $data['booking_id'],
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Installment plan created',
                'data'    => ['installment_plan' => $plan]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Installment plan setup failed'
            ], 500);
        }
    }

    /**
     * Fetch all user transactions.
     */
    public function getUserTransactions(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $transactions = TransactionLog::with(['payment', 'booking'])
                ->where('user_id', $user->id)
                ->latest()
                ->get();
            
            // Log the transaction view activity
            $this->auditService->logEvent(
                'transactions_viewed',
                "User viewed their transaction history",
                ['user_id' => $user->id],
                $user->id,
                null,
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Transactions fetched',
                'data'    => ['transactions' => $transactions]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to fetch user transactions'
            ], 500);
        }
    }

    /**
     * Fetch payment details.
     */
    public function getPaymentDetails(int $transactionId): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $details = TransactionLog::findOrFail($transactionId);
            
            // Verify the user owns this transaction or is an admin
            if ($details->user_id != $user->id && !$user->isAdmin()) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'You do not have permission to view this transaction'
                ], 403);
            }
            
            // Log the access to payment details
            $this->auditService->logEvent(
                'payment_details_viewed',
                "Payment details accessed for transaction #{$transactionId}",
                [
                    'transaction_id' => $transactionId,
                    'user_id' => $user->id,
                    'is_admin' => $user->isAdmin() ? 'yes' : 'no'
                ],
                $user->id,
                $details->booking_id ?? null,
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Payment details fetched',
                'data'    => ['details' => $details]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to fetch payment details'
            ], 500);
        }
    }

    /**
     * Process payment for an installment.
     */
    public function processInstallmentPayment(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $data = $this->validateRequest($_POST, [
                'installment_id'    => 'required|integer',
                'payment_method_id' => 'required|integer',
            ]);
            
            // Get the installment details using DatabaseHelper
            $installment = DatabaseHelper::select(
                "SELECT * FROM installments WHERE id = ? AND user_id = ?",
                [(int)$data['installment_id'], $user->id],
                false // Using application database
            );
            
            if (empty($installment)) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Installment not found or does not belong to you'
                ], 404);
            }
            
            $installmentData = $installment[0];
            
            // Process payment for this specific installment
            $payment = Payment::create([
                'user_id'        => $user->id,
                'booking_id'     => $installmentData['booking_id'],
                'installment_id' => $data['installment_id'],
                'amount'         => $installmentData['amount'],
                'payment_method' => $data['payment_method_id'],
                'status'         => 'completed',
            ]);
            
            // Update installment status
            DatabaseHelper::update(
                "installments",
                ["status" => "paid", "paid_at" => date('Y-m-d H:i:s')],
                ["id" => (int)$data['installment_id']],
                false // Using application database
            );
            
            // Log the payment in audit logs
            $this->auditService->logEvent(
                'installment_payment_processed',
                "Installment payment processed",
                [
                    'user_id' => $user->id,
                    'installment_id' => $data['installment_id'],
                    'payment_id' => $payment->id,
                    'amount' => $installmentData['amount']
                ],
                $user->id,
                $installmentData['booking_id'],
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Installment payment processed successfully',
                'data'    => ['payment' => $payment]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to process installment payment'
            ], 500);
        }
    }

    /**
     * Add a payment method.
     */
    public function addPaymentMethod(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $data = $this->validateRequest($_POST, [
                'type'        => 'required|string',
                'card_last4'  => 'required_if:type,credit_card|numeric',
                'card_brand'  => 'required_if:type,credit_card|string',
                'expiry_date' => 'required_if:type,credit_card|string',
                'is_default'  => 'nullable|boolean',
            ]);
            
            // Add payment method using DatabaseHelper for secure storage
            $paymentMethodId = DatabaseHelper::insert(
                "payment_methods",
                [
                    "user_id" => $user->id,
                    "type" => $data['type'],
                    "card_last4" => $data['card_last4'] ?? null,
                    "card_brand" => $data['card_brand'] ?? null,
                    "expiry_date" => $data['expiry_date'] ?? null,
                    "is_default" => $data['is_default'] ?? false,
                    "created_at" => date('Y-m-d H:i:s')
                ],
                true // Using secure database for payment details
            );
            
            if (!$paymentMethodId) {
                throw new \RuntimeException("Failed to add payment method");
            }
            
            // If this is set as default, update other methods to non-default
            if (!empty($data['is_default']) && $data['is_default']) {
                DatabaseHelper::execute(
                    "UPDATE payment_methods SET is_default = 0 WHERE user_id = ? AND id != ?",
                    [$user->id, $paymentMethodId],
                    true // Using secure database
                );
            }
            
            // Get the newly created payment method
            $paymentMethod = DatabaseHelper::select(
                "SELECT id, type, card_brand, card_last4, expiry_date, is_default 
                 FROM payment_methods 
                 WHERE id = ?",
                [$paymentMethodId],
                true // Using secure database
            )[0];
            
            // Log in audit logs
            $this->auditService->logEvent(
                'payment_method_added',
                "User added a payment method",
                [
                    'user_id' => $user->id,
                    'payment_method_id' => $paymentMethodId,
                    'type' => $data['type']
                ],
                $user->id,
                null,
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Payment method added successfully',
                'data'    => ['payment_method' => $paymentMethod]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to add payment method'
            ], 500);
        }
    }
    
    /**
     * Get all payment methods for a user.
     */
    public function getUserPaymentMethods(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            // Fetch payment methods using DatabaseHelper from secure database
            $paymentMethods = DatabaseHelper::select(
                "SELECT id, type, card_brand, card_last4, expiry_date, is_default 
                 FROM payment_methods 
                 WHERE user_id = ? AND deleted_at IS NULL",
                [$user->id],
                true // Using secure database
            );
            
            // Log in audit logs
            $this->auditService->logEvent(
                'payment_methods_viewed',
                "User viewed their payment methods",
                ['user_id' => $user->id],
                $user->id,
                null,
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Payment methods retrieved successfully',
                'data'    => ['payment_methods' => $paymentMethods]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to retrieve payment methods'
            ], 500);
        }
    }
}
=== App/Controllers/Controller.php ===
<?php

namespace App\Controllers;

use Exception;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use Psr\Http\Message\ResponseInterface as Response;

/**
 * Base Controller - Provides shared methods for all controllers.
 */
class Controller
{
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(LoggerInterface $logger, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * ✅ Standard JSON Response
     */
    protected function jsonResponse(Response $response, $data, $status = 200)
    {
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json')->withStatus($status);
    }

    /**
     * ✅ Error Response
     */
    protected function errorResponse(Response $response, $message, $status = 400)
    {
        return $this->jsonResponse($response, ['error' => $message], $status);
    }

    /**
     * ✅ Handle Exceptions & Log Errors
     * This method is for backward compatibility, new controllers should use ExceptionHandler
     */
    protected function handleException(Exception $e, string $context = 'General Error'): void
    {
        if ($this->exceptionHandler) {
            $this->exceptionHandler->handleException($e);
        } else {
            // Legacy fallback behavior
            $this->logger->error("{$context}: " . $e->getMessage());
            $this->jsonResponse(['status' => 'error', 'message' => 'An error occurred.'], 500);
        }
    }

    /**
     * ✅ Input Validation Helper
     */
    protected function validateRequest(array $data, array $rules): array
    {
        $errors = [];

        foreach ($rules as $field => $rule) {
            $value = $data[$field] ?? null;

            if (strpos($rule, 'required') !== false && empty($value)) {
                $errors[$field] = "{$field} is required.";
            }

            if (strpos($rule, 'integer') !== false && !filter_var($value, FILTER_VALIDATE_INT)) {
                $errors[$field] = "{$field} must be an integer.";
            }

            if (strpos($rule, 'email') !== false && !filter_var($value, FILTER_VALIDATE_EMAIL)) {
                $errors[$field] = "{$field} must be a valid email.";
            }
        }

        if (!empty($errors)) {
            if ($this->exceptionHandler) {
                throw new \InvalidArgumentException(json_encode(['validation' => $errors]));
            } else {
                // Legacy fallback behavior
                $this->jsonResponse(['status' => 'error', 'message' => 'Validation failed', 'errors' => $errors], 422);
            }
        }

        return $data;
    }
}
=== App/Controllers/DocumentController.php ===
<?php

namespace App\Controllers;

use App\Services\DocumentService;
use App\Services\EncryptionService;
use App\Services\FileStorage;
use App\Services\Validator;
use App\Services\AuditService;
use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;
use App\Models\DocumentTemplate;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

class DocumentController extends Controller
{
    private DocumentService $documentService;
    private Validator $validator;
    private AuditService $auditService;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        DocumentService $documentService,
        Validator $validator,
        AuditService $auditService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->documentService = $documentService;
        $this->validator = $validator;
        $this->auditService = $auditService;
        $this->exceptionHandler = $exceptionHandler;
    }
    
    /**
     * Upload a document template.
     */
    public function uploadTemplate(array $data): array
    {
        try {
            $rules = [
                'name' => 'required|string|max:255',
                'file' => 'required|file|mimes:pdf,docx|max:10240', // Max 10MB
            ];

            if (!$this->validator->validate($data, $rules)) {
                return $this->jsonResponse('error', ['message' => 'Validation failed', 'errors' => $this->validator->errors()], 400);
            }

            // Store file using FileStorage service
            $filePath = FileStorage::store($data['file']);
            // Create a new template using Eloquent ORM
            $template = DocumentTemplate::create([
                'name' => $data['name'],
                'file_path' => $filePath,
            ]);
            
            // Log document creation using unified audit service
            $this->auditService->logEvent(
                'document_template_uploaded', 
                "Template uploaded successfully", 
                ['template_id' => $template->id, 'template_name' => $data['name']],
                $_SESSION['user_id'] ?? null,
                null,
                'document'
            );
            
            return $this->jsonResponse('success', ['message' => 'Template uploaded successfully', 'template_id' => $template->id], 201);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', ['message' => 'Failed to upload template'], 500);
        }
    }

    /**
     * Generate a contract for a booking.
     */
    public function generateContract(int $bookingId, int $userId): array
    {
        try {
            // Use a secure contract generation method ensuring encryption is applied
            $contractPath = $this->documentService->generateContractSecure($bookingId, $userId);
            
            // Log the contract generation using unified audit service
            $this->auditService->logEvent(
                'contract_generated',
                "Contract generated successfully",
                ['contract_type' => 'booking', 'booking_id' => $bookingId], 
                $userId,
                $bookingId,
                'document'
            );
            
            return $this->jsonResponse('success', ['message' => 'Contract generated successfully', 'contract_path' => $contractPath], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', ['message' => 'Failed to generate contract'], 500);
        }
    }

    /**
     * Upload and manage the Terms & Conditions document.
     */
    public function uploadTerms(array $data): array
    {
        try {
            $rules = [
                'file' => 'required|file|mimes:pdf|max:5120', // Max 5MB
            ];

            if (!$this->validator->validate($data, $rules)) {
                return $this->jsonResponse('error', ['message' => 'Validation failed', 'errors' => $this->validator->errors()], 400);
            }

            $path = $this->documentService->uploadTerms($data['file']);
            
            // Log using the unified audit service
            $this->auditService->logEvent(
                'terms_uploaded',
                "Terms and Conditions document uploaded",
                ['document_type' => 'terms_conditions', 'path' => $path],
                $_SESSION['user_id'] ?? null,
                null,
                'document'
            );

            return $this->jsonResponse('success', ['message' => 'T&C document uploaded successfully'], 201);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', ['message' => 'Failed to upload T&C document'], 500);
        }
    }

    /**
     * Generate an invoice for a booking.
     */
    public function generateInvoice(int $bookingId): array
    {
        try {
            $invoicePath = $this->documentService->generateInvoice($bookingId);
            
            // Log using the unified audit service
            $this->auditService->logEvent(
                'invoice_generated',
                "Invoice generated successfully",
                ['document_type' => 'invoice', 'booking_id' => $bookingId],
                $_SESSION['user_id'] ?? null,
                $bookingId,
                'document'
            );

            return $this->jsonResponse('success', ['message' => 'Invoice generated successfully', 'invoice_path' => $invoicePath], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', ['message' => 'Failed to generate invoice'], 500);
        }
    }

    /**
     * Delete a document (template or user-specific).
     */
    public function deleteDocument(int $documentId): array
    {
        try {
            $this->documentService->deleteDocument($documentId);
            
            // Log using the unified audit service
            $this->auditService->logEvent(
                'document_deleted',
                "Document deleted successfully",
                ['document_id' => $documentId],
                $_SESSION['user_id'] ?? null,
                null,
                'document'
            );

            return $this->jsonResponse('success', ['message' => 'Document deleted successfully'], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', ['message' => 'Failed to delete document'], 500);
        }
    }
}
=== App/Controllers/ReportController.php ===
<?php

namespace App\Controllers;

use App\Models\Booking;
use App\Models\Payment;
use App\Models\User;
use App\Services\AuditService;
use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;

class ReportController extends Controller
{
    private ReportService $reportService;
    private NotificationService $notificationService;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;
    private AuditService $auditService;

    public function __construct(
        LoggerInterface $logger,
        ReportService $reportService,
        NotificationService $notificationService,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->reportService = $reportService;
        $this->notificationService = $notificationService;
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    /**
     * Admin Report Dashboard View
     */
    public function index()
    {
        try {
            // Log the dashboard access in audit logs
            $this->auditService->logEvent(
                'report_dashboard_accessed',
                'Admin report dashboard accessed',
                ['user_id' => $_SESSION['user_id'] ?? 'unknown'],
                $_SESSION['user_id'] ?? null,
                null,
                'report'
            );
            
            $data = ['view' => 'admin/reports'];
            http_response_code(200);
            echo json_encode(['status' => 'success', 'message' => 'Report dashboard loaded', 'data' => $data]);
            exit;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
        }
    }

    /**
     * Generate Report for Admin using Eloquent ORM.
     */
    public function generateReport()
    {
        try {
            // Replace Request validation with native PHP validation
            $validated = $_POST; // Assumes JSON-decoded input or form data

            $start      = $validated['date_range']['start'] ?? null;
            $end        = $validated['date_range']['end'] ?? null;
            $format     = $validated['format'] ?? null;
            $reportType = $validated['report_type'] ?? null;
            $userId     = $_SESSION['user_id'] ?? null;

            if (!$start || !$end || !$format || !$reportType) {
                http_response_code(400);
                echo json_encode(['status' => 'error', 'message' => 'Missing required parameters']);
                exit;
            }

            switch ($reportType) {
                case 'bookings':
                    $data = Booking::with(['user', 'vehicle'])
                        ->whereBetween('created_at', [$start, $end])
                        ->get()
                        ->toArray();
                    break;
                case 'payments':
                    $data = Payment::whereBetween('created_at', [$start, $end])
                        ->get()
                        ->toArray();
                    break;
                case 'users':
                    $data = User::whereBetween('created_at', [$start, $end])
                        ->get()
                        ->toArray();
                    break;
                default:
                    http_response_code(400);
                    echo json_encode(['status' => 'error', 'message' => 'Invalid report type']);
                    exit;
            }
            
            // Log report generation in audit logs
            $this->auditService->logEvent(
                'report_generated',
                "Admin generated {$reportType} report",
                [
                    'report_type' => $reportType,
                    'format' => $format,
                    'date_range' => ['start' => $start, 'end' => $end]
                ],
                $userId,
                null,
                'report'
            );

            $filename = "{$reportType}_report_" . date('YmdHis');
            if ($format === 'csv') {
                // Assuming Excel::download now returns file content in native PHP
                return Excel::download(new \App\Exports\ReportExport($data), $filename . ".csv");
            } elseif ($format === 'pdf') {
                $pdf = PDF::loadView('reports.template', ['data' => $data]);
                return $pdf->download($filename . ".pdf");
            } else {
                http_response_code(400);
                echo json_encode(['status' => 'error', 'message' => 'Unsupported format']);
                exit;
            }
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
        }
    }

    /**
     * User Report Dashboard View
     */
    public function userReports()
    {
        try {
            $data = ['view' => 'user/reports'];
            http_response_code(200);
            echo json_encode(['status' => 'success', 'message' => 'User report dashboard loaded', 'data' => $data]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
        }
    }

    /**
     * Generate Report for a User using Eloquent ORM.
     */
    public function generateUserReport()
    {
        try {
            $validated = $_POST;
            $userId     = $validated['user_id'] ?? null;
            $start      = $validated['date_range']['start'] ?? null;
            $end        = $validated['date_range']['end'] ?? null;
            $format     = $validated['format'] ?? null;
            $reportType = $validated['report_type'] ?? null;

            if (!$userId || !$start || !$end || !$format || !$reportType) {
                http_response_code(400);
                echo json_encode(['status' => 'error', 'message' => 'Missing required parameters']);
                exit;
            }

            switch ($reportType) {
                case 'bookings':
                    $data = Booking::with(['user', 'vehicle'])
                        ->where('user_reference', $userId)
                        ->whereBetween('created_at', [$start, $end])
                        ->get()
                        ->toArray();
                    break;
                case 'payments':
                    $data = Payment::where('user_id', $userId)
                        ->whereBetween('created_at', [$start, $end])
                        ->get()
                        ->toArray();
                    break;
                default:
                    http_response_code(400);
                    echo json_encode(['status' => 'error', 'message' => 'Invalid report type']);
                    exit;
            }

            $filename = "user_{$userId}_{$reportType}_report_" . date('YmdHis');
            if ($format === 'csv') {
                return Excel::download(new \App\Exports\ReportExport($data), $filename . ".csv");
            } elseif ($format === 'pdf') {
                $pdf = PDF::loadView('reports.template', ['data' => $data]);
                return $pdf->download($filename . ".pdf");
            } else {
                http_response_code(400);
                echo json_encode(['status' => 'error', 'message' => 'Unsupported format']);
                exit;
            }
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
        }
    }

    /**
     * Download a Report
     */
    public function downloadReport(string $filePath): void
    {
        try {
            if (!file_exists($filePath)) {
                http_response_code(404);
                echo json_encode(['status' => 'error', 'message' => 'Report not found', 'data' => []]);
                return;
            }

            header('Content-Description: File Transfer');
            header('Content-Type: application/octet-stream');
            header('Content-Disposition: attachment; filename=' . basename($filePath));
            header('Expires: 0');
            header('Cache-Control: must-revalidate');
            header('Pragma: public');
            header('Content-Length: ' . filesize($filePath));
            readfile($filePath);
            exit;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
        }
    }
}
=== App/Controllers/ApiController.php ===
<?php

namespace App\Controllers;

use App\Helpers\ExceptionHandler;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Log\LoggerInterface;
use App\Services\AuditService;

/**
 * Base API Controller
 * 
 * Provides common functionality for all API controllers including
 * standardized JSON responses, error handling, and shared utilities.
 */
class ApiController extends Controller
{
    protected ResponseFactoryInterface $responseFactory;
    protected ExceptionHandler $exceptionHandler;
    protected AuditService $auditService;
    
    /**
     * Constructor
     */
    public function __construct(
        LoggerInterface $logger,
        ResponseFactoryInterface $responseFactory,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->responseFactory = $responseFactory;
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    /**
     * Create standardized PSR-7 JSON response
     */
    protected function jsonResponse(array $data, int $status = 200): ResponseInterface
    {
        $response = $this->responseFactory->createResponse($status);
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    /**
     * Create a success response
     */
    protected function success($message, $data = [], int $status = 200): ResponseInterface
    {
        return $this->jsonResponse([
            'status' => 'success',
            'message' => $message,
            'data' => $data
        ], $status);
    }

    /**
     * Create an error response
     */
    protected function error($message, $errors = [], int $status = 400): ResponseInterface
    {
        return $this->jsonResponse([
            'status' => 'error',
            'message' => $message,
            'errors' => $errors
        ], $status);
    }

    /**
     * Safe handling of exceptions in API controllers
     */
    protected function safeExecute(callable $action): ResponseInterface
    {
        try {
            return $action();
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // This line won't be reached if the exception handler exits
            return $this->error('An unexpected error occurred', [], 500);
        }
    }

    /**
     * Log audit event with proper context
     */
    protected function logAuditEvent(
        string $eventType,
        string $message,
        array $context = [],
        ?int $userId = null,
        ?int $resourceId = null,
        string $category = 'api'
    ): void {
        $this->auditService->logEvent(
            $eventType,
            $message,
            $context,
            $userId,
            $resourceId,
            $category
        );
    }
}
=== App/Controllers/AuditController.php ===
<?php

namespace App\Controllers;

use App\Services\AuditService;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

/**
 * AuditController - Handles viewing and retrieving audit logs.
 */
class AuditController extends Controller
{
    protected LoggerInterface $logger;
    private AuditService $auditService;
    protected ExceptionHandler $exceptionHandler;
    
    /**
     * Constructor with dependency injection
     */
    public function __construct(
        LoggerInterface $logger, 
        AuditService $auditService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->auditService = $auditService;
        $this->exceptionHandler = $exceptionHandler;
    }
    
    /**
     * ✅ Get audit logs data for admin dashboard
     */
    public function index()
    {
        try {
            // Check if user has admin role
            if (!$this->hasAdminAccess()) {
                return $this->jsonResponse('error', 'Admin access required', 403);
            }
            
            // Process filters from request
            $filters = $this->processFilters($_POST);
            
            // Get logs using the audit service
            $logs = $this->auditService->getLogs($filters);
            
            return $this->jsonResponse('success', ['logs' => $logs], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', 'Failed to retrieve audit logs', 500);
        }
    }

    /**
     * ✅ API Endpoint: Fetch logs based on filters.
     */
    public function fetchLogs()
    {
        try {
            // Check if user has admin role
            if (!$this->hasAdminAccess()) {
                return $this->jsonResponse('error', 'Admin access required', 403);
            }
            
            // Process filters from request
            $filters = $this->processFilters($_POST);
            
            // Get logs using the audit service
            $logs = $this->auditService->getLogs($filters);
            
            return $this->jsonResponse('success', ['logs' => $logs], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', 'Failed to fetch logs', 500);
        }
    }
    
    /**
     * API Endpoint: Get log details by ID
     */
    public function getLog($id)
    {
        try {
            // Check if user has admin role
            if (!$this->hasAdminAccess()) {
                return $this->jsonResponse('error', 'Admin access required', 403);
            }
            
            $log = $this->auditService->getLogById((int)$id);
            
            return $this->jsonResponse('success', ['log' => $log], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', 'Failed to retrieve log', 500);
        }
    }
    
    /**
     * Process and validate incoming filters
     */
    private function processFilters(array $rawFilters): array
    {
        $filters = [];
        
        // Category filter (unified log type)
        if (!empty($rawFilters['category'])) {
            $filters['category'] = $rawFilters['category'];
        }
        
        // Action filter (for backward compatibility)
        if (!empty($rawFilters['action'])) {
            $filters['action'] = $rawFilters['action'];
        }
        
        // User ID filter
        if (!empty($rawFilters['user_id'])) {
            $filters['user_id'] = (int)$rawFilters['user_id'];
        }
        
        // Booking ID filter
        if (!empty($rawFilters['booking_id'])) {
            $filters['booking_id'] = (int)$rawFilters['booking_id'];
        }
        
        // Date range filters
        if (!empty($rawFilters['start_date'])) {
            $filters['start_date'] = $rawFilters['start_date'];
        }
        
        if (!empty($rawFilters['end_date'])) {
            $filters['end_date'] = $rawFilters['end_date'];
        }
        
        return $filters;
    }
    
    /**
     * Check if current user has admin access
     */
    private function hasAdminAccess(): bool
    {
        // Replace with your actual authentication logic
        return isset($_SESSION['user_role']) && $_SESSION['user_role'] === 'admin';
    }
}
=== App/Models/Booking.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Booking Model
 *
 * Represents a booking and handles database interactions.
 */
class Booking extends BaseModel
{
    protected $table = 'bookings';
    protected $resourceName = 'booking';
    protected $useTimestamps = true;
    protected $useSoftDeletes = true;
    
    /**
     * Constructor
     *
     * @param DatabaseHelper|null $dbHelper
     * @param AuditService|null $auditService
     */
    public function __construct(DatabaseHelper $dbHelper = null, AuditService $auditService = null)
    {
        parent::__construct($dbHelper, $auditService);
    }
    
    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'user_id' => 'required|exists:users,id',
        'vehicle_id' => 'required|exists:vehicles,id',
        'pickup_date' => 'required|date',
        'dropoff_date' => 'required|date|after_or_equal:pickup_date',
        'status' => 'required|string|in:pending,confirmed,cancelled,completed',
    ];

    /**
     * Create a new booking
     * 
     * @param array $data
     * @return int|string
     */
    public function create(array $data): int|string
    {
        $id = parent::create($data);
        
        // Custom audit logging
        if ($id && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'booking_created', [
                'booking_id' => $id,
                'user_id' => $data['user_id'] ?? null,
                'vehicle_id' => $data['vehicle_id'] ?? null,
                'status' => $data['status'] ?? null
            ]);
        }
        
        return $id;
    }

    /**
     * Update a booking
     * 
     * @param int|string $id
     * @param array $data
     * @return bool
     */
    public function update(int|string $id, array $data): bool
    {
        $result = parent::update($id, $data);
        
        // Custom audit logging
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'booking_updated', [
                'booking_id' => $id,
                'updated_fields' => array_keys($data)
            ]);
        }
        
        return $result;
    }

    /**
     * Get active bookings.
     *
     * @return array
     */
    public function getActive(): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE status = 'confirmed'
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query);
    }

    /**
     * Get bookings by user ID.
     *
     * @param int|string $userId
     * @return array
     */
    public function getByUser(int|string $userId): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE user_id = :user_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get bookings by status
     * 
     * @param string $status
     * @return array
     */
    public function getByStatus(string $status): array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE status = :status
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':status' => $status]);
    }

    /**
     * Get bookings by date range
     * 
     * @param string $startDate
     * @param string $endDate
     * @return array
     */
    public function getByDateRange(string $startDate, string $endDate): array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE pickup_date >= :start_date AND dropoff_date <= :end_date
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " ORDER BY pickup_date ASC";
        
        return $this->dbHelper->select($query, [
            ':start_date' => $startDate,
            ':end_date' => $endDate
        ]);
    }

    /**
     * Get user data for a booking.
     *
     * @param int|string $bookingId
     * @return array|null
     */
    public function getUser(int|string $bookingId): ?array
    {
        $query = "
            SELECT u.* FROM users u
            JOIN {$this->table} b ON u.id = b.user_id
            WHERE b.id = :booking_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND b.deleted_at IS NULL AND u.deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':booking_id' => $bookingId]);
        return $result ? $result[0] : null;
    }

    /**
     * Get vehicle data for a booking.
     *
     * @param int|string $bookingId
     * @return array|null
     */
    public function getVehicle(int|string $bookingId): ?array
    {
        $query = "
            SELECT v.* FROM vehicles v
            JOIN {$this->table} b ON v.id = b.vehicle_id
            WHERE b.id = :booking_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND b.deleted_at IS NULL AND v.deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':booking_id' => $bookingId]);
        return $result ? $result[0] : null;
    }

    /**
     * Get payment data for a booking.
     *
     * @param int|string $bookingId
     * @return array|null
     */
    public function getPayment(int|string $bookingId): ?array
    {
        $query = "
            SELECT p.* FROM payments p
            WHERE p.booking_id = :booking_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND p.deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':booking_id' => $bookingId]);
        return $result ? $result[0] : null;
    }
    
    /**
     * Check if a vehicle is available during a specific date range
     *
     * @param int|string $vehicleId
     * @param string $startDate
     * @param string $endDate
     * @param int|string|null $excludeBookingId Booking ID to exclude from check (for updates)
     * @return bool
     */
    public function isVehicleAvailable(int|string $vehicleId, string $startDate, string $endDate, int|string $excludeBookingId = null): bool
    {
        $query = "
            SELECT COUNT(*) as booking_count 
            FROM {$this->table}
            WHERE vehicle_id = :vehicle_id
            AND status IN ('pending', 'confirmed')
            AND NOT (
                dropoff_date < :start_date OR pickup_date > :end_date
            )
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        if ($excludeBookingId) {
            $query .= " AND id != :exclude_id";
        }
        
        $result = $this->dbHelper->select($query, [
            ':vehicle_id' => $vehicleId,
            ':start_date' => $startDate,
            ':end_date' => $endDate,
            ':exclude_id' => $excludeBookingId
        ]);
        
        return $result[0]['booking_count'] == 0;
    }
}
=== App/Models/TransactionLog.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;
use App\Services\EncryptionService;

/**
 * TransactionLog Model
 *
 * Represents a financial transaction and handles interactions with the `transaction_logs` table.
 */
class TransactionLog extends BaseModel
{
    protected $table = 'transaction_logs';
    protected $resourceName = 'transaction_log';
    protected $useTimestamps = true; // Transaction logs use timestamps
    protected $useSoftDeletes = false; // Transaction logs don't use soft deletes

    /**
     * Create a new transaction log.
     *
     * @param array $data
     * @return int
     */
    public function create(array $data): int
    {
        // Encrypt transaction details
        $data['amount'] = EncryptionService::encrypt($data['amount']);

        return parent::create($data);
    }

    /**
     * Get transactions by user ID.
     *
     * @param int $userId
     * @return array
     */
    public function getByUserId(int $userId): array
    {
        $query = "SELECT * FROM {$this->table} WHERE user_id = :user_id ORDER BY created_at DESC";
        $transactions = $this->dbHelper->select($query, [':user_id' => $userId]);

        // Decrypt transaction details
        foreach ($transactions as &$transaction) {
            $transaction['amount'] = EncryptionService::decrypt($transaction['amount']);
        }

        return $transactions;
    }

    /**
     * Get transaction by ID.
     *
     * @param int $id
     * @return array|null
     */
    public function getById(int $id): ?array
    {
        $query = "SELECT * FROM {$this->table} WHERE id = :id";
        $transaction = $this->dbHelper->select($query, [':id' => $id]);

        if ($transaction) {
            $transaction = $transaction[0] ?? null;
            // Decrypt transaction details
            $transaction['amount'] = EncryptionService::decrypt($transaction['amount']);
        }

        return $transaction ?: null;
    }

    /**
     * Update transaction status.
     *
     * @param int $id
     * @param string $status
     * @return bool
     */
    public function updateStatus(int $id, string $status): bool
    {
        $result = parent::update($id, ['status' => $status]);

        // Log the event
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'status_update', [
                'id' => $id,
                'status' => $status
            ]);
        }

        return $result;
    }

    /**
     * Get recent transactions.
     *
     * @param int $limit
     * @return array
     */
    public function getRecent(int $limit = 10): array
    {
        $query = "SELECT * FROM {$this->table} ORDER BY created_at DESC LIMIT :limit";
        $transactions = $this->dbHelper->select($query, [':limit' => $limit]);

        // Decrypt transaction details
        foreach ($transactions as &$transaction) {
            $transaction['amount'] = EncryptionService::decrypt($transaction['amount']);
        }

        return $transactions;
    }
}
=== App/Models/Payment.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Payment Model
 *
 * Represents a payment transaction in the system.
 *
 * @property int $id Primary key
 * @property int $user_id ID of the user who made the payment
 * @property int $booking_id ID of the associated booking
 * @property float $amount Transaction amount
 * @property string $method Payment method (credit_card, PayPal, etc.)
 * @property string $status Status of the payment (pending, completed, failed)
 * @property string|null $transaction_id Unique external transaction identifier
 */
class Payment extends BaseModel
{
    protected $table = 'payments';
    protected $resourceName = 'payment';
    
    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'user_id' => 'required|exists:users,id',
        'booking_id' => 'required|exists:bookings,id',
        'amount' => 'required|numeric|min:0',
        'method' => 'required|string|in:credit_card,paypal,bank_transfer',
        'status' => 'required|string|in:pending,completed,failed',
        'transaction_id' => 'nullable|string|max:255',
    ];

    public function __construct(DatabaseHelper $dbHelper, AuditService $auditService = null)
    {
        $this->dbHelper = $dbHelper;
        $this->auditService = $auditService;
    }

    /**
     * Find a payment by ID.
     *
     * @param int $id
     * @return array|null
     */
    public function find(int $id): ?array
    {
        $query = "SELECT * FROM {$this->table} WHERE id = :id AND deleted_at IS NULL LIMIT 1";
        $result = $this->dbHelper->select($query, [':id' => $id]);
        return $result[0] ?? null; // Return first result or null
    }
    

    /**
     * Get all payments.
     *
     * @return array
     */
    public function all(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query);
    }

    /**
     * Create a new payment.
     *
     * @param array $data
     * @return int ID of the created payment
     */
    public function create(array $data): ?int
{
    $data['created_at'] = $data['updated_at'] = date('Y-m-d H:i:s');
    $paymentId = $this->dbHelper->insert($this->table, $data);
    
    if (!$paymentId) {
        return null; // Return null if insertion fails
    }

    if ($this->auditService) {
        $this->auditService->logEvent($this->resourceName, 'Created payment', [
            'payment_id' => $paymentId,
            'user_id' => $data['user_id'],
            'booking_id' => $data['booking_id'],
            'amount' => $data['amount'],
            'method' => $data['method']
        ]);
    }
    
    return (int) $paymentId; // Ensure ID is always an integer
}


    /**
     * Update a payment.
     *
     * @param int $id
     * @param array $data
     * @return bool
     */
    public function update(int $id, array $data): bool
    {
        $data['updated_at'] = date('Y-m-d H:i:s');
        $result = $this->dbHelper->update($this->table, $data, ['id' => $id, 'deleted_at IS NULL']);
        
        // Log audit if service is available and update was successful
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'Updated payment', [
                'payment_id' => $id,
                'updated_fields' => array_keys($data)
            ]);
        }
        
        return $result;
    }

    /**
     * Soft delete a payment.
     *
     * @param int $id
     * @return bool
     */
    public function delete(int $id): bool
    {
        $result = $this->dbHelper->update($this->table, ['deleted_at' => date('Y-m-d H:i:s')], ['id' => $id]);
    
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'Deleted payment', ['payment_id' => $id]);
        }
        
        return $result;
    }
    

    /**
     * Get payments by user ID.
     * Replaces scopeByUser.
     *
     * @param int $userId
     * @return array
     */
    public function getByUser(int $userId): array
    {
        $query = "SELECT * FROM {$this->table} WHERE user_id = :user_id AND deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get completed payments.
     * Replaces scopeCompleted.
     *
     * @return array
     */
    public function getCompleted(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE status = 'completed' AND deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query);
    }

    /**
     * Get payments by status.
     * Replaces scopeByStatus.
     *
     * @param string $status
     * @return array
     */
    public function getByStatus(string $status): array
    {
        $query = "SELECT * FROM {$this->table} WHERE status = :status AND deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query, [':status' => $status]);
    }

    /**
     * Get payments within a date range.
     * Replaces scopeByDateRange.
     *
     * @param string $startDate
     * @param string $endDate
     * @return array
     */
    public function getByDateRange(string $startDate, string $endDate): array
    {
        $query = "SELECT * FROM {$this->table} WHERE created_at BETWEEN :start_date AND :end_date AND deleted_at IS NULL ORDER BY created_at DESC";
        return $this->dbHelper->select($query, [':start_date' => $startDate, ':end_date' => $endDate]);
    }

    /**
     * Get user data for a payment.
     * Replaces user relationship.
     *
     * @param int $paymentId
     * @return array|null
     */
    public function getUser(int $paymentId): ?array
    {
        $query = "SELECT u.* FROM users u JOIN {$this->table} p ON u.id = p.user_id WHERE p.id = :payment_id AND p.deleted_at IS NULL";
        return $this->dbHelper->select($query, [':payment_id' => $paymentId]);
    }

    /**
     * Get booking data for a payment.
     * Replaces booking relationship.
     *
     * @param int $paymentId
     * @return array|null
     */
    public function getBooking(int $paymentId): ?array
    {
        $query = "SELECT b.* FROM bookings b JOIN {$this->table} p ON b.id = p.booking_id WHERE p.id = :payment_id AND p.deleted_at IS NULL AND b.deleted_at IS NULL";
        return $this->dbHelper->select($query, [':payment_id' => $paymentId]);
    }
}
=== App/Models/Admin.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Admin Model - Manages system administrators.
 */
class Admin extends BaseModel
{
    protected $table = 'admins';
    protected $resourceName = 'admin';
    protected $useTimestamps = true;
    protected $useSoftDeletes = true;
    
    /**
     * Constructor
     *
     * @param DatabaseHelper $dbHelper
     * @param AuditService|null $auditService
     */
    public function __construct(DatabaseHelper $dbHelper = null, AuditService $auditService = null)
    {
        parent::__construct($dbHelper, $auditService);
    }
    
    /**
     * Hash a password.
     *
     * @param string $password
     * @return string
     */
    public static function hashPassword(string $password): string
    {
        return password_hash($password, PASSWORD_BCRYPT, ['cost' => 12]);
    }
    
    /**
     * Verify password.
     *
     * @param string $plainPassword
     * @param string $hashedPassword
     * @return bool
     */
    public static function verifyPassword(string $plainPassword, string $hashedPassword): bool
    {
        return password_verify($plainPassword, $hashedPassword);
    }
    
    /**
     * Create an admin.
     * Override to handle password hashing.
     *
     * @param array $data
     * @return int|string
     */
    public function create(array $data): int|string
    {
        if (isset($data['password'])) {
            $data['password'] = self::hashPassword($data['password']);
        }
        
        $id = parent::create($data);
        
        // Add custom audit logging if needed
        if ($this->auditService) {
            $this->auditService->logEvent('admin', 'admin_created', [
                'id' => $id,
                'name' => $data['name'] ?? null,
                'email' => $data['email'] ?? null,
                'role' => $data['role'] ?? null
            ]);
        }
        
        return $id;
    }
    
    /**
     * Update an admin.
     * Override to handle password hashing.
     *
     * @param int|string $id
     * @param array $data
     * @return bool
     */
    public function update(int|string $id, array $data): bool
    {
        if (isset($data['password'])) {
            $data['password'] = self::hashPassword($data['password']);
        }
        
        $result = parent::update($id, $data);
        
        // Add custom audit logging if needed
        if ($result && $this->auditService) {
            $this->auditService->logEvent('admin', 'admin_updated', [
                'id' => $id,
                'updated_fields' => array_keys($data)
            ]);
        }
        
        return $result;
    }
    
    /**
     * Get admin by email.
     *
     * @param string $email
     * @return array|null
     */
    public function getByEmail(string $email): ?array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE email = :email
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':email' => $email]);
        return $result ? $result[0] : null;
    }
    
    /**
     * Restore a soft deleted admin.
     *
     * @param int|string $id
     * @return bool
     */
    public function restore(int|string $id): bool
    {
        if (!$this->useSoftDeletes) {
            return false;
        }
        
        $result = $this->dbHelper->update($this->table, ['deleted_at' => null], ['id' => $id]);
        
        if ($result && $this->auditService) {
            $this->auditService->logEvent('admin', 'admin_restored', [
                'admin_id' => $id
            ]);
        }
        
        return $result;
    }
    
    /**
     * Get users managed by this admin.
     *
     * @param int|string $adminId
     * @return array
     */
    public function getManagedUsers(int|string $adminId): array
    {
        $query = "
            SELECT * FROM users
            WHERE managed_by = :admin_id
        ";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $query .= " ORDER BY name ASC";
        
        return $this->dbHelper->select($query, [':admin_id' => $adminId]);
    }
    
    /**
     * Get admin permissions.
     *
     * @param int|string $adminId
     * @return array
     */
    public function getPermissions(int|string $adminId): array
    {
        $query = "
            SELECT p.* FROM permissions p
            JOIN admin_permissions ap ON p.id = ap.permission_id
            WHERE ap.admin_id = :admin_id
        ";
        
        return $this->dbHelper->select($query, [':admin_id' => $adminId]);
    }
}
=== App/Models/Notification.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Notification Model
 *
 * Represents a notification in the system.
 */
class Notification extends BaseModel
{
    protected $table = 'notifications';
    protected $resourceName = 'notification';
    protected $useTimestamps = false;  // We'll use sent_at instead of created_at
    protected $useSoftDeletes = false; // Notifications don't use soft deletes

    /**
     * Mark a notification as read.
     *
     * @param int $id
     * @return bool
     */
    public function markAsRead(int $id): bool
    {
        $result = $this->dbHelper->update($this->table, ['is_read' => 1], ['id' => $id]);
        
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'notification_read', [
                'id' => $id
            ]);
        }
        
        return $result;
    }

    /**
     * Create a new notification.
     *
     * @param array $data
     * @return int
     */
    public function create(array $data): int
    {
        // Set sent_at to now if not provided
        if (!isset($data['sent_at'])) {
            $data['sent_at'] = date('Y-m-d H:i:s');
        }
        
        // Default is_read to false if not provided
        if (!isset($data['is_read'])) {
            $data['is_read'] = 0;
        }
        
        return parent::create($data);
    }

    /**
     * Get notifications by user ID.
     *
     * @param int $userId
     * @return array
     */
    public function getByUserId(int $userId): array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE user_id = :user_id
            ORDER BY sent_at DESC
        ";
        
        $notifications = $this->dbHelper->select($query, [':user_id' => $userId]);
        return $notifications ?: [];
    }

    /**
     * Get unread notifications for a user.
     *
     * @param int $userId
     * @return array
     */
    public function getUnreadByUserId(int $userId): array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE user_id = :user_id AND is_read = 0
            ORDER BY sent_at DESC
        ";
        
        $notifications = $this->dbHelper->select($query, [':user_id' => $userId]);
        return $notifications ?: [];
    }

    /**
     * Mark all notifications as read for a user.
     *
     * @param int $userId
     * @return bool
     */
    public function markAllAsReadForUser(int $userId): bool
    {
        $result = $this->dbHelper->update($this->table, ['is_read' => 1], ['user_id' => $userId, 'is_read' => 0]);
        
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'all_notifications_read', [
                'user_id' => $userId
            ]);
        }
        
        return $result;
    }

    /**
     * Get the user associated with a notification.
     *
     * @param int $notificationId
     * @return array|null
     */
    public function getUser(int $notificationId): ?array
    {
        $notification = $this->find($notificationId);
        
        if (!$notification || !isset($notification['user_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM users WHERE id = :user_id";
        $result = $this->dbHelper->select($query, [':user_id' => $notification['user_id']]);
        return $result[0] ?? null;
    }
}
=== App/Models/PaymentMethod.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;

/**
 * PaymentMethod Model
 *
 * Represents a payment method and handles interactions with the `payment_methods` table.
 */
class PaymentMethod extends BaseModel
{
    protected $table = 'payment_methods';
    protected $resourceName = 'payment_method';
    
    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'name' => 'required|string|max:255',
        'description' => 'nullable|string',
        'is_active' => 'boolean',
        'user_id' => 'required|exists:users,id',
        'payment_type' => 'required|string|in:credit_card,paypal,bank_transfer'
    ];

    public function __construct(DatabaseHelper $dbHelper)
    {
        $this->pdo = $dbHelper->getPdo();
    }

    /**
     * Get all available payment methods.
     */
    public function getAll(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE is_active = 1";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute();
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Get payment method by ID.
     */
    public function getById(int $id): ?array
    {
        $stmt = $this->pdo->prepare("SELECT * FROM payment_methods WHERE id = :id");
        $stmt->execute([':id' => $id]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }

    /**
     * Add a new payment method.
     */
    public function create(array $data): int
    {
        $validPaymentTypes = ['credit_card', 'paypal', 'bank_transfer'];
        if (!in_array($data['payment_type'], $validPaymentTypes)) {
            throw new \InvalidArgumentException("Invalid payment type.");
        }

        return parent::create($data);
    }
    
    /**
     * Update a payment method.
     */
    public function update(int $id, array $data): bool
    {
        $setClauses = [];
        $params = [':id' => $id];

        foreach ($data as $key => $value) {
            if (in_array($key, ['name', 'description', 'is_active', 'payment_type'])) {
                $setClauses[] = "$key = :$key";
                $params[":$key"] = $value;
            }
        }

        if (empty($setClauses)) {
            return false;
        }

        $setClauses[] = "updated_at = NOW()";
        $setClause = implode(', ', $setClauses);

        $stmt = $this->pdo->prepare("
            UPDATE payment_methods 
            SET $setClause 
            WHERE id = :id
        ");
        return $stmt->execute($params);
    }
    
    /**
     * Delete a payment method.
     */
    public function delete(int $id): bool
    {
        $stmt = $this->pdo->prepare("DELETE FROM payment_methods WHERE id = :id");
        return $stmt->execute([':id' => $id]);
    }

    /**
     * Get payment methods by user ID.
     * Replaces scopeByUser.
     */
    public function getByUser(int $userId): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE user_id = :user_id
            ORDER BY created_at DESC
        ";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':user_id' => $userId]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }
    
    /**
     * Get user data for a payment method.
     * Replaces user relationship.
     */
    public function getUser(int $paymentMethodId): ?array
    {
        $query = "
            SELECT u.* FROM users u
            JOIN {$this->table} pm ON u.id = pm.user_id
            WHERE pm.id = :payment_method_id
        ";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':payment_method_id' => $paymentMethodId]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }
}
=== App/Models/Document.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Document Model
 *
 * Represents documents stored in the system and provides methods
 * for managing and querying them.
 */
class Document extends BaseModel
{
    protected $table = 'documents';
    protected $resourceName = 'document';
    protected $useSoftDeletes = false; // Document model doesn't use soft deletes

    /**
     * Create a new document record.
     *
     * @param array $data Data including name, file_path, user_id, type
     * @return int The ID of the newly created document.
     */
    public function create(array $data): int
    {
        // Add created_at if using timestamps but not provided
        if ($this->useTimestamps && !isset($data['created_at'])) {
            $data['created_at'] = date('Y-m-d H:i:s');
        }
        
        $id = parent::create($data);
        
        // Add custom audit logging if needed
        if ($this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'document_created', [
                'id' => $id,
                'name' => $data['name'] ?? null,
                'type' => $data['type'] ?? null,
                'user_id' => $data['user_id'] ?? null
            ]);
        }
        
        return $id;
    }

    /**
     * Override find to add audit logging for views.
     *
     * @param int $id
     * @return array|null
     */
    public function find(int $id): ?array
    {
        $document = parent::find($id);
        
        // Log view event if document was found
        if ($document && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'document_viewed', [
                'id' => $id,
                'name' => $document['name'] ?? 'unknown'
            ]);
        }
        
        return $document;
    }

    /**
     * Retrieve documents associated with a user.
     *
     * @param int $userId The ID of the user.
     * @return array A list of documents associated with the user.
     */
    public function getByUserId(int $userId): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE user_id = :user_id 
            ORDER BY created_at DESC
        ";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':user_id' => $userId]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Retrieve documents by type.
     *
     * @param string $type The type of document (e.g., 'contract', 'terms').
     * @return array A list of documents matching the specified type.
     */
    public function getByType(string $type): array
    {
        $query = "
            SELECT * FROM {$this->table} 
            WHERE type = :type 
            ORDER BY created_at DESC
        ";
        
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':type' => $type]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Delete a document by its ID.
     *
     * @param int $id The ID of the document to delete.
     * @return bool True on success, false otherwise.
     */
    public function delete(int $id): bool
    {
        // First, get document details for audit log
        $document = $this->find($id);
        
        if (!$document) {
            return false;
        }
        
        $result = parent::delete($id);
        
        // Add custom audit log if needed
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'document_deleted', [
                'id' => $id,
                'name' => $document['name'] ?? 'unknown',
                'type' => $document['type'] ?? null
            ]);
        }
        
        return $result;
    }
    
    /**
     * Update a document's details.
     *
     * @param int $id The ID of the document to update.
     * @param array $data The data to update.
     * @return bool True on success, false otherwise.
     */
    public function update(int $id, array $data): bool
    {
        // Filter data to only include allowed fields
        $validData = array_filter($data, function($key) {
            return in_array($key, ['name', 'file_path', 'type']);
        }, ARRAY_FILTER_USE_KEY);
        
        if (empty($validData)) {
            return false;
        }
        
        $result = parent::update($id, $validData);
        
        // Add custom audit log if needed
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'document_updated', [
                'id' => $id,
                'updated_fields' => array_keys($validData)
            ]);
        }
        
        return $result;
    }
}
=== App/Models/Vehicle.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Vehicle Model
 *
 * Represents a vehicle in the system.
 */
class Vehicle extends BaseModel
{
    protected $table = 'vehicles';
    protected $resourceName = 'vehicle';
    protected $useSoftDeletes = false; // Vehicles use hard deletes

    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'registration_number' => 'required|string|unique:vehicles,registration_number',
        'type' => 'required|string',
        'status' => 'required|in:available,unavailable,maintenance',
        'make' => 'required|string|max:255',
        'model' => 'required|string|max:255',
        'year' => 'required|integer|min:1886|max:' . PHP_INT_MAX,
    ];

    /**
     * Create a new vehicle
     * 
     * @param array $data
     * @return int
     */
    public function create(array $data): int
    {
        // Ensure status is properly managed
        if (empty($data['status'])) {
            $data['status'] = 'available';
        }

        return parent::create($data);
    }

    /**
     * Find available vehicles
     *
     * @return array
     */
    public function findAvailable(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE status = :status";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':status' => 'available']);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Find vehicles by type
     *
     * @param string $type
     * @return array
     */
    public function findByType(string $type): array
    {
        $query = "SELECT * FROM {$this->table} WHERE type = :type";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':type' => $type]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Get vehicle's bookings
     *
     * @param int $vehicleId
     * @return array
     */
    public function getBookings(int $vehicleId): array
    {
        $query = "SELECT * FROM bookings WHERE vehicle_id = :vehicle_id";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':vehicle_id' => $vehicleId]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }
    
    /**
     * Set a vehicle to maintenance status
     *
     * @param int $id
     * @param string $reason
     * @return bool
     */
    public function setToMaintenance(int $id, string $reason = ''): bool
    {
        $result = $this->update($id, ['status' => 'maintenance']);
        
        // Add custom audit logging for maintenance status
        if ($result && $this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'vehicle_maintenance', [
                'vehicle_id' => $id,
                'reason' => $reason
            ]);
        }
        
        return $result;
    }
    
    /**
     * Set a vehicle to available status
     *
     * @param int $id
     * @return bool
     */
    public function setToAvailable(int $id): bool
    {
        return $this->update($id, ['status' => 'available']);
    }
}
=== App/Models/DocumentTemplate.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use App\Traits\Auditable;

/**
 * DocumentTemplate Model
 *
 * Manages templates for documents such as contracts, invoices, and Terms & Conditions.
 */
class DocumentTemplate extends Model
{
    use SoftDeletes, Auditable;

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'name',
        'content',
        'description'
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array
     */
    protected $casts = [
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Get the validation rules for the model.
     *
     * @return array
     */
    public static function validationRules(): array
    {
        return [
            'name' => 'required|string|max:255',
            'content' => 'required|string',
            'description' => 'nullable|string'
        ];
    }
}
=== App/Models/User.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use Illuminate\Support\Facades\Hash;
use Ramsey\Uuid\Uuid;
use App\Services\AuditService;

/**
 * User Model
 * 
 * Represents a user in the system with their associated data and relationships.
 * 
 * @property string $id UUID of the user
 * @property string $name User's first name
 * @property string $surname User's last name
 * @property string $email User's email address
 * @property string $password_hash Hashed password
 * @property string $role User role (user, admin, super_admin)
 * @property string $phone Phone number
 * @property string $address Physical address
 * @property \DateTime $created_at
 * @property \DateTime $updated_at
 * @property \DateTime $deleted_at
 */
class User extends BaseModel
{
    protected $table = 'users';
    protected $primaryKey = 'id';
    protected $resourceName = 'user';
    protected $useTimestamps = true;
    protected $useSoftDeletes = true;
    protected $useUuid = true;

    protected $fillable = [
        'name',
        'surname',
        'email',
        'password_hash',
        'role',
        'phone',
        'address',
    ];

    protected $hidden = [
        'password_hash',
        'remember_token',
        'deleted_at',
    ];

    public static array $rules = [
        'name' => 'required|string|max:255',
        'surname' => 'required|string|max:255',
        'email' => 'required|email|unique:users,email',
        'password' => 'required|min:8|regex:/^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/',
        'role' => 'required|in:user,admin,super_admin',
        'phone' => 'nullable|string|max:20',
        'address' => 'nullable|string|max:255',
    ];

    /**
     * Relationships
     */

    /**
     * Get user's bookings
     * 
     * @param string $userId
     * @return array
     */
    public function getBookings(string $userId): array
    {
        $query = "SELECT * FROM bookings WHERE user_id = :user_id";
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's payments
     * 
     * @param string $userId
     * @return array
     */
    public function getPayments(string $userId): array
    {
        $query = "SELECT * FROM payments WHERE user_id = :user_id";
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's notifications
     * 
     * @param string $userId
     * @return array
     */
    public function getNotifications(string $userId): array
    {
        $query = "SELECT * FROM notifications WHERE user_id = :user_id";
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's logs
     * 
     * @param string $userId
     * @return array
     */
    public function getLogs(string $userId): array
    {
        $query = "SELECT * FROM logs WHERE user_reference = :user_id";
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's audit trails
     * 
     * @param string $userId
     * @return array
     */
    public function getAuditTrails(string $userId): array
    {
        $query = "SELECT * FROM audit_trails WHERE user_reference = :user_id";
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Get user's contracts
     * 
     * @param string $userId
     * @return array
     */
    public function getContracts(string $userId): array
    {
        $query = "SELECT * FROM contracts WHERE user_reference = :user_id";
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        $query .= " ORDER BY created_at DESC";
        
        return $this->dbHelper->select($query, [':user_id' => $userId]);
    }

    /**
     * Accessors & Helpers
     */
    
    /**
     * Get full name by combining first and last name
     * 
     * @param array $user User data
     * @return string
     */
    public static function getFullName(array $user): string
    {
        return "{$user['name']} {$user['surname']}";
    }

    /**
     * Check if user is an admin
     * 
     * @param array $user User data
     * @return bool
     */
    public static function isAdmin(array $user): bool
    {
        return in_array($user['role'], ['admin', 'super_admin']);
    }

    /**
     * Check if user is a super admin
     * 
     * @param array $user User data
     * @return bool
     */
    public static function isSuperAdmin(array $user): bool
    {
        return $user['role'] === 'super_admin';
    }

    /**
     * Check if user has a specific permission
     * 
     * @param array $user User data
     * @param string $permission
     * @return bool
     */
    public static function hasPermission(array $user, string $permission): bool
    {
        $rolePermissions = [
            'user' => ['read_own'],
            'admin' => ['read_own', 'read_all', 'write_all'],
            'super_admin' => ['read_own', 'read_all', 'write_all', 'delete_all'],
        ];

        return in_array($permission, $rolePermissions[$user['role']] ?? []);
    }

    /**
     * Password handling
     */
    
    /**
     * Hash a password
     * 
     * @param string $password
     * @return string
     */
    public static function hashPassword(string $password): string
    {
        return Hash::make($password);
    }
    
    /**
     * Verify a password
     * 
     * @param string $password
     * @param string $hash
     * @return bool
     */
    public static function verifyPassword(string $password, string $hash): bool
    {
        return Hash::check($password, $hash);
    }

    /**
     * Database operations
     */

    /**
     * Create a new user
     * 
     * @param array $data
     * @return int The ID of the created user (or UUID converted to integer if using UUID)
     */
    public function create(array $data): int
    {
        if (isset($data['password'])) {
            $data['password_hash'] = self::hashPassword($data['password']);
            unset($data['password']);
        }

        if ($this->useUuid && !isset($data['id'])) {
            $data['id'] = Uuid::uuid4()->toString();
        }

        if ($this->useTimestamps) {
            $now = date('Y-m-d H:i:s');
            $data['created_at'] = $now;
            $data['updated_at'] = $now;
        }

        $id = $this->dbHelper->insert($this->table, $data);
        
        // Log the creation if audit service is available
        if ($this->auditService) {
            $this->auditService->logEvent('user', 'created', [
                'id' => $id,
                'email' => $data['email'] ?? 'unknown'
            ]);
        }

        // Ensure we return an integer to match the parent class signature
        return is_numeric($id) ? (int)$id : crc32($id);
    }

    /**
     * Update user data
     * 
     * @param string|int $id
     * @param array $data
     * @return bool
     */
    public function update(string|int $id, array $data): bool
    {
        if (isset($data['password'])) {
            $data['password_hash'] = self::hashPassword($data['password']);
            unset($data['password']);
        }

        if ($this->useTimestamps) {
            $data['updated_at'] = date('Y-m-d H:i:s');
        }

        $conditions = ['id' => $id];
        if ($this->useSoftDeletes) {
            $conditions['deleted_at IS NULL'] = null;
        }

        $result = $this->dbHelper->update($this->table, $data, $conditions);
        
        // Log the update if audit service is available
        if ($result && $this->auditService) {
            $this->auditService->logEvent('user', 'updated', [
                'id' => $id,
                'updated_fields' => array_keys($data)
            ]);
        }

        return $result;
    }

    /**
     * Find a user by their email address
     * 
     * @param string $email
     * @return array|null
     */
    public function findByEmail(string $email): ?array
    {
        $query = "SELECT * FROM {$this->table} WHERE email = :email";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':email' => $email]);
        return $result ? $result[0] : null;
    }

    /**
     * Get active users (not deleted)
     * 
     * @return array
     */
    public function getActive(): array
    {
        $query = "SELECT * FROM {$this->table} WHERE deleted_at IS NULL";
        return $this->dbHelper->select($query);
    }

    /**
     * Get users with a specific role
     * 
     * @param string $role
     * @return array
     */
    public function getWithRole(string $role): array
    {
        $query = "SELECT * FROM {$this->table} WHERE role = :role";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        return $this->dbHelper->select($query, [':role' => $role]);
    }
}
=== App/Models/BaseModel.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;
use PDO;

/**
 * BaseModel
 * 
 * Base class for all models that use the DatabaseHelper instead of Eloquent
 */
abstract class BaseModel
{
    /**
     * @var string The table associated with the model
     */
    protected $table;
    
    /**
     * @var string The name of the resource for audit logging
     */
    protected $resourceName;
    
    /**
     * @var bool Whether the model uses timestamps
     */
    protected $useTimestamps = true;
    
    /**
     * @var bool Whether the model uses soft deletes
     */
    protected $useSoftDeletes = false;
    
    /**
     * @var bool Whether the model uses UUID as primary key
     */
    protected $useUuid = false;
    
    /**
     * @var DatabaseHelper Database helper instance
     */
    protected $dbHelper;
    
    /**
     * @var AuditService|null Audit service instance
     */
    protected $auditService;
    
    /**
     * @var PDO PDO instance
     */
    protected $pdo;

    /**
     * Constructor
     *
     * @param DatabaseHelper|null $dbHelper
     * @param AuditService|null $auditService
     */
    public function __construct(DatabaseHelper $dbHelper = null, AuditService $auditService = null)
    {
        $this->dbHelper = $dbHelper ?? new DatabaseHelper();
        $this->auditService = $auditService;
        $this->pdo = $this->dbHelper->getPdo();
    }

    /**
     * Find a record by ID
     *
     * @param int $id
     * @return array|null
     */
    public function find(int|string $id): ?array
    {
        $query = "SELECT * FROM {$this->table} WHERE id = :id";
        
        if ($this->useSoftDeletes) {
            $query .= " AND deleted_at IS NULL";
        }
        
        $result = $this->dbHelper->select($query, [':id' => $id]);
        return $result ? $result[0] : null;
    }

    /**
     * Get all records from the table
     *
     * @return array
     */
    public function all(): array
    {
        $query = "SELECT * FROM {$this->table}";
        
        if ($this->useSoftDeletes) {
            $query .= " WHERE deleted_at IS NULL";
        }
        
        return $this->dbHelper->select($query);
    }

    /**
     * Create a new record
     *
     * @param array $data
     * @return int The ID of the created record
     */
    public function create(array $data): int
    {
        if ($this->useTimestamps && !isset($data['created_at'])) {
            $data['created_at'] = date('Y-m-d H:i:s');
        }
        
        if ($this->useTimestamps && !isset($data['updated_at'])) {
            $data['updated_at'] = date('Y-m-d H:i:s');
        }
        
        if ($this->useUuid && !isset($data['id'])) {
            $data['id'] = \Ramsey\Uuid\Uuid::uuid4()->toString();
        }
        
        $id = $this->dbHelper->insert($this->table, $data);
        
        // Log audit event if service is available
        if ($this->auditService && $this->resourceName) {
            $this->auditService->logEvent($this->resourceName, 'create', [
                'id' => $id,
                'data' => $data
            ]);
        }
        
        return $id;
    }

    /**
     * Update a record
     *
     * @param int $id
     * @param array $data
     * @return bool
     */
    public function update(int|string $id, array $data): bool
    {
        if ($this->useTimestamps) {
            $data['updated_at'] = date('Y-m-d H:i:s');
        }
        
        $conditions = ['id' => $id];
        
        if ($this->useSoftDeletes) {
            $conditions['deleted_at IS NULL'] = null;
        }
        
        $result = $this->dbHelper->update($this->table, $data, $conditions);
        
        // Log audit event if service is available
        if ($result && $this->auditService && $this->resourceName) {
            $this->auditService->logEvent($this->resourceName, 'update', [
                'id' => $id,
                'updated_fields' => array_keys($data)
            ]);
        }
        
        return $result;
    }

    /**
     * Delete a record (soft delete if enabled)
     *
     * @param int $id
     * @return bool
     */
    public function delete(int|string $id): bool
    {
        if ($this->useSoftDeletes) {
            $data = ['deleted_at' => date('Y-m-d H:i:s')];
            $result = $this->dbHelper->update($this->table, $data, ['id' => $id]);
        } else {
            $result = $this->dbHelper->delete($this->table, ['id' => $id]);
        }
        
        // Log audit event if service is available
        if ($result && $this->auditService && $this->resourceName) {
            $this->auditService->logEvent($this->resourceName, 'delete', [
                'id' => $id
            ]);
        }
        
        return $result;
    }
}
=== App/Models/Report.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * Report Model
 *
 * Represents an admin report in the system.
 */
class Report extends BaseModel
{
    protected $table = 'reports';
    protected $resourceName = 'report';
    protected $useSoftDeletes = true;

    /**
     * Attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'admin_id',
        'title',
        'content',
        'status',
        'created_at',
        'updated_at'
    ];

    /**
     * Get reports within a date range.
     *
     * @param string $start
     * @param string $end
     * @return array
     */
    public function getByDateRange(string $start, string $end): array
    {
        $query = "
            SELECT * FROM {$this->table}
            WHERE created_at BETWEEN :start AND :end
        ";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':start' => $start, ':end' => $end]);
        return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Get the admin who created the report.
     *
     * @param int $reportId
     * @return array|null
     */
    public function getAdmin(int $reportId): ?array
    {
        $report = $this->find($reportId);
        
        if (!$report || !isset($report['admin_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM admins WHERE id = :admin_id";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':admin_id' => $report['admin_id']]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }
}
=== App/Models/AuditTrail.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * AuditTrail Model
 *
 * Represents the audit trails stored in the database and provides methods
 * for accessing and filtering the logs.
 */
class AuditTrail extends BaseModel
{
    protected $table = 'audit_trails';
    protected $resourceName = 'audit_trail';
    protected $useTimestamps = true;
    protected $useSoftDeletes = false;

    /**
     * Retrieve audit trail records based on filters.
     *
     * @param array $filters An associative array of filters:
     *                       - 'user_id' (int): Filter by user ID.
     *                       - 'booking_id' (int): Filter by booking ID.
     *                       - 'action' (string): Filter by action type.
     *                       - 'start_date' (string): Filter by start date (YYYY-MM-DD).
     *                       - 'end_date' (string): Filter by end date (YYYY-MM-DD).
     * @return array An array of matching audit trail records.
     */
    public function getLogs(array $filters = []): array
    {
        $query = "SELECT * FROM {$this->table} WHERE 1=1";
        $params = [];

        if (!empty($filters['user_id'])) {
            $query .= " AND user_id = :user_id";
            $params[':user_id'] = $filters['user_id'];
        }

        if (!empty($filters['booking_id'])) {
            $query .= " AND booking_id = :booking_id";
            $params[':booking_id'] = $filters['booking_id'];
        }

        if (!empty($filters['action'])) {
            $query .= " AND action = :action";
            $params[':action'] = $filters['action'];
        }

        if (!empty($filters['start_date'])) {
            $query .= " AND created_at >= :start_date";
            $params[':start_date'] = $filters['start_date'];
        }

        if (!empty($filters['end_date'])) {
            $query .= " AND created_at <= :end_date";
            $params[':end_date'] = $filters['end_date'];
        }

        $query .= " ORDER BY created_at DESC";

        return $this->dbHelper->select($query, $params);
    }
}
=== App/Models/RefundLog.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * RefundLog Model
 *
 * Represents a refund and handles interactions with the `refund_logs` table.
 */
class RefundLog extends BaseModel
{
    protected $table = 'refund_logs';
    protected $resourceName = 'refund_log';
    protected $useTimestamps = true;
    protected $useSoftDeletes = true;

    /**
     * Get the user associated with the refund.
     *
     * @param int $refundId
     * @return array|null
     */
    public function getUser(int $refundId): ?array
    {
        $refund = $this->find($refundId);
        
        if (!$refund || !isset($refund['user_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM users WHERE id = :user_id";
        $result = $this->dbHelper->select($query, [':user_id' => $refund['user_id']]);
        return $result[0] ?? null;
    }

    /**
     * Get the payment associated with the refund.
     *
     * @param int $refundId
     * @return array|null
     */
    public function getPayment(int $refundId): ?array
    {
        $refund = $this->find($refundId);
        
        if (!$refund || !isset($refund['payment_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM payments WHERE id = :payment_id";
        $result = $this->dbHelper->select($query, [':payment_id' => $refund['payment_id']]);
        return $result[0] ?? null;
    }
}=== App/Models/Signature.php ===
namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;
use App\Services\EncryptionService;

class Signature extends BaseModel
{
    protected $table = 'signatures';
    protected $resourceName = 'signature';
    protected $useTimestamps = true;
    protected $useSoftDeletes = false;

    /**
     * Create a new signature.
     *
     * @param array $data
     * @return int
     */
    public function create(array $data): int
    {
        if (isset($data['signature'])) {
            $data['signature'] = EncryptionService::encrypt($data['signature']);
        }

        return parent::create($data);
    }

    /**
     * Update a signature.
     *
     * @param int $id
     * @param array $data
     * @return bool
     */
    public function update(int $id, array $data): bool
    {
        if (isset($data['signature'])) {
            $data['signature'] = EncryptionService::encrypt($data['signature']);
        }

        return parent::update($id, $data);
    }

    /**
     * Get the signature.
     *
     * @param int $signatureId
     * @return string|null
     */
    public function getSignature(int $signatureId): ?string
    {
        $signature = $this->find($signatureId);

        if ($signature && isset($signature['signature'])) {
            return EncryptionService::decrypt($signature['signature']);
        }

        return null;
    }

    /**
     * Get the user associated with the signature.
     *
     * @param int $signatureId
     * @return array|null
     */
    public function getUser(int $signatureId): ?array
    {
        $signature = $this->find($signatureId);
        
        if (!$signature || !isset($signature['user_id'])) {
            return null;
        }
        
        $query = "SELECT * FROM users WHERE id = :user_id";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':user_id' => $signature['user_id']]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }
}
=== App/Models/PasswordReset.php ===
<?php

namespace App\Models;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

/**
 * PasswordReset Model
 *
 * Represents a password reset request.
 */
class PasswordReset extends BaseModel
{
    protected $table = 'password_resets';
    protected $resourceName = 'password_reset';
    protected $useTimestamps = true;
    protected $useSoftDeletes = false;

    /**
     * Find a password reset by token.
     *
     * @param string $token
     * @return array|null
     */
    public function findByToken(string $token): ?array
    {
        $query = "SELECT * FROM {$this->table} WHERE token = :token";
        $stmt = $this->pdo->prepare($query);
        $stmt->execute([':token' => $token]);
        return $stmt->fetch(\PDO::FETCH_ASSOC) ?: null;
    }

    /**
     * Create a new password reset.
     *
     * @param array $data
     * @return int
     */
    public function create(array $data): int
    {
        // Generate a token if not provided
        if (!isset($data['token'])) {
            $data['token'] = bin2hex(random_bytes(32));
        }

        $id = parent::create($data);

        // Add custom audit logging if needed
        if ($this->auditService) {
            $this->auditService->logEvent($this->resourceName, 'password_reset_created', [
                'id' => $id,
                'email' => $data['email'] ?? null
            ]);
        }

        return $id;
    }
}
=== App/Queues/DocumentQueue.php ===
<?php

namespace App\Queues;

use DocumentManager\Services\FileStorage;
use Psr\Log\LoggerInterface;

class DocumentQueue
{
    private FileStorage $fileStorage;
    private string $queueFile;
    private LoggerInterface $logger;
    private const MAX_RETRY_ATTEMPTS = 3;

    public function __construct(LoggerInterface $logger, FileStorage $fileStorage, string $queueFile)
    {
        $this->logger = $logger;
        $this->fileStorage = $fileStorage;
        $this->queueFile = $queueFile;
    }

    public function push(array $document): void
    {
        $queue = $this->getQueue();
        $document['attempts'] = 0;
        $queue[] = $document;
        $this->saveQueue($queue);
        $this->logger->info('Document added to queue', $document);
    }

    public function process(): void
    {
        $queue = $this->getQueue();
        foreach ($queue as $index => $document) {
            try {
                $success = $this->fileStorage->storeFile($document['file_path'], $document['destination']);

                if ($success) {
                    unset($queue[$index]);
                    $this->logger->info('Document processed successfully', $document);
                } else {
                    $queue[$index]['attempts']++;
                    $this->logger->warning('Document processing failed, retrying...', [
                        'document' => $document,
                        'attempts' => $queue[$index]['attempts'],
                    ]);
                }

                if ($queue[$index]['attempts'] >= self::MAX_RETRY_ATTEMPTS) {
                    $this->logger->error('Max retry attempts reached for document', $document);
                    unset($queue[$index]);
                }
            } catch (\Exception $e) {
                $this->logger->error('Error processing document', [
                    'document' => $document,
                    'error' => $e->getMessage(),
                ]);
            }
        }

        $this->saveQueue(array_values($queue));
    }

    private function getQueue(): array
    {
        if (!file_exists($this->queueFile)) {
            return [];
        }
        return json_decode(file_get_contents($this->queueFile), true) ?? [];
    }

    private function saveQueue(array $queue): void
    {
        file_put_contents($this->queueFile, json_encode($queue, JSON_PRETTY_PRINT));
    }
}
=== App/Queues/NotificationQueue.php ===
<?php

namespace App\Queues;

use App\Services\NotificationService;
use Psr\Log\LoggerInterface;

class NotificationQueue
{
    private string $queueFile;
    private NotificationService $notificationService;
    private LoggerInterface $logger;
    private const MAX_RETRY_ATTEMPTS = 3;

    public function __construct(
        LoggerInterface $logger,
        NotificationService $notificationService,
        string $queueFile
    ) {
        $this->logger = $logger;
        $this->notificationService = $notificationService;
        $this->queueFile = $queueFile;
    }

    /**
     * Push a notification onto the queue
     */
    public function push(array $notification): void
    {
        $queue = $this->getQueue();
        $notification['attempts'] = 0; // Initialize retry attempts
        $queue[] = $notification;
        $this->saveQueue($queue);
        $this->logger->info('Notification added to queue', $notification);
    }

    /**
     * Process the notification queue
     */
    public function process(): void
    {
        $queue = $this->getQueue();
        foreach ($queue as $index => $notification) {
            try {
                $success = $this->notificationService->sendNotification(
                    $notification['user_id'],
                    $notification['type'],
                    $notification['message'],
                    $notification['options']
                );

                if ($success) {
                    unset($queue[$index]); // Remove notification on success
                    $this->logger->info('Notification processed successfully', $notification);
                } else {
                    $queue[$index]['attempts']++;
                    $this->logger->warning('Notification failed, retrying...', [
                        'notification' => $notification,
                        'attempts' => $queue[$index]['attempts'],
                    ]);
                }

                // Remove notifications that exceed retry attempts
                if ($queue[$index]['attempts'] >= self::MAX_RETRY_ATTEMPTS) {
                    $this->logger->error('Max retry attempts reached for notification', $notification);
                    unset($queue[$index]);
                }
            } catch (\Exception $e) {
                $this->logger->error('Error processing notification', [
                    'notification' => $notification,
                    'error' => $e->getMessage(),
                ]);
            }
        }

        $this->saveQueue(array_values($queue)); // Reindex and save the queue
    }

    /**
     * Retrieve the current queue
     */
    private function getQueue(): array
    {
        if (!file_exists($this->queueFile)) {
            return [];
        }
        return json_decode(file_get_contents($this->queueFile), true) ?? [];
    }

    /**
     * Save the current queue to the file
     */
    private function saveQueue(array $queue): void
    {
        file_put_contents($this->queueFile, json_encode($queue, JSON_PRETTY_PRINT));
    }
}
=== App/Services/TemplateService.php ===
<?php

namespace App\Services;

use Exception;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use App\Models\DocumentTemplate;
use App\Services\AuditService;

/**
 * Template Service
 *
 * Provides functionality for managing and rendering document templates.
 * Templates support placeholders for dynamic data injection.
 */
class TemplateService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private AuditService $auditService;

    /**
     * Constructor
     *
     * @param LoggerInterface $logger The logger instance.
     * @param ExceptionHandler $exceptionHandler The exception handler instance.
     * @param AuditService $auditService The audit service instance.
     */
    public function __construct(
        LoggerInterface $logger, 
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    /**
     * List all available templates.
     *
     * @return array List of templates.
     */
    public function listTemplates(): array
    {
        return DocumentTemplate::all()->toArray();
    }

    /**
     * Load the content of a template.
     *
     * @param int|string $templateId The ID or name of the template.
     * @return DocumentTemplate The template.
     * @throws Exception If the template cannot be found.
     */
    public function loadTemplate($templateId): DocumentTemplate
    {
        try {
            $template = is_numeric($templateId) 
                ? DocumentTemplate::findOrFail($templateId)
                : DocumentTemplate::where('name', $templateId)->firstOrFail();
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[system] Loaded template", ['template' => $template->name]);
            }
            
            $this->auditService->logEvent('template_loaded', [
                'template_id' => $template->id,
                'template_name' => $template->name
            ]);
            
            return $template;
        } catch (\Exception $e) {
            $this->logger->error("[system] ❌ Error loading template: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Render a template by replacing placeholders with data.
     *
     * @param int|string $templateId The ID or name of the template.
     * @param array $data Key-value pairs to replace placeholders.
     * @return string Rendered template with placeholders replaced.
     * @throws Exception If the template cannot be loaded.
     */
    public function renderTemplate($templateId, array $data): string
    {
        $template = $this->loadTemplate($templateId);
        $content = $template->content;

        foreach ($data as $key => $value) {
            $placeholder = '{{' . $key . '}}';
            $content = str_replace($placeholder, htmlspecialchars((string)$value, ENT_QUOTES, 'UTF-8'), $content);
        }

        $this->auditService->logEvent('template_rendered', [
            'template_id' => $template->id,
            'template_name' => $template->name
        ]);
        
        return $content;
    }

    /**
     * Save a new or updated template.
     *
     * @param string $templateName The name of the template.
     * @param string $content The template content to save.
     * @param int|null $templateId The template ID for updates (null for new templates).
     * @return DocumentTemplate The saved template.
     * @throws Exception If saving fails.
     */
    public function saveTemplate(string $templateName, string $content, ?int $templateId = null): DocumentTemplate
    {
        try {
            if ($templateId) {
                $template = DocumentTemplate::findOrFail($templateId);
                $template->name = $templateName;
                $template->content = $content;
                $template->save();
            } else {
                $template = DocumentTemplate::create([
                    'name' => $templateName,
                    'content' => $content
                ]);
            }
            
            return $template;
        } catch (\Exception $e) {
            $this->logger->error("Error saving template", ['template' => $templateName, 'error' => $e->getMessage()]);
            throw $e;
        }
    }

    /**
     * Delete a template.
     *
     * @param int $templateId The ID of the template to delete.
     * @return bool True if deleted successfully.
     * @throws Exception If the template cannot be found or deleted.
     */
    public function deleteTemplate(int $templateId): bool
    {
        try {
            $template = DocumentTemplate::findOrFail($templateId);
            $template->delete();
            
            return true;
        } catch (\Exception $e) {
            $this->logger->error("Error deleting template", ['template_id' => $templateId, 'error' => $e->getMessage()]);
            throw $e;
        }
    }
}
=== App/Services/MetricsService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use Exception;

class MetricsService
{
    public const DEBUG_MODE = true;
    private DatabaseHelper $db;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        DatabaseHelper $db
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->db = $db;
    }

    public function getDashboardMetrics(): array
    {
        try {
            $totalUsers        = $this->db->table('users')->count();
            $activeUsers       = $this->db->table('users')->where('active', true)->count();
            $totalBookings     = $this->db->table('bookings')->count();
            $completedBookings = $this->db->table('bookings')->where('status', 'completed')->count();
            $canceledBookings  = $this->db->table('bookings')->where('status', 'canceled')->count();
            $totalRevenue      = $this->db->table('payments')->where('status', 'completed')->sum('amount');
            $totalRefunds      = $this->db->table('payments')
                                          ->where('status', 'completed')
                                          ->where('type', 'refund')
                                          ->sum('amount');
            
            $metrics = [
                'total_users'         => $totalUsers,
                'active_users'        => $activeUsers,
                'total_bookings'      => $totalBookings,
                'completed_bookings'  => $completedBookings,
                'canceled_bookings'   => $canceledBookings,
                'total_revenue'       => $totalRevenue,
                'total_refunds'       => $totalRefunds,
            ];
            $metrics['net_revenue'] = $totalRevenue - $totalRefunds;
            if (self::DEBUG_MODE) {
                $this->logger->info("[Metrics] Dashboard metrics retrieved successfully");
            }
            return $metrics;
        } catch (Exception $e) {
            $this->logger->error("[DB] ❌ MetricsService error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return [];
        }
    }
}
=== App/Services/UserService.php ===
<?php

namespace App\Services;

use Psr\Log\LoggerInterface;
use Firebase\JWT\JWT;
use Exception;
use App\Helpers\DatabaseHelper;
use App\Helpers\ApiHelper;
use App\Helpers\ExceptionHandler;

class UserService
{
    public const DEBUG_MODE = true;

    private DatabaseHelper $db;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private AuditService $auditService;

    public function __construct(
        LoggerInterface $logger,
        DatabaseHelper $db,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        $this->logger = $logger;
        $this->db = $db;
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
        
        if (self::DEBUG_MODE) {
            $this->logger->info("[auth] UserService initialized", ['service' => 'UserService']);
        }
    }

    public function createUser(array $data): array
    {
        $rules = [
            'name' => 'required|string|max:255',
            'email' => 'required|email|unique:users',
            'password' => 'required|string|min:8|regex:/^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/',
            'phone' => 'required|string|max:20',
            'address' => 'required|string|max:255',
        ];

        try {
            Validator::validate($data, $rules);
        } catch (Exception $e) {
            return ['status' => 'error', 'message' => $e->getMessage()];
        }

        try {
            $userId = $this->db->table('users')->insertGetId($data);
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[auth] ✅ User registered.", ['userId' => $userId]);
            }
            
            // Log using the unified audit service
            $this->auditService->logEvent(
                'user',
                'User created',
                ['email' => $data['email']],
                $userId,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return ['status' => 'success', 'message' => 'User created successfully', 'data' => ['user_id' => $userId]];
        } catch (Exception $e) {
            $this->logger->error("[auth] ❌ User creation failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'User creation failed'];
        }
    }

    public function updateUser(int $id, array $data): array
    {
        try {
            $user = $this->db->table('users')->where('id', $id)->first();
            if (!$user) {
                $this->logger->error("User not found", ['userId' => $id]);
                throw new ModelNotFoundException();
            }
            
            $this->db->table('users')->where('id', $id)->update($data);
            $this->logger->info("✅ User updated.", ['userId' => $id]);
            
            // Log using the unified audit service
            $this->auditService->logEvent(
                'user',
                'User updated',
                array_merge(['user_id' => $id], $data),
                $id,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return ['status' => 'success', 'message' => 'User updated successfully', 'data' => ['user_id' => $id]];
        } catch (ModelNotFoundException $e) {
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'User not found', 'code' => 404];
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'User update failed'];
        }
    }

    public function authenticate(string $email, string $password): array
    {
        try {
            $user = $this->db->table('users')->where('email', $email)->first();
            
            if (!$user || !Hash::check($password, $user->password_hash)) {
                $this->logger->error("Authentication failed", ['email' => $email]);
                
                // Log failed authentication
                $this->auditService->logEvent(
                    'auth',
                    'Authentication failed',
                    ['email' => $email],
                    null,
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
                
                return ['status' => 'error', 'message' => 'Authentication failed', 'code' => 401];
            }
            
            $this->logger->info("✅ Authentication successful.", ['userId' => $user->id]);
            
            // Log successful authentication
            $this->auditService->logEvent(
                'auth',
                'Authentication successful',
                ['email' => $email],
                $user->id,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            $jwt = $this->generateJWT($user);
            return ['status' => 'success', 'message' => 'Authentication successful', 'data' => ['token' => $jwt]];
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'Authentication error'];
        }
    }

    private function generateJWT($user): string
    {
        $payload = [
            'sub' => $user->id,
            'email' => $user->email,
            'role' => $user->role,
            'iat' => time(),
            'exp' => time() + 3600,
        ];

        return JWT::encode($payload, $this->jwtSecret, 'HS256');
    }

    public function requestPasswordReset(string $email): array
    {
        try {
            $user = $this->db->table('users')->where('email', $email)->first();
            
            if (!$user) {
                $this->logger->error("Password reset request failed", ['email' => $email]);
                return ['status' => 'error', 'message' => 'User not found', 'code' => 404];
            }
            
            $token = bin2hex(random_bytes(32));
            $expiresAt = now()->addHour();
            
            $this->db->table('password_resets')->insert([
                'email' => $email,
                'token' => $token,
                'expires_at' => $expiresAt
            ]);
            
            $this->logger->info("✅ Password reset requested.", ['userId' => $user->id]);
            
            // Log password reset request
            $this->auditService->logEvent(
                'auth',
                'Password reset requested',
                ['email' => $email],
                $user->id,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return [
                'status' => 'success',
                'message' => 'Password reset requested',
                'data' => ['reset_token' => $token]
            ];
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'Password reset request error'];
        }
    }
}
=== App/Services/Validator.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

/**
 * Validator Service
 *
 * Validates input data against defined rules.
 */
class Validator
{
    public const DEBUG_MODE = true;
    private array $errors = [];
    private LoggerInterface $logger;
    private DatabaseHelper $db;
    private ExceptionHandler $exceptionHandler;

    // Updated constructor for Dependency Injection
    public function __construct(LoggerInterface $logger, DatabaseHelper $db, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->db = $db;
        $this->exceptionHandler = $exceptionHandler;
        $this->logger->debug("Validator initialized with database connection");
    }

    /**
     * Validate data against rules.
     */
    public function validate(array $data, array $rules): bool
    {
        $this->logger->debug("Starting validation with rules", ['rules' => $rules]);
        $this->errors = [];
        
        foreach ($rules as $field => $ruleSet) {
            $rulesArray = explode('|', $ruleSet);
            foreach ($rulesArray as $rule) {
                $this->applyRule($field, $data[$field] ?? null, $rule, $data);
            }
        }

        if (!empty($this->errors)) {
            if (self::DEBUG_MODE) {
                $this->logger->warning("Validation failed", ['errors' => $this->errors]);
            }

            // Throw an exception to prevent further execution
            throw new \InvalidArgumentException(json_encode(['errors' => $this->errors]));
        }

        $this->logger->debug("Validation successful");
        return true;
    }

    /**
     * Get validation errors.
     */
    public function errors(): array
    {
        return $this->errors;
    }

    /**
     * Apply a validation rule to a field.
     */
    private function applyRule(string $field, $value, string $rule, array $data): void
    {
        try {
            if ($rule === 'required' && empty($value)) {
                $this->errors[$field][] = "The {$field} field is required.";
            } elseif (strpos($rule, 'max:') === 0) {
                $maxLength = (int)explode(':', $rule)[1];
                if (!empty($value) && strlen($value) > $maxLength) {
                    $this->errors[$field][] = "The {$field} must not exceed {$maxLength} characters.";
                }
            } elseif (strpos($rule, 'min:') === 0) {
                $minLength = (int)explode(':', $rule)[1];
                if (!empty($value) && strlen($value) < $minLength) {
                    $this->errors[$field][] = "The {$field} must be at least {$minLength} characters.";
                }
            } elseif ($rule === 'email' && !empty($value) && !filter_var($value, FILTER_VALIDATE_EMAIL)) {
                $this->errors[$field][] = "The {$field} must be a valid email address.";
            } elseif (strpos($rule, 'regex:') === 0) {
                $pattern = substr($rule, 6);
                if (!empty($value) && !preg_match($pattern, $value)) {
                    $this->errors[$field][] = "The {$field} format is invalid.";
                }
            } elseif (strpos($rule, 'same:') === 0) {
                $otherField = substr($rule, 5);
                if (!empty($value) && isset($data[$otherField]) && $value !== $data[$otherField]) {
                    $this->errors[$field][] = "The {$field} and {$otherField} must match.";
                }
            } elseif (strpos($rule, 'unique:') === 0) {
                [$table, $column] = explode(',', substr($rule, 7));
                
                $this->logger->debug("Checking uniqueness", [
                    'field' => $field,
                    'table' => $table,
                    'column' => $column,
                    'value' => $value
                ]);
                
                if (!empty($value)) {
                    $pdo = $this->db->getPdo(); // Get PDO instance from DatabaseHelper
                    $stmt = $pdo->prepare("SELECT COUNT(*) FROM {$table} WHERE {$column} = ?");
                    $stmt->execute([$value]);
                    $count = (int)$stmt->fetchColumn();
                    
                    if ($count > 0) {
                        $this->errors[$field][] = "The {$field} has already been taken.";
                    }
                }
            }
        } catch (\Exception $e) {
            $this->logger->error("Validation error: " . $e->getMessage(), [
                'field' => $field,
                'rule' => $rule
            ]);
            
            // Add a generic error and continue validation
            $this->errors[$field][] = "An error occurred while validating {$field}.";
        }
    }
}=== App/Services/BookingService.php ===
<?php

namespace App\Services;

use App\Models\Booking;
use Exception;
use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class BookingService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private DatabaseHelper $db;
    private Booking $bookingModel;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        DatabaseHelper $db,
        Booking $bookingModel
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->db = $db;
        $this->bookingModel = $bookingModel;
    }

    /**
     * Get booking details by ID
     */
    public function getBookingById(int $id): array
    {
        try {
            $booking = $this->bookingModel->find($id);
            if (!$booking) {
                throw new Exception("Booking not found.");
            }
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved booking id: {$id}");
            }
            return (array)$booking;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getBookingById error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Reschedule a booking
     */
    public function rescheduleBooking(int $id, string $pickupDate, string $dropoffDate): void
    {
        try {
            $booking = $this->bookingModel->find($id);
            if (!$booking) {
                throw new Exception("Booking not found.");
            }

            $updated = $this->bookingModel->update($id, [
                'pickup_date'  => $pickupDate,
                'dropoff_date' => $dropoffDate,
                'status'       => 'rescheduled'
            ]);

            if (!$updated) {
                throw new Exception("Failed to update booking.");
            }
            
            // Business-level logging (keep it as it's not just a record change)
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Rescheduled booking id: {$id}");
            }
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ rescheduleBooking error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Cancel a booking and calculate refund amount
     */
    public function cancelBooking(int $id): float
    {
        try {
            $booking = $this->bookingModel->find($id);
            if (!$booking) {
                throw new Exception("Booking not found.");
            }

            $updated = $this->bookingModel->update($id, ['status' => 'canceled']);

            if (!$updated) {
                throw new Exception("Failed to update booking status.");
            }
            
            // Business-level logging (keep it as it's not just a record change)
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Canceled booking id: {$id}");
            }
            
            return isset($booking['refund_amount']) ? (float)$booking['refund_amount'] : 0.0;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ cancelBooking error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get user ID associated with a booking
     */
    public function getUserIdByBooking(int $id): int
    {
        try {
            $booking = $this->bookingModel->find($id);
            if (!$booking) {
                throw new Exception("Booking not found.");
            }
            
            $userId = $this->bookingModel->getUserId($id);
            
            if (!$userId) {
                throw new Exception("User not found for booking.");
            }
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved user id for booking id: {$id}");
            }
            
            return (int)$userId;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getUserIdByBooking error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get monthly booking trends for the current year
     */
    public function getMonthlyBookingTrends(): array
    {
        try {
            $trends = $this->bookingModel->getMonthlyTrends();
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved monthly booking trends.");
            }
            
            return $trends;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getMonthlyBookingTrends error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get total number of bookings
     */
    public function getTotalBookings(): int
    {
        try {
            $total = $this->bookingModel->getTotalBookings();
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved total bookings.");
            }
            
            return $total;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getTotalBookings error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get the number of completed bookings
     */
    public function getCompletedBookings(): int
    {
        try {
            $completed = $this->bookingModel->getCompletedBookings();
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved completed bookings.");
            }
            
            return $completed;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getCompletedBookings error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get the number of canceled bookings
     */
    public function getCanceledBookings(): int
    {
        try {
            $canceled = $this->bookingModel->getCanceledBookings();
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved canceled bookings.");
            }
            
            return $canceled;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getCanceledBookings error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get booking logs for a specific booking ID
     */
    public function getBookingLogs(int $bookingId): array
    {
        try {
            $logs = $this->bookingModel->getLogs($bookingId);
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved logs for booking id: {$bookingId}");
            }
            
            return $logs;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getBookingLogs error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Check booking availability
     */
    private function isBookingAvailable(int $vehicleId, string $pickupDate, string $dropoffDate): bool
    {
        try {
            $available = $this->bookingModel->isAvailable($vehicleId, $pickupDate, $dropoffDate);
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Checked availability for vehicle id: {$vehicleId}");
            }
            
            return $available;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ isBookingAvailable error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Create a new booking
     */
    public function createBooking(int $userId, int $vehicleId, string $pickupDate, string $dropoffDate): array
    {
        if (!$this->isBookingAvailable($vehicleId, $pickupDate, $dropoffDate)) {
            $this->logger->error("[Booking] ❌ Vehicle not available for booking (vehicle id: {$vehicleId})");
            return ['status' => 'error', 'message' => 'Vehicle not available for the selected dates'];
        }

        try {
            $bookingData = [
                'user_id'     => $userId,
                'vehicle_id'  => $vehicleId,
                'pickup_date' => $pickupDate,
                'dropoff_date'=> $dropoffDate,
                'status'      => 'booked',
                'created_at'  => date('Y-m-d H:i:s'),
                'updated_at'  => date('Y-m-d H:i:s')
            ];
            
            $booking = $this->bookingModel->create($bookingData);

            // Business-level logging (keep it as it's not just a record change)
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Booking created for user {$userId}");
            }

            return ['status' => 'success', 'message' => 'Booking created successfully'];
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ createBooking error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'Failed to create booking'];
        }
    }
    
    /**
     * Get all bookings for a user
     */
    public function getUserBookings(int $userId): array
    {
        try {
            $bookings = $this->bookingModel->getByUser($userId);
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved bookings for user id: {$userId}");
            }
            
            return $bookings;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getUserBookings error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
    
    /**
     * Delete a booking (soft delete if model supports it)
     */
    public function deleteBooking(int $id): bool
    {
        try {
            $deleted = $this->bookingModel->delete($id);
            
            if (!$deleted) {
                throw new Exception("Failed to delete booking.");
            }
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Deleted booking id: {$id}");
            }
            
            return true;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ deleteBooking error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
}
=== App/Services/Auth/TokenService.php ===
<?php

namespace App\Services\Auth;

use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use App\Helpers\DatabaseHelper;
use App\Services\AuditService;

class TokenService
{
    public const DEBUG_MODE = true;

    private string $jwtSecret;
    private string $jwtRefreshSecret;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private DatabaseHelper $db;
    private DatabaseHelper $secureDb;
    private AuditService $auditService;

    public function __construct(
        string $jwtSecret,
        string $jwtRefreshSecret,
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        DatabaseHelper $appDb,
        DatabaseHelper $secureDb,
        AuditService $auditService
    ) {
        $this->jwtSecret = $jwtSecret;
        $this->jwtRefreshSecret = $jwtRefreshSecret;
        if (empty($this->jwtSecret) || empty($this->jwtRefreshSecret)) {
            throw new \RuntimeException('❌ JWT secrets are missing.');
        }
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->db = $appDb;
        $this->secureDb = $secureDb;
        $this->auditService = $auditService;
        
        if (self::DEBUG_MODE) {
            $this->logger->info("[auth] TokenService initialized.");
        }
    }

    public function generateToken($user): string
    {
        // Extract user ID safely from either array or object
        $userId = is_array($user) ? $user['id'] : $user->id;

        $payload = [
            'iss' => "your-issuer",
            'sub' => $userId,
            'iat' => time(),
            'exp' => time() + 3600
        ];
        try {
            $token = JWT::encode($payload, $this->jwtSecret, 'HS256');
            if (self::DEBUG_MODE) {
                $this->logger->info("[auth] ✅ Token generated.", ['userId' => $userId]);
            }
            
            // Log JWT creation as a business-level event in audit trail
            $this->auditService->logEvent(
                'auth',
                'jwt_created',
                ['user_id' => $userId],
                $userId,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return $token;
        } catch (\Exception $e) {
            $this->logger->error("[auth] ❌ Token generation failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function verifyToken(string $token): array
    {
        try {
            $decoded = JWT::decode($token, new Key($this->jwtSecret, 'HS256'));
            if ($decoded->exp < time()) {
                throw new \Exception("Token has expired.");
            }
            $this->logger->info("✅ Token verified.", ['userId' => $decoded->sub]);
            return (array)$decoded;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function generateRefreshToken($user): string
    {
        // Extract user ID safely from either array or object
        $userId = is_array($user) ? $user['id'] : $user->id;

        $payload = [
            'iss' => "your-issuer",
            'sub' => $userId,
            'iat' => time(),
            'exp' => time() + 604800
        ];
        try {
            $refreshToken = JWT::encode($payload, $this->jwtRefreshSecret, 'HS256');
            
            // Store the refresh token in database using DatabaseHelper
            $this->storeRefreshToken($userId, $refreshToken);
            
            return $refreshToken;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
    
    /**
     * Store refresh token in database
     */
    private function storeRefreshToken(int $userId, string $refreshToken): void
    {
        try {
            // Store the token in the refresh_tokens table using secure db helper
            DatabaseHelper::insert('refresh_tokens', [
                'user_id' => $userId,
                'token' => hash('sha256', $refreshToken), // Store hashed token for security
                'expires_at' => date('Y-m-d H:i:s', time() + 604800),
                'created_at' => date('Y-m-d H:i:s'),
                'ip_address' => $_SERVER['REMOTE_ADDR'] ?? null
            ], true); // Set useSecureDb to true
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[auth] Refresh token stored in secure database", ['user_id' => $userId]);
            }
        } catch (\Exception $e) {
            $this->logger->error("[auth] Failed to store refresh token: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            // Continue without failing - JWT will still work even if storage fails
        }
    }

    /**
     * Decode and validate a refresh token
     *
     * @param string $refreshToken The refresh token to decode
     * @return object The decoded token payload
     * @throws \Exception If token is invalid or expired
     */
    public function decodeRefreshToken(string $refreshToken)
    {
        try {
            // Check if token has been revoked
            if ($this->isTokenRevoked($refreshToken)) {
                throw new \Exception("Refresh token has been revoked.");
            }
            
            $decoded = JWT::decode($refreshToken, new Key($this->jwtRefreshSecret, 'HS256'));
            
            if ($decoded->exp < time()) {
                throw new \Exception("Refresh token has expired.");
            }
            
            $this->logger->debug("Refresh token decoded successfully", ['sub' => $decoded->sub]);
            return $decoded;
        } catch (\Exception $e) {
            $this->logger->error("Failed to decode refresh token: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
    
    /**
     * Check if a token has been revoked
     */
    private function isTokenRevoked(string $refreshToken): bool
    {
        try {
            // Check cache first for performance
            if (apcu_exists("revoked_refresh_token_$refreshToken")) {
                return true;
            }
            
            // If not in cache, check secure database
            $hashedToken = hash('sha256', $refreshToken);
            $query = "SELECT 1 FROM refresh_tokens WHERE token = :token AND revoked = 1 LIMIT 1";
            $revoked = DatabaseHelper::select($query, [':token' => $hashedToken], true); // Set useSecureDb to true
                
            // If revoked in database, store in cache for next time
            if ($revoked) {
                apcu_store("revoked_refresh_token_$refreshToken", true, 604800);
            }
            
            return !empty($revoked);
        } catch (\Exception $e) {
            $this->logger->warning("Error checking if token is revoked: " . $e->getMessage());
            // Default to not revoked if there's an error checking, but log it
            return false;
        }
    }

    public function refreshToken(string $refreshToken): string
    {
        try {
            $decoded = $this->decodeRefreshToken($refreshToken);
            
            // Generate a new access token
            $newToken = $this->generateToken((object)['id' => $decoded->sub]);
            
            // Log token refresh as a business event
            $this->auditService->logEvent(
                'auth',
                'jwt_refreshed',
                ['user_id' => $decoded->sub],
                $decoded->sub,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return $newToken;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function revokeToken(string $token): void
    {
        try {
            // Store in cache for quick lookups
            apcu_store("revoked_refresh_token_$token", true, 604800);
            
            // Store in secure database for persistence
            $hashedToken = hash('sha256', $token);
            
            // Update the token status in secure database using db helper
            DatabaseHelper::update('refresh_tokens', [
                'revoked' => 1,
                'revoked_at' => date('Y-m-d H:i:s')
            ], ['token' => $hashedToken], true); // Set useSecureDb to true
                
            // Try to get the user ID for audit logging
            $query = "SELECT user_id FROM refresh_tokens WHERE token = :token LIMIT 1";
            $tokenData = DatabaseHelper::select($query, [':token' => $hashedToken], true); // Set useSecureDb to true
            
            $userId = $tokenData[0]['user_id'] ?? null;
            
            // Log token revocation as a business event
            if ($userId) {
                $this->auditService->logEvent(
                    'auth',
                    'token_revoked',
                    [],
                    $userId,
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
            }
            
            $this->logger->info("✅ [TokenService] Revoked refresh token.");
        } catch (\Exception $e) {
            $this->logger->error("Failed to revoke token: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
        }
    }
    
    /**
     * Remove expired tokens from the database
     */
    public function purgeExpiredTokens(): int
    {
        try {
            $query = "DELETE FROM refresh_tokens WHERE expires_at < :now";
            $count = DatabaseHelper::delete('refresh_tokens', ['expires_at < ' => date('Y-m-d H:i:s')], false, true); // Set useSecureDb to true
                
            $this->logger->info("[TokenService] Purged {$count} expired tokens");
            return $count;
        } catch (\Exception $e) {
            $this->logger->error("Failed to purge expired tokens: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return 0;
        }
    }
    
    /**
     * Get all active tokens for a user
     */
    public function getActiveTokensForUser(int $userId): array
    {
        try {
            $query = "SELECT * FROM refresh_tokens WHERE user_id = :user_id AND revoked = 0 AND expires_at > :now";
            $tokens = DatabaseHelper::select($query, [
                ':user_id' => $userId,
                ':now' => date('Y-m-d H:i:s')
            ], true); // Set useSecureDb to true
                
            return $tokens ?: [];
        } catch (\Exception $e) {
            $this->logger->error("Failed to get active tokens: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return [];
        }
    }

    /**
     * Validate a token and return user data if valid.
     * This replaces TokenValidator::validateToken
     *
     * @param string|null $tokenHeader The Authorization header value
     * @return array|null User data if valid, null if invalid
     */
    public function validateTokenFromHeader(?string $tokenHeader): ?array
    {
        try {
            if (!$tokenHeader) {
                return null;
            }

            // Extract the token from the Authorization header
            $token = preg_replace('/^Bearer\s+/', '', $tokenHeader);
            if (empty($token)) {
                return null;
            }

            // Decode and verify the token
            $decoded = $this->verifyToken($token);
            
            // Get the user ID from the token
            $userId = $decoded['sub'] ?? null;
            if (!$userId) {
                $this->logger->warning('Token missing user ID claim', ['token' => substr($token, 0, 10) . '...']);
                return null;
            }

            // Fetch user data from the database
            $user = $this->getUserById($userId);
            if (!$user) {
                $this->logger->warning('User from token not found in database', ['user_id' => $userId]);
                return null;
            }

            if (self::DEBUG_MODE) {
                $this->logger->info('Token validation successful', ['user_id' => $userId]);
            }
            
            // Log token validation in audit trail
            $this->auditService->logEvent(
                'auth',
                'token_validated',
                ['user_id' => $userId],
                $userId,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            return $user;
        } catch (\Exception $e) {
            $this->logger->warning('Token validation failed', ['error' => $e->getMessage()]);
            return null;
        }
    }
    
    /**
     * Extract token from Authorization header or cookie
     * 
     * @param mixed $request The request object or authorization header
     * @return string|null The token or null if not found
     */
    public function extractToken($request): ?string
    {
        // Handle different request formats
        if (is_string($request)) {
            // Assume $request is directly the Authorization header
            $authHeader = $request;
        } elseif (is_array($request) && isset($request['Authorization'])) {
            // Handle array format (e.g. from getHeader)
            $authHeader = $request['Authorization'];
        } elseif (is_object($request) && method_exists($request, 'getHeaderLine')) {
            // Handle PSR-7 request object
            $authHeader = $request->getHeaderLine('Authorization');
        } elseif (is_object($request) && method_exists($request, 'headers')) {
            // Handle Laravel/Symfony style request
            $authHeader = $request->headers->get('Authorization');
        } else {
            $authHeader = null;
        }
        
        // Extract token from Bearer format
        $token = null;
        if ($authHeader && strpos($authHeader, 'Bearer ') === 0) {
            $token = substr($authHeader, 7);
        }
        
        // If not found in Authorization header, check cookies
        if (!$token && isset($_COOKIE['jwt'])) {
            $token = $_COOKIE['jwt'];
        }
        
        return $token;
    }
    
    /**
     * Get user data by ID from the database
     * 
     * @param int $userId The user ID
     * @return array|null User data or null if not found
     */
    private function getUserById(int $userId): ?array
    {
        try {
            $sql = "SELECT * FROM users WHERE id = ? AND deleted_at IS NULL LIMIT 1";
            $users = DatabaseHelper::select($sql, [$userId]);
            
            if (empty($users)) {
                return null;
            }
            
            // Remove sensitive data
            unset($users[0]['password']);
            
            return $users[0];
        } catch (\Exception $e) {
            $this->logger->error("Error fetching user data: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }
    
    /**
     * Validate token and get user data in a single operation
     * 
     * @param mixed $request The request object or authorization header
     * @return array|null User data if token valid, null otherwise
     */
    public function validateRequest($request): ?array
    {
        $token = $this->extractToken($request);
        if (!$token) {
            return null;
        }
        
        try {
            $decoded = $this->verifyToken($token);
            return $this->getUserById($decoded['sub']);
        } catch (\Exception $e) {
            $this->logger->warning('Token validation failed during request', ['error' => $e->getMessage()]);
            return null;
        }
    }
}
=== App/Services/Auth/AuthService.php ===
<?php

namespace App\Services\Auth;

use App\Models\User;
use App\Helpers\DatabaseHelper;
use Firebase\JWT\JWT;
use App\Helpers\ExceptionHandler;
use Firebase\JWT\Key;
use Exception;
use Psr\Log\LoggerInterface;
use App\Helpers\ApiHelper;
use App\Services\Validator;
use App\Services\AuditService;

class AuthService
{
    private $pdo;
    private TokenService $tokenService;
    private ExceptionHandler $exceptionHandler;
    private LoggerInterface $logger;
    private AuditService $auditService;
    private array $encryptionConfig;
    private Validator $validator;
    private User $userModel;

    public function __construct(
        DatabaseHelper $dbHelper,
        TokenService $tokenService,
        ExceptionHandler $exceptionHandler,
        LoggerInterface $logger,
        AuditService $auditService,
        array $encryptionConfig,
        Validator $validator,
        User $userModel
    ) {
        $this->pdo = $dbHelper->getPdo();
        $this->tokenService = $tokenService;
        $this->exceptionHandler = $exceptionHandler;
        $this->logger = $logger;
        $this->auditService = $auditService;
        $this->encryptionConfig = $encryptionConfig;
        $this->validator = $validator;
        $this->userModel = $userModel;

        $this->logger->info("AuthService initialized with app_database connection");
    }

    public function login(array $data)
    {
        try {
            // Use the User model to find by email
            $user = User::findByEmail($data['email']);
            $this->logger->debug("Executing login query for user email: {$data['email']}");
            
            if (!$user || !password_verify($data['password'], $user['password_hash'])) {
                $this->logger->warning("Authentication failed", ['email' => $data['email']]);
                
                // Log failed authentication with unified AuditService
                $this->auditService->logEvent(
                    'auth',
                    'Authentication failed',
                    ['email' => $data['email']],
                    null,
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
                
                throw new Exception("Invalid email or password", 401);
            }

            // Cast user array to object for TokenService
            $userObject = (object)$user;
            $this->logger->debug("User data converted to object", ['type' => gettype($userObject)]);

            $token = $this->tokenService->generateToken($userObject);
            $refreshToken = $this->tokenService->generateRefreshToken($userObject);

            // Store access token in application database
            $this->storeAccessToken($userObject->id, $token);

            // Log successful login with unified AuditService
            $this->auditService->logEvent(
                'auth',
                'Authentication successful',
                ['email' => $user['email'], 'user_id' => $user['id']],
                $user['id'],
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            // Include minimal user information in the result
            return [
                'token'         => $token,
                'refresh_token' => $refreshToken,
                'user_id'       => $user['id'],
                'name'          => $user['name'],
                'email'         => $user['email']
            ];
        } catch (Exception $e) {
            $this->logger->error("[auth] ❌ Login error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function register(array $data)
    {
        try {
            $this->logger->info("Starting registration process", ['email' => $data['email'] ?? 'unknown']);
            
            // Define the validation rules, ensuring surname and confirm_password are required
            $rules = [
                'email'           => 'required|email|unique:users,email',
                'password'        => 'required|min:8',
                'confirm_password'=> 'required|same:password',
                'name'            => 'required|string',
                'surname'         => 'required|string', // Ensure surname is required
                'phone'           => 'string|nullable',
                'address'         => 'string|nullable',
                'pesel_or_id'     => 'string|nullable'
            ];

            // Log sanitized input data (without passwords)
            $logData = $data;
            if (isset($logData['password'])) unset($logData['password']);
            if (isset($logData['confirm_password'])) unset($logData['confirm_password']);
            $this->logger->debug("Registration input data", ['data' => $logData]);
            
            // Validate input data
            $this->validator->validate($data, $rules);
            
            // Check passwords match (redundant with validation but keeping as a double-check)
            if (!isset($data['password']) || !isset($data['confirm_password']) || $data['password'] !== $data['confirm_password']) {
                $this->logger->warning("Passwords don't match during registration");
                throw new Exception("Passwords do not match", 400);
            }
            
            // Prepare user data for creation via model
            $userData = [
                'name' => $data['name'],
                'surname' => $data['surname'],
                'email' => $data['email'],
                'password_hash' => password_hash($data['password'], PASSWORD_BCRYPT, ['cost' => 12]),
                'phone' => $data['phone'] ?? null,
                'address' => $data['address'] ?? null,
                'pesel_or_id' => $data['pesel_or_id'] ?? null,
                'role' => 'user', // Default role, only override if admin is creating the user
                'email_notifications' => $data['email_notifications'] ?? 0,
                'sms_notifications' => $data['sms_notifications'] ?? 0,
                'active' => 1,
                'created_at' => date('Y-m-d H:i:s'),
                'updated_at' => date('Y-m-d H:i:s')
            ];
            
            // Log prepared data (without password_hash)
            $logUserData = $userData;
            unset($logUserData['password_hash']);
            $this->logger->debug("Prepared user data for database", ['data' => $logUserData]);
            
            // Use the User model to create the user
            $userId = $this->userModel->create($userData);
            
            $this->logger->info("User registered successfully", ['user_id' => $userId, 'email' => $data['email']]);
            
            // Log registration with unified AuditService - business logic event
            $this->auditService->logEvent(
                'auth',
                'User registration',
                ['email' => $data['email'], 'name' => $data['name']],
                $userId,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return ['user_id' => $userId];
        } catch (\InvalidArgumentException $e) {
            $this->logger->warning("Validation error during registration", ['error' => $e->getMessage()]);
            throw $e;
        } catch (Exception $e) {
            $this->logger->error("Registration error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function refresh(array $data)
    {
        try {
            // Use the new method to decode the refresh token
            $decoded = $this->tokenService->decodeRefreshToken($data['refresh_token']);
            
            // Use the User model to find user by ID
            $user = $this->userModel->find($decoded->sub);
            $this->logger->debug("Executing refresh query for user ID: {$decoded->sub}");
            
            if (!$user) {
                $this->logger->warning("Invalid refresh token", ['token_sub' => $decoded->sub]);
                throw new Exception("Invalid refresh token", 400);
            }

            // Cast user array to object for TokenService
            $userObject = (object)$user;
            $this->logger->debug("User data converted to object for token refresh", ['type' => gettype($userObject)]);

            $token = $this->tokenService->generateToken($userObject);
            $this->logger->info("Token refreshed successfully", ['user_id' => $user['id']]);
            
            // Store new access token in application database
            $this->storeAccessToken($decoded->sub, $token);

            // Log token refresh with unified AuditService - business logic event
            $this->auditService->logEvent(
                'auth',
                'Token refreshed',
                ['user_id' => $user['id']],
                $user['id'],
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return ['token' => $token];
        } catch (Exception $e) {
            $this->logger->error("Refresh token error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function logout(array $data)
    {
        // Extract user ID from token if available
        $userId = null;
        if (!empty($data['user_id'])) {
            $userId = (int)$data['user_id'];
        }
        
        // Log logout with unified AuditService - business logic event
        $this->auditService->logEvent(
            'auth',
            'User logged out',
            [],
            $userId,
            null,
            $_SERVER['REMOTE_ADDR'] ?? null
        );
        
        return ["message" => "Logged out successfully"];
    }

    public function updateProfile($userId, array $data)
    {
        try {
            // Get current user data
            $user = $this->userModel->find($userId);
            if (!$user) {
                throw new Exception("User not found", 404);
            }
            
            // Prepare update data
            $updateData = [];
            
            // Handle fields that can be updated
            if (isset($data['name'])) {
                $updateData['name'] = $data['name'];
            }
            if (isset($data['surname'])) {
                $updateData['surname'] = $data['surname'];
            }
            if (isset($data['phone'])) {
                $updateData['phone'] = $data['phone'];
            }
            if (isset($data['address'])) {
                $updateData['address'] = $data['address'];
            }
            if (isset($data['email_notifications'])) {
                $updateData['email_notifications'] = (int)$data['email_notifications'];
            }
            if (isset($data['sms_notifications'])) {
                $updateData['sms_notifications'] = (int)$data['sms_notifications'];
            }
            
            // Only update if we have data
            if (!empty($updateData)) {
                $updateData['updated_at'] = date('Y-m-d H:i:s');
                
                // Update the user via model
                $this->userModel->update($userId, $updateData);
                
                // Log the profile update - business logic event
                $this->auditService->logEvent(
                    'auth',
                    'Profile updated',
                    ['user_id' => $userId],
                    $userId,
                    null,
                    $_SERVER['REMOTE_ADDR'] ?? null
                );
                
                return ["message" => "Profile updated successfully"];
            }
            
            return ["message" => "No changes to update"];
        } catch (Exception $e) {
            $this->logger->error("Update profile error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Initiates the password reset process
     */
    public function resetPasswordRequest(array $data): array
    {
        try {
            if (!isset($data['email'])) {
                throw new Exception("Email is required", 400);
            }
            
            // Validate email format
            if (!filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
                throw new Exception("Invalid email format", 400);
            }
            
            // Use the User model to find user by email
            $user = $this->userModel->findByEmail($data['email']);
            $this->logger->debug("Executing password reset request query for email: {$data['email']}");
            
            if (!$user) {
                // Don't reveal that the email doesn't exist (security best practice)
                $this->logger->info("Password reset requested for non-existent email", ['email' => $data['email']]);
                return ["message" => "If your email is registered, you will receive a password reset link"];
            }
            
            // Generate a secure reset token
            $resetToken = bin2hex(random_bytes(32));
            $tokenExpiry = date('Y-m-d H:i:s', time() + 3600); // Token valid for 1 hour
            $ipAddress = $_SERVER['REMOTE_ADDR'] ?? null;
            
            // Store the token using a model method
            $this->userModel->createPasswordReset($user['email'], $resetToken, $ipAddress, $tokenExpiry);
            
            // Log password reset request with unified AuditService - business logic event
            $this->auditService->logEvent(
                'auth',
                'Password reset requested',
                ['email' => $user['email']],
                $user['id'],
                null,
                $ipAddress
            );
            
            // In a real application, you would send an email here
            // For this example, we'll just return the token (not secure for production)
            return [
                "message" => "Password reset email sent",
                "debug_token" => $resetToken // Remove this in production!
            ];
        } catch (Exception $e) {
            $this->logger->error("Password reset request error: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Completes the password reset process
     */
    public function resetPassword(array $data): array
    {
        try {
            // Validate required fields
            if (!isset($data['token']) || !isset($data['password']) || !isset($data['confirm_password'])) {
                throw new Exception("Token, password and confirmation are required", 400);
            }
            
            // Validate password
            if (strlen($data['password']) < 8) {
                throw new Exception("Password must be at least 8 characters", 400);
            }
            
            // Check passwords match
            if ($data['password'] !== $data['confirm_password']) {
                throw new Exception("Passwords do not match", 400);
            }
            
            // Verify token using the User model
            $tokenRecord = $this->userModel->verifyResetToken($data['token']);
            $this->logger->debug("Verifying reset token: {$data['token']}");
            
            if (!$tokenRecord) {
                throw new Exception("Invalid or expired token", 400);
            }
            
            // Get user via model
            $user = $this->userModel->findByEmail($tokenRecord['email']);
            $this->logger->debug("Retrieving user for password reset, email: {$tokenRecord['email']}");
            
            if (!$user) {
                throw new Exception("User not found", 404);
            }
            
            // Update the password via model
            $hashedPassword = password_hash($data['password'], PASSWORD_BCRYPT, ['cost' => 12]);
            $this->userModel->updatePassword($user['id'], $hashedPassword);
            $this->logger->debug("Updating password for user ID: {$user['id']}");
            
            // Mark token as used via model
            $this->userModel->markResetTokenUsed($tokenRecord['id']);
            
            // Log password reset completion with unified AuditService - business logic event
            $this->auditService->logEvent(
                'auth',
                'Password reset completed',
                ['email' => $user['email']],
                $user['id'],
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return ["message" => "Password has been reset successfully"];
        } catch (Exception $e) {
            $this->logger->error("Password reset error: " . $e->getMessage());
            throw $e;
        }
    }

    private function storeAccessToken(int $userId, string $accessToken): void
    {
        try {
            // Store the token in the access_tokens table using app db helper
            $appDb = DatabaseHelper::getInstance();
            $appDb->insert('access_tokens', [
                'user_id' => $userId,
                'token' => hash('sha256', $accessToken), // Store hashed token for security
                'expires_at' => date('Y-m-d H:i:s', time() + 3600),
                'created_at' => date('Y-m-d H:i:s')
            ]);
            
            $this->logger->info("[auth] Access token stored in application database", ['user_id' => $userId]);
        } catch (\Exception $e) {
            $this->logger->error("[auth] Failed to store access token: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            // Continue without failing - JWT will still work even if storage fails
        }
    }
}
?>
=== App/Services/DocumentService.php ===
<?php

namespace DocumentManager\Services;

use Exception;
use App\Helpers\DatabaseHelper;
use AuditManager\Services\AuditService;
use DocumentManager\Services\FileStorage;
use DocumentManager\Services\TemplateService;
use App\Services\EncryptionService;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use App\Models\Document;
use App\Models\DocumentTemplate;
use App\Models\Contract;
use App\Models\User;
use App\Models\Booking;

/**
 * Document Service
 *
 * Manages documents including templates, contracts, and Terms & Conditions (T&C).
 * Supports encryption, secure storage, logging, and dynamic document generation.
 */
class DocumentService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private DatabaseHelper $db;
    private AuditService $auditService;
    private FileStorage $fileStorage;
    private EncryptionService $encryptionService;
    private TemplateService $templateService;
    private Document $documentModel;
    private DocumentTemplate $templateModel;
    private Contract $contractModel;
    private User $userModel;
    private Booking $bookingModel;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        DatabaseHelper $db,
        AuditService $auditService,
        FileStorage $fileStorage,
        EncryptionService $encryptionService,
        TemplateService $templateService,
        Document $documentModel,
        DocumentTemplate $templateModel,
        Contract $contractModel,
        User $userModel,
        Booking $bookingModel
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->db = $db;
        $this->auditService = $auditService;
        $this->fileStorage = $fileStorage;
        $this->encryptionService = $encryptionService;
        $this->templateService = $templateService;
        $this->documentModel = $documentModel;
        $this->templateModel = $templateModel;
        $this->contractModel = $contractModel;
        $this->userModel = $userModel;
        $this->bookingModel = $bookingModel;
    }

    /**
     * Upload a document template.
     */
    public function uploadTemplate(string $name, string $content): void
    {
        $this->processTemplate($name, $content, 'template_uploaded');
    }

    /**
     * Upload the Terms & Conditions document.
     */
    public function uploadTerms(string $content): void
    {
        $this->processTemplate('terms_and_conditions', $content, 'terms_uploaded');
    }

    /**
     * Process template storage and logging.
     */
    private function processTemplate(string $name, string $content, string $logAction): void
    {
        try {
            if (self::DEBUG_MODE) {
                $this->logger->info("[Document] Uploading template: {$name}");
            }
            
            $encryptedContent = $this->encryptionService->encrypt($content);
            $filePath = $this->fileStorage->storeFile("templates", "{$name}.html", $encryptedContent);
            
            // Use template model instead of direct DB access
            $existingTemplate = $this->templateModel->findByName($name);
            
            if ($existingTemplate) {
                // Update existing template
                $this->templateModel->update($existingTemplate['id'], [
                    'content' => $encryptedContent,
                    'file_path' => $filePath,
                    'updated_at' => date('Y-m-d H:i:s')
                ]);
            } else {
                // Create new template
                $this->templateModel->create([
                    'name' => $name,
                    'content' => $encryptedContent,
                    'file_path' => $filePath,
                    'created_at' => date('Y-m-d H:i:s'),
                    'updated_at' => date('Y-m-d H:i:s')
                ]);
            }
            
            // Business-level audit logging - template operations are important business events
            $this->auditService->log($logAction, ['template' => $name]);
            
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Upload template exception: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to upload template: {$name} " . $e->getMessage());
        }
    }

    /**
     * Generate a rental contract document dynamically.
     */
    public function generateContract(int $bookingId, int $userId): string
    {
        try {
            if (self::DEBUG_MODE) {
                $this->logger->info("[Document] Generating contract for booking {$bookingId}");
            }

            // Load the contract template using template model
            $templateData = $this->templateModel->findByName('rental_contract');
            if (!$templateData) {
                throw new Exception("Contract template not found");
            }
            
            // Get user and booking data using models
            $userData = $this->userModel->find($userId);
            $bookingData = $this->bookingModel->find($bookingId);
            
            if (!$userData || !$bookingData) {
                throw new Exception("User or booking data not found");
            }

            // Prepare data for template rendering
            $data = array_merge($userData, $bookingData);
            
            // Decrypt template content and render with data
            $templateContent = $this->encryptionService->decrypt($templateData['content']);
            $renderedContent = $this->templateService->renderTemplateContent($templateContent, $data);

            // Encrypt the rendered content
            $encryptedContract = $this->encryptionService->encrypt($renderedContent);
            
            // Store the file
            $filePath = $this->fileStorage->storeFile("contracts", "contract_{$bookingId}.pdf", $encryptedContract);

            // Store contract record using contract model
            $this->contractModel->create([
                'booking_id'  => $bookingId,
                'user_id'     => $userId,
                'contract_pdf'=> $filePath,
                'created_at'  => date('Y-m-d H:i:s')
            ]);

            // Business-level audit log for contract generation - important business event
            $this->auditService->log('contract_generated', [
                'booking_id' => $bookingId, 
                'user_id' => $userId
            ]);

            return $filePath;
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Contract generation error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Retrieve and decrypt a document.
     */
    public function retrieveDocument(string $filePath): string
    {
        try {
            if (self::DEBUG_MODE) {
                $this->logger->info("[Document] Retrieving document from {$filePath}");
            }

            $encryptedContent = $this->fileStorage->retrieveFile($filePath);
            $decryptedContent = $this->encryptionService->decrypt($encryptedContent);

            // Business-level audit log for document retrieval - security-sensitive event
            $this->auditService->log('document_retrieved', ['file_path' => $filePath]);

            return $decryptedContent;
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Retrieve document error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to retrieve document " . $e->getMessage());
        }
    }

    /**
     * Delete a document.
     */
    public function deleteDocument(int $documentId): void
    {
        try {
            if (self::DEBUG_MODE) {
                $this->logger->info("[Document] Deleting document ID {$documentId}");
            }

            // Get document using model
            $document = $this->documentModel->find($documentId);

            if (!$document) {
                throw new Exception("Document not found.");
            }

            // Delete the physical file
            $this->fileStorage->deleteFile($document['file_path']);
            
            // Delete the document record using model
            $this->documentModel->delete($documentId);

            // Business-level audit log for document deletion - security-sensitive event
            $this->auditService->log('document_deleted', ['document_id' => $documentId]);
            
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Delete document error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to delete document " . $e->getMessage());
        }
    }

    /**
     * Get a list of available templates.
     */
    public function getTemplates(): array
    {
        try {
            // Use template model to get all templates
            $templates = $this->templateModel->getAll();
            
            // Return only necessary information, not the entire model
            return array_map(function($template) {
                return [
                    'id' => $template['id'],
                    'name' => $template['name'],
                    'created_at' => $template['created_at'],
                    'updated_at' => $template['updated_at']
                ];
            }, $templates);
            
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Get templates error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
    
    /**
     * Get a specific template by ID.
     */
    public function getTemplateById(int $templateId): array
    {
        try {
            // Use template model to get template by ID
            $template = $this->templateModel->find($templateId);
            
            if (!$template) {
                throw new Exception("Template not found.");
            }
            
            // Decrypt the content for use
            $template['content'] = $this->encryptionService->decrypt($template['content']);
            
            return $template;
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Get template error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
    
    /**
     * Get contracts for a specific user.
     */
    public function getUserContracts(int $userId): array
    {
        try {
            // Use contract model to get user contracts
            $contracts = $this->contractModel->getByUserId($userId);
            
            return $contracts;
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Get user contracts error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
    
    /**
     * Get contract for a specific booking.
     */
    public function getBookingContract(int $bookingId): array
    {
        try {
            // Use contract model to get booking contract
            $contract = $this->contractModel->getByBookingId($bookingId);
            
            if (!$contract) {
                throw new Exception("Contract not found for booking.");
            }
            
            return $contract;
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Get booking contract error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }
}
=== App/Services/NotificationService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use App\Models\Notification;
use Psr\Log\LoggerInterface;
use PHPMailer\PHPMailer\PHPMailer;
use PHPMailer\PHPMailer\Exception;
use App\Helpers\ExceptionHandler;

/**
 * NotificationService
 *
 * Handles various notification types (email, SMS, webhook, push notifications).
 */
class NotificationService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private array $config;
    private DatabaseHelper $db;
    private Notification $notificationModel;

    public function __construct(
        LoggerInterface $logger, 
        ExceptionHandler $exceptionHandler, 
        DatabaseHelper $db, 
        Notification $notificationModel,
        array $config
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->db = $db;
        $this->notificationModel = $notificationModel;
        $this->config = $config;
    }

    /**
     * Send a notification
     */
    public function sendNotification(int $userId, string $type, string $message, array $options = []): bool
    {
        try {
            $this->storeNotification($userId, $type, $message);
            // Business-level logging - keep this separate from model-level audit
            if (self::DEBUG_MODE) {
                $this->logger->info('Notification prepared for dispatch', ['user_id' => $userId, 'type' => $type]);
            }
            return $this->dispatchNotification($userId, $type, $message, $options);
        } catch (\Exception $e) {
            $this->logger->error('Failed to send notification', ['error' => $e->getMessage()]);
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Store notification in the database
     */
    private function storeNotification(int $userId, string $type, string $message): void
    {
        try {
            // Use the model to create the notification - model handles audit logging
            $this->notificationModel->create([
                'user_id' => $userId,
                'type'    => $type,
                'message' => $message,
                'sent_at' => date('Y-m-d H:i:s'),
                'is_read' => false,
            ]);
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ storeNotification error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function getUserNotifications(int $userId): array
    {
        try {
            // Use the model to get user notifications
            $notifications = $this->notificationModel->getByUserId($userId);
            
            // Business-level logging
            if (self::DEBUG_MODE) {
                $this->logger->info("[Notification] Retrieved notifications for user {$userId}");
            }
            
            return $notifications;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ getUserNotifications error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function markAsRead(int $notificationId): bool
    {
        try {
            // Use the model to mark notification as read - model handles audit logging
            $result = $this->notificationModel->markAsRead($notificationId);
            
            // Business-level logging
            if (self::DEBUG_MODE && $result) {
                $this->logger->info("[Notification] Marked notification {$notificationId} as read");
            }
            
            return $result;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ markAsRead error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function deleteNotification(int $notificationId): bool
    {
        try {
            // Use the model to delete notification - model handles audit logging
            $result = $this->notificationModel->delete($notificationId);
            
            // Business-level logging
            if (self::DEBUG_MODE && $result) {
                $this->logger->info("[Notification] Deleted notification {$notificationId}");
            }
            
            return $result;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ deleteNotification error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function markAllAsRead(int $userId): bool
    {
        try {
            // Use the model to mark all notifications as read - model handles audit logging
            $result = $this->notificationModel->markAllAsRead($userId);
            
            // Business-level logging
            if (self::DEBUG_MODE && $result) {
                $this->logger->info("[Notification] Marked all notifications as read for user {$userId}");
            }
            
            return $result;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ markAllAsRead error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Dispatch the appropriate notification method
     */
    private function dispatchNotification(int $userId, string $type, string $message, array $options): bool
    {
        $result = false;
        
        try {
            $result = match ($type) {
                'email' => $this->sendEmail($options['email'] ?? '', $message, $options['subject'] ?? 'Notification'),
                'sms' => $this->sendSMS($options['phone'] ?? '', $message),
                'webhook' => $this->sendWebhook($options['url'] ?? '', $message),
                'push' => $this->sendPushNotification($options['device_token'] ?? '', $message),
                default => throw new \InvalidArgumentException("Unsupported notification type: $type"),
            };
            
            // Business-level logging of success/failure
            if (self::DEBUG_MODE) {
                if ($result) {
                    $this->logger->info("[Notification] Successfully sent {$type} notification to user {$userId}");
                } else {
                    $this->logger->warning("[Notification] Failed to send {$type} notification to user {$userId}");
                }
            }
            
            return $result;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ Dispatch error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Send an email using PHPMailer
     */
    private function sendEmail(string $to, string $message, string $subject): bool
    {
        if (empty($to)) return false;

        try {
            $mail = new PHPMailer(true);
            $mail->isSMTP();
            $mail->Host = $this->config['smtp_host'];
            $mail->SMTPAuth = true;
            $mail->Username = $this->config['smtp_user'];
            $mail->Password = $this->config['smtp_password'];
            $mail->SMTPSecure = $this->config['smtp_secure'] ?? 'tls';
            $mail->Port = $this->config['smtp_port'];
            $mail->setFrom($this->config['from_email'], $this->config['from_name']);
            $mail->addAddress($to);
            $mail->Subject = $subject;
            $mail->isHTML(true);
            $mail->Body = "<p>$message</p>";
            $mail->send();

            // Business-level logging only - no need for audit here
            if (self::DEBUG_MODE) {
                $this->logger->info("[Notification] Email sent to {$to}");
            }

            return true;
        } catch (Exception $e) {
            $this->logger->error("[Notification] ❌ Email error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Send an SMS
     */
    private function sendSMS(string $phone, string $message): bool
    {
        if (empty($phone)) return false;

        try {
            // SMS implementation code would go here
            
            // Business-level logging only
            if (self::DEBUG_MODE) {
                $this->logger->info("[Notification] SMS sent to {$phone}");
            }
            return true;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ SMS error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Send a webhook notification
     */
    private function sendWebhook(string $url, string $message): bool
    {
        if (empty($url)) return false;

        try {
            $ch = curl_init($url);
            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
            curl_setopt($ch, CURLOPT_POST, true);
            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode(['message' => $message]));
            curl_setopt($ch, CURLOPT_HTTPHEADER, ['Content-Type: application/json']);
            $response = curl_exec($ch);
            curl_close($ch);

            // Business-level logging only
            if (self::DEBUG_MODE && $response !== false) {
                $this->logger->info("[Notification] Webhook sent to {$url}");
            }

            return $response !== false;
        } catch (\Exception $e) {
            $this->logger->error('[Notification] ❌ Webhook error: ' . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Send a push notification
     */
    private function sendPushNotification(string $deviceToken, string $message): bool
    {
        if (empty($deviceToken)) return false;

        try {
            $payload = [
                'to' => $deviceToken,
                'notification' => ['title' => 'Notification', 'body' => $message],
            ];
            
            $result = $this->sendFCMRequest($payload);
            
            // Business-level logging only
            if (self::DEBUG_MODE && $result) {
                $this->logger->info("[Notification] Push notification sent to device {$deviceToken}");
            }
            
            return $result;
        } catch (\Exception $e) {
            $this->logger->error('[Notification] ❌ Push notification error: ' . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Send Firebase Cloud Messaging (FCM) request
     */
    private function sendFCMRequest(array $payload): bool
    {
        $ch = curl_init('https://fcm.googleapis.com/fcm/send');
        curl_setopt($ch, CURLOPT_HTTPHEADER, [
            'Content-Type: application/json',
            'Authorization: key=' . $this->config['fcm_api_key'],
        ]);
        curl_setopt($ch, CURLOPT_POST, true);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($payload));
        $response = curl_exec($ch);

        curl_close($ch);
        return $response !== false;
    }
    
    /**
     * Get notification by ID
     */
    public function getNotificationById(int $id): ?array
    {
        try {
            $notification = $this->notificationModel->find($id);
            return $notification;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ getNotificationById error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }
    
    /**
     * Get unread notifications count for user
     */
    public function getUnreadCount(int $userId): int
    {
        try {
            $count = $this->notificationModel->getUnreadCount($userId);
            return $count;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ getUnreadCount error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return 0;
        }
    }
}
=== App/Services/AuditService.php ===
<?php

namespace App\Services;

use Exception;
use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class AuditService
{
    // Define standard log categories as constants
    public const CATEGORY_SYSTEM = 'system';
    public const CATEGORY_AUTH = 'auth';
    public const CATEGORY_TRANSACTION = 'transaction';
    public const CATEGORY_BOOKING = 'booking';
    public const CATEGORY_USER = 'user';
    public const CATEGORY_ADMIN = 'admin';
    public const CATEGORY_DOCUMENT = 'document';
    public const CATEGORY_API = 'api';
    public const CATEGORY_SECURITY = 'security';

    public const DEBUG_MODE = true;
    private $db;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        DatabaseHelper $db
    ) {
        $this->db = $db;
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;

        // Log the database instance being used
        $this->logger->info("AuditService initialized with database instance", [
            'database' => $db === DatabaseHelper::getSecureInstance() ? 'secure_db' : 'db'
        ]);
    }

    /**
     * Unified method to log events across the system to a single audit_logs table.
     *
     * @param string $category The category of the event (system, transaction, booking, etc.)
     * @param string $message Human-readable message describing the event
     * @param array $context Additional contextual data for the event
     * @param int|null $userId ID of the user associated with the event
     * @param int|null $bookingId ID of the booking associated with the event
     * @param string|null $ipAddress IP address of the user
     * @return void
     * @throws Exception If logging fails
     */
    public function logEvent(
        string $category, 
        string $message, 
        array $context = [], 
        ?int $userId = null, 
        ?int $bookingId = null, 
        ?string $ipAddress = null
    ): void {
        try {
            // Ensure category is standardized
            $category = strtolower(trim($category));
            
            // Prepare data for insertion using DatabaseHelper::insert instead of table()->insert
            $data = [
                'action'             => $category,  // Using action field to store category
                'message'            => $message,
                'details'            => json_encode($context, JSON_UNESCAPED_UNICODE),
                'user_reference'     => $userId,
                'booking_reference'  => $bookingId,
                'ip_address'         => $ipAddress,
                'created_at'         => date('Y-m-d H:i:s') // Replace now() function with PHP date
            ];
            
            // Log the data array before insertion
            $this->logger->info("[Audit] Data to be inserted: ", $data);
            
            // Log the query being executed
            $this->logger->info("[Audit] Executing query: INSERT INTO audit_logs", $data);
            
            // Use DatabaseHelper::insert with secure database
            $insertId = DatabaseHelper::insert('audit_logs', $data, true);
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Audit] Logged {$category} event: {$message}", [
                    'user_reference' => $userId,
                    'booking_reference' => $bookingId,
                    'insert_id' => $insertId
                ]);
            }
        } catch (Exception $e) {
            $this->logger->error("[Audit] ❌ logEvent error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception('Failed to log event: ' . $e->getMessage());
        }
    }

    /**
     * Legacy method to log an action.
     * @deprecated Use logEvent() instead for new code
     */
    public function log(
        string $action,
        string $message,
        array $details = [],
        ?int $userId = null,
        ?int $bookingId = null,
        ?string $ipAddress = null
    ): void {
        // For backward compatibility, call the new unified method
        $this->logEvent($action, $message, $details, $userId, $bookingId, $ipAddress);
    }

    /**
     * Retrieve logs from the unified audit_logs table with applied filters.
     *
     * @param array $filters Various filters to apply (category, user_id, etc.)
     * @return array Paginated result containing logs and pagination metadata
     * @throws Exception If fetching logs fails
     */
    public function getLogs(array $filters = []): array
    {
        try {
            // Build WHERE clause and parameters for both count and select queries
            $whereClause = "1=1"; // Always true condition to start with
            $params = [];
            
            // Apply filters
            if (!empty($filters['user_id'])) {
                $whereClause .= " AND user_reference = ?";
                $params[] = $filters['user_id'];
            }
            
            if (!empty($filters['booking_id'])) {
                $whereClause .= " AND booking_reference = ?";
                $params[] = $filters['booking_id'];
            }
            
            // Support both 'category' and 'action' fields
            if (!empty($filters['category'])) {
                $whereClause .= " AND action = ?";
                $params[] = $filters['category'];
            } elseif (!empty($filters['action'])) {
                $whereClause .= " AND action = ?";
                $params[] = $filters['action'];
            }
            
            // Date range filters
            if (!empty($filters['start_date'])) {
                $whereClause .= " AND created_at >= ?";
                $params[] = $filters['start_date'];
            }
            
            if (!empty($filters['end_date'])) {
                $whereClause .= " AND created_at <= ?";
                $params[] = $filters['end_date'];
            }
            
            // Message search
            if (!empty($filters['search'])) {
                $whereClause .= " AND message LIKE ?";
                $params[] = '%' . $filters['search'] . '%';
            }
            
            // Get total count first (for pagination)
            $countSql = "SELECT COUNT(*) as total FROM audit_logs WHERE {$whereClause}";
            $this->logger->info("[Audit] Executing count query: {$countSql}", $params);
            $countResult = DatabaseHelper::select($countSql, $params);
            $totalItems = isset($countResult[0]['total']) ? (int)$countResult[0]['total'] : 0;
            
            // Pagination parameters
            $page = isset($filters['page']) ? max(1, (int)$filters['page']) : 1;
            $perPage = isset($filters['per_page']) ? max(1, (int)$filters['per_page']) : 10;
            $offset = ($page - 1) * $perPage;
            $totalPages = ceil($totalItems / $perPage);
            
            // Custom sort options
            $allowedSortFields = ['id', 'action', 'message', 'user_reference', 'booking_reference', 'created_at'];
            $sortField = in_array($filters['sort_field'] ?? '', $allowedSortFields) ? $filters['sort_field'] : 'created_at';
            $sortOrder = strtoupper($filters['sort_order'] ?? 'desc') === 'ASC' ? 'ASC' : 'DESC';
            
            // Build and execute the main query
            $sql = "SELECT * FROM audit_logs WHERE {$whereClause} ORDER BY {$sortField} {$sortOrder} LIMIT {$perPage} OFFSET {$offset}";
            $this->logger->info("[Audit] Executing select query: {$sql}", $params);
            $logs = DatabaseHelper::select($sql, $params);
            
            // Process the results - parse JSON details
            foreach ($logs as &$log) {
                if (isset($log['details']) && is_string($log['details'])) {
                    $log['details'] = json_decode($log['details'], true);
                }
            }
            
            // Create a custom paginated result array
            return [
                'data' => $logs,
                'pagination' => [
                    'total' => $totalItems,
                    'per_page' => $perPage,
                    'current_page' => $page,
                    'last_page' => $totalPages,
                    'from' => $offset + 1,
                    'to' => min($offset + $perPage, $totalItems),
                ]
            ];
            
        } catch (Exception $e) {
            $this->logger->error("[Audit] ❌ getLogs error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception('Failed to get logs: ' . $e->getMessage());
        }
    }

    /**
     * Retrieve a single log entry by ID from the audit_logs table.
     * 
     * @param int $logId The ID of the log entry
     * @return array|null The log entry
     * @throws Exception If the log entry is not found
     */
    public function getLogById(int $logId)
    {
        try {
            // Use DatabaseHelper::select instead of $this->db->table()->where()->first()
            $sql = "SELECT * FROM audit_logs WHERE id = ? LIMIT 1";
            $this->logger->info("[Audit] Executing select query: {$sql}", [$logId]);
            $logs = DatabaseHelper::select($sql, [$logId]);
            $log = !empty($logs) ? $logs[0] : null;
            
            if (!$log) {
                throw new Exception('Log entry not found.');
            }
            
            // Parse JSON details if present
            if (isset($log['details']) && is_string($log['details'])) {
                $log['details'] = json_decode($log['details'], true);
            }
            
            return $log;
        } catch (Exception $e) {
            $this->logger->error("[Audit] ❌ getLogById error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception('Failed to retrieve log: ' . $e->getMessage());
        }
    }

    /**
     * Delete logs from the audit_logs table based on specific filters.
     * 
     * @param array $filters Filters to determine which logs to delete
     * @return int Number of logs deleted
     * @throws Exception If deletion fails
     */
    public function deleteLogs(array $filters): int
    {
        try {
            // Build WHERE clause and parameters
            $whereClause = "1=1";
            $params = [];
            
            // Apply filters
            if (!empty($filters['user_id'])) {
                $whereClause .= " AND user_reference = ?";
                $params[] = $filters['user_id'];
            }
            
            if (!empty($filters['booking_id'])) {
                $whereClause .= " AND booking_reference = ?";
                $params[] = $filters['booking_id'];
            }
            
            // Support both 'category' and 'action' fields
            if (!empty($filters['category'])) {
                $whereClause .= " AND action = ?";
                $params[] = $filters['category'];
            } elseif (!empty($filters['action'])) {
                $whereClause .= " AND action = ?";
                $params[] = $filters['action'];
            }
            
            // Date range filters
            if (!empty($filters['start_date'])) {
                $whereClause .= " AND created_at >= ?";
                $params[] = $filters['start_date'];
            }
            
            if (!empty($filters['end_date'])) {
                $whereClause .= " AND created_at <= ?";
                $params[] = $filters['end_date'];
            }
            
            // Use DatabaseHelper::safeQuery for custom DELETE query
            $sql = "DELETE FROM audit_logs WHERE {$whereClause}";
            $this->logger->info("[Audit] Executing delete query: {$sql}", $params);
            $deleted = DatabaseHelper::safeQuery(function ($pdo) use ($sql, $params) {
                $stmt = $pdo->prepare($sql);
                $stmt->execute($params);
                return $stmt->rowCount();
            });
            
            if (self::DEBUG_MODE) {
                $this->logger->info("[Audit] Deleted {$deleted} logs with filters: " . json_encode($filters));
            }
            
            return $deleted;
        } catch (Exception $e) {
            $this->logger->error("[Audit] ❌ deleteLogs error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception('Failed to delete logs: ' . $e->getMessage());
        }
    }
    
    /**
     * Export logs to a CSV file based on provided filters.
     * 
     * @param array $filters Filters to determine which logs to export
     * @return string Path to the exported CSV file
     * @throws Exception If export fails
     */
    public function exportLogs(array $filters): string
    {
        try {
            // Build WHERE clause and parameters
            $whereClause = "1=1";
            $params = [];
            
            // Apply the same filters as in getLogs
            if (!empty($filters['user_id'])) {
                $whereClause .= " AND user_reference = ?";
                $params[] = $filters['user_id'];
            }
            
            if (!empty($filters['booking_id'])) {
                $whereClause .= " AND booking_reference = ?";
                $params[] = $filters['booking_id'];
            }
            
            if (!empty($filters['category'])) {
                $whereClause .= " AND action = ?";
                $params[] = $filters['category'];
            } elseif (!empty($filters['action'])) {
                $whereClause .= " AND action = ?";
                $params[] = $filters['action'];
            }
            
            if (!empty($filters['start_date'])) {
                $whereClause .= " AND created_at >= ?";
                $params[] = $filters['start_date'];
            }
            
            if (!empty($filters['end_date'])) {
                $whereClause .= " AND created_at <= ?";
                $params[] = $filters['end_date'];
            }
            
            // Use DatabaseHelper::select instead of query builder get()
            $sql = "SELECT * FROM audit_logs WHERE {$whereClause} ORDER BY created_at DESC";
            $this->logger->info("[Audit] Executing select query for export: {$sql}", $params);
            $logs = DatabaseHelper::select($sql, $params);
            
            // Create CSV file
            $filename = 'audit_logs_export_' . date('Y-m-d_His') . '.csv';
            $filepath = sys_get_temp_dir() . '/' . $filename;
            
            $file = fopen($filepath, 'w');
            
            // Write CSV header
            fputcsv($file, ['ID', 'Category', 'Message', 'User Reference', 'Booking Reference', 'IP Address', 'Created At', 'Details']);
            
            // Write data rows
            foreach ($logs as $log) {
                fputcsv($file, [
                    $log['id'],
                    $log['action'],
                    $log['message'],
                    $log['user_reference'],
                    $log['booking_reference'],
                    $log['ip_address'],
                    $log['created_at'],
                    $log['details'] // This will be JSON string already
                ]);
            }
            
            fclose($file);
            
            // Log the export action using our refactored logEvent method
            $this->logEvent(
                'system',
                'Audit logs exported',
                ['filters' => $filters, 'count' => count($logs)],
                $_SESSION['user_id'] ?? null,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            
            return $filepath;
        } catch (Exception $e) {
            $this->logger->error("[Audit] ❌ exportLogs error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception('Failed to export logs: ' . $e->getMessage());
        }
    }

    /**
     * Log a user authentication event.
     * 
     * @param int $userId User ID
     * @param string $action Login/Logout/Failed login
     * @param array $context Additional context (device, browser, etc)
     * @param string|null $ipAddress User's IP address
     * @return void
     */
    public function logAuthEvent(int $userId, string $action, array $context = [], ?string $ipAddress = null): void
    {
        $message = "User authentication: {$action}";
        $this->logEvent(
            self::CATEGORY_AUTH,
            $message,
            $context,
            $userId,
            null,
            $ipAddress ?? $_SERVER['REMOTE_ADDR'] ?? null
        );
    }

    /**
     * Log a user action (CRUD operation on resources).
     * 
     * @param int|null $userId User ID
     * @param string $action The action performed (create, update, delete)
     * @param string $resource The resource type (user, booking, document)
     * @param int|null $resourceId The ID of the resource
     * @param array $changes The changes made (before/after)
     * @return void
     */
    public function logUserAction(?int $userId, string $action, string $resource, ?int $resourceId = null, array $changes = []): void
    {
        $message = "User {$action} {$resource}" . ($resourceId ? " #{$resourceId}" : "");
        
        $context = [
            'resource_type' => $resource,
            'resource_id' => $resourceId,
            'changes' => $changes
        ];
        
        $this->logEvent(
            self::CATEGORY_USER,
            $message,
            $context,
            $userId,
            null,
            $_SERVER['REMOTE_ADDR'] ?? null
        );
    }

    /**
     * Log a booking-related event.
     * 
     * @param int $bookingId Booking ID
     * @param string $action The action performed
     * @param int|null $userId User who performed the action
     * @param array $context Additional context
     * @return void
     */
    public function logBookingEvent(int $bookingId, string $action, ?int $userId = null, array $context = []): void
    {
        $message = "Booking #{$bookingId}: {$action}";
        
        $this->logEvent(
            self::CATEGORY_BOOKING,
            $message,
            $context,
            $userId,
            $bookingId,
            $_SERVER['REMOTE_ADDR'] ?? null
        );
    }

    /**
     * Log an API request/response.
     * 
     * @param string $endpoint API endpoint
     * @param string $method HTTP method
     * @param array $requestData Request data
     * @param array $responseData Response data
     * @param int $statusCode HTTP status code
     * @param int|null $userId User ID if authenticated
     * @return void
     */
    public function logApiRequest(
        string $endpoint,
        string $method,
        array $requestData = [],
        array $responseData = [],
        int $statusCode = 200,
        ?int $userId = null
    ): void {
        // Remove sensitive information
        unset($requestData['password'], $requestData['token']);
        
        $message = "{$method} {$endpoint} - Status: {$statusCode}";
        
        $context = [
            'method' => $method,
            'endpoint' => $endpoint,
            'request' => $requestData,
            'response' => $responseData,
            'status_code' => $statusCode
        ];
        
        $this->logEvent(
            self::CATEGORY_API,
            $message,
            $context,
            $userId,
            null,
            $_SERVER['REMOTE_ADDR'] ?? null
        );
    }

    /**
     * Log a system event (startup, shutdown, error).
     * 
     * @param string $eventType Type of system event
     * @param string $message Event message
     * @param array $context Additional context
     * @return void
     */
    public function logSystemEvent(string $eventType, string $message, array $context = []): void
    {
        $this->logEvent(
            self::CATEGORY_SYSTEM,
            "{$eventType}: {$message}",
            $context,
            null,
            null,
            null
        );
    }

    /**
     * Log a security-related event.
     * 
     * @param string $eventType Security event type
     * @param string $message Event details
     * @param array $context Additional context
     * @param int|null $userId Associated user ID
     * @return void
     */
    public function logSecurityEvent(string $eventType, string $message, array $context = [], ?int $userId = null): void
    {
        $this->logEvent(
            self::CATEGORY_SECURITY,
            "{$eventType}: {$message}",
            $context,
            $userId,
            null,
            $_SERVER['REMOTE_ADDR'] ?? null
        );
    }

    /**
     * Get current request information for audit logs.
     * 
     * @return array Request information
     */
    public static function getRequestInfo(): array
    {
        return [
            'method' => $_SERVER['REQUEST_METHOD'] ?? 'UNKNOWN',
            'uri' => $_SERVER['REQUEST_URI'] ?? 'UNKNOWN',
            'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? 'UNKNOWN',
            'referer' => $_SERVER['HTTP_REFERER'] ?? null,
            'ip_address' => $_SERVER['REMOTE_ADDR'] ?? 'UNKNOWN',
        ];
    }
}
=== App/Services/README.md ===
# Token Validation Changes

## TokenValidator Deprecation

The `TokenValidator` class has been deprecated in favor of the more robust `TokenService` class. This change centralizes all token-related functionality into a single service class, making the codebase more maintainable and testable.

## Migration Guide

### Before

```php
use App\Helpers\TokenValidator;

// In controllers
$user = TokenValidator::validateToken($request->getHeader('Authorization'));
if (!$user) {
    // Handle unauthorized access
}
```

### After

```php
use App\Services\Auth\TokenService;

// In constructor
private TokenService $tokenService;

public function __construct(TokenService $tokenService, /* other dependencies */) {
    $this->tokenService = $tokenService;
    // ...
}

// In controller methods
$user = $this->tokenService->validateTokenFromHeader($request->getHeader('Authorization')[0] ?? null);
// or
$user = $this->tokenService->validateRequest($request);

if (!$user) {
    // Handle unauthorized access
}
```

## New TokenService Methods

- `validateTokenFromHeader($tokenHeader)` - Validates a token from an Authorization header
- `extractToken($request)` - Extracts a token from various request formats
- `validateRequest($request)` - Validates a token and returns user data in one step
- `verifyToken($token)` - Verifies JWT token and returns decoded payload

## Benefits

1. **Centralized Logic**: All token operations are now in one service
2. **Dependency Injection**: The service can be properly injected, allowing for easier testing
3. **Consistent Error Handling**: All token errors are handled consistently
4. **Audit Logging**: Token validations are now logged in the audit trail

## Automatic Compatibility

To ease migration, a compatibility layer has been added to the old `TokenValidator` class that delegates to `TokenService`. However, you should update your code to use `TokenService` directly, as the compatibility layer will be removed in a future release.
=== App/Services/TransactionService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class TransactionService
{
    public const DEBUG_MODE = true;
    private DatabaseHelper $db;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    // Constructor for dependency injection
    public function __construct(LoggerInterface $logger, DatabaseHelper $db, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->db = $db;
        $this->exceptionHandler = $exceptionHandler;
    }

    public function getByUserId(int $userId): array
    {
        try {
            $transactions = $this->db->table('transaction_logs')
                                     ->where('user_id', $userId)
                                     ->orderBy('created_at', 'desc')
                                     ->get()
                                     ->toArray();
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Retrieved transactions", ['userId' => $userId]);
            }
            return $transactions;
        } catch (\Exception $e) {
            $this->logger->error("[db] ❌ Error retrieving transactions: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return [];
        }
    }

    public function create(array $data): void
    {
        try {
            $this->db->table('transaction_logs')->insert([
                'user_id'    => $data['user_id'],
                'booking_id' => $data['booking_id'],
                'amount'     => $data['amount'],
                'type'       => $data['type'],
                'status'     => $data['status'],
                'created_at' => date('Y-m-d H:i:s'),
            ]);
            $this->logger->info("Transaction created", ['userId' => $data['user_id']]);
        } catch (\Exception $e) {
            $this->logger->error("Database error while creating transaction", ['error' => $e->getMessage()]);
            throw $e;
        }
    }

    public function updateStatus(int $transactionId, string $status): void
    {
        try {
            $this->db->table('transaction_logs')
                     ->where('id', $transactionId)
                     ->update(['status' => $status, 'updated_at' => date('Y-m-d H:i:s')]);
            $this->logger->info("Updated transaction status", ['transactionId' => $transactionId, 'status' => $status]);
        } catch (\Exception $e) {
            $this->logger->error("Database error while updating transaction status", ['error' => $e->getMessage()]);
            throw $e;
        }
    }
}
=== App/Services/EncryptionService.php ===
<?php

namespace App\Services;

use Illuminate\Support\Facades\Crypt;
use Illuminate\Support\Facades\Storage;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class EncryptionService
{
    public const DEBUG_MODE = true;

    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private string $encryptionKey;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        string $encryptionKey
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->encryptionKey = $encryptionKey;
    }

    public function encrypt(string $data): string
    {
        try {
            return Crypt::encryptString($data);
        } catch (\Exception $e) {
            $this->logger->error("[Encryption] ❌ Encryption failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function decrypt(string $encryptedData): ?string
    {
        try {
            return Crypt::decryptString($encryptedData);
        } catch (\Exception $e) {
            $this->logger->error("[Encryption] ❌ Decryption failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }

    public function encryptFile(string $inputFile, string $outputFile): bool
    {
        try {
            $data = file_get_contents($inputFile);
            if ($data === false) {
                throw new \RuntimeException("Failed to read file: $inputFile");
            }
            $encrypted = Crypt::encryptString($data);
            Storage::put($outputFile, $encrypted);
            return true;
        } catch (\Exception $e) {
            $this->logger->error("File encryption failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    public function decryptFile(string $inputFile, string $outputFile): bool
    {
        try {
            $encryptedData = Storage::get($inputFile);
            $decrypted = Crypt::decryptString($encryptedData);
            Storage::put($outputFile, $decrypted);
            return true;
        } catch (\Exception $e) {
            $this->logger->error("File decryption failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    public function sign(string $data): string
    {
        return hash_hmac('sha256', $data, $this->encryptionKey);
    }

    public function verify(string $data, string $signature): bool
    {
        return hash_equals($this->sign($data), $signature);
    }
}
=== App/Services/FileStorage.php ===
<?php

namespace App\Services;

use Exception;
use App\Services\EncryptionService;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class FileStorage
{
    public const DEBUG_MODE = true;
    private string $basePath;
    private array $config;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private EncryptionService $encryptionService;

    public function __construct(
        array $config,
        EncryptionService $encryptionService,
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->config = $config;
        $this->encryptionService = $encryptionService;
        $this->basePath = rtrim($config['base_directory'], DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;

        if (!is_dir($this->basePath) || !is_writable($this->basePath)) {
            throw new Exception("Invalid storage base path or insufficient permissions: {$this->basePath}");
        }
    }

    public function storeFile(string $directory, string $fileName, string $content, bool $encrypt = false): string
    {
        $safeDirectory = $this->getDirectoryPath($directory);
        $safeFileName = $this->sanitizeFileName($fileName);
        $filePath = $safeDirectory . $safeFileName;

        if ($encrypt) {
            $content = $this->encryptionService->encrypt($content);
        }

        try {
            if (file_put_contents($filePath, $content) === false) {
                throw new Exception("Failed to store file: $fileName");
            }

            chmod($filePath, $this->config['security']['permissions']['default']);
            if (self::DEBUG_MODE) {
                $this->logger->info("[FileStorage] File stored: {$fileName}");
            }

            return $filePath;
        } catch (\Exception $e) {
            $this->logger->error("[FileStorage] ❌ Failed to store file: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function retrieveFile(string $filePath, bool $decrypt = false): string
    {
        try {
            if (!file_exists($filePath) || !is_readable($filePath)) {
                throw new Exception("File not found or not readable: $filePath");
            }

            $content = file_get_contents($filePath);
            if ($content === false) {
                throw new Exception("Failed to retrieve file: $filePath");
            }

            if ($decrypt) {
                $content = $this->encryptionService->decrypt($content);
                if ($content === null) {
                    throw new Exception("Failed to decrypt file: $filePath");
                }
            }

            if (self::DEBUG_MODE) {
                $this->logger->info("[FileStorage] File retrieved: {$filePath}");
            }
            return $content;
        } catch (\Exception $e) {
            $this->logger->error("[FileStorage] ❌ Failed to retrieve file: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function deleteFile(string $filePath): void
    {
        try {
            if (!file_exists($filePath)) {
                throw new Exception("File not found: $filePath");
            }

            if (!unlink($filePath)) {
                throw new Exception("Failed to delete file: $filePath");
            }

            if (self::DEBUG_MODE) {
                $this->logger->info("[FileStorage] File deleted: {$filePath}");
            }
        } catch (\Exception $e) {
            $this->logger->error("[FileStorage] ❌ Failed to delete file: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    private function sanitizeFileName(string $fileName): string
    {
        return preg_replace('/[^a-zA-Z0-9_\.-]/', '_', $fileName);
    }

    private function getDirectoryPath(string $directory): string
    {
        $path = $this->basePath . trim($directory, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;

        if (!is_dir($path) && !mkdir($path, 0755, true)) {
            $this->logger->error("❌ Failed to create directory.", ['path' => $path, 'trace' => debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS)]);
            throw new Exception("Failed to create directory: $path");
        }

        if (!is_writable($path)) {
            $this->logger->error("❌ Directory is not writable.", ['path' => $path, 'trace' => debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS)]);
            throw new Exception("Directory is not writable: $path");
        }

        return $path;
    }
}
=== App/Services/RateLimiter.php ===
<?php

namespace App\Services;

use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

/**
 * Rate Limiter Service
 *
 * Implements IP-based rate limiting.
 */
class RateLimiter
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    public function __construct(LoggerInterface $logger, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
    }

    public function isRateLimited(string $ip): bool
    {
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }
        if (!isset($_SESSION['rate_limit'])) {
            $_SESSION['rate_limit'] = [];
        }
        $attempts = $_SESSION['rate_limit'][$ip] ?? 0;
        if ($attempts >= 5) {
            if (self::DEBUG_MODE) {
                $this->logger->warning("[security] Rate limit exceeded for IP: {$ip}", ['category' => 'security']);
            }
            return true;
        }
        return false;
    }

    public function recordFailedAttempt(string $ip): void
    {
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }
        if (!isset($_SESSION['rate_limit'])) {
            $_SESSION['rate_limit'] = [];
        }
        $_SESSION['rate_limit'][$ip] = ($_SESSION['rate_limit'][$ip] ?? 0) + 1;
        if (self::DEBUG_MODE) {
            $this->logger->info("[security] Recorded failed attempt for IP: {$ip}", ['category' => 'security']);
        }
    }
}
=== App/Services/RevenueService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use App\Models\Payment;
use App\Models\TransactionLog;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class RevenueService
{
    public const DEBUG_MODE = true;
    private $db;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    // Assume dependency injection now supplies the logger.
    public function __construct(LoggerInterface $logger, DatabaseHelper $db, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->db = $db;
        $this->exceptionHandler = $exceptionHandler;
    }

    public function getMonthlyRevenueTrends(): array
    {
        try {
            $data = $this->db->table('payments')
                ->where('status', 'completed')
                ->selectRaw('DATE_FORMAT(created_at, "%Y-%m") as month, SUM(amount) as revenue')
                ->groupBy('month')
                ->orderBy('month')
                ->get();
            $labels = array_column($data, 'month');
            $amounts = array_column($data, 'revenue');
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Retrieved monthly revenue trends", ['category' => 'revenue']);
            }
            return [
                'labels' => $labels,
                'data'   => $amounts,
            ];
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function getTotalRevenue(): float
    {
        try {
            $total = $this->db->table('transaction_logs')
                ->where('type', 'payment')
                ->sum('amount');
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Retrieved total revenue", ['category' => 'revenue']);
            }
            return (float) $total;
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function getTotalRefunds(): float
    {
        try {
            $total = $this->db->table('transaction_logs')
                ->where('type', 'refund')
                ->sum('amount');
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Retrieved total refunds", ['category' => 'revenue']);
            }
            return (float) $total;
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function getNetRevenue(): float
    {
        return $this->getTotalRevenue() - $this->getTotalRefunds();
    }
}
=== App/Services/Security/KeyManager.php ===
<?php

namespace App\Services\Security;

use Exception;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class KeyManager
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private array $keys;

    public function __construct(
        array $keys,
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->keys = $keys;
    }

    public function getKey(string $identifier): string
    {
        $keyName = 'encryption_key_' . strtolower($identifier);

        if (!isset($this->keys[$keyName]) || empty($this->keys[$keyName])) {
            $this->logger->error("[security] ❌ Encryption key for {$identifier} not found.", ['identifier' => $identifier]);
            throw new Exception("Encryption key for {$identifier} not found.");
        }

        return $this->keys[$keyName];
    }

    public function generateKey(): string
    {
        try {
            $key = base64_encode(random_bytes(32)); // AES-256 key
            $this->logger->info('Key generated', ['key_data' => $key]);
            return $key;
        } catch (Exception $e) {
            $this->logger->error('Failed to generate key', ['error' => $e->getMessage()]);
            throw $e;
        }
    }

    public function storeKey(string $identifier, string $key): void
    {
        if (self::DEBUG_MODE) {
            $this->logger->info("[security] Storing key for {$identifier}");
        }
        $this->logger->info("[security] ✅ Storing key for {$identifier}", ['identifier' => $identifier]);
        // Implementation for storing key securely (e.g., database, key vault)
    }

    public function rotateKey(string $identifier): void
    {
        $newKey = $this->generateKey();
        $this->storeKey($identifier, $newKey);
        $this->logger->info("[security] ✅ Rotated key for {$identifier}", ['identifier' => $identifier]);
    }

    public function revokeKey(string $identifier): void
    {
        $this->logger->info("[security] ✅ Revoking key for {$identifier}", ['identifier' => $identifier]);
        // Implementation for revoking key securely
    }
}
=== App/Services/SignatureService.php ===
<?php

namespace App\Services;

use Exception;
use GuzzleHttp\Client;
use Psr\Log\LoggerInterface;
use App\Services\FileStorage;
use App\Services\EncryptionService;
use App\Helpers\DatabaseHelper;
use App\Helpers\ExceptionHandler;

/**
 * Signature Service
 *
 * Manages electronic signatures both locally and via an external AES API.
 */
class SignatureService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private DatabaseHelper $db;
    private string $apiEndpoint;
    private string $apiKey;
    private FileStorage $fileStorage;
    private EncryptionService $encryptionService;
    private ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        DatabaseHelper $db,
        array $config,
        FileStorage $fileStorage,
        EncryptionService $encryptionService,
        ExceptionHandler $exceptionHandler
    ) {
        if (empty($config['api_endpoint']) || empty($config['api_key'])) {
            throw new Exception('AES API configuration is incomplete.');
        }

        $this->logger = $logger;
        $this->db = $db;
        $this->apiEndpoint = $config['api_endpoint'];
        $this->apiKey = $config['api_key'];
        $this->fileStorage = $fileStorage;
        $this->encryptionService = $encryptionService;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Upload a local signature securely.
     */
    public function uploadSignature(string $filePath, int $userId): string
    {
        $this->validateFileType($filePath);

        $encryptedContent = $this->encryptionService->encrypt(file_get_contents($filePath));
        $fileName = uniqid() . '.' . pathinfo($filePath, PATHINFO_EXTENSION);
        $storagePath = $this->fileStorage->storeFile("signatures/{$userId}", $fileName, $encryptedContent, false);

        try {
            $this->db->table('signatures')->insert([
                'user_id'   => $userId,
                'file_path' => $storagePath,
                'encrypted' => true,
                'created_at'=> date('Y-m-d H:i:s'),
            ]);
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Signature record created", ['userId' => $userId, 'storagePath' => $storagePath]);
            }
        } catch (Exception $e) {
            $this->logger->error("[db] ❌ Database error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
        if (self::DEBUG_MODE) {
            $this->logger->info("[system] Signature uploaded", ['userId' => $userId, 'storagePath' => $storagePath]);
        }
        return $storagePath;
    }

    /**
     * Send a document for AES signature.
     */
    public function sendForAdvancedSignature(string $filePath, int $userId, string $callbackUrl): array
    {
        try {
            $documentHash = hash_file('sha256', $filePath);

            $client = new Client();
            $response = $client->post("{$this->apiEndpoint}/sign-aes", [
                'headers' => $this->getAuthHeaders(),
                'multipart' => [
                    ['name' => 'file', 'contents' => fopen($filePath, 'r')],
                    ['name' => 'user_id', 'contents' => $userId],
                    ['name' => 'document_hash', 'contents' => $documentHash],
                    ['name' => 'callback_url', 'contents' => $callbackUrl],
                ],
            ]);

            return json_decode($response->getBody()->getContents(), true);
        } catch (Exception $e) {
            $this->logger->error("[api] Failed to send document for AES signing: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to send document for AES signing: " . $e->getMessage());
        }
    }

    /**
     * Verify an AES signature using Laravel HTTP client.
     */
    public function verifySignature(string $signedFilePath, string $originalFilePath): bool
    {
        try {
            $originalHash = hash_file('sha256', $originalFilePath);
            $signedHash = hash_file('sha256', $signedFilePath);
            
            $client = new Client();
            $response = $client->post("{$this->apiEndpoint}/verify-aes", [
                'headers' => $this->getAuthHeaders(),
                'json' => [
                    'original_hash' => $originalHash,
                    'signed_hash'   => $signedHash,
                ],
            ]);

            $result = json_decode($response->getBody()->getContents(), true);
            if (self::DEBUG_MODE) {
                $this->logger->info("[api] Signature verification", ['result' => $result]);
            }
            return $result['verified'] ?? false;
        } catch (Exception $e) {
            $this->logger->error("[api] Failed to verify signature: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to verify signature: " . $e->getMessage());
        }
    }

    /**
     * Retrieve stored local signatures for a user.
     */
    public function getSignatures(int $userId): array
    {
        $storedSignatures = $this->fileStorage->retrieveFiles("signatures/{$userId}");

        if (empty($storedSignatures)) {
            throw new Exception('No signatures found.');
        }

        return array_map(fn($path) => $this->encryptionService->decrypt($this->fileStorage->retrieveFile($path, false)), $storedSignatures);
    }

    /**
     * Check the status of an AES signature request.
     */
    public function checkAdvancedSignatureStatus(string $requestId): array
    {
        try {
            $client = new Client();
            $response = $client->get("{$this->apiEndpoint}/status/{$requestId}", [
                'headers' => $this->getAuthHeaders(),
            ]);

            return json_decode($response->getBody()->getContents(), true);
        } catch (Exception $e) {
            $this->logger->error("[api] Failed to check AES signature status: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to check AES signature status: " . $e->getMessage());
        }
    }

    /**
     * Download a signed AES document.
     */
    public function downloadSignedDocument(string $requestId, string $outputPath): bool
    {
        try {
            $client = new Client();
            $response = $client->get("{$this->apiEndpoint}/download/{$requestId}", [
                'headers' => $this->getAuthHeaders(),
                'sink' => $outputPath,
            ]);

            return $response->getStatusCode() === 200;
        } catch (Exception $e) {
            $this->logger->error("[api] Failed to download AES signed document: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to download AES signed document: " . $e->getMessage());
        }
    }

    /**
     * Get authentication headers for API requests.
     */
    private function getAuthHeaders(): array
    {
        return [
            'Authorization' => "Bearer {$this->apiKey}",
            'Content-Type'  => 'application/json',
        ];
    }

    /**
     * Validate allowed file types.
     */
    private function validateFileType(string $filePath): void
    {
        $allowedExtensions = ['png', 'jpg', 'svg'];
        if (!in_array(pathinfo($filePath, PATHINFO_EXTENSION), $allowedExtensions)) {
            throw new Exception('Invalid file type.');
        }
    }

    /**
     * Log error and throw exception.
     */
    private function logAndThrow(string $message, Exception $e): void
    {
        $this->logger->error($message, ['error' => $e->getMessage()]);
        throw new Exception("$message: " . $e->getMessage());
    }
}
=== App/Services/ReportService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use App\Models\Booking;
use App\Models\Payment;
use App\Models\User;
use Dompdf\Dompdf;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class ReportService
{
    public const DEBUG_MODE = true;
    private DatabaseHelper $db;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    public function __construct(LoggerInterface $logger, DatabaseHelper $db, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->db = $db;
        $this->exceptionHandler = $exceptionHandler;
    }    

    public function generateReport(string $reportType, array $dateRange, string $format, array $filters = []): string
    {
        $start = $dateRange['start'];
        $end   = $dateRange['end'];
        $data = match ($reportType) {
            'bookings' => $this->getBookingReportData($dateRange, $filters),
            'payments' => $this->getPaymentReportData($dateRange, $filters),
            'users'    => $this->getUserReportData($dateRange, $filters),
            default    => throw new \InvalidArgumentException("Invalid report type: $reportType"),
        };
        return $this->exportReport($data, "{$reportType}_" . date('YmdHis'), $format);
    }

    public function generateUserReport(int $userId, string $reportType, array $dateRange, string $format): string
    {
        $start = $dateRange['start'];
        $end   = $dateRange['end'];
        $data = match ($reportType) {
            'bookings' => Booking::with('user')
                         ->where('user_id', $userId)
                         ->whereBetween('created_at', [$start, $end])
                         ->get()
                         ->toArray(),
            'payments' => Payment::where('user_id', $userId)
                         ->whereBetween('created_at', [$start, $end])
                         ->get()
                         ->toArray(),
            default    => throw new \InvalidArgumentException("Invalid report type: $reportType"),
        };
        return $this->exportReport($data, "{$reportType}_user_{$userId}", $format);
    }

    private function getBookingReportData(array $dateRange, array $filters): array
    {
        try {
            $query = $this->db->table('bookings')->whereBetween('created_at', [$dateRange['start'], $dateRange['end']]);
            if (!empty($filters['status'])) {
                $query->where('status', $filters['status']);
            }
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Fetched booking report data", ['category' => 'report']);
            }
            return $query->get();
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error (booking): " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    private function getPaymentReportData(array $dateRange, array $filters): array
    {
        try {
            $query = $this->db->table('payments')->whereBetween('created_at', [$dateRange['start'], $dateRange['end']]);
            if (!empty($filters['type'])) {
                $query->where('type', $filters['type']);
            }
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Fetched payment report data", ['category' => 'report']);
            }
            return $query->get();
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error (payments): " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    private function getUserReportData(array $dateRange, array $filters): array
    {
        try {
            $data = $this->db->table('users')
                         ->whereBetween('created_at', [$dateRange['start'], $dateRange['end']])
                         ->get();
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Fetched user report data");
            }
            return $data;
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error (users): " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    private function exportReport(array $data, string $reportName, string $format): string
    {
        $filePath = __DIR__ . "/../../storage/reports/{$reportName}_" . date('YmdHis') . ".{$format}";

        if ($format === 'csv') {
            $file = fopen($filePath, 'w');
            if (!empty($data)) {
                fputcsv($file, array_keys($data[0])); // headers
                foreach ($data as $row) {
                    fputcsv($file, $row);
                }
            }
            fclose($file);
        } elseif ($format === 'pdf') {
            $dompdf = new Dompdf();
            $html = '<table border="1"><tr>';
            if (!empty($data)) {
                foreach (array_keys($data[0]) as $header) {
                    $html .= "<th>$header</th>";
                }
                $html .= "</tr>";
                foreach ($data as $row) {
                    $html .= "<tr>";
                    foreach ($row as $cell) {
                        $html .= "<td>$cell</td>";
                    }
                    $html .= "</tr>";
                }
            }
            $html .= "</table>";
            $dompdf->loadHtml($html);
            $dompdf->render();
            file_put_contents($filePath, $dompdf->output());
        } else {
            throw new \InvalidArgumentException("Unsupported format: $format");
        }
        if (self::DEBUG_MODE) {
            $this->logger->info("[system] Exported report: {$filePath}");
        }
        return $filePath;
    }
}
=== App/Services/PaymentService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use App\Helpers\ExceptionHandler;
use App\Models\Payment;
use App\Models\Booking;
use Psr\Log\LoggerInterface;

class PaymentService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private DatabaseHelper $db;
    private ExceptionHandler $exceptionHandler;
    private Payment $paymentModel;
    private Booking $bookingModel;

    public function __construct(
        LoggerInterface $logger, 
        DatabaseHelper $db, 
        ExceptionHandler $exceptionHandler,
        Payment $paymentModel,
        Booking $bookingModel
    ) {
        $this->logger = $logger;
        $this->db = $db;
        $this->exceptionHandler = $exceptionHandler;
        $this->paymentModel = $paymentModel;
        $this->bookingModel = $bookingModel;
    }

    public function processPayment($user, array $paymentData)
    {
        if (empty($user) || empty($user['authenticated']) || !$user['authenticated']) {
            $this->logger->error("[PaymentService] Unauthenticated payment attempt", ['category' => 'auth']);
            return ['status' => 'error', 'message' => 'User not authenticated'];
        }

        if (!empty($paymentData['adminOnly']) && $paymentData['adminOnly'] === true && $user['role'] !== 'admin') {
            $this->logger->error("[PaymentService] Unauthorized admin transaction", ['category' => 'auth']);
            return ['status' => 'error', 'message' => 'Admin privileges required'];
        }

        try {
            // Start a transaction (will use the payment model's transaction handling)
            $this->paymentModel->beginTransaction();

            // Insert payment record using the model
            $paymentId = $this->paymentModel->create([
                'booking_id'     => $paymentData['bookingId'],
                'amount'         => $paymentData['amount'],
                'payment_method' => $paymentData['paymentMethod'],
                'status'         => 'completed',
                'created_at'     => date('Y-m-d H:i:s')
            ]);

            // Check if booking exists
            $booking = $this->bookingModel->find($paymentData['bookingId']);
            if (!$booking) {
                $this->paymentModel->rollBack();
                throw new \Exception("Booking not found");
            }

            // Update booking status
            $this->bookingModel->update($paymentData['bookingId'], [
                'status' => 'paid'
            ]);

            // Log transaction (business level logging)
            $this->paymentModel->logTransaction($paymentData['bookingId'], $paymentData['amount'], 'payment', 'completed');
            
            // Commit the transaction
            $this->paymentModel->commit();
            
            // Business-level logging
            if (self::DEBUG_MODE) {
                $this->logger->info("[payment] Payment processed for booking {$paymentData['bookingId']}", ['category' => 'system']);
            }
            return ['status' => 'success', 'message' => 'Payment processed successfully'];
        } catch (\Exception $e) {
            // Ensure we rollback if any exception occurs
            $this->paymentModel->rollBack();
            
            $this->logger->error("[db] Database error: " . $e->getMessage(), ['category' => 'db']);
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'Payment processing failed'];
        }
    }

    public function processRefund(int $bookingId, float $amount): bool
    {
        try {
            // Start a transaction
            $this->paymentModel->beginTransaction();

            // Log the refund
            $this->paymentModel->logRefund($bookingId, $amount, 'processed');

            // Get booking
            $booking = $this->bookingModel->find($bookingId);
            if (!$booking) {
                $this->paymentModel->rollBack();
                throw new \Exception("Booking not found");
            }
            
            // Update booking refund status
            $this->bookingModel->update($bookingId, [
                'refund_status' => 'processed'
            ]);

            // Log transaction (business level logging)
            $this->paymentModel->logTransaction($bookingId, $amount, 'refund', 'completed');
            
            // Commit the transaction
            $this->paymentModel->commit();
            
            // Business-level logging
            if (self::DEBUG_MODE) {
                $this->logger->info("[payment] Refund processed for booking {$bookingId}", ['category' => 'system']);
            }
            return true;
        } catch (\Exception $e) {
            // Ensure we rollback if any exception occurs
            $this->paymentModel->rollBack();
            
            $this->logger->error("[db] Database error: " . $e->getMessage(), ['category' => 'db']);
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    public function getMonthlyRevenueTrends(): array
    {
        try {
            $data = $this->paymentModel->getMonthlyRevenueTrends();
            $this->logger->info("[PaymentService] Retrieved monthly revenue trends");
            return $data;
        } catch (\Exception $e) {
            $this->logger->error("[PaymentService] Database error: " . $e->getMessage());
            throw $e;
        }
    }
    
    /**
     * Get payment by ID
     */
    public function getPaymentById(int $id): ?array
    {
        try {
            $payment = $this->paymentModel->find($id);
            if (!$payment) {
                return null;
            }
            return $payment;
        } catch (\Exception $e) {
            $this->logger->error("[PaymentService] Error getting payment: " . $e->getMessage());
            throw $e;
        }
    }
    
    /**
     * Get all payments for a specific booking
     */
    public function getPaymentsByBooking(int $bookingId): array
    {
        try {
            return $this->paymentModel->getByBookingId($bookingId);
        } catch (\Exception $e) {
            $this->logger->error("[PaymentService] Error getting payments by booking: " . $e->getMessage());
            throw $e;
        }
    }
    
    /**
     * Get all payments for a specific user
     */
    public function getPaymentsByUser(int $userId): array
    {
        try {
            return $this->paymentModel->getByUserId($userId);
        } catch (\Exception $e) {
            $this->logger->error("[PaymentService] Error getting payments by user: " . $e->getMessage());
            throw $e;
        }
    }
}
=== App/Services/PayUService.php ===
<?php

namespace App\Services;

use Exception;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use App\Helpers\DatabaseHelper; // new import
use Psr\Log\LoggerInterface; // ensure LoggerInterface is imported
use App\Helpers\ExceptionHandler;
require_once __DIR__ . '/../../config/payu.php';
/**
 * PayUService
 * 
 * Handles PayU API integration, including payment initialization, verification, and refunds.
 */
class PayUService
{
    public const DEBUG_MODE = true;
    private string $merchantKey;
    private string $merchantSalt;
    private string $endpoint;
    private $db; // DatabaseHelper instance
    private LoggerInterface $logger; // injected logger
    private ExceptionHandler $exceptionHandler;

    // Constructor updated to accept LoggerInterface
    public function __construct(array $config, LoggerInterface $logger, ExceptionHandler $exceptionHandler)
    {
        $this->merchantKey = $config['merchant_key'];
        $this->merchantSalt = $config['merchant_salt'];
        $this->endpoint = $config['endpoint'];
        $this->db = DatabaseHelper::getInstance();
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Initialize a payment transaction
     *
     * @param string $transactionId
     * @param float $amount
     * @param string $productInfo
     * @param string $customerEmail
     * @param string $customerPhone
     * @return array
     */
    public function initiatePayment(string $transactionId, float $amount, string $productInfo, string $customerEmail, string $customerPhone): array
    {
        $hash = $this->generateHash($transactionId, $amount, $productInfo, $customerEmail);

        $params = [
            'key' => $this->merchantKey,
            'txnid' => $transactionId,
            'amount' => $amount,
            'productinfo' => $productInfo,
            'firstname' => $customerEmail, // Assuming first name is derived from the email
            'email' => $customerEmail,
            'phone' => $customerPhone,
            'surl' => $this->endpoint . '/success', // Success callback URL
            'furl' => $this->endpoint . '/failure', // Failure callback URL
            'hash' => $hash,
            'service_provider' => 'payu_paisa'
        ];

        if (self::DEBUG_MODE) {
            $this->logger->info("[api] Initiating PayU payment", ['transactionId' => $transactionId, 'category' => 'api']);
        }

        $response = Http::post("{$this->endpoint}/_payment", $params);
        throw_if($response->failed(), Exception::class, 'Payment API error');
        return [
            'status' => 'success',
            'data'   => $response->json()
        ];
    }

    /**
     * Verify a payment transaction
     *
     * @param string $transactionId
     * @return array
     */
    public function verifyPayment(string $transactionId): array
    {
        $params = [
            'key' => $this->merchantKey,
            'command' => 'verify_payment',
            'var1' => $transactionId,
        ];

        if (self::DEBUG_MODE) {
            $this->logger->info("[api] Verifying PayU payment", ['transactionId' => $transactionId, 'category' => 'api']);
        }

        $response = Http::post("{$this->endpoint}/payment/verify", $params);
        throw_if($response->failed(), Exception::class, 'Payment verification error');
        return [
            'status' => 'success',
            'data'   => $response->json()
        ];
    }

    /**
     * Process a refund
     *
     * @param string $transactionId
     * @param float $amount
     * @return array
     */
    public function processRefund(string $transactionId, float $amount): array
    {
        $params = [
            'key' => $this->merchantKey,
            'command' => 'refund_transaction',
            'var1' => $transactionId,
            'var2' => $amount,
        ];

        try {
            $response = Http::post("{$this->endpoint}/refund", $params);
            throw_if($response->failed(), Exception::class, 'Refund processing error');
            $this->db->table('transaction_logs')->insert([
                'booking_id' => $transactionId,
                'amount'     => $amount,
                'type'       => 'refund',
                'status'     => 'completed'
            ]);
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Refund logged for transaction {$transactionId}", ['category' => 'db']);
            }
            return [
                'status' => 'success',
                'data'   => $response->json()
            ];
        } catch (Exception $e) {
            $this->logger->error("[payment] Refund processing error: " . $e->getMessage(), ['category' => 'system']);
            $this->exceptionHandler->handleException($e);
            return [
                'status' => 'error',
                'message' => 'Refund processing failed'
            ];
        }
    }

    /**
     * Generate hash for PayU API
     *
     * @param string $transactionId
     * @param float $amount
     * @param string $productInfo
     * @param string $customerEmail
     * @return string
     */
    private function generateHash(string $transactionId, float $amount, string $productInfo, string $customerEmail): string
    {
        $hashString = implode('|', [
            $this->merchantKey,
            $transactionId,
            $amount,
            $productInfo,
            $customerEmail,
            $this->merchantSalt
        ]);

        return hash('sha512', $hashString);
    }
}
=== App/Middleware/EncryptionMiddleware.php ===
<?php

namespace App\Middleware;

// Removed: use Illuminate\Http\Request;
// Removed: use Illuminate\Support\Facades\Log;
use Psr\Log\LoggerInterface;
use App\Services\EncryptionService;

class EncryptionMiddleware
{
    private LoggerInterface $logger;
    
    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }
    
    // Modified handle() to use native PHP request handling without Closure
    public function handle(array $request)
    {
        $uri = $_SERVER['REQUEST_URI'] ?? '/';
        if ($this->isSensitiveEndpoint($uri)) {
            $this->encryptRequestData($request);
        }

        // Process request (replace with your actual request processing)
        // ...existing code or processRequest($request)...
        $response = []; // Placeholder for processed response
        
        if ($this->isSensitiveEndpoint($uri)) {
            $response = $this->encryptResponseData(json_encode($response));
        }
        
        echo json_encode($response);
        exit;
    }
    
    // Modified to encrypt response data and return a string
    private function encryptResponseData(string $data): string
    {
        return EncryptionService::encrypt($data);
    }

    // Handle encryption on native request arrays (e.g., $_POST or $_GET)
    private function encryptRequestData(array &$request)
    {
        foreach ($request as $key => $value) {
            if ($this->isSensitiveField($key)) {
                $request[$key] = EncryptionService::encrypt($value);
            }
        }
    }

    // Load sensitive fields dynamically from configuration file
    private function isSensitiveField(string $field): bool
    {
        $configPath = __DIR__ . '/../../config/sensitive_fields.json';
        $config = file_exists($configPath) ? json_decode(file_get_contents($configPath), true) : [];
        $sensitiveFields = $config['sensitive_fields'] ?? ['password', 'email', 'phone'];
        return in_array($field, $sensitiveFields);
    }

    // Load sensitive endpoints dynamically from configuration file
    private function isSensitiveEndpoint(string $endpoint): bool
    {
        $configPath = __DIR__ . '/../../config/sensitive_endpoints.json';
        $config = file_exists($configPath) ? json_decode(file_get_contents($configPath), true) : [];
        $sensitiveEndpoints = $config['sensitive_endpoints'] ?? ['/user/profile-data'];
        return in_array($endpoint, $sensitiveEndpoints);
    }
    
    // Log events using injected LoggerInterface
    private function logEvent(string $message)
    {
        $this->logger->info("[EncryptionMiddleware] $message");
    }
}
=== App/Middleware/AuthMiddleware.php ===
<?php

namespace App\Middleware;

use App\Services\Auth\TokenService;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface as RequestHandler;
use Psr\Log\LoggerInterface;
use App\Helpers\DatabaseHelper;

class AuthMiddleware implements MiddlewareInterface
{
    private TokenService $tokenService;
    private LoggerInterface $logger;
    private $pdo;
    private bool $required;

    public function __construct(
        TokenService $tokenService, 
        LoggerInterface $logger,
        DatabaseHelper $dbHelper,
        bool $required = false
    ) {
        $this->tokenService = $tokenService;
        $this->logger = $logger;
        $this->pdo = $dbHelper->getPdo();
        $this->required = $required;
    }

    public function process(Request $request, RequestHandler $handler): Response
    {
        $this->logger->debug("AuthMiddleware processing request", [
            'required_auth' => $this->required ? 'yes' : 'no'
        ]);
        
        // Try to get token from Authorization header
        $token = null;
        $authHeader = $request->getHeaderLine('Authorization');
        if (strpos($authHeader, 'Bearer ') === 0) {
            $token = substr($authHeader, 7);
            $this->logger->debug("Found token in Authorization header");
        }
        
        // If not in header, try cookies
        if (!$token) {
            $cookies = $request->getCookieParams();
            $token = $cookies['jwt'] ?? null;
            if ($token) {
                $this->logger->debug("Found token in cookies");
            }
        }
        
        $authenticated = false;
        
        if ($token) {
            try {
                // Verify and decode the token
                $decoded = $this->tokenService->verifyToken($token);
                $userId = $decoded['sub'];
                $this->logger->debug("Token verified successfully", ['userId' => $userId]);
                
                // Fetch user from application database
                $stmt = $this->pdo->prepare("
                    SELECT id, name, surname, email, phone, role, address, 
                           pesel_or_id, created_at, email_notifications, sms_notifications 
                    FROM users WHERE id = ? AND active = 1
                ");
                $stmt->execute([$userId]);
                $user = $stmt->fetch();
                
                if ($user) {
                    // Attach user to request
                    $this->logger->debug("User attached to request", ['userId' => $user['id']]);
                    $request = $request->withAttribute('user', $user);
                    $authenticated = true;
                } else {
                    $this->logger->warning("User not found or inactive", ['userId' => $userId]);
                }
            } catch (\Exception $e) {
                $this->logger->warning("Token validation failed: " . $e->getMessage());
                // We'll proceed without setting the user attribute
            }
        } else {
            $this->logger->debug("No token found in request");
        }
        
        // If authentication is required but failed, return 401 Unauthorized
        if ($this->required && !$authenticated) {
            $this->logger->warning("Authentication required but failed or missing");
            $response = new \Slim\Psr7\Response();
            $response->getBody()->write(json_encode([
                'error' => 'Authentication required',
                'status' => 401
            ]));
            return $response
                ->withHeader('Content-Type', 'application/json')
                ->withStatus(401);
        }
        
        return $handler->handle($request);
    }
}
?>
=== App/Middleware/RequireAuthMiddleware.php ===
<?php

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface as RequestHandler;
use Psr\Log\LoggerInterface;

/**
 * Middleware that ensures a user is authenticated
 * To be used after AuthMiddleware has processed the request
 */
class RequireAuthMiddleware implements MiddlewareInterface
{
    private LoggerInterface $logger;

    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }

    public function process(Request $request, RequestHandler $handler): Response
    {
        $user = $request->getAttribute('user');
        
        if (!$user) {
            $this->logger->warning("Access attempt to protected route without authentication");
            
            $response = new \Slim\Psr7\Response();
            $response->getBody()->write(json_encode([
                'error' => 'Authentication required',
                'status' => 401
            ]));
            
            return $response
                ->withHeader('Content-Type', 'application/json')
                ->withStatus(401);
        }
        
        $this->logger->debug("User authenticated for protected route", ['user_id' => $user['id']]);
        return $handler->handle($request);
    }
}
=== App/Middleware/TokenValidationMiddleware.php ===
<?php

namespace App\Middleware;

use App\Services\Auth\AuthService;
use App\Services\Auth\TokenService;
use App\Helpers\ApiHelper;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Server\RequestHandlerInterface as RequestHandler;
use Psr\Log\LoggerInterface;

class TokenValidationMiddleware
{
    private AuthService $authService;
    private LoggerInterface $logger;
    private TokenService $tokenService;

    public function __construct(
        AuthService $authService, 
        LoggerInterface $logger,
        TokenService $tokenService
    ) {
        $this->authService = $authService;
        $this->logger = $logger;
        $this->tokenService = $tokenService;
    }

    public function __invoke(Request $request, RequestHandler $handler): Response
    {
        // Use TokenService to extract and validate the token
        $user = $this->tokenService->validateRequest($request);

        if (!$user) {
            $this->logger->warning("Invalid or missing token", ['ip' => $request->getServerParams()['REMOTE_ADDR']]);
            return ApiHelper::sendJsonResponse('error', 'Unauthorized', [], 401);
        }

        $request = $request->withAttribute('user', $user);

        return $handler->handle($request);
    }
}
?>
=== App/Middleware/AuditTrailMiddleware.php ===
<?php

namespace App\Middleware;

use App\Services\AuditService;
use Psr\Log\LoggerInterface;

/**
 * @deprecated This middleware is deprecated and will be removed in a future version. 
 * Use AuditService methods directly in your controllers instead.
 * 
 * AuditTrailMiddleware - Logs user actions for audit tracking.
 */
class AuditTrailMiddleware
{
    private AuditService $auditService;
    private LoggerInterface $logger;

    public function __construct(AuditService $auditService, LoggerInterface $logger)
    {
        $this->auditService = $auditService;
        $this->logger = $logger;
        
        // Log a warning about using deprecated middleware
        $this->logger->warning(
            'AuditTrailMiddleware is deprecated. Use AuditService methods directly in controllers instead.',
            ['trace' => debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 2)]
        );
    }

    /**
     * Handle an incoming request and log relevant details.
     *
     * @param array $request The request data.
     * @param callable $next The next middleware function.
     * @deprecated Use AuditService methods directly in your controllers instead
     */
    public function handle(array $request, callable $next)
    {
        try {
            // Extract request details
            $requestInfo = AuditService::getRequestInfo();
            $userId = $_SESSION['user_id'] ?? null;
            
            // Use the new API logging method
            $this->auditService->logApiRequest(
                $requestInfo['uri'],
                $requestInfo['method'],
                $this->sanitizeRequestData($request),
                [], // Response not available here
                200, // Status code not available yet
                $userId
            );

            // Continue to the next middleware/controller
            return $next($request);
        } catch (\Exception $e) {
            $this->logger->error('[AuditTrail] Failed to log action', ['error' => $e->getMessage()]);
            return $next($request); // Allow the request to proceed even if logging fails
        }
    }

    /**
     * Sanitize request data before logging.
     *
     * @param array $request The raw request data.
     * @return array The sanitized request data.
     */
    private function sanitizeRequestData(array $request): array
    {
        unset($request['password'], $request['token'], $request['credit_card'], $request['cvv']);
        return $request;
    }
}
=== App/TokenValidator.php ===
<?php

/**
 * @deprecated This file is deprecated and will be removed in a future version.
 * Use App\Services\Auth\TokenService instead for token validation.
 */

namespace App;

class TokenValidator 
{
    /**
     * @deprecated Use App\Services\Auth\TokenService::validateTokenFromHeader() instead
     */
    public static function validateToken($tokenHeader)
    {
        trigger_error(
            'TokenValidator is deprecated. Use App\Services\Auth\TokenService::validateTokenFromHeader() instead.', 
            E_USER_DEPRECATED
        );
        
        // Get the TokenService from the service container
        $tokenService = \App\Container::getInstance()->get(\App\Services\Auth\TokenService::class);
        return $tokenService->validateTokenFromHeader($tokenHeader);
    }
}
=== App/Helpers/ViewHelper.php ===
<?php

function view($viewName, $data = [])
{
    $viewPath = BASE_PATH . "/App/Views/{$viewName}.php";

    if (!file_exists($viewPath)) {
        die("❌ View not found: {$viewName}");
    }

    extract($data); // Extract data for use inside views
    require $viewPath;
}
=== App/Helpers/SecurityHelper.php ===
<?php

namespace App\Helpers;

use Psr\Log\LoggerInterface;
use Firebase\JWT\JWT;

class SecurityHelper
{
    // Security Configuration
    const SESSION_CONFIG = [
        'use_only_cookies'        => 1,
        'use_strict_mode'         => 1,
        'cookie_httponly'         => 1,
        'cookie_samesite'         => 'Lax',
        'gc_maxlifetime'          => 3600,
        'cookie_lifetime'         => 0,
        'use_trans_sid'           => 0,
        'sid_bits_per_character'  => 6
    ];

    // Standardized Logging Function
    public static function securityLog(LoggerInterface $logger, $message, $level = 'info', $category = 'Security')
    {
        if ($logger && method_exists($logger, 'log')) {
            $logger->log($level, "[$category] $message");
        } else {
            error_log("[$category][$level] $message");
        }
    }

    // Log authentication events
    public static function logAuthEvent($message, $level = 'info')
    {
        self::securityLog(null, $message, $level, 'Auth');
    }

    // Helper to log authentication failures
    public static function logAuthFailure($message)
    {
        self::securityLog(null, $message, 'error', 'Auth');
    }

    // Secure Session Handling using native PHP sessions
    public static function startSecureSession()
    {
        if (session_status() === PHP_SESSION_NONE) {
            ini_set('session.use_only_cookies', 1);
            ini_set('session.use_strict_mode', 1);
            ini_set('session.cookie_httponly', 1);
            ini_set('session.cookie_samesite', 'Lax');
            session_start();
        }
        return true;
    }

    // Refresh session to extend its duration
    public static function refreshSession()
    {
        $logFile = __DIR__ . '/../../logs/security.log';
        $timestamp = date('Y-m-d H:i:s');

        try {
            if (session_status() === PHP_SESSION_ACTIVE) {
                $_SESSION['last_activity'] = time();
                session_regenerate_id(true);
                error_log("[$timestamp][info] Session refreshed\n", 3, $logFile);
            }
        } catch (Exception $e) {
            error_log("[$timestamp][error] Session refresh failed: " . $e->getMessage() . "\n", 3, $logFile);
        }
    }

    // Replace Laravel session calls with native PHP for session expiry enforcement
    public static function enforceSessionExpiry(LoggerInterface $logger)
    {
        if (!isset($_SESSION['last_activity'])) {
            $_SESSION['last_activity'] = time();
            return;
        }
        if (time() - $_SESSION['last_activity'] > 1800) { // 30 min timeout
            self::securityLog($logger, 'Session expired due to inactivity', 'info');
            $_SESSION = [];
            if (ini_get('session.use_cookies')) {
                setcookie(session_name(), '', time() - 42000, '/');
            }
            session_destroy();
        }
    }

    // Fingerprint-Based Session Integrity Check
    public static function validateSessionIntegrity(LoggerInterface $logger)
    {
        $currentIp = hash('sha256', $_SERVER['REMOTE_ADDR']);
        $currentAgent = hash('sha256', $_SERVER['HTTP_USER_AGENT']);

        if (!isset($_SESSION['client_ip'])) {
            $_SESSION['client_ip'] = $currentIp;
            $_SESSION['user_agent'] = $currentAgent;
            return true;
        }
        if ($_SESSION['client_ip'] !== $currentIp || $_SESSION['user_agent'] !== $currentAgent) {
            self::securityLog($logger, 'Session integrity check failed: Mismatch detected', 'warning');
            $_SESSION = [];
            if (ini_get('session.use_cookies')) {
                setcookie(session_name(), '', time() - 42000, '/');
            }
            session_destroy();
            return false;
        }
        return true;
    }

    // Sanitize user input to prevent XSS
    public static function sanitizeInput($data)
    {
        if (!isset($data) || $data === null) {
            $data = ''; // Default to empty string to prevent undefined variable errors
        }
        $cleanedData = trim((string)$data);
        return htmlspecialchars($cleanedData, ENT_QUOTES, 'UTF-8');
    }

    // Generate secure random string (for password resets, API keys, etc.)
    public static function generateSecureToken($length = 64)
    {
        return bin2hex(random_bytes($length / 2));
    }

    // Secure Session Destruction using native PHP
    public static function destroySession(LoggerInterface $logger)
    {
        self::securityLog($logger, 'Destroying session', 'info');
        $_SESSION = [];
        if (ini_get('session.use_cookies')) {
            setcookie(session_name(), '', time() - 42000, '/');
        }
        session_destroy();
        self::securityLog($logger, 'Session destroyed successfully', 'info');
    }

    // Check if a user is logged in
    public static function isUserLoggedIn()
    {
        return isset($_SESSION['user_id']);
    }

    // Get the logged-in user's role
    public static function getUserRole()
    {
        return isset($_SESSION['user_id']) ? ($_SESSION['user_role'] ?? 'guest') : 'guest';
    }

    // Get session data safely
    public static function getSessionData($key)
    {
        return $_SESSION[$key] ?? null;
    }

    // Set session data safely
    public static function setSessionData($key, $value)
    {
        $_SESSION[$key] = $value;
    }

    // Validate JWT token
    public static function validateJWT($token)
    {
        // Replace Laravel's authentication with a native JWT approach or session check.
        // For example, decode using firebase/php-jwt, here we simply check session.
        return $_SESSION['user_id'] ?? null;
    }

    // Enforce authentication for protected pages
    public static function requireUserAuth()
    {
        return self::requireAuth();
    }

    // Custom Authentication Enforcement
    public static function requireAuth($allowGuest = false)
    {
        if (isset($_SESSION['user_id'])) {
            return $_SESSION['user_id'];
        }
        if ($allowGuest) {
            return null;
        }
        header('Content-Type: application/json');
        http_response_code(401);
        echo json_encode(['error' => 'Unauthorized']);
        exit;
    }

    // CSRF Token Generation
    public static function generateCsrfToken()
    {
        if (!isset($_SESSION['csrf_token'])) {
            $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
        }
        return $_SESSION['csrf_token'];
    }

    // Validate CSRF token in POST requests
    public static function validateCsrfToken($token)
    {
        return isset($_SESSION['csrf_token']) && $_SESSION['csrf_token'] === $token;
    }

    // Return structured JSON response
    public static function jsonResponse($data, $statusCode = 200)
    {
        header('Content-Type: application/json');
        http_response_code($statusCode);
        echo json_encode($data);
        exit;
    }
}

// Initialize secure session when the file is included
if (!SecurityHelper::startSecureSession()) {
    SecurityHelper::securityLog(null, 'Critical: Failed to initialize secure session', 'critical');
}
?>
=== App/Helpers/ExceptionHandler.php ===
<?php
namespace App\Helpers;

use PDOException;
use Exception;
use InvalidArgumentException;
use Psr\Log\LoggerInterface;

class ExceptionHandler
{
    private LoggerInterface $dbLogger;
    private LoggerInterface $authLogger;
    private LoggerInterface $systemLogger;

    public function __construct(
        LoggerInterface $dbLogger,
        LoggerInterface $authLogger,
        LoggerInterface $systemLogger
    ) {
        $this->dbLogger = $dbLogger;
        $this->authLogger = $authLogger;
        $this->systemLogger = $systemLogger;
    }

    /**
     * Handle exceptions centrally with consistent logging and JSON responses.
     */
    public function handleException(Exception $e): void
    {
        // Extract status code if available or use default
        $statusCode = method_exists($e, 'getCode') && is_numeric($e->getCode()) && $e->getCode() >= 400 && $e->getCode() < 600 
            ? $e->getCode() 
            : 500;
            
        // Database-related exceptions
        if ($e instanceof PDOException) {
            $errorCode = $e->getCode();
            $this->dbLogger->error("❌ Database Error: " . $e->getMessage(), [
                'code' => $errorCode,
                'trace' => $e->getTraceAsString(),
                'file' => $e->getFile(),
                'line' => $e->getLine()
            ]);
            
            // Handle specific database errors
            if ($errorCode == '23000') { // Integrity constraint violation
                ApiHelper::sendJsonResponse('error', 'Duplicate entry or constraint violation', ['error' => $this->sanitizeErrorMessage($e->getMessage())], 400);
            } elseif ($errorCode == '42S02') { // Table not found
                ApiHelper::sendJsonResponse('error', 'Database table error', ['error' => 'Requested table not found'], 500);
            } else {
                ApiHelper::sendJsonResponse('error', 'Database error', ['error' => $this->sanitizeErrorMessage($e->getMessage())], 500);
            }
        }
        // Validation exceptions
        elseif ($e instanceof InvalidArgumentException) {
            $this->systemLogger->warning("⚠️ Validation Error: " . $e->getMessage());
            ApiHelper::sendJsonResponse('error', 'Validation error', ['errors' => json_decode($e->getMessage(), true) ?? ['validation' => $e->getMessage()]], 400);
        }
        // Authentication exceptions - We'll uncomment and implement when needed
        elseif (strpos($e->getMessage(), 'Invalid credentials') !== false || strpos($e->getMessage(), 'Unauthorized') !== false) {
            $this->authLogger->error("🔒 Authentication Error: " . $e->getMessage(), [
                'trace' => $e->getTraceAsString(),
                'file' => $e->getFile(),
                'line' => $e->getLine()
            ]);
            ApiHelper::sendJsonResponse('error', 'Authentication error', ['error' => $e->getMessage()], 401);
        }
        // Other exceptions
        else {
            $this->systemLogger->error("❌ System Error: " . $e->getMessage(), [
                'code' => $e->getCode(),
                'trace' => $e->getTraceAsString(),
                'file' => $e->getFile(),
                'line' => $e->getLine()
            ]);
            
            // Use provided status code or default to 500
            ApiHelper::sendJsonResponse(
                'error', 
                'Unexpected error occurred', 
                ['error' => $this->sanitizeErrorMessage($e->getMessage())], 
                $statusCode
            );
        }
        exit();
    }
    
    /**
     * Sanitize error messages to remove sensitive information
     */
    private function sanitizeErrorMessage(string $message): string
    {
        // Remove potentially sensitive information (like SQL queries, passwords, etc)
        $message = preg_replace('/password\s*=\s*[^\s,)]+/i', 'password=*****', $message);
        
        // For production, you might want to return generic messages instead of actual DB errors
        if (getenv('APP_ENV') === 'production') {
            if (strpos($message, 'SQL') !== false) {
                return 'A database error occurred';
            }
        }
        
        return $message;
    }
}
?>=== App/Helpers/ApiHelper.php ===
<?php

namespace App\Helpers;

/**
 * API Helper Functions
 */
class ApiHelper
{
    /**
     * ✅ Log API Events for Debugging
     */
    public static function logApiEvent($message)
    {
        $timestamp = date('Y-m-d H:i:s');
        $logFile = __DIR__ . '/../../logs/api.log';
        file_put_contents($logFile, "{$timestamp} - {$message}\n", FILE_APPEND);
    }

    /**
     * ✅ Standardized JSON Response Function
     */
    public static function sendJsonResponse($status, $message, $data = [], $httpCode = 200)
    {
        http_response_code($httpCode);
        header('Content-Type: application/json');
        echo json_encode(['status' => $status, 'message' => $message, 'data' => $data]);
        exit();
    }

    /**
     * ✅ Extract JWT from Authorization Header or Cookie
     */
    public static function getJWT()
    {
        $headers = getallheaders();
        if (isset($headers['Authorization']) && preg_match('/Bearer\s(\S+)/', $headers['Authorization'], $matches)) {
            return $matches[1];
        }
        return $_COOKIE['jwt'] ?? null;
    }
}
=== App/Helpers/SetupHelper.php ===
<?php

namespace App\Helpers;

use Psr\Log\LoggerInterface;
use App\Helpers\DatabaseHelper;

/**
 * Helper class to setup and verify the application environment
 */
class SetupHelper
{
    private $pdo;
    private LoggerInterface $logger;
    
    public function __construct(DatabaseHelper $dbHelper, LoggerInterface $logger)
    {
        $this->pdo = $dbHelper->getPdo();
        $this->logger = $logger;
    }
    
    /**
     * Add required indexes to database tables if they don't exist
     */
    public function ensureIndexes(): void
    {
        try {
            // Check for email index on users table
            $stmt = $this->pdo->prepare("
                SELECT COUNT(*) as count
                FROM information_schema.statistics
                WHERE table_schema = DATABASE()
                AND table_name = 'users'
                AND index_name = 'idx_users_email'
            ");
            $stmt->execute();
            $result = $stmt->fetch();
            
            if ($result['count'] == 0) {
                $this->logger->info("Creating index on users.email");
                $this->pdo->exec("CREATE INDEX idx_users_email ON users(email)");
            }
            
            // Check for other important indexes
            $this->logger->info("Database indexes verified");
        } catch (\Exception $e) {
            $this->logger->error("Failed to ensure indexes: " . $e->getMessage());
            throw $e;
        }
    }
    
    /**
     * Verify that the application is running in a secure environment
     */
    public function verifySecureEnvironment(): array
    {
        $issues = [];
        
        // Check if we're running over HTTPS
        $isSecure = (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off') 
                  || (isset($_SERVER['SERVER_PORT']) && $_SERVER['SERVER_PORT'] == 443);
                  
        if (!$isSecure) {
            $issues[] = "Application is not running over HTTPS. This is insecure for production.";
            $this->logger->warning("Security warning: Not running over HTTPS");
        }
        
        // Check PHP version
        if (version_compare(PHP_VERSION, '7.4.0', '<')) {
            $issues[] = "PHP version is below 7.4. Please upgrade for security.";
            $this->logger->warning("Security warning: PHP version below 7.4", ['version' => PHP_VERSION]);
        }
        
        // Return issues found
        return $issues;
    }
}
=== App/Helpers/DatabaseHelper.php ===
<?php

namespace App\Helpers;

use PDO;
use Exception;
use Psr\Log\LoggerInterface;
use App\Helpers\ApiHelper;

class DatabaseHelper
{
    protected static ?DatabaseHelper $instance = null;
    protected static ?DatabaseHelper $secureInstance = null;
    private PDO $pdo;
    private static LoggerInterface $logger;

    private function __construct(array $config)
    {
        try {
            $dsn = "mysql:host={$config['host']};dbname={$config['database']};charset={$config['charset']}";
            $this->pdo = new PDO($dsn, $config['username'], $config['password'], [
                PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
                PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
                PDO::ATTR_EMULATE_PREPARES => false,
            ]);

            self::$logger->info("✅ Database connection initialized successfully.");
        } catch (Exception $e) {
            self::$logger->critical("❌ Database connection failed: " . $e->getMessage());
            die("Database connection failed. Check logs for details.");
        }
    }

    public static function setLogger(LoggerInterface $logger)
    {
        if (!isset(self::$logger)) {
            self::$logger = $logger;
        }
    }

    private static function getDatabaseConfig(string $type = 'default'): array
    {
        $config = require __DIR__ . '/../../config/database.php';
    
        if (!isset($config['secure_database']) || !isset($config['app_database'])) {
            throw new Exception("Database configuration is missing required keys.");
        }
    
        return $type === 'secure' ? $config['secure_database'] : $config['app_database'];
    }
    
    public static function getInstance(): DatabaseHelper
    {
        if (self::$instance === null) {
            if (!isset(self::$logger)) {
                throw new Exception("Logger must be set before initializing the database.");
            }
            try {
                $dbConfig = self::getDatabaseConfig('default');
                self::$instance = new DatabaseHelper($dbConfig);
                self::$logger->info("✅ Application database initialized successfully.");
            } catch (Exception $e) {
                self::$logger->critical("❌ Application database initialization failed: " . $e->getMessage());
                die("Application database initialization failed.");
            }
        }
    
        return self::$instance;
    }
    
    public static function getSecureInstance(): DatabaseHelper
    {
        if (self::$secureInstance === null) {
            if (!isset(self::$logger)) {
                throw new Exception("Logger must be set before initializing the database.");
            }
            try {
                $dbConfig = self::getDatabaseConfig('secure');
                self::$secureInstance = new DatabaseHelper($dbConfig);
                self::$logger->info("✅ Secure database initialized successfully.");
            } catch (Exception $e) {
                self::$logger->critical("❌ Secure database initialization failed: " . $e->getMessage());
                die("Secure database initialization failed.");
            }
        }
    
        return self::$secureInstance;
    }

    public static function getAppInstance(): ?DatabaseHelper
    {
        return self::$instance;
    }

    public static function getSecureDbInstance(): ?DatabaseHelper
    {
        return self::$secureInstance;
    }
    
    public function getPdo(): PDO
    {
        return $this->pdo;
    }

    public function getConnection()
    {
        try {
            return $this->pdo;
        } catch (Exception $e) {
            if (self::$logger) {
                self::$logger->error("❌ Failed to get database connection: " . $e->getMessage());
            }
            return null;
        }
    }

    /**
     * Execute a database query safely with comprehensive logging and error handling
     * 
     * @param callable $query Function containing the query to execute
     * @param string $queryDescription Description of the query for logging
     * @param bool $useSecureDb Whether to use the secure database
     * @param array $context Additional context information for logging
     * @return mixed Query result or error response
     */
    public static function safeQuery(
        callable $query, 
        string $queryDescription = 'Database Query', 
        bool $useSecureDb = false,
        array $context = []
    ) {
        $startTime = microtime(true);
        $dbInstance = $useSecureDb ? self::getSecureInstance() : self::getInstance();
        $dbType = $useSecureDb ? "secure" : "application";
        
        try {
            // Get database name for logging
            $databaseName = $dbInstance->getPdo()->query("SELECT DATABASE()")->fetchColumn();
            
            // Log query execution start with sanitized parameters
            $logContext = array_merge($context, [
                'database' => $databaseName,
                'database_type' => $dbType,
                'timestamp_start' => date('Y-m-d H:i:s.u'),
            ]);
            
            // Sanitize any sensitive data in context
            $sanitizedContext = self::sanitizeLogContext($logContext);
            self::$logger->info("🔍 Executing {$queryDescription} on {$dbType} database: {$databaseName}", $sanitizedContext);
            
            // Execute the query
            $result = $query($dbInstance->getPdo());
            
            // Calculate execution time
            $executionTime = round((microtime(true) - $startTime) * 1000, 2);
            
            // Log successful query completion
            self::$logger->info("✅ {$queryDescription} completed successfully", [
                'database' => $databaseName,
                'execution_time_ms' => $executionTime,
                'database_type' => $dbType,
                'timestamp_end' => date('Y-m-d H:i:s.u'),
            ]);
            
            return $result;
            
        } catch (\PDOException $e) {
            $executionTime = round((microtime(true) - $startTime) * 1000, 2);
            $errorCode = $e->getCode();
            
            // Log detailed error information
            self::$logger->error("❌ {$queryDescription} failed with PDO error {$errorCode}", [
                'error_message' => $e->getMessage(),
                'database_type' => $dbType,
                'execution_time_ms' => $executionTime,
                'error_code' => $errorCode,
                'trace' => $e->getTraceAsString(),
                'context' => $sanitizedContext ?? [],
            ]);
            
            // Return appropriate error responses based on error type
            if ($errorCode == "23000") {
                return ApiHelper::sendJsonResponse('error', 'Database constraint violation: Duplicate or invalid data', [], 400);
            } elseif ($errorCode == "42S02") {
                return ApiHelper::sendJsonResponse('error', 'Table not found error', [], 500);
            } elseif ($errorCode == "42000") {
                return ApiHelper::sendJsonResponse('error', 'SQL syntax error', [], 500);
            } else {
                return ApiHelper::sendJsonResponse('error', 'Database query failed: ' . self::getSafeErrorMessage($e->getMessage()), [], 500);
            }
            
        } catch (\Exception $e) {
            $executionTime = round((microtime(true) - $startTime) * 1000, 2);
            
            // Log general exceptions
            self::$logger->error("❌ {$queryDescription} failed with exception", [
                'error_message' => $e->getMessage(),
                'database_type' => $dbType,
                'execution_time_ms' => $executionTime,
                'trace' => $e->getTraceAsString(),
                'context' => $sanitizedContext ?? [],
            ]);
            
            return ApiHelper::sendJsonResponse('error', 'Database operation failed: ' . self::getSafeErrorMessage($e->getMessage()), [], 500);
        }
    }

    /**
     * Sanitize log context to remove sensitive data
     */
    private static function sanitizeLogContext(array $context): array
    {
        $sensitiveKeys = ['password', 'token', 'secret', 'credit_card', 'card_number', 'cvv'];
        
        foreach ($context as $key => $value) {
            if (is_array($value)) {
                $context[$key] = self::sanitizeLogContext($value);
            } elseif (is_string($value) && self::containsSensitiveData($key, $sensitiveKeys)) {
                $context[$key] = '***REDACTED***';
            }
        }
        
        return $context;
    }
    
    /**
     * Check if a key contains sensitive data
     */
    private static function containsSensitiveData(string $key, array $sensitiveKeys): bool
    {
        $key = strtolower($key);
        foreach ($sensitiveKeys as $sensitiveKey) {
            if (strpos($key, $sensitiveKey) !== false) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Get a safe error message that doesn't expose sensitive information
     */
    private static function getSafeErrorMessage(string $originalMessage): string
    {
        // Remove potentially sensitive details from error messages
        $safeMessage = preg_replace('/SQLSTATE\[\w+\]: .+?: /', '', $originalMessage);
        $safeMessage = preg_replace('/near \'(.+?)\'/', 'near [SQL]', $safeMessage);
        
        return $safeMessage;
    }

    /**
     * Insert data into a table
     * 
     * @param string $table Table name
     * @param array $data Data to insert (column => value)
     * @param bool $useSecureDb Whether to use the secure database
     * @param array $context Additional context information for logging
     * @return string|mixed Last insert ID or error response
     */
    public static function insert(
        string $table, 
        array $data, 
        bool $useSecureDb = false,
        array $context = []
    ): string {
        $queryContext = array_merge($context, [
            'operation' => 'INSERT',
            'table' => $table,
            'field_count' => count($data),
        ]);
        
        return self::safeQuery(function ($pdo) use ($table, $data) {
            $columns = implode(", ", array_keys($data));
            $placeholders = implode(", ", array_fill(0, count($data), "?"));
            $sql = "INSERT INTO {$table} ({$columns}) VALUES ({$placeholders})";
            
            $stmt = $pdo->prepare($sql);
            $stmt->execute(array_values($data));
            $lastInsertId = $pdo->lastInsertId();
            
            return $lastInsertId;
        }, "Insert into {$table}", $useSecureDb, $queryContext);
    }

    /**
     * Update data in a table
     * 
     * @param string $table Table name
     * @param array $data Data to update (column => value)
     * @param array $where Where conditions (column => value)
     * @param bool $useSecureDb Whether to use the secure database 
     * @param array $context Additional context information for logging
     * @return int|mixed Number of affected rows or error response
     */
    public static function update(
        string $table, 
        array $data, 
        array $where, 
        bool $useSecureDb = false,
        array $context = []
    ): int {
        $queryContext = array_merge($context, [
            'operation' => 'UPDATE',
            'table' => $table,
            'field_count' => count($data),
            'condition_count' => count($where),
        ]);
        
        return self::safeQuery(function ($pdo) use ($table, $data, $where) {
            $set = implode(", ", array_map(fn($key) => "{$key} = ?", array_keys($data)));
            $whereClause = implode(" AND ", array_map(fn($key) => "{$key} = ?", array_keys($where)));
            $sql = "UPDATE {$table} SET {$set} WHERE {$whereClause}";
            
            $stmt = $pdo->prepare($sql);
            $params = array_merge(array_values($data), array_values($where));
            $stmt->execute($params);
            $rowCount = $stmt->rowCount();
            
            // Log affected rows count
            self::$logger->info("Updated {$rowCount} rows in table {$table}");
            
            return $rowCount;
        }, "Update {$table}", $useSecureDb, $queryContext);
    }

    /**
     * Delete data from a table
     * 
     * @param string $table Table name
     * @param array $where Where conditions (column => value)
     * @param bool $softDelete Whether to perform a soft delete
     * @param bool $useSecureDb Whether to use the secure database
     * @param array $context Additional context information for logging
     * @return int|mixed Number of affected rows or error response
     */
    public static function delete(
        string $table, 
        array $where, 
        bool $softDelete = false, 
        bool $useSecureDb = false,
        array $context = []
    ): int {
        $operation = $softDelete ? 'SOFT_DELETE' : 'DELETE';
        $queryContext = array_merge($context, [
            'operation' => $operation,
            'table' => $table,
            'condition_count' => count($where),
        ]);
        
        return self::safeQuery(function ($pdo) use ($table, $where, $softDelete) {
            if ($softDelete) {
                $sql = "UPDATE {$table} SET deleted_at = NOW() WHERE " . implode(" AND ", array_map(fn($key) => "{$key} = ?", array_keys($where)));
            } else {
                $sql = "DELETE FROM {$table} WHERE " . implode(" AND ", array_map(fn($key) => "{$key} = ?", array_keys($where)));
            }
            
            $stmt = $pdo->prepare($sql);
            $stmt->execute(array_values($where));
            $rowCount = $stmt->rowCount();
            
            // Log affected rows count
            self::$logger->info(($softDelete ? "Soft deleted" : "Deleted") . " {$rowCount} rows from table {$table}");
            
            return $rowCount;
        }, ($softDelete ? "Soft delete from" : "Delete from") . " {$table}", $useSecureDb, $queryContext);
    }

    /**
     * Select data from the database
     * 
     * @param string $query SQL query
     * @param array $params Query parameters
     * @param bool $useSecureDb Whether to use the secure database
     * @param array $context Additional context information for logging
     * @return array|mixed Query results or error response
     */
    public static function select(
        string $query, 
        array $params = [], 
        bool $useSecureDb = false,
        array $context = []
    ): array {
        $queryContext = array_merge($context, [
            'operation' => 'SELECT',
            'param_count' => count($params),
            'query_hash' => md5($query), // For tracking unique queries
        ]);
        
        return self::safeQuery(function ($pdo) use ($query, $params) {
            $stmt = $pdo->prepare($query);
            $stmt->execute($params);
            $results = $stmt->fetchAll();
            
            // Log result count
            self::$logger->debug("Query returned " . count($results) . " rows");
            
            return $results;
        }, "Select query", $useSecureDb, $queryContext);
    }
    
    /**
     * Execute a raw query with enhanced logging
     * 
     * @param string $query SQL query
     * @param array $params Query parameters
     * @param bool $useSecureDb Whether to use the secure database
     * @param array $context Additional context information for logging
     * @return mixed Query result or error response
     */
    public static function rawQuery(
        string $query, 
        array $params = [], 
        bool $useSecureDb = false,
        array $context = []
    ) {
        $operation = strtoupper(trim(explode(' ', $query)[0]));
        $queryContext = array_merge($context, [
            'operation' => $operation,
            'param_count' => count($params),
            'query_hash' => md5($query),
        ]);
        
        return self::safeQuery(function ($pdo) use ($query, $params, $operation) {
            $stmt = $pdo->prepare($query);
            $stmt->execute($params);
            
            if ($operation === 'SELECT') {
                $results = $stmt->fetchAll();
                return $results;
            } else {
                $rowCount = $stmt->rowCount();
                self::$logger->debug("{$operation} affected {$rowCount} rows");
                return $rowCount;
            }
        }, "{$operation} raw query", $useSecureDb, $queryContext);
    }
}
=== App/Helpers/LoggingHelper.php ===
<?php
namespace App\Helpers;

use Psr\Log\LoggerInterface;

/**
 * @deprecated This class is deprecated. Use global functions from logger.php instead:
 * - getLogger(string $category): LoggerInterface
 * - getDefaultLogger(): LoggerInterface
 */
class LoggingHelper
{
    /**
     * @deprecated Use getDefaultLogger() function from logger.php instead
     */
    public static function getDefaultLogger(): LoggerInterface
    {
        trigger_error('LoggingHelper is deprecated. Use getDefaultLogger() function directly.', E_USER_DEPRECATED);
        return \getDefaultLogger();
    }

    /**
     * @deprecated Use getLogger($category) function from logger.php instead
     */
    public static function getLoggerByCategory(string $category): LoggerInterface
    {
        trigger_error('LoggingHelper is deprecated. Use getLogger(category) function directly.', E_USER_DEPRECATED);
        return \getLogger($category);
    }
}
=== App/api.php ===
<?php

require_once __DIR__ . '/../vendor/autoload.php';
require_once __DIR__ . '/../App/Helpers/SecurityHelper.php';

use Firebase\JWT\JWT;
use Firebase\JWT\Key;

// ✅ Load encryption keys
$config = require __DIR__ . '/encryption.php';
$jwtSecret = $config['jwt_secret'] ?? '';

header('Content-Type: application/json');

// ✅ Log Incoming Headers and Cookies
$tmpHeaders = getallheaders();
if (isset($tmpHeaders['X-Auth-Token'])) {
    $tmpHeaders['X-Auth-Token'] = 'Bearer <redacted>';
}
$tmpCookies = $_COOKIE;
if (isset($tmpCookies['jwt'])) {
    $tmpCookies['jwt'] = '<redacted>';
}
error_log("[API DEBUG] " . date('Y-m-d H:i:s') . " - Headers: " . json_encode($tmpHeaders) . "\n", 3, __DIR__ . '/../logs/debug.log');
error_log("[API DEBUG] " . date('Y-m-d H:i:s') . " - Cookies: " . json_encode($tmpCookies) . "\n", 3, __DIR__ . '/../logs/debug.log');

// ✅ Extract JWT from X-Auth-Token Header or Cookie
function getJWT() {
    $headers = getallheaders();
    if (isset($headers['X-Auth-Token']) && preg_match('/Bearer\s+(\S+)/', $headers['X-Auth-Token'], $matches)) {
        return trim($matches[1]);
    }
    return isset($_COOKIE['jwt']) ? trim($_COOKIE['jwt']) : null;
}

// ✅ Validate JWT and Decode User Info
function validateToken() {
    global $jwtSecret;

    $jwt = getJWT();
    if (!$jwt) {
        logApiError("Missing JWT");
        http_response_code(401);
        echo json_encode(["error" => "Unauthorized: Missing token"]);
        exit;
    }

    try {
        return (array) JWT::decode($jwt, new Key($jwtSecret, 'HS256'));
    } catch (Exception $e) {
        logApiError("Invalid JWT: " . $e->getMessage());
        http_response_code(401);
        echo json_encode(["error" => "Unauthorized: Invalid token"]);
        exit;
    }
}

// ✅ Log API Errors for Debugging
function logApiError($message) {
    error_log("[API] " . date('Y-m-d H:i:s') . " - {$message}\n", 3, __DIR__ . '/../logs/debug.log');
}

// ✅ CORS Handling (Apply to All Requests)
header('Access-Control-Allow-Origin: *');
header('Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, X-Auth-Token');

// ✅ Handle CORS Preflight Requests
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    exit;
}

// ✅ Parse API request
$requestUri = $_SERVER['REQUEST_URI'];
$apiPath = trim(str_replace('/api/', '', parse_url($requestUri, PHP_URL_PATH)), '/');

// ✅ Hardcoded Public API Routes
$publicApiRoutes = [
    'auth/login' => '/../public/api/auth/login.php',
    'auth/logout' => '/../public/api/auth/logout.php',
    'auth/register' => '/../public/api/auth/register.php',
    'auth/reset_request' => '/../public/api/auth/reset_request.php',
    'home' => '/../public/api/home.php',
    'vehicles' => '/../public/api/vehicles.php',
];

// ✅ Hardcoded Protected API Routes (Require Authentication)
$protectedApiRoutes = [
    'user/dashboard' => '/../public/api/user/dashboard.php',
    'user/profile' => '/../public/api/user/profile.php',
    'user/reports' => '/../public/api/user/reports.php',
    'user/notifications' => '/../public/api/user/notifications.php',
    'user/documents' => '/../public/api/user/documents.php',
    'payments/history' => '/../public/api/payments/history.php',
    'payments/make_payment' => '/../public/api/payments/make_payment.php',
    'payments/methods' => '/../public/api/payments/methods.php',
    'payments/refund' => '/../public/api/payments/refund.php',
];

// ✅ Ensure API Route Exists
if (isset($protectedApiRoutes[$apiPath])) {
    validateToken();
    $apiFile = __DIR__ . $protectedApiRoutes[$apiPath];
} elseif (isset($publicApiRoutes[$apiPath])) {
    $apiFile = __DIR__ . $publicApiRoutes[$apiPath];
} else {
    logApiError("API Endpoint Not Found: $apiPath");
    http_response_code(404);
    echo json_encode(['error' => 'API not found']);
    exit;
}

// ✅ Include API File
if (file_exists($apiFile)) {
    logApiError("Processing API endpoint: $apiPath");
    require_once $apiFile;
} else {
    logApiError("API File Not Found: $apiFile");
    http_response_code(404);
    echo json_encode(['error' => 'API file not found']);
}
