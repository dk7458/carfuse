=== App/Controllers/UserController.php ===
<?php

namespace App\Controllers;

use App\Services\NotificationService;
use App\Services\Validator;
use App\Services\RateLimiter;
use AuditManager\Services\AuditService;
use PDO;
use Psr\Log\LoggerInterface;
use Firebase\JWT\JWT;
use App\Services\UserService;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

/**
 * User Management Controller
 *
 * Handles user registration, authentication, profile management, and password resets.
 * Implements enhanced security and scalability features.
 */
class UserController
{
    private PDO $appDb;
    private PDO $secureDb;
    private LoggerInterface $logger;
    private array $config;
    private Validator $validator;
    private RateLimiter $rateLimiter;
    private AuditService $auditService;
    private NotificationService $notificationService;
    protected $userService;

    public function __construct(
        PDO $appDb,
        PDO $secureDb,
        LoggerInterface $logger,
        array $config,
        Validator $validator,
        RateLimiter $rateLimiter,
        AuditService $auditService,
        NotificationService $notificationService
    ) {
        $this->appDb = $appDb;
        $this->secureDb = $secureDb;
        $this->logger = $logger;
        $this->config = $config;
        $this->validator = $validator;
        $this->rateLimiter = $rateLimiter;
        $this->auditService = $auditService;
        $this->notificationService = $notificationService;
        $this->userService = new UserService();
    }

    /**
     * Register a new user
     */
    public function register(array $data): array
    {
        try {
            $rules = [
                'name' => 'required|string|max:255',
                'email' => 'required|email|unique:users',
                'password' => 'required|string|min:8|regex:/^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/',
                'phone' => 'required|string|max:20',
                'address' => 'required|string|max:255',
            ];

            if (!$this->validator->validate($data, $rules)) {
                http_response_code(400);
                echo json_encode(['status' => 'error','message' => 'Validation failed','data' => []]);
                exit;
            }

            // Store user in secure database
            $stmt = $this->secureDb->prepare("
                INSERT INTO users (name, email, password_hash, phone, address, role, created_at)
                VALUES (:name, :email, :password, :phone, :address, 'user', NOW())
            ");
            $stmt->execute([
                'name' => $data['name'],
                'email' => $data['email'],
                'password' => password_hash($data['password'], PASSWORD_BCRYPT),
                'phone' => $data['phone'],
                'address' => $data['address'],
            ]);

            $userId = $this->secureDb->lastInsertId();

            // Log action in secure database
            $this->auditService->log(
                'user_registered',
                'A new user has been registered.',
                $userId,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            // Send notification
            $this->notificationService->sendNotification(
                $userId,
                'email',
                'Welcome to Carfuse! Your account has been created successfully.',
                ['email' => $data['email']]
            );

            http_response_code(200);
            echo json_encode(['status' => 'success','message' => 'Registration successful','data' => []]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'Internal Server Error','data' => []]);
        }
        exit;
    }

    /**
     * Authenticate user and generate JWT token
     */
    public function login(string $email, string $password, string $ip): array
    {
        try {
            if ($this->rateLimiter->isRateLimited($ip)) {
                http_response_code(401);
                echo json_encode(['status' => 'error','message' => 'Too many requests','data' => []]);
                exit;
            }

            // Fetch user from secure database
            $stmt = $this->secureDb->prepare("SELECT * FROM users WHERE email = ?");
            $stmt->execute([$email]);
            $user = $stmt->fetch(PDO::FETCH_ASSOC);

            if (!$user || !password_verify($password, $user['password_hash'])) {
                $this->auditService->log(
                    'failed_login_attempt',
                    'Failed login attempt.',
                    null,
                    null,
                    $ip
                );
                http_response_code(401);
                echo json_encode(['status' => 'error','message' => 'Invalid credentials','data' => []]);
                exit;
            }

            $token = $this->generateJWT($user);

            $this->auditService->log(
                'user_logged_in',
                'User logged in successfully.',
                $user['id'],
                null,
                $ip
            );

            http_response_code(200);
            echo json_encode(['status' => 'success','message' => 'Login successful','data' => ['token' => $token]]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'Internal Server Error','data' => []]);
        }
        exit;
    }

/**
 * Update user profile (API version)
 */
public function updateProfile($request) {
    header('Content-Type: application/json');

    try {
        // Replace session-based auth with JWT validation and CSRF protection
        $userId = validateJWT(); // Decodes JWT and returns user_id
        validateCSRFToken($request); // Validate CSRF token

        $data = $request->getParsedBody();

        // ✅ Input Validation (Ensure valid name, email, and phone)
        $rules = [
            'name' => 'required|string|max:255',
            'email' => 'required|email',
            'phone' => 'string|max:20',
            'address' => 'string|max:255',
        ];

        if (!$this->validator->validate($data, $rules)) {
            throw new \Exception("Validation failed: Invalid input.");
        }

        // ✅ Delegate profile update to UserService
        $result = $this->userService->updateProfile($userId, $data);

        if (!$result) {
            throw new \Exception("Profile update failed.");
        }

        // ✅ Log the profile update
        $logMessage = sprintf("[%s] User ID %s: Profile updated\n", date('Y-m-d H:i:s'), $userId);
        file_put_contents(BASE_PATH . '/logs/user.log', $logMessage, FILE_APPEND);

        // ✅ Return JSON response
        http_response_code(200);
        echo json_encode([
            'status' => 'success',
            'message' => 'Profile updated successfully',
            'data' => []
        ]);
    } catch (\Exception $e) {
        error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');

        http_response_code(400);
        echo json_encode([
            'status' => 'error',
            'message' => $e->getMessage(),
            'data' => []
        ]);
    }
}


    /**
     * Generate password reset token
     */
    public function requestPasswordReset(string $email): array
    {
        try {
            $stmt = $this->secureDb->prepare("SELECT * FROM users WHERE email = ?");
            $stmt->execute([$email]);
            $user = $stmt->fetch(PDO::FETCH_ASSOC);

            if (!$user) {
                http_response_code(404);
                echo json_encode(['status' => 'error','message' => 'User not found','data' => []]);
                exit;
            }

            $token = bin2hex(random_bytes(32));
            $expires = date('Y-m-d H:i:s', strtotime('+1 hour'));

            $stmt = $this->secureDb->prepare("
                INSERT INTO password_resets (email, token, expires_at) 
                VALUES (:email, :token, :expires)
            ");
            $stmt->execute([
                'email' => $email,
                'token' => $token,
                'expires' => $expires,
            ]);

            // Send password reset notification
            $this->notificationService->sendNotification(
                $user['id'],
                'email',
                "Use this link to reset your password: {$this->config['reset_url']}?token=$token",
                ['email' => $email]
            );

            http_response_code(200);
            echo json_encode(['status' => 'success','message' => 'Password reset token generated','data' => []]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'Internal Server Error','data' => []]);
        }
        exit;
    }

    private function generateJWT(array $user): string
    {
        $payload = [
            'sub' => $user['id'],
            'email' => $user['email'],
            'role' => $user['role'],
            'iat' => time(),
            'exp' => time() + 3600,
        ];

        return JWT::encode($payload, $this->config['jwt_secret'], 'HS256');
    }

    public function viewProfile(int $userId)
    {
        try {
            $user = $this->getUserById($userId);
            view('user/profile', ['user' => $user]);
        } catch (\Exception $e) {
            $this->logger->error('Failed to load user profile', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error', 'message' => 'Failed to load user profile', 'data' => []]);
        }
    }

    public function editProfileView(int $userId)
    {
        try {
            $user = $this->getUserById($userId);
            view('user/edit_profile', ['user' => $user]);
        } catch (\Exception $e) {
            $this->logger->error('Failed to load edit profile view', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error', 'message' => 'Failed to load edit profile view', 'data' => []]);
        }
    }

    public function userDashboard()
    {
        try {
            // Enforce JWT authentication for protected endpoints
            validateJWT();
            view('dashboard/user_dashboard');
            http_response_code(200);
            echo json_encode(['status' => 'success', 'message' => 'Dashboard loaded', 'data' => []]);
        } catch (\Exception $e) {
            $this->logger->error('Failed to load user dashboard', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error', 'message' => 'Failed to load user dashboard', 'data' => []]);
        }
    }

    // Retrieve user profile and return JSON response
    public function getProfile($request) {
        header('Content-Type: application/json');
        try {
            // Replace requireAuth and session lookup with JWT validation
            $userId = validateJWT();
            $profile = $this->userService->getProfileById($userId);
            http_response_code(200);
            echo json_encode([
                'status' => 'success',
                'data' => $profile
            ]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            http_response_code(400);
            echo json_encode([
                'status' => 'error',
                'message' => $e->getMessage(),
                'data' => []
            ]);
        }
    }
}
=== App/Controllers/BookingController.php ===
<?php

namespace App\Controllers;

use App\Services\BookingService;
use App\Services\PaymentService;
use App\Services\Validator;
use AuditManager\Services\AuditService;
use App\Services\NotificationService;
use Psr\Log\LoggerInterface;
use App\Middleware\AuthMiddleware;
use Exception;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

/**
 * Booking Controller
 *
 * Handles booking operations, including creating, rescheduling,
 * canceling bookings, and fetching booking details or logs.
 */
class BookingController
{
    private BookingService $bookingService;
    private PaymentService $paymentService;
    private Validator $validator;
    private AuditService $auditService;
    private NotificationService $notificationService;
    private LoggerInterface $logger;

    public function __construct(
        BookingService $bookingService,
        PaymentService $paymentService,
        Validator $validator,
        AuditService $auditService,
        NotificationService $notificationService,
        LoggerInterface $logger
    ) {
        $this->bookingService = $bookingService;
        $this->paymentService = $paymentService;
        $this->validator = $validator;
        $this->auditService = $auditService;
        $this->notificationService = $notificationService;
        $this->logger = $logger;
    }

    /**
     * View Booking Details
     */
    public function viewBooking(int $id)
    {
        header('Content-Type: application/json');
        try {
            AuthMiddleware::validateSession();
            $booking = $this->bookingService->getBookingById($id);
            $logs = $this->bookingService->getBookingLogs($id);

            if (!$booking) {
                throw new \Exception("Booking not found.");
            }

            echo json_encode([
                'status' => 'success',
                'message' => 'Booking details fetched',
                'data' => ['booking' => $booking, 'logs' => $logs]
            ]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . " " . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            http_response_code(404);
            echo json_encode(['status' => 'error', 'message' => 'Booking not found', 'data' => []]);
        }
    }

    /**
     * Reschedule Booking
     */
    public function rescheduleBooking(int $id, array $data): array
    {
        try {
            AuthMiddleware::validateSession();
            $rules = [
                'pickup_date' => 'required|date|after_or_equal:today',
                'dropoff_date' => 'required|date|after:pickup_date',
            ];

            if (!$this->validator->validate($data, $rules)) {
                return ['status' => 'error', 'message' => 'Validation failed', 'errors' => $this->validator->errors(), 'data' => []];
            }

            $this->bookingService->rescheduleBooking($id, $data['pickup_date'], $data['dropoff_date']);
            $this->auditService->log(
                'booking_rescheduled',
                'Booking successfully rescheduled.',
                $this->bookingService->getUserIdByBooking($id),
                $id,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            $this->notificationService->sendNotification(
                $this->bookingService->getUserIdByBooking($id),
                'email',
                'Your booking has been rescheduled successfully.',
                []
            );

            http_response_code(200);
            return ['status' => 'success', 'message' => 'Booking rescheduled successfully', 'data' => []];
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . " " . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            http_response_code(500);
            return ['status' => 'error', 'message' => 'Failed to reschedule booking', 'data' => []];
        }
    }

    /**
     * Cancel Booking
     */
    public function cancelBooking(int $id): array
    {
        try {
            AuthMiddleware::validateSession();
            $refundAmount = $this->bookingService->cancelBooking($id);

            if ($refundAmount > 0) {
                $this->paymentService->processRefundForBooking($id, $refundAmount);
            }

            $this->auditService->log(
                'booking_canceled',
                'Booking successfully canceled.',
                $this->bookingService->getUserIdByBooking($id),
                $id,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            $this->notificationService->sendNotification(
                $this->bookingService->getUserIdByBooking($id),
                'email',
                'Your booking has been canceled.',
                []
            );

            http_response_code(200);
            return ['status' => 'success', 'message' => 'Booking canceled successfully', 'data' => []];
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . " " . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            http_response_code(500);
            return ['status' => 'error', 'message' => 'Failed to cancel booking', 'data' => []];
        }
    }

    /**
     * Fetch Booking Logs
     */
    public function getBookingLogs(int $bookingId): array
    {
        try {
            AuthMiddleware::validateSession();
            $logs = $this->bookingService->getBookingLogs($bookingId);
            http_response_code(200);
            return ['status' => 'success', 'message' => 'Booking logs fetched successfully', 'data' => ['logs' => $logs]];
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . " " . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            http_response_code(500);
            return ['status' => 'error', 'message' => 'Failed to fetch booking logs', 'data' => []];
        }
    }

    /**
     * List All Bookings for a User
     */
    public function getUserBookings(int $userId): array
    {
        try {
            AuthMiddleware::validateSession();
            $bookings = $this->bookingService->getUserBookings($userId);
            http_response_code(200);
            return ['status' => 'success', 'message' => 'User bookings fetched successfully', 'data' => ['bookings' => $bookings]];
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . " " . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            http_response_code(500);
            return ['status' => 'error', 'message' => 'Failed to fetch user bookings', 'data' => []];
        }
    }

    /**
     * Create New Booking
     */
    public function createBooking(array $data): array
    {
        header('Content-Type: application/json');
        try {
            AuthMiddleware::validateSession();
            $csrf = $_SERVER['HTTP_X_CSRF_TOKEN'] ?? ($_POST['csrf_token'] ?? '');
            if (!validateCsrfToken($csrf)) {
                throw new Exception("Invalid CSRF token");
            }
            $rules = [
                'user_id' => 'required|integer',
                'vehicle_id' => 'required|integer',
                'pickup_date' => 'required|date|after_or_equal:today',
                'dropoff_date' => 'required|date|after:pickup_date',
            ];

            if (!$this->validator->validate($data, $rules)) {
                return ['status' => 'error', 'message' => 'Validation failed', 'errors' => $this->validator->errors(), 'data' => []];
            }

            if (!$this->bookingService->isVehicleAvailable($data['vehicle_id'], $data['pickup_date'], $data['dropoff_date'])) {
                return ['status' => 'error', 'message' => 'Vehicle is not available for the selected dates', 'data' => []];
            }

            $bookingId = $this->bookingService->createBooking($data);

            $this->auditService->log(
                'booking_created',
                'New booking created.',
                $data['user_id'],
                $bookingId,
                $_SERVER['REMOTE_ADDR'] ?? null
            );
            $this->notificationService->sendNotification(
                $data['user_id'],
                'email',
                'Your booking has been created successfully.',
                []
            );

            http_response_code(201);
            return ['status' => 'success', 'message' => 'Booking created successfully', 'data' => ['booking_id' => $bookingId]];
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . " " . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            http_response_code(500);
            return ['status' => 'error', 'message' => 'Failed to create booking', 'data' => []];
        }
    }
}
=== App/Controllers/NotificationController.php ===
<?php

namespace App\Controllers;

use App\Services\NotificationService;
use App\Services\Validator;
use Psr\Log\LoggerInterface;
use App\Queue\NotificationQueue;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

/**
 * Notification Controller
 *
 * Handles notification management, including sending notifications,
 * marking notifications as read, deleting notifications, and
 * fetching user notifications for display.
 */
class NotificationController
{
    private NotificationService $notificationService;
    private Validator $validator;
    private LoggerInterface $logger;
    private NotificationQueue $notificationQueue;

    public function __construct(
        NotificationService $notificationService,
        Validator $validator,
        LoggerInterface $logger,
        NotificationQueue $notificationQueue
    ) {
        $this->notificationService = $notificationService;
        $this->validator = $validator;
        $this->logger = $logger;
        $this->notificationQueue = $notificationQueue;
    }

    /**
     * Display user notifications in the view.
     */
    public function viewNotifications(int $userId): void
    {
        try {
            $notifications = $this->notificationService->getUserNotifications($userId);
            http_response_code(200);
            echo json_encode(['status' => 'success','message' => 'Notifications loaded','data' => ['notifications' => $notifications]]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            $this->logger->error('Failed to load notifications view', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'An error occurred while fetching notifications','data' => []]);
        }
        exit;
    }

    /**
     * Fetch all notifications for a user via API.
     */
    public function getUserNotifications(int $userId): array
    {
        try {
            $notifications = $this->notificationService->getUserNotifications($userId);
            http_response_code(200);
            echo json_encode(['status' => 'success','message' => 'Notifications fetched','data' => ['notifications' => $notifications]]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            $this->logger->error('Failed to fetch user notifications', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'Failed to fetch user notifications','data' => []]);
        }
        exit;
    }

    /**
     * Fetch all notifications for a user via AJAX.
     */
    public function fetchNotificationsAjax(int $userId): void
    {
        try {
            $notifications = $this->notificationService->getUserNotifications($userId);
            http_response_code(200);
            echo json_encode(['status' => 'success','message' => 'Notifications fetched','data' => ['notifications' => $notifications]]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            $this->logger->error('Failed to fetch user notifications via AJAX', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'Failed to fetch user notifications','data' => []]);
        }
        exit;
    }

    /**
     * Mark a notification as read.
     */
    public function markNotificationAsRead(int $notificationId): array
    {
        try {
            $this->notificationService->markAsRead($notificationId);
            $this->logger->info("Notification marked as read", ['notification_id' => $notificationId]);
            http_response_code(200);
            echo json_encode(['status' => 'success','message' => 'Notification marked as read','data' => []]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            $this->logger->error('Failed to mark notification as read', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'Failed to mark notification as read','data' => []]);
        }
        exit;
    }

    /**
     * Mark a notification as read via POST request.
     */
    public function markNotificationAsReadPost(): void
    {
        $notificationId = $_POST['notification_id'] ?? null;

        if (!$notificationId) {
            http_response_code(400);
            echo json_encode(['status' => 'error','message' => 'Notification ID is required','data' => []]);
            exit;
        }

        try {
            $this->notificationService->markAsRead((int)$notificationId);
            $this->logger->info("Notification marked as read", ['notification_id' => $notificationId]);
            http_response_code(200);
            echo json_encode(['status' => 'success','message' => 'Notification marked as read','data' => []]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            $this->logger->error('Failed to mark notification as read', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'Failed to mark notification as read','data' => []]);
        }
        exit;
    }

    /**
     * Delete a notification.
     */
    public function deleteNotification(int $notificationId): array
    {
        try {
            $this->notificationService->deleteNotification($notificationId);
            $this->logger->info("Notification deleted", ['notification_id' => $notificationId]);
            http_response_code(200);
            echo json_encode(['status' => 'success','message' => 'Notification deleted','data' => []]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            $this->logger->error('Failed to delete notification', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'Failed to delete notification','data' => []]);
        }
        exit;
    }

    /**
     * Send a notification to a user.
     */
    public function sendNotification(array $data): array
    {
        $rules = [
            'user_id' => 'required|integer',
            'type' => 'required|in:email,sms,webhook,push',
            'message' => 'required|string|max:1000',
            'options' => 'array',
        ];

        if (!$this->validator->validate($data, $rules)) {
            $this->logger->warning('Notification validation failed', ['data' => $data]);
            http_response_code(400);
            echo json_encode(['status' => 'error','message' => 'Validation failed','data' => $this->validator->errors()]);
            exit;
        }

        try {
            $success = $this->notificationService->sendNotification(
                $data['user_id'],
                $data['type'],
                $data['message'],
                $data['options'] ?? []
            );

            if ($success) {
                $this->logger->info('Notification sent successfully', ['data' => $data]);
                $this->notificationQueue->queueNotification($data);
                http_response_code(200);
                echo json_encode(['status' => 'success','message' => 'Notification sent successfully','data' => []]);
            } else {
                http_response_code(500);
                echo json_encode(['status' => 'error','message' => 'Notification delivery failed','data' => []]);
            }
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            $this->logger->error('Failed to send notification', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'Failed to send notification','data' => []]);
        }
        exit;
    }

    /**
     * Retry sending a notification.
     */
    public function retryNotification(array $data): array
    {
        $rules = [
            'user_id' => 'required|integer',
            'type' => 'required|in:email,sms,webhook,push',
            'message' => 'required|string|max:1000',
            'options' => 'array',
        ];

        if (!$this->validator->validate($data, $rules)) {
            $this->logger->warning('Retry validation failed', ['data' => $data]);
            http_response_code(400);
            echo json_encode(['status' => 'error','message' => 'Validation failed','data' => $this->validator->errors()]);
            exit;
        }

        try {
            $success = $this->notificationService->sendNotificationWithRetry(
                $data['user_id'],
                $data['type'],
                $data['message'],
                $data['options'] ?? []
            );

            if ($success) {
                $this->logger->info('Notification retry succeeded', ['data' => $data]);
                http_response_code(200);
                echo json_encode(['status' => 'success','message' => 'Notification sent successfully after retries','data' => []]);
            } else {
                http_response_code(500);
                echo json_encode(['status' => 'error','message' => 'Notification delivery failed after retries','data' => []]);
            }
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            $this->logger->error('Retry failed', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Retry failed'];
        }
    }
}
=== App/Controllers/AuthController.php ===
<?php

namespace App\Controllers;

use App\Services\Auth\TokenService;
use PDO;
use Exception;

require_once __DIR__ . '/../Helpers/ViewHelper.php';
require_once __DIR__ . '/../Helpers/SecurityHelper.php';
require_once __DIR__ . '/../Services/Auth/AuthService.php';

class AuthController
{
    protected $authService;
    protected PDO $pdo;

    public function __construct()
    {
        startSecureSession();
        // Use AuthService for authentication logic
        $this->authService = new \App\Services\Auth\AuthService();

        // Load the encryption configuration
        $configPath = __DIR__ . '/../../config/encryption.php';
        if (!file_exists($configPath)) {
            throw new Exception("Encryption configuration missing.");
        }

        $encryptionConfig = require $configPath;

        // Ensure required keys exist
        if (!isset($encryptionConfig['jwt_secret'], $encryptionConfig['jwt_refresh_secret'])) {
            throw new Exception("JWT configuration missing in encryption.php.");
        }

        // Instantiate TokenService
        $this->tokenService = new TokenService(
            $encryptionConfig['jwt_secret'],
            $encryptionConfig['jwt_refresh_secret']
        );

        // Load the database connection
        $dbConfig = require BASE_PATH . '/../../config/database.php';
        try {
            $this->pdo = new PDO(
                "mysql:host={$dbConfig['app_database']['host']};dbname={$dbConfig['app_database']['database']};charset=utf8mb4",
                $dbConfig['app_database']['username'],
                $dbConfig['app_database']['password'],
                [PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION]
            );
        } catch (Exception $e) {
            throw new Exception("Database connection failed: " . $e->getMessage());
        }
    }

    /**
     * Show the login page (GET /auth/login)
     */
    public function loginView()
    {
        view('auth/login');
    }

    /**
     * Show the register page (GET /auth/register)
     */
    public function registerView()
    {
        view('auth/register');
    }

    /**
     * Handle user login (POST /auth/login)
     */
    public function login($request)
    {
        header('Content-Type: application/json');
        try {
            // Assume request body is already parsed
            $data = $request->getParsedBody(); // ...existing code...
            
            // --- CSRF check placeholder (enforce CSRF protection) ---
            // validateCsrfToken($data['csrf_token'] ?? '');

            $username = $data['username'] ?? '';
            $password = $data['password'] ?? '';
            $result = $this->authService->login($username, $password);
            
            // Validate token before returning user details
            if (!$this->authService->validateToken($result['token'])) {
                throw new \Exception('Token validation failed.');
            }

            // Securely store JWT and refresh token in HTTP-only cookies
            setcookie("jwt", $result['token'], [
                "expires" => time() + 3600,
                "path" => "/",
                "secure" => true,
                "httponly" => true,
                "samesite" => "Strict"
            ]);
            setcookie("refresh_token", $result['refresh_token'], [
                "expires" => time() + 604800,
                "path" => "/",
                "secure" => true,
                "httponly" => true,
                "samesite" => "Strict"
            ]);

            http_response_code(200);
            echo json_encode([
                'status' => 'success',
                'message' => 'User logged in',
                'data' => [] // JWT not exposed in response
            ]);
        } catch (\Exception $e) {
            http_response_code(400);
            echo json_encode([
                'status' => 'error',
                'message' => $e->getMessage(),
                'data' => []
            ]);
        }
    }

    /**
     * Refresh access token (POST /auth/refresh)
     */
    public function refresh()
    {
        header('Content-Type: application/json');
        try {
            if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
                throw new \Exception('Method Not Allowed');
            }

            $refreshToken = $_COOKIE['refresh_token'] ?? null;

            if (!$refreshToken) {
                throw new \Exception('Refresh token is required');
            }

            // Validate refresh token before issuing a new access token
            $newToken = $this->tokenService->refreshAccessToken($refreshToken);

            if ($newToken) {
                // Set new access token in HTTP-only secure cookie
                setcookie("jwt", $newToken, [
                    "expires" => time() + 3600,
                    "path" => "/",
                    "secure" => true,
                    "httponly" => true,
                    "samesite" => "Strict"
                ]);

                http_response_code(200);
                echo json_encode([
                    'status' => 'success',
                    'message' => 'Token refreshed',
                    'data' => []
                ]);
            } else {
                throw new \Exception('Invalid refresh token');
            }
        } catch (\Exception $e) {
            http_response_code(401);
            echo json_encode([
                'status' => 'error',
                'message' => $e->getMessage(),
                'data' => []
            ]);
        }
    }

    /**
     * Handle user logout (POST /auth/logout)
     */
    public function logout($request)
    {
        header('Content-Type: application/json');
        try {
            $this->authService->logout();
            
            // --- CSRF check placeholder (enforce CSRF protection) ---

            // Clear the JWT and refresh token cookies
            setcookie("jwt", "", [
                "expires" => time() - 3600,
                "path" => "/",
                "secure" => true,
                "httponly" => true,
                "samesite" => "Strict"
            ]);
            setcookie("refresh_token", "", [
                "expires" => time() - 3600,
                "path" => "/",
                "secure" => true,
                "httponly" => true,
                "samesite" => "Strict"
            ]);

            http_response_code(200);
            echo json_encode([
                'status' => 'success',
                'message' => 'User logged out',
                'data' => []
            ]);
        } catch (\Exception $e) {
            http_response_code(400);
            echo json_encode([
                'status' => 'error',
                'message' => $e->getMessage(),
                'data' => []
            ]);
        }
    }

    /**
     * Get user details endpoint, ensuring token is valid
     */
    public function userDetails($request)
    {
        header('Content-Type: application/json');
        try {
            $token = $_COOKIE['jwt'] ?? '';
            
            // Validate token before processing
            if (!$this->authService->validateToken($token)) {
                throw new \Exception('Invalid token.');
            }
            
            $userData = $this->authService->getUserFromToken($token);
            http_response_code(200);
            echo json_encode([
                'status' => 'success',
                'message' => 'User details fetched',
                'data' => $userData
            ]);
        } catch (\Exception $e) {
            http_response_code(400);
            echo json_encode([
                'status' => 'error',
                'message' => $e->getMessage(),
                'data' => []
            ]);
        }
    }

    private function refreshToken()
    {
        // Logic to refresh JWT token
        // ...existing code...
    }

    private function updateSessionActivity()
    {
        $_SESSION['last_activity'] = time();
    }

    private function logAuthAttempt($status, $message)
    {
        $logMessage = sprintf("[%s] %s: %s from IP: %s\n", date('Y-m-d H:i:s'), ucfirst($status), $message, $_SERVER['REMOTE_ADDR']);
        file_put_contents(__DIR__ . '/../../logs/auth.log', $logMessage, FILE_APPEND);
    }
}
=== App/Controllers/DashboardController.php ===
<?php

namespace App\Controllers;

use App\Services\BookingService;
use App\Services\StatisticsService;
use App\Services\NotificationService;
use App\Services\UserService;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

class DashboardController
{
    private BookingService $bookingService;
    private StatisticsService $statisticsService;
    private NotificationService $notificationService;
    private UserService $userService;

    public function __construct(
        BookingService $bookingService,
        StatisticsService $statisticsService,
        NotificationService $notificationService,
        UserService $userService
    ) {
        $this->bookingService = $bookingService;
        $this->statisticsService = $statisticsService;
        $this->notificationService = $notificationService;
        $this->userService = $userService;
    }

    /**
     * Render user dashboard view
     */
    public function userDashboard()
    {
        view('dashboard/user_dashboard');
    }

    /**
     * Fetch user bookings
     */
    public function getUserBookings(): void
    {
        try {
            $userId = requireAuth(); // get authenticated user id
            $bookings = $this->bookingService->getUserBookings($userId);
            http_response_code(200);
            echo json_encode(['status' => 'success', 'message' => 'Bookings fetched', 'data' => ['bookings' => $bookings]]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . " " . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            http_response_code(500);
            echo json_encode(['status' => 'error', 'message' => 'Failed to fetch bookings', 'data' => []]);
        }
        exit;
    }

    /**
     * Fetch dashboard statistics
     */
    public function fetchStatistics(): void
    {
        try {
            $statistics = $this->statisticsService->getDashboardStatistics();
            http_response_code(200);
            echo json_encode(['status' => 'success', 'message' => 'Statistics fetched', 'data' => $statistics]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . " " . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            http_response_code(500);
            echo json_encode(['status' => 'error', 'message' => 'Failed to fetch statistics', 'data' => []]);
        }
        exit;
    }

    /**
     * Fetch user notifications
     */
    public function fetchNotifications(): void
    {
        try {
            $userId = requireAuth(); // get authenticated user id
            $notifications = $this->notificationService->getUserNotifications($userId);
            http_response_code(200);
            echo json_encode(['status' => 'success', 'message' => 'Notifications fetched', 'data' => ['notifications' => $notifications]]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . " " . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            http_response_code(500);
            echo json_encode(['status' => 'error', 'message' => 'Failed to fetch notifications', 'data' => []]);
        }
        exit;
    }

    /**
     * Fetch user profile information
     */
    public function fetchUserProfile(): void
    {
        try {
            $userId = requireAuth(); // get authenticated user id
            $profile = $this->userService->getUserProfile($userId);
            http_response_code(200);
            echo json_encode(['status' => 'success', 'message' => 'User profile fetched', 'data' => ['profile' => $profile]]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . " " . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            http_response_code(500);
            echo json_encode(['status' => 'error', 'message' => 'Failed to fetch user profile', 'data' => []]);
        }
        exit;
    }
}
=== App/Controllers/AdminDashboardController.php ===
<?php

namespace App\Controllers;

use App\Services\BookingService;
use App\Services\PaymentService;
use App\Services\UserService;
use Psr\Log\LoggerInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

class AdminDashboardController
{
    private BookingService $bookingService;
    private PaymentService $paymentService;
    private UserService $userService;
    private LoggerInterface $logger;

    public function __construct(
        BookingService $bookingService,
        PaymentService $paymentService,
        UserService $userService,
        LoggerInterface $logger
    ) {
        $this->bookingService = $bookingService;
        $this->paymentService = $paymentService;
        $this->userService = $userService;
        $this->logger = $logger;
    }

    /**
     * Render the admin dashboard view.
     */
    public function index(): void
    {
        try {
            $metrics = [
                'total_users' => $this->userService->getTotalUsers(),
                'active_users' => $this->userService->getActiveUsers(),
                'total_bookings' => $this->bookingService->getTotalBookings(),
                'completed_bookings' => $this->bookingService->getCompletedBookings(),
                'canceled_bookings' => $this->bookingService->getCanceledBookings(),
                'total_revenue' => $this->paymentService->getTotalRevenue(),
                'total_refunds' => $this->paymentService->getTotalRefunds(),
                'net_revenue' => $this->paymentService->getNetRevenue(),
            ];

            // Fetch data for graphs
            $graphData = [
                'booking_trends' => $this->bookingService->getMonthlyBookingTrends(),
                'revenue_trends' => $this->paymentService->getMonthlyRevenueTrends(),
            ];

            view('admin/dashboard', ['metrics' => $metrics, 'graphData' => $graphData]);
        } catch (\Exception $e) {
            $this->logger->error('Failed to load admin dashboard', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo 'Error loading the dashboard. Please try again later.';
        }
    }

    /**
     * Get data for admin dashboard metrics and graphs (API).
     */
    public function getDashboardData(): void
    {
        requireAuth(); // ensure admin authentication is in place
        try {
            $metrics = [
                'total_users' => $this->userService->getTotalUsers(),
                'active_users' => $this->userService->getActiveUsers(),
                'total_bookings' => $this->bookingService->getTotalBookings(),
                'completed_bookings' => $this->bookingService->getCompletedBookings(),
                'canceled_bookings' => $this->bookingService->getCanceledBookings(),
                'total_revenue' => $this->paymentService->getTotalRevenue(),
                'total_refunds' => $this->paymentService->getTotalRefunds(),
                'net_revenue' => $this->paymentService->getNetRevenue(),
            ];

            $graphData = [
                'booking_trends' => $this->bookingService->getMonthlyBookingTrends(),
                'revenue_trends' => $this->paymentService->getMonthlyRevenueTrends(),
            ];

            http_response_code(200);
            echo json_encode([
                'status' => 'success',
                'message' => 'Dashboard data fetched',
                'data' => ['metrics' => $metrics, 'graph_data' => $graphData]
            ]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . " " . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            http_response_code(500);
            echo json_encode(['status' => 'error', 'message' => 'Failed to fetch dashboard data', 'data' => []]);
        }
    }
}
=== App/Controllers/PaymentController.php ===
<?php

namespace App\Controllers;

use App\Services\PaymentService;
use App\Services\Validator;
use App\Services\NotificationService;
use AuditManager\Services\AuditService;
use PDO;
use Psr\Log\LoggerInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

/**
 * Payment Controller
 *
 * Handles payment processing, refunds, installment payments, and user transactions.
 */
class PaymentController
{
    private PaymentService $paymentService;
    private Validator $validator;
    private NotificationService $notificationService;
    private AuditService $auditService;
    private PDO $db;
    private LoggerInterface $logger;

    public function __construct(
        PaymentService $paymentService,
        Validator $validator,
        NotificationService $notificationService,
        AuditService $auditService,
        PDO $db,
        LoggerInterface $logger
    ) {
        $this->paymentService = $paymentService;
        $this->validator = $validator;
        $this->notificationService = $notificationService;
        $this->auditService = $auditService;
        $this->db = $db;
        $this->logger = $logger;
    }

    /**
     * Process a payment.
     */
    public function processPayment(array $data): array
    {
        $rules = [
            'user_id' => 'required|integer',
            'amount' => 'required|numeric|min:0.01',
            'payment_method_id' => 'required|integer',
        ];

        if (!$this->validator->validate($data, $rules)) {
            http_response_code(400);
            echo json_encode(['status' => 'error','message' => 'Validation failed','data' => $this->validator->errors()]);
            exit;
        }

        try {
            $transaction = $this->paymentService->processPayment(
                $data['user_id'],
                $data['payment_method_id'],
                $data['amount']
            );

            $this->auditService->log(
                'payment_processed',
                'Payment successfully processed.',
                $data['user_id'],
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            $this->notificationService->sendNotification(
                $data['user_id'],
                'email',
                "Payment of {$data['amount']} was successfully processed.",
                ['email' => $transaction['email']]
            );

            http_response_code(200);
            echo json_encode(['status' => 'success','message' => 'Payment processed','data' => ['transaction' => $transaction]]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            $this->logger->error('Payment processing failed', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'Payment processing failed','data' => []]);
        }
        exit;
    }

    /**
     * Refund a payment.
     */
    public function refundPayment(array $data): array
    {
        $rules = [
            'transaction_id' => 'required|integer',
            'amount' => 'required|numeric|min:0.01',
        ];

        if (!$this->validator->validate($data, $rules)) {
            http_response_code(400);
            echo json_encode(['status' => 'error','message' => 'Validation failed','data' => $this->validator->errors()]);
            exit;
        }

        try {
            $refund = $this->paymentService->processRefund(
                $data['transaction_id'],
                $data['amount']
            );

            $this->auditService->log(
                'refund_processed',
                'Refund successfully processed.',
                null,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            $this->notificationService->sendNotification(
                $refund['user_id'],
                'email',
                "A refund of {$data['amount']} was processed for your transaction.",
                ['email' => $refund['email']]
            );

            http_response_code(200);
            echo json_encode(['status' => 'success','message' => 'Refund processed','data' => ['refund' => $refund]]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            $this->logger->error('Refund processing failed', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'Refund processing failed','data' => []]);
        }
        exit;
    }

    /**
     * Set up installment payments.
     */
    public function setupInstallment(array $data): array
    {
        $rules = [
            'user_id' => 'required|integer',
            'total_amount' => 'required|numeric|min:0.01',
            'installments' => 'required|integer|min:2',
            'payment_method_id' => 'required|integer',
        ];

        if (!$this->validator->validate($data, $rules)) {
            http_response_code(400);
            echo json_encode(['status' => 'error','message' => 'Validation failed','data' => $this->validator->errors()]);
            exit;
        }

        try {
            $installmentPlan = $this->paymentService->createInstallmentPlan(
                $data['user_id'],
                $data['total_amount'],
                $data['installments'],
                $data['payment_method_id']
            );

            $this->auditService->log(
                'installment_plan_created',
                'Installment plan successfully created.',
                $data['user_id'],
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            $this->notificationService->sendNotification(
                $data['user_id'],
                'email',
                "Your installment plan for {$data['total_amount']} has been set up successfully.",
                ['email' => $installmentPlan['email']]
            );

            http_response_code(200);
            echo json_encode(['status' => 'success','message' => 'Installment plan created','data' => ['installment_plan' => $installmentPlan]]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            $this->logger->error('Installment plan setup failed', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'Installment plan setup failed','data' => []]);
        }
        exit;
    }

    /**
     * Fetch all user transactions.
     */
    public function getUserTransactions(int $userId): array
    {
        try {
            $transactions = $this->paymentService->getUserTransactions($userId);
            http_response_code(200);
            echo json_encode(['status' => 'success','message' => 'Transactions fetched','data' => ['transactions' => $transactions]]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            $this->logger->error('Failed to fetch user transactions', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'Failed to fetch user transactions','data' => []]);
        }
        exit;
    }

    /**
     * Fetch payment details.
     */
    public function getPaymentDetails(int $transactionId): array
    {
        try {
            $details = $this->paymentService->getPaymentDetails($transactionId);
            http_response_code(200);
            echo json_encode(['status' => 'success','message' => 'Payment details fetched','data' => ['details' => $details]]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            $this->logger->error('Failed to fetch payment details', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'Failed to fetch payment details','data' => []]);
        }
        exit;
    }
}
=== App/Controllers/ReportController.php ===
<?php

namespace App\Controllers;

use App\Services\ReportService;
use App\Services\Validator;
use App\Services\NotificationService;
use Psr\Log\LoggerInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

class ReportController
{
    private ReportService $reportService;
    private Validator $validator;
    private NotificationService $notificationService;
    private LoggerInterface $logger;

    public function __construct(
        ReportService $reportService,
        Validator $validator,
        NotificationService $notificationService,
        LoggerInterface $logger
    ) {
        $this->reportService = $reportService;
        $this->validator = $validator;
        $this->notificationService = $notificationService;
        $this->logger = $logger;
    }

    /**
     * Admin Report Dashboard View
     */
    public function index()
    {
        try {
            $data = ['view' => 'admin/reports'];
            http_response_code(200);
            echo json_encode(['status' => 'success','message' => 'Report dashboard loaded','data' => $data]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            $this->logger->error('Failed to load admin report dashboard', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'Failed to load report dashboard','data' => []]);
        }
        exit;
    }

    /**
     * Generate Report for Admin
     */
    public function generateReport(array $data): array
    {
        $rules = [
            'report_type' => 'required|in:bookings,payments,users',
            'date_range' => 'required|array',
            'date_range.start' => 'required|date',
            'date_range.end' => 'required|date',
            'filters' => 'array',
            'format' => 'required|in:csv,pdf',
        ];

        if (!$this->validator->validate($data, $rules)) {
            http_response_code(400);
            echo json_encode(['status' => 'error','message' => 'Validation failed','data' => $this->validator->errors()]);
            exit;
        }

        try {
            $report = $this->reportService->generateReport(
                $data['report_type'],
                $data['date_range'],
                $data['filters'] ?? [],
                $data['format']
            );
            http_response_code(200);
            echo json_encode(['status' => 'success','message' => 'Report generated','data' => ['report' => $report]]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            $this->logger->error('Failed to generate report', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'Failed to generate report','data' => []]);
        }
        exit;
    }

    /**
     * User Report Dashboard View
     */
    public function userReports()
    {
        try {
            $data = ['view' => 'user/reports'];
            http_response_code(200);
            echo json_encode(['status' => 'success','message' => 'User report dashboard loaded','data' => $data]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            $this->logger->error('Failed to load user report dashboard', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'Failed to load report dashboard','data' => []]);
        }
        exit;
    }

    /**
     * Generate Report for Users
     */
    public function generateUserReport(array $data): array
    {
        $rules = [
            'user_id' => 'required|integer',
            'report_type' => 'required|in:bookings,payments',
            'date_range' => 'required|array',
            'date_range.start' => 'required|date',
            'date_range.end' => 'required|date',
            'format' => 'required|in:csv,pdf',
        ];

        if (!$this->validator->validate($data, $rules)) {
            http_response_code(400);
            echo json_encode(['status' => 'error','message' => 'Validation failed','data' => $this->validator->errors()]);
            exit;
        }

        try {
            $report = $this->reportService->generateUserReport(
                $data['user_id'],
                $data['report_type'],
                $data['date_range'],
                $data['format']
            );
            http_response_code(200);
            echo json_encode(['status' => 'success','message' => 'User report generated','data' => ['report' => $report]]);
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            $this->logger->error('Failed to generate user report', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'Failed to generate report','data' => []]);
        }
        exit;
    }

    /**
     * Download a Report
     */
    public function downloadReport(string $filePath): void
    {
        try {
            if (!file_exists($filePath)) {
                http_response_code(404);
                echo json_encode(['status' => 'error','message' => 'Report not found','data' => []]);
                return;
            }

            header('Content-Description: File Transfer');
            header('Content-Type: application/octet-stream');
            header('Content-Disposition: attachment; filename=' . basename($filePath));
            header('Expires: 0');
            header('Cache-Control: must-revalidate');
            header('Pragma: public');
            header('Content-Length: ' . filesize($filePath));
            readfile($filePath);
            exit;
        } catch (\Exception $e) {
            error_log(date('Y-m-d H:i:s') . ' ' . $e->getMessage() . "\n", 3, BASE_PATH . '/logs/api.log');
            $this->logger->error('Failed to download report', ['error' => $e->getMessage()]);
            http_response_code(500);
            echo json_encode(['status' => 'error','message' => 'Failed to download report','data' => []]);
        }
    }
}
=== App/Models/Booking.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasOne;

/**
 * Booking Model
 *
 * Represents a booking and handles database interactions.
 */
class Booking extends BaseModel
{
    use SoftDeletes;

    /**
     * Attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'user_id',
        'vehicle_id',
        'pickup_date',
        'dropoff_date',
        'status'
    ];

    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'user_id' => 'required|exists:users,id',
        'vehicle_id' => 'required|exists:vehicles,id',
        'pickup_date' => 'required|date',
        'dropoff_date' => 'required|date|after_or_equal:pickup_date',
        'status' => 'required|string|in:pending,confirmed,cancelled,completed',
    ];

    /**
     * Relationships
     */

    /**
     * Get the user who made the booking.
     *
     * @return BelongsTo
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Get the vehicle associated with the booking.
     *
     * @return BelongsTo
     */
    public function vehicle(): BelongsTo
    {
        return $this->belongsTo(Vehicle::class);
    }

    /**
     * Get the payment associated with the booking.
     *
     * @return HasOne
     */
    public function payment(): HasOne
    {
        return $this->hasOne(Payment::class);
    }

    /**
     * Scopes
     */

    /**
     * Scope a query to filter active bookings.
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopeActive($query)
    {
        return $query->where('status', 'confirmed');
    }

    /**
     * Scope a query to filter bookings by user.
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     * @param int $userId
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopeByUser($query, int $userId)
    {
        return $query->where('user_id', $userId);
    }
}
=== App/Models/TransactionLog.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use App\Services\EncryptionService;

/**
 * TransactionLog Model
 *
 * Represents a financial transaction and handles interactions with the `transaction_logs` table.
 */
class TransactionLog extends BaseModel
{
    // Define relationships
    public function user()
    {
        return $this->belongsTo(User::class);
    }

    // Define query scopes
    public function scopeRecent($query)
    {
        return $query->orderBy('created_at', 'desc');
    }

    public function scopeByUser($query, $userId)
    {
        return $query->where('user_id', $userId);
    }

    // Prevent modification of log entries after creation
    public static function boot()
    {
        parent::boot();

        static::updating(function ($model) {
            return false;
        });
    }

    private PDO $db;

    public function __construct(PDO $db)
    {
        $this->db = $db;
    }

    /**
     * Get all transactions for a user.
     */
    public function getByUserId(int $userId): array
    {
        $stmt = $this->db->prepare("SELECT * FROM transaction_logs WHERE user_id = :user_id ORDER BY created_at DESC");
        $stmt->execute([':user_id' => $userId]);
        $transactions = $stmt->fetchAll(PDO::FETCH_ASSOC) ?: [];

        // Decrypt transaction details
        foreach ($transactions as &$transaction) {
            $transaction['amount'] = EncryptionService::decrypt($transaction['amount']);
        }

        return $transactions;
    }

    /**
     * Get transaction by ID.
     */
    public function getById(int $id): ?array
    {
        $stmt = $this->db->prepare("SELECT * FROM transaction_logs WHERE id = :id");
        $stmt->execute([':id' => $id]);
        $transaction = $stmt->fetch(PDO::FETCH_ASSOC) ?: null;

        if ($transaction) {
            // Decrypt transaction details
            $transaction['amount'] = EncryptionService::decrypt($transaction['amount']);
        }

        return $transaction;
    }

    /**
     * Log a new transaction.
     */
    public function create(array $data): int
    {
        // Encrypt transaction details
        $data['amount'] = EncryptionService::encrypt($data['amount']);

        $stmt = $this->db->prepare("
            INSERT INTO transaction_logs (user_id, booking_id, amount, type, status, created_at)
            VALUES (:user_id, :booking_id, :amount, :type, :status, NOW())
        ");
        $stmt->execute([
            ':user_id' => $data['user_id'],
            ':booking_id' => $data['booking_id'],
            ':amount' => $data['amount'],
            ':type' => $data['type'],
            ':status' => $data['status'] ?? 'pending',
        ]);
        return $this->db->lastInsertId();
    }

    /**
     * Update transaction status.
     */
    public function updateStatus(int $id, string $status): bool
    {
        $stmt = $this->db->prepare("UPDATE transaction_logs SET status = :status WHERE id = :id");
        return $stmt->execute([':status' => $status, ':id' => $id]);
    }
}
=== App/Models/Payment.php ===
<?php

namespace App\Models;

use App\Models\BaseModel;
use App\Models\User;
use App\Models\Booking;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo; // Ensure this is included

/**
 * Payment Model
 *
 * Represents a payment transaction in the system.
 *
 * @property int $id Primary key
 * @property int $user_id ID of the user who made the payment
 * @property int $booking_id ID of the associated booking
 * @property float $amount Transaction amount
 * @property string $method Payment method (credit_card, PayPal, etc.)
 * @property string $status Status of the payment (pending, completed, failed)
 * @property string|null $transaction_id Unique external transaction identifier
 * @property \DateTime $created_at Timestamp when the record was created
 * @property \DateTime $updated_at Timestamp when the record was last updated
 * @property \DateTime|null $deleted_at Soft delete timestamp
 */
class Payment extends BaseModel
{
    use SoftDeletes;

    /**
     * Attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'user_id',
        'booking_id',
        'amount',
        'method',
        'status',
        'transaction_id'
    ];

    /**
     * Attributes that should be hidden for arrays.
     *
     * @var array
     */
    protected $hidden = [
        'deleted_at'
    ];

    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'user_id' => 'required|exists:users,id',
        'booking_id' => 'required|exists:bookings,id',
        'amount' => 'required|numeric|min:0',
        'method' => 'required|string|in:credit_card,paypal,bank_transfer',
        'status' => 'required|string|in:pending,completed,failed',
        'transaction_id' => 'nullable|string|max:255',
    ];

    /**
     * Relationships
     */

    /**
     * Get the user who made the payment.
     *
     * @return BelongsTo
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Get the booking associated with the payment.
     *
     * @return BelongsTo
     */
    public function booking(): BelongsTo
    {
        return $this->belongsTo(Booking::class);
    }

    /**
     * Scopes
     */

    /**
     * Scope a query to filter payments by user.
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     * @param int $userId
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopeByUser($query, int $userId)
    {
        return $query->where('user_id', $userId);
    }

    /**
     * Scope a query to fetch completed payments.
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopeCompleted($query)
    {
        return $query->where('status', 'completed');
    }

    /**
     * Scope a query to filter payments by status.
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     * @param string $status
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopeByStatus($query, string $status)
    {
        return $query->where('status', $status);
    }

    /**
     * Scope a query to filter payments by a date range.
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     * @param string $startDate
     * @param string $endDate
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopeByDateRange($query, string $startDate, string $endDate)
    {
        return $query->whereBetween('created_at', [$startDate, $endDate]);
    }
}
=== App/Models/Notification.php ===
<?php

namespace App\Models;

use DateTime;
use PDO;
use PDOException;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

/**
 * Notification Model
 *
 * Represents a notification in the system.
 *
 * @property int $id
 * @property int $user_id
 * @property string $type
 * @property string $message
 * @property DateTime $sent_at
 * @property bool $is_read
 */
class Notification extends BaseModel
{
    use SoftDeletes;

    private int $id;
    private int $user_id;
    private string $type;
    private string $message;
    private DateTime $sent_at;
    private bool $is_read;

    /**
     * Attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'user_id',
        'type',
        'message',
        'sent_at',
        'is_read'
    ];

    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'user_id' => 'required|exists:users,id',
        'type' => 'required|string|max:255',
        'message' => 'required|string',
        'sent_at' => 'required|date',
        'is_read' => 'boolean',
    ];

    public function __construct(
        int $user_id,
        string $type,
        string $message,
        DateTime $sent_at = null,
        bool $is_read = false
    ) {
        $this->user_id = $user_id;
        $this->type = $type;
        $this->message = $message;
        $this->sent_at = $sent_at ?? new DateTime();
        $this->is_read = $is_read;
    }

    /**
     * Save the notification to the database.
     */
    public function save(PDO $db): bool
    {
        try {
            $stmt = $db->prepare("
                INSERT INTO notifications (user_id, type, message, sent_at, is_read)
                VALUES (:user_id, :type, :message, :sent_at, :is_read)
            ");
            $success = $stmt->execute([
                ':user_id' => $this->user_id,
                ':type' => $this->type,
                ':message' => $this->message,
                ':sent_at' => $this->sent_at->format('Y-m-d H:i:s'),
                ':is_read' => (int)$this->is_read,
            ]);

            if ($success) {
                $this->id = (int)$db->lastInsertId();
            }

            return $success;
        } catch (PDOException $e) {
            return false;
        }
    }

    /**
     * Mark the notification as read.
     */
    public function markAsRead(PDO $db): bool
    {
        try {
            $stmt = $db->prepare("
                UPDATE notifications
                SET is_read = 1
                WHERE id = :id
            ");
            return $stmt->execute([':id' => $this->id]);
        } catch (PDOException $e) {
            return false;
        }
    }

    /**
     * Delete the notification from the database.
     */
    public function delete(PDO $db): bool
    {
        try {
            $stmt = $db->prepare("
                DELETE FROM notifications
                WHERE id = :id
            ");
            return $stmt->execute([':id' => $this->id]);
        } catch (PDOException $e) {
            return false;
        }
    }

    /**
     * Fetch all notifications for a specific user.
     */
    public static function getByUserId(PDO $db, int $user_id): array
    {
        try {
            $stmt = $db->prepare("
                SELECT * FROM notifications
                WHERE user_id = :user_id
                ORDER BY sent_at DESC
            ");
            $stmt->execute([':user_id' => $user_id]);
            $results = $stmt->fetchAll(PDO::FETCH_ASSOC);

            return array_map(function ($data) {
                return new self(
                    $data['user_id'],
                    $data['type'],
                    $data['message'],
                    new DateTime($data['sent_at']),
                    (bool)$data['is_read']
                );
            }, $results);
        } catch (PDOException $e) {
            return [];
        }
    }

    /**
     * Fetch a single notification by its ID.
     */
    public static function getById(PDO $db, int $id): ?self
    {
        try {
            $stmt = $db->prepare("
                SELECT * FROM notifications
                WHERE id = :id
            ");
            $stmt->execute([':id' => $id]);
            $data = $stmt->fetch(PDO::FETCH_ASSOC);

            if ($data) {
                return new self(
                    $data['user_id'],
                    $data['type'],
                    $data['message'],
                    new DateTime($data['sent_at']),
                    (bool)$data['is_read']
                );
            }

            return null;
        } catch (PDOException $e) {
            return null;
        }
    }

    /**
     * Mark all notifications as read for a user.
     */
    public static function markAllAsRead(PDO $db, int $user_id): bool
    {
        try {
            $stmt = $db->prepare("
                UPDATE notifications
                SET is_read = 1
                WHERE user_id = :user_id
            ");
            return $stmt->execute([':user_id' => $user_id]);
        } catch (PDOException $e) {
            return false;
        }
    }

    /**
     * Relationships
     */

    /**
     * Get the user associated with the notification.
     *
     * @return BelongsTo
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Scopes
     */

    /**
     * Scope a query to filter unread notifications.
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopeUnread($query)
    {
        return $query->where('is_read', false);
    }
}
=== App/Models/PaymentMethod.php ===
<?php

namespace App\Models;

use PDO;
use App\Models\BaseModel;
use App\Models\User;

/**
 * PaymentMethod Model
 *
 * Represents a payment method and handles interactions with the `payment_methods` table.
 */
class PaymentMethod extends BaseModel
{
    protected $fillable = ['name', 'description', 'is_active', 'user_id', 'payment_type'];
    private PDO $db;

    public function __construct(PDO $db)
    {
        $this->db = $db;
    }

    /**
     * Get all available payment methods.
     */
    public function getAll(): array
    {
        $stmt = $this->db->query("SELECT * FROM payment_methods WHERE is_active = 1");
        return $stmt->fetchAll(PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Get payment method by ID.
     */
    public function getById(int $id): ?array
    {
        $stmt = $this->db->prepare("SELECT * FROM payment_methods WHERE id = :id");
        $stmt->execute([':id' => $id]);
        return $stmt->fetch(PDO::FETCH_ASSOC) ?: null;
    }

    /**
     * Add a new payment method.
     */
    public function create(array $data): int
    {
        $validPaymentTypes = ['credit_card', 'paypal', 'bank_transfer'];
        if (!in_array($data['payment_type'], $validPaymentTypes)) {
            throw new \InvalidArgumentException("Invalid payment type.");
        }

        $stmt = $this->db->prepare("
            INSERT INTO payment_methods (name, description, is_active, created_at, user_id, payment_type)
            VALUES (:name, :description, :is_active, NOW(), :user_id, :payment_type)
        ");
        $stmt->execute([
            ':name' => $data['name'],
            ':description' => $data['description'] ?? '',
            ':is_active' => $data['is_active'] ?? 1,
            ':user_id' => $data['user_id'],
            ':payment_type' => $data['payment_type'],
        ]);
        return $this->db->lastInsertId();
    }

    /**
     * Define relationship with User.
     */
    public function user()
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Scope to filter by user.
     */
    public function scopeByUser($query, $userId)
    {
        return $query->where('user_id', $userId);
    }
}
=== App/Models/Vehicle.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Vehicle extends BaseModel
{
    protected string $table = 'vehicles';

    protected array $fillable = [
        'registration_number',
        'type',
        'status',
        'make',
        'model',
        'year',
    ];

    public static array $rules = [
        'registration_number' => 'required|string|unique:vehicles,registration_number',
        'type' => 'required|string',
        'status' => 'required|in:available,unavailable,maintenance',
        'make' => 'required|string|max:255',
        'model' => 'required|string|max:255',
        'year' => 'required|integer|min:1886|max:' . date('Y'),
    ];

    /**
     * Relationships
     */

    // Get vehicle's bookings
    public function bookings()
    {
        return $this->hasMany(Booking::class, 'vehicle_id', 'id');
    }

    /**
     * Scopes
     */

    // Scope a query to only include available vehicles
    public function scopeAvailable($query)
    {
        return $query->where('status', 'available');
    }

    // Scope a query to only include vehicles of a specific type
    public function scopeByType($query, $type)
    {
        return $query->where('type', $type);
    }

    /**
     * Events
     */

    // Actions to take after vehicle creation
    protected static function boot()
    {
        parent::boot();

        static::creating(function ($vehicle) {
            // Ensure vehicle status is properly managed
            if (empty($vehicle->status)) {
                $vehicle->status = 'available';
            }
        });
    }
}
=== App/Models/User.php ===
<?php

namespace App\Models;

use App\Models\BaseModel;
use App\Models\Booking;
use App\Models\Notification;
use App\Models\Payment;
use App\Traits\HasUuid;
use App\Traits\SoftDeletes;
use App\Helpers\HashHelper;

/**
 * User Model
 * 
 * Represents a user in the system with their associated data and relationships.
 * 
 * @property string $id UUID of the user
 * @property string $name User's first name
 * @property string $surname User's last name
 * @property string $email User's email address
 * @property string $password_hash Hashed password
 * @property string $role User role (user, admin, super_admin)
 * @property string $phone Phone number
 * @property string $address Physical address
 * @property \DateTime $created_at
 * @property \DateTime $updated_at
 * @property \DateTime $deleted_at
 */
class User extends BaseModel
{
    use HasUuid, SoftDeletes;

    protected string $table = 'users';

    protected array $fillable = [
        'name',
        'surname',
        'email',
        'password',
        'role',
        'phone',
        'address',
    ];

    protected array $hidden = [
        'password_hash',
        'remember_token',
        'deleted_at',
    ];

    protected array $dates = [
        'created_at',
        'updated_at',
        'deleted_at',
        'email_verified_at',
    ];

    public static array $rules = [
        'name' => 'required|string|max:255',
        'surname' => 'required|string|max:255',
        'email' => 'required|email|unique:users,email',
        'password' => 'required|min:8|regex:/^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/',
        'role' => 'required|in:user,admin,super_admin',
        'phone' => 'required|string|max:20',
        'address' => 'required|string|max:255',
    ];

    /**
     * Relationships
     */

    // Get user's bookings
    public function bookings()
    {
        return $this->hasMany(Booking::class, 'user_id', 'id');
    }

    // Get user's payments
    public function payments()
    {
        return $this->hasMany(Payment::class, 'user_id', 'id');
    }

    // Get user's notifications
    public function notifications()
    {
        return $this->hasMany(Notification::class, 'user_id', 'id');
    }

    /**
     * Accessors
     */

    // Get user's full name
    public function getFullNameAttribute(): string
    {
        return "{$this->name} {$this->surname}";
    }

    /**
     * Mutators
     */

    // Set password (automatically hash)
    public function setPasswordAttribute(string $value): void
    {
        $this->attributes['password_hash'] = HashHelper::hash($value);
    }

    /**
     * Helpers
     */

    // Check if user is an admin
    public function isAdmin(): bool
    {
        return in_array($this->role, ['admin', 'super_admin']);
    }

    // Check if user is a super admin
    public function isSuperAdmin(): bool
    {
        return $this->role === 'super_admin';
    }

    // Check if user has a specific permission
    public function hasPermission(string $permission): bool
    {
        $rolePermissions = [
            'user' => ['read_own'],
            'admin' => ['read_own', 'read_all', 'write_all'],
            'super_admin' => ['read_own', 'read_all', 'write_all', 'delete_all'],
        ];

        return in_array($permission, $rolePermissions[$this->role] ?? []);
    }

    /**
     * Scopes
     */

    // Scope a query to only include active users
    public function scopeActive($query)
    {
        return $query->whereNull('deleted_at');
    }

    // Scope a query to only include users with a specific role
    public function scopeWithRole($query, string $role)
    {
        return $query->where('role', $role);
    }

    /**
     * Events
     */

    // Actions to take after user creation
    protected static function boot()
    {
        parent::boot();

        static::creating(function ($user) {
            if (empty($user->id)) {
                $user->id = (string) \Ramsey\Uuid\Uuid::uuid4();
            }
        });

        static::deleting(function ($user) {
            // Perform any cleanup tasks like logging the deletion
        });
    }
}
=== App/Models/BaseModel.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Support\Str;


class BaseModel extends Model
{
    use SoftDeletes;

    /**
     * The "booting" method of the model.
     *
     * @return void
     */
    protected static function boot()
    {
        parent::boot();

        // Automatically generate UUID for primary key
        static::creating(function ($model) {
            if (empty($model->{$model->getKeyName()})) {
                $model->{$model->getKeyName()} = (string) Str::uuid();
            }
        });

        // Apply global scope for soft deletes
        static::addGlobalScope('softDeletes', function (Builder $builder) {
            $builder->whereNull('deleted_at');
        });

        // Apply global scope for default ordering
        static::addGlobalScope('order', function (Builder $builder) {
            $builder->orderBy('created_at', 'desc');
        });
    }

    /**
     * Indicates if the IDs are auto-incrementing.
     *
     * @var bool
     */
    public $incrementing = false;

    /**
     * The data type of the primary key.
     *
     * @var string
     */
    protected $keyType = 'string';

    /**
     * Attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [];

    /**
     * Log changes made to the model.
     *
     * @return void
     */
    protected static function bootLogging()
    {
        static::updated(function ($model) {
            // Log changes
        });
    }
}
=== App/Models/Report.php ===
<?php

namespace App\Models;

use App\Models\BaseModel;
use App\Models\Admin;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

/**
 * Report Model
 *
 * Represents an admin report in the system.
 */
class Report extends BaseModel
{
    use SoftDeletes;

    /**
     * Attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'admin_id',
        'title',
        'content',
        'status',
        'created_at',
        'updated_at'
    ];

    /**
     * Relationships
     */

    /**
     * Get the admin who created the report.
     *
     * @return BelongsTo
     */
    public function admin(): BelongsTo
    {
        return $this->belongsTo(Admin::class);
    }

    /**
     * Scopes
     */

    /**
     * Scope a query to filter reports by a date range.
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     * @param string $start
     * @param string $end
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopeByDateRange($query, string $start, string $end)
    {
        return $query->whereBetween('created_at', [$start, $end]);
    }
}
=== App/Models/RefundLog.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

/**
 * RefundLog Model
 *
 * Represents a refund and handles interactions with the `refund_logs` table.
 */
class RefundLog extends Model  // Directly extend Eloquent's Model for testing
{
    use SoftDeletes;

    protected $fillable = ['booking_id', 'amount', 'reason', 'status', 'user_id', 'payment_id'];

    /**
     * Validation rules for the model.
     */
    public static $rules = [
        'booking_id' => 'required|exists:bookings,id',
        'amount' => 'required|numeric|min:0',
        'reason' => 'nullable|string',
        'status' => 'required|string|in:pending,approved,denied',
        'user_id' => 'required|exists:users,id',
        'payment_id' => 'required|exists:payments,id',
    ];

    /**
     * Relationship with User.
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Relationship with Payment.
     */
    public function payment(): BelongsTo
    {
        return $this->belongsTo(Payment::class);
    }
}=== App/Models/Signature.php ===
namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use App\Services\EncryptionService;

class Signature extends BaseModel
{
    // Define relationships
    public function user()
    {
        return $this->belongsTo(User::class);
    }

    // Ensure secure storage handling using encryption
    public function setSignatureAttribute($value)
    {
        $this->attributes['signature'] = EncryptionService::encrypt($value);
    }

    public function getSignatureAttribute($value)
    {
        return EncryptionService::decrypt($value);
    }

    // Implement validation rules to only allow specific file types
    public static function rules()
    {
        return [
            'signature' => 'required|mimes:png,jpg,svg|max:2048',
        ];
    }
}
=== App/Queues/DocumentQueue.php ===
<?php

namespace App\Queues;

use DocumentManager\Services\FileStorage;
use Psr\Log\LoggerInterface;

class DocumentQueue
{
    private FileStorage $fileStorage;
    private string $queueFile;
    private LoggerInterface $logger;
    private const MAX_RETRY_ATTEMPTS = 3;

    public function __construct(FileStorage $fileStorage, string $queueFile, LoggerInterface $logger)
    {
        $this->fileStorage = $fileStorage;
        $this->queueFile = $queueFile;
        $this->logger = $logger;
    }

    public function push(array $document): void
    {
        $queue = $this->getQueue();
        $document['attempts'] = 0;
        $queue[] = $document;
        $this->saveQueue($queue);
        $this->logger->info('Document added to queue', $document);
    }

    public function process(): void
    {
        $queue = $this->getQueue();
        foreach ($queue as $index => $document) {
            try {
                $success = $this->fileStorage->storeFile($document['file_path'], $document['destination']);

                if ($success) {
                    unset($queue[$index]);
                    $this->logger->info('Document processed successfully', $document);
                } else {
                    $queue[$index]['attempts']++;
                    $this->logger->warning('Document processing failed, retrying...', [
                        'document' => $document,
                        'attempts' => $queue[$index]['attempts'],
                    ]);
                }

                if ($queue[$index]['attempts'] >= self::MAX_RETRY_ATTEMPTS) {
                    $this->logger->error('Max retry attempts reached for document', $document);
                    unset($queue[$index]);
                }
            } catch (\Exception $e) {
                $this->logger->error('Error processing document', [
                    'document' => $document,
                    'error' => $e->getMessage(),
                ]);
            }
        }

        $this->saveQueue(array_values($queue));
    }

    private function getQueue(): array
    {
        if (!file_exists($this->queueFile)) {
            return [];
        }
        return json_decode(file_get_contents($this->queueFile), true) ?? [];
    }

    private function saveQueue(array $queue): void
    {
        file_put_contents($this->queueFile, json_encode($queue, JSON_PRETTY_PRINT));
    }
}
=== App/Queues/NotificationQueue.php ===
<?php

namespace App\Queues;

use App\Services\NotificationService;
use Psr\Log\LoggerInterface;

class NotificationQueue
{
    private string $queueFile;
    private NotificationService $notificationService;
    private LoggerInterface $logger;
    private const MAX_RETRY_ATTEMPTS = 3;

    public function __construct(
        NotificationService $notificationService,
        string $queueFile,
        LoggerInterface $logger
    ) {
        $this->notificationService = $notificationService;
        $this->queueFile = $queueFile;
        $this->logger = $logger;
    }

    /**
     * Push a notification onto the queue
     */
    public function push(array $notification): void
    {
        $queue = $this->getQueue();
        $notification['attempts'] = 0; // Initialize retry attempts
        $queue[] = $notification;
        $this->saveQueue($queue);
        $this->logger->info('Notification added to queue', $notification);
    }

    /**
     * Process the notification queue
     */
    public function process(): void
    {
        $queue = $this->getQueue();
        foreach ($queue as $index => $notification) {
            try {
                $success = $this->notificationService->sendNotification(
                    $notification['user_id'],
                    $notification['type'],
                    $notification['message'],
                    $notification['options']
                );

                if ($success) {
                    unset($queue[$index]); // Remove notification on success
                    $this->logger->info('Notification processed successfully', $notification);
                } else {
                    $queue[$index]['attempts']++;
                    $this->logger->warning('Notification failed, retrying...', [
                        'notification' => $notification,
                        'attempts' => $queue[$index]['attempts'],
                    ]);
                }

                // Remove notifications that exceed retry attempts
                if ($queue[$index]['attempts'] >= self::MAX_RETRY_ATTEMPTS) {
                    $this->logger->error('Max retry attempts reached for notification', $notification);
                    unset($queue[$index]);
                }
            } catch (\Exception $e) {
                $this->logger->error('Error processing notification', [
                    'notification' => $notification,
                    'error' => $e->getMessage(),
                ]);
            }
        }

        $this->saveQueue(array_values($queue)); // Reindex and save the queue
    }

    /**
     * Retrieve the current queue
     */
    private function getQueue(): array
    {
        if (!file_exists($this->queueFile)) {
            return [];
        }
        return json_decode(file_get_contents($this->queueFile), true) ?? [];
    }

    /**
     * Save the current queue to the file
     */
    private function saveQueue(array $queue): void
    {
        file_put_contents($this->queueFile, json_encode($queue, JSON_PRETTY_PRINT));
    }
}
=== App/Services/MetricsService.php ===
<?php

namespace App\Services;

use PDO;

class MetricsService
{
    private PDO $db;

    public function __construct(PDO $db)
    {
        $this->db = $db;
    }

    /**
     * Fetch dashboard metrics
     */
    public function getDashboardMetrics(): array
    {
        $metrics = [
            'total_users' => 0,
            'active_users' => 0,
            'total_bookings' => 0,
            'completed_bookings' => 0,
            'canceled_bookings' => 0,
            'total_revenue' => 0.0,
            'total_refunds' => 0.0,
            'net_revenue' => 0.0,
        ];

        // Fetch total and active users
        $stmt = $this->db->query("SELECT COUNT(*) AS total_users, SUM(active = 1) AS active_users FROM users");
        $userData = $stmt->fetch(PDO::FETCH_ASSOC);
        if ($userData) {
            $metrics['total_users'] = $userData['total_users'];
            $metrics['active_users'] = $userData['active_users'];
        }

        // Fetch bookings data
        $stmt = $this->db->query("
            SELECT 
                COUNT(*) AS total_bookings,
                SUM(status = 'completed') AS completed_bookings,
                SUM(status = 'canceled') AS canceled_bookings
            FROM bookings
        ");
        $bookingData = $stmt->fetch(PDO::FETCH_ASSOC);
        if ($bookingData) {
            $metrics['total_bookings'] = $bookingData['total_bookings'];
            $metrics['completed_bookings'] = $bookingData['completed_bookings'];
            $metrics['canceled_bookings'] = $bookingData['canceled_bookings'];
        }

        // Fetch revenue and refunds
        $stmt = $this->db->query("
            SELECT 
                SUM(CASE WHEN type = 'payment' THEN amount ELSE 0 END) AS total_revenue,
                SUM(CASE WHEN type = 'refund' THEN amount ELSE 0 END) AS total_refunds
            FROM transaction_logs
            WHERE status = 'completed'
        ");
        $revenueData = $stmt->fetch(PDO::FETCH_ASSOC);
        if ($revenueData) {
            $metrics['total_revenue'] = $revenueData['total_revenue'] ?? 0.0;
            $metrics['total_refunds'] = $revenueData['total_refunds'] ?? 0.0;
            $metrics['net_revenue'] = $metrics['total_revenue'] - $metrics['total_refunds'];
        }

        return $metrics;
    }
}
=== App/Services/UserService.php ===
<?php

namespace App\Services;

use PDO;
use PDOException;
use Psr\Log\LoggerInterface;
use Firebase\JWT\JWT;
use Firebase\JWT\Key;

/**
 * UserService
 * 
 * Handles user-related operations such as creation, updates, authentication, role management,
 * password management, and logging.
 */
class UserService
{
    private PDO $db;
    private LoggerInterface $logger;
    private string $jwtSecret;

    public function __construct(PDO $db, LoggerInterface $logger, string $jwtSecret)
    {
        $this->db = $db;
        $this->logger = $logger;
        $this->jwtSecret = $jwtSecret;
    }

    /**
     * Create a new user
     */
    public function createUser(array $data): array
    {
        $rules = [
            'name' => 'required|string|max:255',
            'email' => 'required|email|unique:users',
            'password' => 'required|string|min:8|regex:/^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/',
            'phone' => 'required|string|max:20',
            'address' => 'required|string|max:255',
        ];

        $validator = new Validator();
        if (!$validator->validate($data, $rules)) {
            return ['status' => 'error', 'message' => 'Validation failed', 'errors' => $validator->errors()];
        }

        try {
            $stmt = $this->db->prepare("
                INSERT INTO users (name, email, password, phone, address, role, created_at)
                VALUES (:name, :email, :password, :phone, :address, 'user', NOW())
            ");

            $stmt->execute([
                'name' => $data['name'],
                'email' => $data['email'],
                'password' => password_hash($data['password'], PASSWORD_BCRYPT),
                'phone' => $data['phone'],
                'address' => $data['address']
            ]);

            $this->logAction(null, 'user_created', ['email' => $data['email']]);
            return ['status' => 'success', 'message' => 'User created successfully'];
        } catch (PDOException $e) {
            $this->logger->error('User creation failed', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'User creation failed'];
        }
    }

    /**
     * Update an existing user's information
     */
    public function updateUser(int $id, array $data): array
    {
        // Allowed update fields including password
        $allowedFields = ['name', 'phone', 'address', 'password'];
        $updates = array_intersect_key($data, array_flip($allowedFields));

        // Input validation: ensure there's at least one field to update
        if (empty($updates)) {
            return ['status' => 'error', 'message' => 'No valid fields to update'];
        }

        // Process password: hash if provided and non-empty, otherwise remove it
        if (isset($updates['password'])) {
            if (!empty($updates['password'])) {
                $updates['password'] = password_hash($updates['password'], PASSWORD_BCRYPT);
            } else {
                unset($updates['password']);
            }
        }

        // Use UserModel for DB update
        $userModel = new \App\Models\UserModel($this->db);
        $result = $userModel->update($id, $updates);

        if ($result) {
            $this->logAction($id, 'user_updated', $updates);
            return ['status' => 'success', 'message' => 'User updated successfully'];
        } else {
            $this->logger->error('User update failed');
            return ['status' => 'error', 'message' => 'User update failed'];
        }
    }

    /**
     * Delete a user (soft delete)
     */
    public function deleteUser(int $id): bool
    {
        try {
            $stmt = $this->db->prepare("UPDATE users SET deleted_at = NOW() WHERE id = :id");
            $stmt->execute(['id' => $id]);

            $this->logAction($id, 'user_deleted');
            return true;
        } catch (PDOException $e) {
            $this->logger->error('User deletion failed', ['error' => $e->getMessage()]);
            return false;
        }
    }

    /**
     * Authenticate a user
     */
    public function authenticate(string $email, string $password): ?string
    {
        $stmt = $this->db->prepare("SELECT * FROM users WHERE email = :email AND deleted_at IS NULL");
        $stmt->execute(['email' => $email]);
        $user = $stmt->fetch(PDO::FETCH_ASSOC);

        if (!$user || !password_verify($password, $user['password'])) {
            $this->logAction(null, 'authentication_failed', ['email' => $email]);
            return null;
        }

        $this->logAction($user['id'], 'authentication_successful');
        return $this->generateJWT($user);
    }

    /**
     * Change a user's password
     */
    public function changePassword(int $id, string $newPassword): bool
    {
        try {
            $hashedPassword = password_hash($newPassword, PASSWORD_BCRYPT);
            $stmt = $this->db->prepare("UPDATE users SET password = :password WHERE id = :id");
            $stmt->execute(['password' => $hashedPassword, 'id' => $id]);

            $this->logAction($id, 'password_changed');
            return true;
        } catch (PDOException $e) {
            $this->logger->error('Password change failed', ['error' => $e->getMessage()]);
            return false;
        }
    }

    /**
     * Assign a role to a user
     */
    public function assignRole(int $id, string $role): bool
    {
        $validRoles = ['user', 'admin', 'super_admin'];
        if (!in_array($role, $validRoles)) {
            return false;
        }

        try {
            $stmt = $this->db->prepare("UPDATE users SET role = :role WHERE id = :id");
            $stmt->execute(['role' => $role, 'id' => $id]);

            $this->logAction($id, 'role_assigned', ['role' => $role]);
            return true;
        } catch (PDOException $e) {
            $this->logger->error('Role assignment failed', ['error' => $e->getMessage()]);
            return false;
        }
    }

    /**
     * Generate a JWT token for a user
     */
    private function generateJWT(array $user): string
    {
        $payload = [
            'sub' => $user['id'],
            'email' => $user['email'],
            'role' => $user['role'],
            'iat' => time(),
            'exp' => time() + 3600, // Token expires in 1 hour
        ];

        return JWT::encode($payload, $this->jwtSecret, 'HS256');
    }

    /**
     * Log an action for auditing purposes
     */
    private function logAction(?int $userId, string $action, array $details = []): void
    {
        $this->logger->info($action, ['user_id' => $userId, 'details' => $details]);
    }
}
=== App/Services/Validator.php ===
<?php

namespace App\Services;

/**
 * Validator Service
 *
 * Validates input data against defined rules.
 */
class Validator
{
    private array $errors = [];

    /**
     * Validate data against rules.
     */
    public function validate(array $data, array $rules): bool
    {
        $this->errors = [];

        foreach ($rules as $field => $ruleSet) {
            $rulesArray = explode('|', $ruleSet);
            foreach ($rulesArray as $rule) {
                $this->applyRule($field, $data[$field] ?? null, $rule);
            }
        }

        return empty($this->errors);
    }

    /**
     * Get validation errors.
     */
    public function errors(): array
    {
        return $this->errors;
    }

    /**
     * Apply a validation rule to a field.
     */
    private function applyRule(string $field, $value, string $rule): void
    {
        if ($rule === 'required' && empty($value)) {
            $this->errors[$field][] = 'This field is required.';
        } elseif (str_starts_with($rule, 'max:')) {
            $maxLength = (int)explode(':', $rule)[1];
            if (strlen($value) > $maxLength) {
                $this->errors[$field][] = "Maximum length is $maxLength characters.";
            }
        } elseif ($rule === 'email' && !filter_var($value, FILTER_VALIDATE_EMAIL)) {
            $this->errors[$field][] = 'Invalid email address.';
        } elseif (str_starts_with($rule, 'regex:')) {
            $pattern = substr($rule, 6);
            if (!preg_match($pattern, $value)) {
                $this->errors[$field][] = 'Invalid format.';
            }
        }
    }
}
=== App/Services/BookingService.php ===
<?php

namespace App\Services;

use PDO;
use Psr\Log\LoggerInterface;

class BookingService
{
    private PDO $db;
    private LoggerInterface $logger;

    public function __construct(PDO $db, LoggerInterface $logger)
    {
        $this->db = $db;
        $this->logger = $logger;
    }

    /**
     * Get booking details by ID
     */
    public function getBookingById(int $id): array
    {
        $stmt = $this->db->prepare("
            SELECT b.*, CONCAT(f.make, ' ', f.model) AS vehicle
            FROM bookings b
            JOIN fleet f ON b.vehicle_id = f.id
            WHERE b.id = :id
        ");
        $stmt->execute(['id' => $id]);
        $booking = $stmt->fetch(PDO::FETCH_ASSOC);

        if (!$booking) {
            throw new \Exception('Booking not found');
        }

        return $booking;
    }

    /**
     * Reschedule a booking
     */
    public function rescheduleBooking(int $id, string $pickupDate, string $dropoffDate): void
    {
        $stmt = $this->db->prepare("
            UPDATE bookings
            SET pickup_date = :pickup_date, dropoff_date = :dropoff_date, status = 'rescheduled'
            WHERE id = :id
        ");
        $stmt->execute([
            'id' => $id,
            'pickup_date' => $pickupDate,
            'dropoff_date' => $dropoffDate,
        ]);
    }

    /**
     * Cancel a booking and calculate refund amount
     */
    public function cancelBooking(int $id): float
    {
        $stmt = $this->db->prepare("
            UPDATE bookings
            SET status = 'canceled'
            WHERE id = :id
        ");
        $stmt->execute(['id' => $id]);

        // Calculate refund amount (example: 80% of total price if canceled)
        $refundStmt = $this->db->prepare("
            SELECT total_price * 0.8 AS refund_amount
            FROM bookings
            WHERE id = :id
        ");
        $refundStmt->execute(['id' => $id]);
        $result = $refundStmt->fetch(PDO::FETCH_ASSOC);

        return $result['refund_amount'] ?? 0.0;
    }

    /**
     * Get user ID associated with a booking
     */
    public function getUserIdByBooking(int $id): int
    {
        $stmt = $this->db->prepare("
            SELECT user_id 
            FROM bookings 
            WHERE id = :id
        ");
        $stmt->execute(['id' => $id]);
        return (int) $stmt->fetchColumn();
    }

    /**
     * Get monthly booking trends for the current year
     */
    public function getMonthlyBookingTrends(): array
    {
        $stmt = $this->db->prepare("
            SELECT 
                MONTH(created_at) AS month, 
                COUNT(*) AS total
            FROM bookings
            WHERE YEAR(created_at) = YEAR(CURRENT_DATE)
            GROUP BY MONTH(created_at)
            ORDER BY MONTH(created_at)
        ");
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Get total number of bookings
     */
    public function getTotalBookings(): int
    {
        $stmt = $this->db->prepare("SELECT COUNT(*) FROM bookings");
        $stmt->execute();
        return (int) $stmt->fetchColumn();
    }

    /**
     * Get the number of completed bookings
     */
    public function getCompletedBookings(): int
    {
        $stmt = $this->db->prepare("SELECT COUNT(*) FROM bookings WHERE status = 'completed'");
        $stmt->execute();
        return (int) $stmt->fetchColumn();
    }

    /**
     * Get the number of canceled bookings
     */
    public function getCanceledBookings(): int
    {
        $stmt = $this->db->prepare("SELECT COUNT(*) FROM bookings WHERE status = 'canceled'");
        $stmt->execute();
        return (int) $stmt->fetchColumn();
    }

    /**
     * Get booking logs for a specific booking ID
     */
    public function getBookingLogs(int $bookingId): array
    {
        $stmt = $this->db->prepare("
            SELECT 
                action, 
                details, 
                created_at 
            FROM booking_logs
            WHERE booking_id = :booking_id
            ORDER BY created_at DESC
        ");
        $stmt->execute(['booking_id' => $bookingId]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Check booking availability
     */
    private function isBookingAvailable(int $vehicleId, string $pickupDate, string $dropoffDate): bool
    {
        $stmt = $this->db->prepare("
            SELECT COUNT(*) 
            FROM bookings 
            WHERE vehicle_id = :vehicle_id 
              AND status NOT IN ('canceled', 'completed')
              AND (
                  (pickup_date BETWEEN :pickup_date AND :dropoff_date) OR
                  (dropoff_date BETWEEN :pickup_date AND :dropoff_date) OR
                  (:pickup_date BETWEEN pickup_date AND dropoff_date) OR
                  (:dropoff_date BETWEEN pickup_date AND dropoff_date)
              )
        ");
        $stmt->execute([
            'vehicle_id' => $vehicleId,
            'pickup_date' => $pickupDate,
            'dropoff_date' => $dropoffDate,
        ]);
        return (int)$stmt->fetchColumn() === 0;
    }

    /**
     * Create a new booking
     */
    public function createBooking(int $userId, int $vehicleId, string $pickupDate, string $dropoffDate): array
    {
        if (!$this->isBookingAvailable($vehicleId, $pickupDate, $dropoffDate)) {
            $this->logger->warning('Booking attempt failed: vehicle not available', [
                'user_id' => $userId,
                'vehicle_id' => $vehicleId,
                'pickup_date' => $pickupDate,
                'dropoff_date' => $dropoffDate,
            ]);
            return ['status' => 'error', 'message' => 'Vehicle not available for the selected dates'];
        }

        try {
            $stmt = $this->db->prepare("
                INSERT INTO bookings (user_id, vehicle_id, pickup_date, dropoff_date, status)
                VALUES (:user_id, :vehicle_id, :pickup_date, :dropoff_date, 'booked')
            ");
            $stmt->execute([
                'user_id' => $userId,
                'vehicle_id' => $vehicleId,
                'pickup_date' => $pickupDate,
                'dropoff_date' => $dropoffDate,
            ]);

            $this->logger->info('Booking created successfully', [
                'user_id' => $userId,
                'vehicle_id' => $vehicleId,
                'pickup_date' => $pickupDate,
                'dropoff_date' => $dropoffDate,
            ]);

            return ['status' => 'success', 'message' => 'Booking created successfully'];
        } catch (\Exception $e) {
            $this->logger->error('Failed to create booking', [
                'error' => $e->getMessage(),
                'user_id' => $userId,
                'vehicle_id' => $vehicleId,
                'pickup_date' => $pickupDate,
                'dropoff_date' => $dropoffDate,
            ]);
            return ['status' => 'error', 'message' => 'Failed to create booking'];
        }
    }
}
=== App/Services/Auth/TokenService.php ===
<?php

namespace App\Services\Auth;

use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Illuminate\Support\Facades\Cache;

class TokenService
{
    private string $secretKey;
    private string $refreshSecretKey;

    public function __construct(string $secretKey, string $refreshSecretKey)
    {
        if (empty($secretKey) || empty($refreshSecretKey)) {
            throw new \RuntimeException('❌ JWT secrets are missing.');
        }

        $this->secretKey = $secretKey;
        $this->refreshSecretKey = $refreshSecretKey;
    }

    public function generateToken($user): string
    {
        $payload = [
            'iss' => "your-issuer",
            'sub' => $user->id,
            'iat' => time(),
            'exp' => time() + 3600
        ];

        return JWT::encode($payload, $this->secretKey, 'HS256');
    }

    public function verifyToken(string $token): ?array
    {
        try {
            $decoded = JWT::decode($token, new Key($this->secretKey, 'HS256'));
            return (array) $decoded;
        } catch (\Exception $e) {
            return null;
        }
    }

    // New method: validateToken() to reject expired tokens and log failures
    public function validateToken(string $token): ?array
    {
        try {
            $decoded = JWT::decode($token, new Key($this->secretKey, 'HS256'));
            if ($decoded->exp < time()) {
                \logAuthFailure("Expired token for user id: " . ($decoded->sub ?? 'unknown'));
                return null;
            }
            return (array)$decoded;
        } catch (\Exception $e) {
            \logAuthFailure("Token validation failed: " . $e->getMessage());
            return null;
        }
    }

    public function generateRefreshToken($user): string
    {
        $payload = [
            'iss' => "your-issuer",
            'sub' => $user->id,
            'iat' => time(),
            'exp' => time() + 604800
        ];

        return JWT::encode($payload, $this->refreshSecretKey, 'HS256');
    }

    public function refreshAccessToken(string $refreshToken): ?string
    {
        $decoded = $this->verifyToken($refreshToken);
        if ($decoded) {
            $userId = $decoded['sub'];

            if (Cache::has("revoked_refresh_token_$refreshToken")) {
                return null;
            }

            return $this->generateToken((object) ['id' => $userId]);
        }
        return null;
    }

    // New method: refreshToken() to securely generate a new access token using a valid refresh token
    public function refreshToken(string $refreshToken): ?string
    {
        try {
            $decoded = JWT::decode($refreshToken, new Key($this->refreshSecretKey, 'HS256'));
            if ($decoded->exp < time()) {
                \logAuthFailure("Expired refresh token for user id: " . ($decoded->sub ?? 'unknown'));
                return null;
            }
            if (\Illuminate\Support\Facades\Cache::has("revoked_refresh_token_$refreshToken")) {
                \logAuthFailure("Revoked refresh token attempted for user id: " . ($decoded->sub ?? 'unknown'));
                return null;
            }
            return $this->generateToken((object)['id' => $decoded->sub]);
        } catch (\Exception $e) {
            \logAuthFailure("Refresh token validation failed: " . $e->getMessage());
            return null;
        }
    }

    public function revokeToken(string $token): void
    {
        Cache::put("revoked_refresh_token_$token", true, 604800);
    }
}
=== App/Services/Auth/AuthService.php ===
<?php
// ...existing code...
use App\Models\UserModel; // New dependency for database queries

class AuthService {

    // ...existing properties and methods...

    public function login($email, $password) {
        // Use UserModel to fetch the user instead of raw SQL
        $user = UserModel::findUserByEmail($email);
        if (!$user || !password_verify($password, $user->password_hash)) {
            logAuthFailure("Failed login attempt for email: " . $email);
            // ...existing error handling...
            throw new \Exception("Invalid credentials");
        }
        // ...existing login logic (e.g., token generation)...
        return [
            'user' => $user,
            'token' => $this->generateToken($user)
        ];
    }

    public function registerUser(array $data) {
        // Ensure the password is hashed with bcrypt
        $data['password_hash'] = password_hash($data['password'], PASSWORD_BCRYPT);
        unset($data['password']);
        
        // Use UserModel to create the new user
        $newUser = UserModel::createUser($data);
        if (!$newUser) {
            throw new \Exception("User registration failed");
        }
        return $newUser;
    }

    // ...existing code...
}
?>
=== App/Services/NotificationService.php ===
<?php

namespace App\Services;

use PDO;
use Psr\Log\LoggerInterface;
use PHPMailer\PHPMailer\PHPMailer;
use PHPMailer\PHPMailer\Exception;

/**
 * NotificationService
 *
 * Handles various notification types (email, SMS, webhook, push notifications).
 */
class NotificationService
{
    private PDO $pdo;
    private LoggerInterface $logger;
    private array $config;

    public function __construct(PDO $pdo, LoggerInterface $logger, array $config)
    {
        $this->pdo = $pdo;
        $this->logger = $logger;
        $this->config = $config;
    }

    /**
     * Send a notification
     */
    public function sendNotification(int $userId, string $type, string $message, array $options = []): bool
    {
        try {
            $this->storeNotification($userId, $type, $message);
            return $this->dispatchNotification($userId, $type, $message, $options);
        } catch (\Exception $e) {
            $this->logger->error('Notification failed', ['error' => $e->getMessage()]);
            return false;
        }
    }

    /**
     * Store notification in the database
     */
    private function storeNotification(int $userId, string $type, string $message): void
    {
        $stmt = $this->pdo->prepare("
            INSERT INTO notifications (user_id, type, message, sent_at, is_read)
            VALUES (:user_id, :type, :message, NOW(), 0)
        ");
        $stmt->execute([
            'user_id' => $userId,
            'type' => $type,
            'message' => $message,
        ]);
    }

    /**
     * Dispatch the appropriate notification method
     */
    private function dispatchNotification(int $userId, string $type, string $message, array $options): bool
    {
        return match ($type) {
            'email' => $this->sendEmail($options['email'] ?? '', $message, $options['subject'] ?? 'Notification'),
            'sms' => $this->sendSMS($options['phone'] ?? '', $message),
            'webhook' => $this->sendWebhook($options['url'] ?? '', $message),
            'push' => $this->sendPushNotification($options['device_token'] ?? '', $message),
            default => throw new \InvalidArgumentException("Unsupported notification type: $type"),
        };
    }

    /**
     * Send an email using PHPMailer
     */
    private function sendEmail(string $to, string $message, string $subject): bool
    {
        if (empty($to)) return false;

        try {
            $mail = new PHPMailer(true);
            $mail->isSMTP();
            $mail->Host = $this->config['smtp_host'];
            $mail->SMTPAuth = true;
            $mail->Username = $this->config['smtp_user'];
            $mail->Password = $this->config['smtp_password'];
            $mail->SMTPSecure = $this->config['smtp_secure'] ?? 'tls';
            $mail->Port = $this->config['smtp_port'];
            $mail->setFrom($this->config['from_email'], $this->config['from_name']);
            $mail->addAddress($to);
            $mail->Subject = $subject;
            $mail->isHTML(true);
            $mail->Body = "<p>$message</p>";
            $mail->send();

            return true;
        } catch (Exception $e) {
            $this->logger->error('Email failed', ['error' => $e->getMessage()]);
            return false;
        }
    }

    /**
     * Send an SMS
     */
    private function sendSMS(string $phone, string $message): bool
    {
        if (empty($phone)) return false;

        try {
            $this->logger->info("Sending SMS to $phone: $message");
            return true;
        } catch (\Exception $e) {
            $this->logger->error('SMS failed', ['error' => $e->getMessage()]);
            return false;
        }
    }

    /**
     * Send a webhook notification
     */
    private function sendWebhook(string $url, string $message): bool
    {
        if (empty($url)) return false;

        try {
            $ch = curl_init($url);
            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
            curl_setopt($ch, CURLOPT_POST, true);
            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode(['message' => $message]));
            curl_setopt($ch, CURLOPT_HTTPHEADER, ['Content-Type: application/json']);
            $response = curl_exec($ch);
            curl_close($ch);

            return $response !== false;
        } catch (\Exception $e) {
            $this->logger->error('Webhook failed', ['error' => $e->getMessage()]);
            return false;
        }
    }

    /**
     * Send a push notification
     */
    private function sendPushNotification(string $deviceToken, string $message): bool
    {
        if (empty($deviceToken)) return false;

        try {
            $payload = [
                'to' => $deviceToken,
                'notification' => ['title' => 'Notification', 'body' => $message],
            ];
            return $this->sendFCMRequest($payload);
        } catch (\Exception $e) {
            $this->logger->error('Push notification failed', ['error' => $e->getMessage()]);
            return false;
        }
    }

    /**
     * Send Firebase Cloud Messaging (FCM) request
     */
    private function sendFCMRequest(array $payload): bool
    {
        $ch = curl_init('https://fcm.googleapis.com/fcm/send');
        curl_setopt($ch, CURLOPT_HTTPHEADER, [
            'Content-Type: application/json',
            'Authorization: key=' . $this->config['fcm_api_key'],
        ]);
        curl_setopt($ch, CURLOPT_POST, true);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($payload));
        $response = curl_exec($ch);

        curl_close($ch);
        return $response !== false;
    }
}
=== App/Services/TransactionService.php ===
<?php

namespace App\Services;

use PDO;

class TransactionService
{
    private PDO $db;

    public function __construct(PDO $db)
    {
        $this->db = $db;
    }

    /**
     * Get transactions by user ID.
     */
    public function getByUserId(int $userId): array
    {
        $stmt = $this->db->prepare("
            SELECT * FROM transaction_logs WHERE user_id = :user_id ORDER BY created_at DESC
        ");
        $stmt->execute([':user_id' => $userId]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Log a transaction.
     */
    public function create(array $data): void
    {
        $stmt = $this->db->prepare("
            INSERT INTO transaction_logs (user_id, booking_id, amount, type, status, created_at)
            VALUES (:user_id, :booking_id, :amount, :type, :status, NOW())
        ");
        $stmt->execute([
            ':user_id' => $data['user_id'],
            ':booking_id' => $data['booking_id'],
            ':amount' => $data['amount'],
            ':type' => $data['type'],
            ':status' => $data['status'],
        ]);
    }
}
=== App/Services/EncryptionService.php ===
<?php

namespace App\Services;

use Exception;
use RuntimeException;
use Illuminate\Support\Facades\Log;

/**
 * EncryptionService
 *
 * Provides functionality for encrypting/decrypting strings and files securely.
 */
class EncryptionService
{
    private string $encryptionKey;
    private string $cipher = 'AES-256-CBC';
    private int $ivLength;

    public function __construct(string $encryptionKey)
    {
        if (empty($encryptionKey) || strlen($encryptionKey) < 32) {
            throw new RuntimeException('❌ Encryption key is missing or too short. It must be at least 32 characters long.');
        }

        $this->encryptionKey = $encryptionKey;
        $this->ivLength = openssl_cipher_iv_length($this->cipher);

        if ($this->ivLength === false) {
            throw new RuntimeException('❌ Unable to determine IV length for the cipher.');
        }
    }

    public function encrypt(string $data): string
    {
        $iv = random_bytes($this->ivLength);
        $encrypted = openssl_encrypt($data, $this->cipher, $this->encryptionKey, 0, $iv);

        if ($encrypted === false) {
            throw new RuntimeException('❌ Encryption failed.');
        }

        return base64_encode($iv . $encrypted);
    }

    public function decrypt(string $encryptedData): ?string
    {
        $decoded = base64_decode($encryptedData, true);
        if ($decoded === false) {
            Log::error('❌ Decryption failed: Invalid base64 input.');
            return null;
        }

        $iv = substr($decoded, 0, $this->ivLength);
        $cipherText = substr($decoded, $this->ivLength);

        if (strlen($iv) !== $this->ivLength) {
            throw new RuntimeException('❌ Invalid IV length.');
        }

        $decrypted = openssl_decrypt($cipherText, $this->cipher, $this->encryptionKey, 0, $iv);

        if ($decrypted === false) {
            Log::error('❌ Decryption failed: Data may have been tampered with.');
            return null;
        }

        return $decrypted;
    }

    /**
     * Encrypt a file.
     */
    public function encryptFile(string $inputFile, string $outputFile): bool
    {
        $this->validateFile($inputFile);
        $data = file_get_contents($inputFile);

        if ($data === false) {
            throw new \RuntimeException("Failed to read file: $inputFile");
        }

        return $this->writeFile($outputFile, $this->encrypt($data));
    }

    /**
     * Decrypt a file.
     */
    public function decryptFile(string $inputFile, string $outputFile): bool
    {
        $this->validateFile($inputFile);
        $encryptedData = file_get_contents($inputFile);

        if ($encryptedData === false) {
            throw new \RuntimeException("Failed to read encrypted file: $inputFile");
        }

        $decryptedData = $this->decrypt($encryptedData);
        if ($decryptedData === null) {
            throw new \RuntimeException("Failed to decrypt file: $inputFile");
        }

        return $this->writeFile($outputFile, $decryptedData);
    }

    /**
     * Sign data using HMAC SHA-256.
     */
    public function sign(string $data): string
    {
        return hash_hmac('sha256', $data, $this->encryptionKey);
    }

    /**
     * Verify the integrity of signed data.
     */
    public function verify(string $data, string $signature): bool
    {
        return hash_equals($this->sign($data), $signature);
    }

    /**
     * Validate if a file exists and is readable.
     */
    private function validateFile(string $filePath): void
    {
        if (!file_exists($filePath) || !is_readable($filePath)) {
            throw new \InvalidArgumentException("File not found or not readable: $filePath");
        }
    }

    /**
     * Write data to a file.
     */
    private function writeFile(string $filePath, string $data): bool
    {
        if (file_put_contents($filePath, $data) === false) {
            throw new \RuntimeException("Failed to write to file: $filePath");
        }

        return true;
    }
}
=== App/Services/RateLimiter.php ===
<?php

namespace App\Services;

use PDO;

/**
 * Rate Limiter Service
 *
 * Implements IP-based rate limiting.
 */
class RateLimiter
{
    private PDO $db;

    public function __construct(PDO $db)
    {
        $this->db = $db;
    }

    /**
     * Check if an IP is rate-limited.
     */
    public function isRateLimited(string $ip): bool
    {
        $stmt = $this->db->prepare("
            SELECT COUNT(*) FROM login_attempts 
            WHERE ip_address = ? AND created_at > DATE_SUB(NOW(), INTERVAL 15 MINUTE)
        ");
        $stmt->execute([$ip]);

        return $stmt->fetchColumn() >= 5;
    }

    /**
     * Record a failed login attempt.
     */
    public function recordFailedAttempt(string $ip): void
    {
        $stmt = $this->db->prepare("
            INSERT INTO login_attempts (ip_address, created_at) 
            VALUES (?, NOW())
        ");
        $stmt->execute([$ip]);
    }
}
=== App/Services/RevenueService.php ===
<?php

namespace App\Services;

use PDO;

class RevenueService
{
    private PDO $db;

    public function __construct(PDO $db)
    {
        $this->db = $db;
    }

    /**
     * Fetch monthly revenue trends
     */
    public function getMonthlyRevenueTrends(): array
    {
        $stmt = $this->db->query("
            SELECT DATE_FORMAT(created_at, '%Y-%m') AS month, SUM(amount) AS revenue
            FROM transaction_logs
            WHERE type = 'payment' AND status = 'completed'
            GROUP BY month
            ORDER BY month
        ");

        $data = $stmt->fetchAll(PDO::FETCH_ASSOC);
        $labels = array_column($data, 'month');
        $amounts = array_column($data, 'revenue');

        return [
            'labels' => $labels,
            'data' => $amounts,
        ];
    }
}
=== App/Services/Security/KeyManager.php ===
<?php

namespace App\Services\Security;

use Exception;
use Psr\Log\LoggerInterface;

class KeyManager
{
    private array $keys;
    private LoggerInterface $logger;

    public function __construct(array $keys, LoggerInterface $logger)
    {
        $this->keys = $keys;
        $this->logger = $logger;
    }

    public function getKey(string $identifier): string
    {
        $keyName = 'encryption_key_' . strtolower($identifier);

        if (!isset($this->keys[$keyName]) || empty($this->keys[$keyName])) {
            $this->logger->error("Encryption key for {$identifier} not found.");
            throw new Exception("Encryption key for {$identifier} not found.");
        }

        return $this->keys[$keyName];
    }

    public function generateKey(): string
    {
        return base64_encode(random_bytes(32)); // AES-256 key
    }

    public function storeKey(string $identifier, string $key): void
    {
        $this->logger->info("Storing key for {$identifier}");
        // Implementation for storing key securely (e.g., database, key vault)
    }

    public function rotateKey(string $identifier): void
    {
        $newKey = $this->generateKey();
        $this->storeKey($identifier, $newKey);
        $this->logger->info("Rotated key for {$identifier}");
    }

    public function revokeKey(string $identifier): void
    {
        $this->logger->info("Revoking key for {$identifier}");
        // Implementation for revoking key securely
    }
}
=== App/Services/ReportService.php ===
<?php

namespace App\Services;

use PDO;

class ReportService
{
    private PDO $db;

    public function __construct(PDO $db)
    {
        $this->db = $db;
    }

    /**
     * Generate a report for admin
     */
    public function generateReport(string $reportType, array $dateRange, array $filters = [], string $format): string
    {
        $data = match ($reportType) {
            'bookings' => $this->getBookingReportData($dateRange, $filters),
            'payments' => $this->getPaymentReportData($dateRange, $filters),
            'users' => $this->getUserReportData($dateRange, $filters),
            default => throw new \InvalidArgumentException("Invalid report type: $reportType"),
        };

        return $this->exportReport($data, $reportType, $format);
    }

    /**
     * Generate a user-specific report
     */
    public function generateUserReport(int $userId, string $reportType, array $dateRange, string $format): string
    {
        $data = match ($reportType) {
            'bookings' => $this->getUserBookingReportData($userId, $dateRange),
            'payments' => $this->getUserPaymentReportData($userId, $dateRange),
            default => throw new \InvalidArgumentException("Invalid report type: $reportType"),
        };

        return $this->exportReport($data, "{$reportType}_user_{$userId}", $format);
    }

    /**
     * Fetch booking report data
     */
    private function getBookingReportData(array $dateRange, array $filters): array
    {
        $query = "
            SELECT b.id, b.pickup_date, b.dropoff_date, b.status, b.total_price, u.email AS user_email
            FROM bookings b
            JOIN users u ON b.user_id = u.id
            WHERE b.created_at BETWEEN :start AND :end
        ";

        if (!empty($filters['status'])) {
            $query .= " AND b.status = :status";
        }

        $stmt = $this->db->prepare($query);
        $params = [
            ':start' => $dateRange['start'],
            ':end' => $dateRange['end'],
        ];

        if (!empty($filters['status'])) {
            $params[':status'] = $filters['status'];
        }

        $stmt->execute($params);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Fetch payment report data
     */
    private function getPaymentReportData(array $dateRange, array $filters): array
    {
        $query = "
            SELECT t.id, t.amount, t.type, t.status, t.created_at, u.email AS user_email
            FROM transaction_logs t
            JOIN users u ON t.user_id = u.id
            WHERE t.created_at BETWEEN :start AND :end
        ";

        if (!empty($filters['type'])) {
            $query .= " AND t.type = :type";
        }

        $stmt = $this->db->prepare($query);
        $params = [
            ':start' => $dateRange['start'],
            ':end' => $dateRange['end'],
        ];

        if (!empty($filters['type'])) {
            $params[':type'] = $filters['type'];
        }

        $stmt->execute($params);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Fetch user report data
     */
    private function getUserReportData(array $dateRange, array $filters): array
    {
        $query = "
            SELECT id, email, created_at, active
            FROM users
            WHERE created_at BETWEEN :start AND :end
        ";

        $stmt = $this->db->prepare($query);
        $stmt->execute([
            ':start' => $dateRange['start'],
            ':end' => $dateRange['end'],
        ]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Fetch user-specific booking report data
     */
    private function getUserBookingReportData(int $userId, array $dateRange): array
    {
        $stmt = $this->db->prepare("
            SELECT id, pickup_date, dropoff_date, status, total_price
            FROM bookings
            WHERE user_id = :user_id AND created_at BETWEEN :start AND :end
        ");
        $stmt->execute([
            ':user_id' => $userId,
            ':start' => $dateRange['start'],
            ':end' => $dateRange['end'],
        ]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Fetch user-specific payment report data
     */
    private function getUserPaymentReportData(int $userId, array $dateRange): array
    {
        $stmt = $this->db->prepare("
            SELECT id, amount, type, status, created_at
            FROM transaction_logs
            WHERE user_id = :user_id AND created_at BETWEEN :start AND :end
        ");
        $stmt->execute([
            ':user_id' => $userId,
            ':start' => $dateRange['start'],
            ':end' => $dateRange['end'],
        ]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Export the report data
     */
    private function exportReport(array $data, string $reportName, string $format): string
    {
        $filePath = __DIR__ . "/../../storage/reports/{$reportName}_" . date('YmdHis') . ".{$format}";

        if ($format === 'csv') {
            $file = fopen($filePath, 'w');
            if (!empty($data)) {
                fputcsv($file, array_keys($data[0])); // Add headers
                foreach ($data as $row) {
                    fputcsv($file, $row);
                }
            }
            fclose($file);
        } elseif ($format === 'pdf') {
            // For simplicity, we use plain text for PDF export (enhance later with libraries like FPDF or TCPDF)
            $content = '';
            foreach ($data as $row) {
                $content .= implode(' | ', $row) . "\n";
            }
            file_put_contents($filePath, $content);
        } else {
            throw new \InvalidArgumentException("Unsupported format: $format");
        }

        return $filePath;
    }
}
=== App/Services/PaymentService.php ===
<?php

namespace App\Services;

use App\Models\Booking;
use App\Models\TransactionLog;
use App\Models\Payment;
use PDO;
use Psr\Log\LoggerInterface;

class PaymentService
{
    private PDO $pdo;
    private LoggerInterface $logger;
    private Payment $paymentModel;
    private string $payuApiKey;
    private string $payuApiSecret;

    public function __construct(PDO $pdo, LoggerInterface $logger, Payment $paymentModel, string $payuApiKey, string $payuApiSecret)
    {
        $this->db = $pdo;
        $this->logger = $logger;
        $this->paymentModel = $paymentModel;
        $this->payuApiKey = $payuApiKey;
        $this->payuApiSecret = $payuApiSecret;
    }

    public function processPayment($user, array $paymentData)
    {
        // Verify user authentication
        if (empty($user) || empty($user['authenticated']) || !$user['authenticated']) {
            $this->logger->error('Unauthenticated payment attempt', ['user' => $user]);
            return ['status' => 'error', 'message' => 'User not authenticated'];
        }

        // Role-based access control for admin-only transactions
        if (!empty($paymentData['adminOnly']) && $paymentData['adminOnly'] === true) {
            if ($user['role'] !== 'admin') {
                $this->logger->error('Unauthorized admin transaction', ['user' => $user]);
                return ['status' => 'error', 'message' => 'Admin privileges required'];
            }
        }

        try {
            $this->paymentModel->createPayment($paymentData['bookingId'], $paymentData['amount'], $paymentData['paymentMethod']);

            $booking = new Booking($this->db);
            $booking->updateStatus($paymentData['bookingId'], 'paid');

            $this->logTransaction($paymentData['bookingId'], $paymentData['amount'], 'payment');

            $this->logger->info("Payment processed for booking {$paymentData['bookingId']}");
            return ['status' => 'success', 'message' => 'Payment processed successfully'];
        } catch (\Exception $e) {
            $this->logger->error('Payment processing failed', ['error' => $e->getMessage(), 'user' => $user]);
            return ['status' => 'error', 'message' => 'Payment processing failed'];
        }
    }

    public function processRefund(int $bookingId, float $amount): bool
    {
        try {
            $this->paymentModel->createRefund($bookingId, $amount);

            $stmt = $this->db->prepare("UPDATE bookings SET refund_status = 'processed' WHERE id = :id");
            $stmt->execute([':id' => $bookingId]);

            $this->logTransaction($bookingId, $amount, 'refund');

            $this->logger->info("Refund processed for booking $bookingId");
            return true;
        } catch (\Exception $e) {
            $this->logger->error('Refund processing failed', ['error' => $e->getMessage()]);
            return false;
        }
    }

    private function logTransaction(int $bookingId, float $amount, string $type): void
    {
        $transactionLog = new TransactionLog($this->db);
        $transactionLog->create([
            'booking_id' => $bookingId,
            'amount' => $amount,
            'type' => $type,
            'status' => 'completed',
        ]);
    }

    public function getMonthlyRevenueTrends(): array
    {
        $stmt = $this->db->prepare("
            SELECT MONTH(created_at) AS month, SUM(amount) AS total
            FROM transaction_logs
            WHERE type = 'payment' AND YEAR(created_at) = YEAR(CURRENT_DATE)
            GROUP BY MONTH(created_at)
            ORDER BY MONTH(created_at)
        ");
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
}
=== App/Services/PayUService.php ===
<?php

namespace App\Services;

use GuzzleHttp\Client;
use GuzzleHttp\Exception\RequestException;
use Psr\Log\LoggerInterface;
require_once __DIR__ . '/../../config/payu.php';
/**
 * PayUService
 * 
 * Handles PayU API integration, including payment initialization, verification, and refunds.
 */
class PayUService
{
    private Client $client;
    private LoggerInterface $logger;
    private string $merchantKey;
    private string $merchantSalt;
    private string $endpoint;

    public function __construct(Client $client, LoggerInterface $logger, array $config)
    {
        $this->client = $client;
        $this->logger = $logger;
        $this->merchantKey = $config['merchant_key'];
        $this->merchantSalt = $config['merchant_salt'];
        $this->endpoint = $config['endpoint'];
    }

    /**
     * Initialize a payment transaction
     *
     * @param string $transactionId
     * @param float $amount
     * @param string $productInfo
     * @param string $customerEmail
     * @param string $customerPhone
     * @return array
     */
    public function initiatePayment(string $transactionId, float $amount, string $productInfo, string $customerEmail, string $customerPhone): array
    {
        $hash = $this->generateHash($transactionId, $amount, $productInfo, $customerEmail);

        $params = [
            'key' => $this->merchantKey,
            'txnid' => $transactionId,
            'amount' => $amount,
            'productinfo' => $productInfo,
            'firstname' => $customerEmail, // Assuming first name is derived from the email
            'email' => $customerEmail,
            'phone' => $customerPhone,
            'surl' => $this->endpoint . '/success', // Success callback URL
            'furl' => $this->endpoint . '/failure', // Failure callback URL
            'hash' => $hash,
            'service_provider' => 'payu_paisa'
        ];

        try {
            $response = $this->client->post($this->endpoint . '/_payment', [
                'form_params' => $params,
            ]);

            return json_decode($response->getBody()->getContents(), true);
        } catch (RequestException $e) {
            $this->logger->error('PayU payment initialization failed', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Payment initialization failed'];
        }
    }

    /**
     * Verify a payment transaction
     *
     * @param string $transactionId
     * @return array
     */
    public function verifyPayment(string $transactionId): array
    {
        $params = [
            'key' => $this->merchantKey,
            'command' => 'verify_payment',
            'var1' => $transactionId,
        ];

        try {
            $response = $this->client->post($this->endpoint . '/payment/verify', [
                'form_params' => $params,
            ]);

            return json_decode($response->getBody()->getContents(), true);
        } catch (RequestException $e) {
            $this->logger->error('PayU payment verification failed', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Payment verification failed'];
        }
    }

    /**
     * Process a refund
     *
     * @param string $transactionId
     * @param float $amount
     * @return array
     */
    public function processRefund(string $transactionId, float $amount): array
    {
        $params = [
            'key' => $this->merchantKey,
            'command' => 'refund_transaction',
            'var1' => $transactionId,
            'var2' => $amount,
        ];

        try {
            $response = $this->client->post($this->endpoint . '/refund', [
                'form_params' => $params,
            ]);

            return json_decode($response->getBody()->getContents(), true);
        } catch (RequestException $e) {
            $this->logger->error('PayU refund processing failed', ['error' => $e->getMessage()]);
            return ['status' => 'error', 'message' => 'Refund processing failed'];
        }
    }

    /**
     * Generate hash for PayU API
     *
     * @param string $transactionId
     * @param float $amount
     * @param string $productInfo
     * @param string $customerEmail
     * @return string
     */
    private function generateHash(string $transactionId, float $amount, string $productInfo, string $customerEmail): string
    {
        $hashString = implode('|', [
            $this->merchantKey,
            $transactionId,
            $amount,
            $productInfo,
            $customerEmail,
            $this->merchantSalt
        ]);

        return hash('sha512', $hashString);
    }
}
=== App/Middleware/EncryptionMiddleware.php ===
<?php

namespace App\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use App\Services\EncryptionService;

class EncryptionMiddleware
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle(Request $request, Closure $next)
    {
        // Encrypt sensitive data in the request
        if ($this->isSensitiveEndpoint($request)) {
            $this->encryptRequestData($request);
        }

        $response = $next($request);

        // Encrypt sensitive data in the response
        if ($this->isSensitiveEndpoint($request)) {
            $this->encryptResponseData($response);
        }

        return $response;
    }

    /**
     * Determine if the request is for a sensitive endpoint.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return bool
     */
    private function isSensitiveEndpoint(Request $request): bool
    {
        $sensitiveEndpoints = [
            '/user/profile-data',
            // Add other sensitive endpoints here
        ];

        return in_array($request->path(), $sensitiveEndpoints);
    }

    /**
     * Encrypt sensitive data in the request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return void
     */
    private function encryptRequestData(Request $request): void
    {
        $data = $request->all();
        foreach ($data as $key => $value) {
            if ($this->isSensitiveField($key)) {
                $data[$key] = EncryptionService::encrypt($value);
            }
        }
        $request->merge($data);
    }

    /**
     * Encrypt sensitive data in the response.
     *
     * @param  \Illuminate\Http\Response  $response
     * @return void
     */
    private function encryptResponseData($response): void
    {
        $data = $response->getContent();
        $encryptedData = EncryptionService::encrypt($data);
        $response->setContent($encryptedData);
    }

    /**
     * Determine if the field is sensitive.
     *
     * @param  string  $field
     * @return bool
     */
    private function isSensitiveField(string $field): bool
    {
        $sensitiveFields = [
            'password',
            'email',
            'phone',
            // Add other sensitive fields here
        ];

        return in_array($field, $sensitiveFields);
    }
}
=== App/Middleware/AuthMiddleware.php ===
<?php

namespace App\Middleware;

use App\Services\Auth\TokenService;
use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Exception;

require_once __DIR__ . '/../Helpers/SecurityHelper.php';

class AuthMiddleware
{
    protected TokenService $tokenService;
    private int $maxAttempts = 5;
    private int $blockDuration = 300; // 5 minutes
    private static string $jwtSecret;

    public function __construct()
    {
        $configPath = __DIR__ . '/../../config/encryption.php';
        if (!file_exists($configPath)) {
            throw new Exception("Encryption configuration missing.");
        }

        $encryptionConfig = require $configPath;

        if (!isset($encryptionConfig['jwt_secret'], $encryptionConfig['jwt_refresh_secret'])) {
            throw new Exception("JWT configuration missing in encryption.php.");
        }

        $this->tokenService = new TokenService(
            $encryptionConfig['jwt_secret'],
            $encryptionConfig['jwt_refresh_secret']
        );

        if (!isset($encryptionConfig['jwt_secret'])) {
            throw new Exception("JWT secret missing in encryption configuration.");
        }
        self::$jwtSecret = $encryptionConfig['jwt_secret'];
    }

    // New private method for rate limiting
    private function checkRateLimit(string $ip): bool
    {
        if (!isset($_SESSION['failed_attempts'])) {
            $_SESSION['failed_attempts'] = [];
        }
        if (!isset($_SESSION['failed_attempts'][$ip])) {
            $_SESSION['failed_attempts'][$ip] = ['count' => 0, 'start' => time()];
        }
        $attempt = $_SESSION['failed_attempts'][$ip];
        // Reset count if block duration has passed
        if (time() - $attempt['start'] > $this->blockDuration) {
            $_SESSION['failed_attempts'][$ip] = ['count' => 0, 'start' => time()];
            return true;
        }
        return $attempt['count'] < $this->maxAttempts;
    }

    // New private method to record a failed attempt
    private function recordFailedAttempt(string $ip): void
    {
        if (!isset($_SESSION['failed_attempts'])) {
            $_SESSION['failed_attempts'] = [];
        }
        if (!isset($_SESSION['failed_attempts'][$ip])) {
            $_SESSION['failed_attempts'][$ip] = ['count' => 0, 'start' => time()];
        }
        $_SESSION['failed_attempts'][$ip]['count']++;
        $_SESSION['failed_attempts'][$ip]['start'] = time();
    }

    /**
     * Handle incoming requests.
     *
     * @param mixed $request
     * @param callable $next
     * @param bool $protected Set to true to enforce JWT validation.
     * @return mixed
     */
    public function handle($request, $next, bool $protected = true)
    {
        if (!$protected) {
            return $next($request);
        }

        $ip = $_SERVER['REMOTE_ADDR'] ?? 'unknown';
        // Enforce rate limiting for failed attempts
        if (!$this->checkRateLimit($ip)) {
            http_response_code(429);
            echo json_encode(['error' => 'Too many failed login attempts. Please try again later.']);
            exit;
        }

        $publicRoutes = ['/public', '/api/public']; // Define public routes

        if (in_array($request->getPathInfo(), $publicRoutes)) {
            return $next($request); // Allow guest access for public routes
        }

        // Define protected routes
        $protectedRoutes = [
            '/views/dashboard.php',
            '/views/user/profile.php'
        ];
        
        $currentPath = $request->getPathInfo();
        // Apply middleware to protected views and admin pages
        if (!in_array($currentPath, $protectedRoutes) && strpos($currentPath, '/admin') !== 0) {
            return $next($request);
        }
        
        $token = '';
        // Extract token from Authorization header if available
        $authHeader = $request->getHeader('Authorization');
        if ($authHeader && strpos($authHeader, 'Bearer ') === 0) {
            $token = str_replace('Bearer ', '', $authHeader);
        } elseif (isset($_COOKIE['jwt'])) {
            $token = $_COOKIE['jwt'];
        }
        
        if (empty($token)) {
            $this->logUnauthorized("Missing token");
            http_response_code(403);
            echo json_encode(['error' => 'Unauthorized: Missing token.']);
            exit();
        }
        
        try {
            $decoded = JWT::decode($token, new Key(self::$jwtSecret, 'HS256'));
            if ($decoded->exp < time()) {
                $this->logUnauthorized("Token expired");
                http_response_code(403);
                echo json_encode(['error' => 'Unauthorized: Token expired.']);
                exit();
            }
        } catch (Exception $e) {
            $this->logUnauthorized("Token invalid: " . $e->getMessage());
            http_response_code(403);
            echo json_encode(['error' => 'Unauthorized: ' . $e->getMessage()]);
            exit();
        }

        // Enforce admin-only routes for paths beginning with '/admin'
        if (strpos($request->getPathInfo(), '/admin') === 0) {
            // Assume the token or session holds a 'role' claim
            $role = $decoded->role ?? ($_SESSION['user_role'] ?? 'user');
            if ($role !== 'admin') {
                http_response_code(403);
                echo json_encode(['error' => 'Forbidden: Admins only']);
                $this->recordFailedAttempt($ip);
                return;
            }
        }

        // Optional: Validate session integrity for web requests
        if (!validateSessionIntegrity()) {
            http_response_code(401);
            echo json_encode(['error' => 'Session expired']);
            $this->recordFailedAttempt($ip);
            return;
        }

        return $next($request);
    }

    private function unauthorizedResponse($message)
    {
        http_response_code(403);
        header('Content-Type: application/json');
        echo json_encode(['status' => 'error', 'message' => $message, 'data' => []]);
        exit();
    }

    private function logAuthAttempt($status, $message)
    {
        $logMessage = sprintf("[%s] %s: %s from IP: %s\n", date('Y-m-d H:i:s'), ucfirst($status), $message, $_SERVER['REMOTE_ADDR']);
        file_put_contents(__DIR__ . '/../../logs/auth.log', $logMessage, FILE_APPEND);
    }

    private function logUnauthorized(string $message): void
    {
        $logMessage = sprintf("[%s] Unauthorized access: %s from IP: %s\n", 
            date('Y-m-d H:i:s'), 
            $message, 
            $_SERVER['REMOTE_ADDR'] ?? 'unknown'
        );
        file_put_contents(BASE_PATH . '/logs/auth.log', $logMessage, FILE_APPEND);
    }
}
=== App/Helpers/ViewHelper.php ===
<?php

function view($viewName, $data = [])
{
    $viewPath = BASE_PATH . "/App/Views/{$viewName}.php";

    if (!file_exists($viewPath)) {
        die("❌ View not found: {$viewName}");
    }

    extract($data); // Extract data for use inside views
    require $viewPath;
}
=== App/Helpers/SecurityHelper.php ===
<?php
/*
|--------------------------------------------------------------------------
| Security Helper - Centralized Session & Security Functions
|--------------------------------------------------------------------------
| This file handles secure session management, CSRF protection, input sanitization,
| and user session handling to ensure global consistency and security.
|
| Path: App/Helpers/SecurityHelper.php
*/

// Security Configuration
const SESSION_CONFIG = [
    'use_only_cookies' => 1,
    'use_strict_mode' => 1,
    'cookie_httponly' => 1,
    'cookie_samesite' => 'Lax',
    'gc_maxlifetime' => 3600,
    'cookie_lifetime' => 0,
    'use_trans_sid' => 0,
    'sid_bits_per_character' => 6
];

// Enhanced logging with severity levels
function securityLog($message, $level = 'info') {
    $logFile = __DIR__ . '/../../logs/security.log';
    $timestamp = date('Y-m-d H:i:s');
    $userId = $_SESSION['user_id'] ?? 'guest';
    
    // Sanitize sensitive data
    $patterns = [
        '/user_id[\s]?[=:][\s]?["\']?\w+["\']?/i',
        '/[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/',
        '/Mozilla\/[^\s]+/'
    ];
    $message = preg_replace($patterns, '[REDACTED]', $message);
    $sanitizedMessage = str_replace(["\n", "\r"], '', $message);
    
    error_log("[$timestamp][$level][user_id: $userId] $sanitizedMessage\n", 3, $logFile);
}

/**
 * Log authentication events.
 */
function logAuthEvent($message, $level = 'info') {
    // Changed to security.log
    $logFile = __DIR__ . '/../../logs/security.log';
    $timestamp = date('Y-m-d H:i:s');
    $userId = $_SESSION['user_id'] ?? 'guest';

    error_log("[$timestamp][$level][user_id: $userId] $message\n", 3, $logFile);
}

// Helper to log authentication failures to auth.log
function logAuthFailure($message) {
    $logFile = __DIR__ . '/../../logs/auth.log';
    $timestamp = date('Y-m-d H:i:s');
    error_log("[$timestamp][auth_failure] $message\n", 3, $logFile);
}

// Improved startSecureSession to support API requests via JWT
function startSecureSession() {
    // If API request and JWT provided, attempt JWT validation and setup session
    if (defined('API_ENTRY')) {
        $authHeader = $_SERVER['HTTP_AUTHORIZATION'] ?? ($_SERVER['REDIRECT_HTTP_AUTHORIZATION'] ?? '');
        if ($authHeader && preg_match('/Bearer\s(\S+)/', $authHeader, $matches)) {
            $token = $matches[1];
            $decoded = validateJWT($token);
            if ($decoded !== false) {
                if (session_status() !== PHP_SESSION_ACTIVE) {
                    session_start();
                }
                $_SESSION['api_authenticated'] = true;
                $_SESSION['user_id'] = $decoded->sub ?? 'api_user';
                // Optionally store more token data in session
            }
        }
    }

    // Proceed with standard session initialization if not active
    if (session_status() === PHP_SESSION_ACTIVE) {
        return true;
    }

    if (headers_sent()) {
        securityLog('Headers already sent, cannot modify session settings', 'warning');
    } else {
        foreach (SESSION_CONFIG as $key => $value) {
            @ini_set("session.$key", $value);
        }

        session_set_cookie_params([
            'lifetime' => 0,
            'path' => '/',
            'domain' => $_SERVER['HTTP_HOST'] ?? '',
            'secure' => (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off'),
            'httponly' => true,
            'samesite' => 'Lax'
        ]);
    }

    try {
        if (!session_start()) { // will only be called if not already active
            throw new Exception('Session start failed');
        }

        // Initialize session only once
        if (empty($_SESSION['initiated'])) {
            session_regenerate_id(true);
            $_SESSION['initiated'] = time();
            $_SESSION['client_ip'] = hash('sha256', $_SERVER['REMOTE_ADDR']);
            $_SESSION['user_agent'] = hash('sha256', $_SERVER['HTTP_USER_AGENT']);
            $_SESSION['last_activity'] = time();
            $_SESSION['guest'] = true; // Default guest initialization
            securityLog('New guest session initiated');
        }

        // CSRF protection
        if (empty($_SESSION['csrf_token'])) {
            $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
        }

        return validateSessionIntegrity();
    } catch (Exception $e) {
        securityLog('Session initialization failed: ' . $e->getMessage(), 'critical');
        return false;
    }
}

// ...existing code...

/**
 * Refresh session to extend its duration.
 */
function refreshSession() {
    // Changed to security.log
    $logFile = __DIR__ . '/../../logs/security.log';
    $timestamp = date('Y-m-d H:i:s');

    try {
        if (session_status() === PHP_SESSION_ACTIVE) {
            $_SESSION['last_activity'] = time();
            session_regenerate_id(true);
            error_log("[$timestamp][info] Session refreshed\n", 3, $logFile);
        }
    } catch (Exception $e) {
        error_log("[$timestamp][error] Session refresh failed: " . $e->getMessage() . "\n", 3, $logFile);
    }
}

// ...existing code...

function validateSessionIntegrity() {
    if (!isset($_SESSION['initiated'])) {
        securityLog('Session integrity check failed: not initiated', 'warning');
        return false;
    }

    $currentIp = hash('sha256', $_SERVER['REMOTE_ADDR']);
    $currentAgent = hash('sha256', $_SERVER['HTTP_USER_AGENT']);
    
    // Flexible validation for guest sessions
    if (isset($_SESSION['user_id'])) {
        // Strict validation for authenticated users
        if ($_SESSION['client_ip'] !== $currentIp || 
            $_SESSION['user_agent'] !== $currentAgent) {
            securityLog('Session integrity check failed: authenticated user mismatch', 'warning');
            destroySession();
            return false;
        }
    } else {
        // Update fingerprint for guest sessions
        $_SESSION['client_ip'] = $currentIp;
        $_SESSION['user_agent'] = $currentAgent;
        $_SESSION['guest'] = true;
    }

    // Check for session timeout (30 minutes)
    if (time() - $_SESSION['last_activity'] > 1800) {
        securityLog('Session expired due to inactivity', 'info');
        destroySession();
        return false;
    }

    // Refresh session if about to expire (within 5 minutes)
    if (time() - $_SESSION['last_activity'] > 1500) {
        refreshSession();
    }

    $_SESSION['last_activity'] = time();
    return true;
}

// ...existing code...

function generateCsrfToken() {
    try {
        // Ensure we have a token and it's not expired
        if (empty($_SESSION['csrf_token']) || 
            !isset($_SESSION['csrf_time']) || 
            (time() - $_SESSION['csrf_time'] > 1800)) {
            
            $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
            $_SESSION['csrf_time'] = time();
        }
        return $_SESSION['csrf_token'];
    } catch (Exception $e) {
        securityLog('CSRF token generation failed: ' . $e->getMessage(), 'error');
        // Fallback to a less secure but functional token
        return hash('sha256', uniqid(mt_rand(), true));
    }
}

/**
 * Validate CSRF token from user input.
 */
function validateCsrfToken($token)
{
    if (!isset($_SESSION['csrf_token']) || !hash_equals($_SESSION['csrf_token'], $token)) {
        securityLog('CSRF validation failed for token: ' . ($token ?? 'null'), 'warning');
        return false;
    }
    return true;
}

/**
 * Return CSRF hidden input field for forms.
 */
function csrf_field()
{
    $token = generateCsrfToken();
    return '<input type="hidden" name="csrf_token" value="' . htmlspecialchars($token, ENT_QUOTES, 'UTF-8') . '">';
}

/**
 * Sanitize user input to prevent XSS.
 */
function sanitizeInput($data)
{
    return htmlspecialchars(trim($data), ENT_QUOTES, 'UTF-8');
}

/**
 * Generate secure random string (for password resets, API keys, etc.).
 */
function generateSecureToken($length = 64)
{
    return bin2hex(random_bytes($length / 2));
}

function destroySession() {
    if (session_status() !== PHP_SESSION_ACTIVE) {
        return false;
    }

    try {
        $wasGuest = $_SESSION['guest'] ?? false;
        securityLog('Initiating session destruction: ' . ($wasGuest ? 'guest' : 'user') . ' session');
        
        // Clear session data
        $_SESSION = [];
        
        // Delete session cookie
        if (ini_get('session.use_cookies')) {
            $params = session_get_cookie_params();
            setcookie(session_name(), '', [
                'expires' => time() - 42000,
                'path' => $params['path'],
                'domain' => $params['domain'],
                'secure' => $params['secure'],
                'httponly' => $params['httponly'],
                'samesite' => 'Lax'
            ]);
        }
        
        if (!session_destroy()) {
            throw new Exception('Session destruction failed');
        }
        
        securityLog('Session destroyed successfully');
        return true;
    } catch (Exception $e) {
        securityLog('Session destruction error: ' . $e->getMessage(), 'error');
        return false;
    }
}

/**
 * Check if a user is logged in.
 */
function isUserLoggedIn()
{
    return session_status() === PHP_SESSION_ACTIVE && 
           isset($_SESSION['user_id']) && 
           !($_SESSION['guest'] ?? true) && 
           validateSessionIntegrity();
}

/**
 * Get the logged-in user's role.
 */
function getUserRole()
{
    return $_SESSION['user_role'] ?? 'guest';
}

/**
 * Get session data safely.
 */
function getSessionData($key)
{
    return $_SESSION[$key] ?? null;
}

/**
 * Set session data safely.
 */
function setSessionData($key, $value)
{
    $_SESSION[$key] = $value;
}

/**
 * Validate JWT token.
 */
function validateJWT($token) {
    // Changed to use security.log for logging all security events.
    $logFile = __DIR__ . '/../../logs/security.log';
    $timestamp = date('Y-m-d H:i:s');
    $userId = $_SESSION['user_id'] ?? 'guest';

    try {
        // Decode the token (assuming using Firebase JWT library)
        $decoded = \Firebase\JWT\JWT::decode($token, new \Firebase\JWT\Key('your-secret-key', 'HS256'));

        // Check if the token is expired
        if ($decoded->exp < time()) {
            securityLog("JWT expired for token: $token", 'warning');
            return false;
        }

        return $decoded;
    } catch (Exception $e) {
        securityLog("JWT validation failed: " . $e->getMessage(), 'error');
        return false;
    }
} // <-- Added missing closing brace

/**
 * Enforce authentication for protected pages.
 */
function requireUserAuth() {
    requireAuth();
}

// New function to enforce authentication dynamically
function requireAuth($allowGuest = false) {
    // Get HTTP headers if available
    $headers = function_exists('getallheaders') ? getallheaders() : [];
    $authHeader = $headers['Authorization'] ?? '';

    if ($authHeader && str_starts_with($authHeader, 'Bearer ')) {
        // API authentication using JWT Bearer
        $config = require __DIR__ . '/../../config/encryption.php';
        $jwtSecret = $config['jwt_secret'] ?? '';
        $token = substr($authHeader, 7);
        try {
            return (array) Firebase\JWT\JWT::decode($token, new Firebase\JWT\Key($jwtSecret, 'HS256'));
        } catch (Exception $e) {
            error_log("[AUTH] API authentication failure: " . $e->getMessage() . "\n", 3, __DIR__ . '/../../logs/auth.log');
            header('Content-Type: application/json');
            http_response_code(401);
            echo json_encode(['error' => 'Unauthorized']);
            exit;
        }
    } else {
        // Web authentication using session
        if (session_status() !== PHP_SESSION_ACTIVE) {
            session_start();
        }
        if (isset($_SESSION['user_id'])) {
            return $_SESSION['user_id'];
        } elseif ($allowGuest) {
            return null;
        } else {
            error_log("[AUTH] Web authentication failure: No session user_id\n", 3, __DIR__ . '/../../logs/auth.log');
            // If the request expects JSON, return JSON response
            if (isset($_SERVER['HTTP_ACCEPT']) && strpos($_SERVER['HTTP_ACCEPT'], 'application/json') !== false) {
                header('Content-Type: application/json');
                http_response_code(401);
                echo json_encode(['error' => 'Unauthorized']);
            } else {
                http_response_code(401);
                echo 'Unauthorized';
            }
            exit;
        }
    }
}

// Initialize secure session when the file is included
if (!startSecureSession()) {
    securityLog('Critical: Failed to initialize secure session', 'critical');
}
?>
=== App/Helpers/DatabaseHelper.php ===
<?php

namespace App\Helpers;

use Illuminate\Database\Capsule\Manager as Capsule;
use Illuminate\Events\Dispatcher;
use Illuminate\Container\Container;
use Dotenv\Dotenv;
use Exception;

class DatabaseHelper
{
    private static $capsule = null;
    private static $secureCapsule = null;

    private function __construct() {}

    // ✅ Load Environment Variables
    private static function loadEnv()
    {
        $dotenv = Dotenv::createImmutable(__DIR__ . '/../../');
        $dotenv->safeLoad(); // Load .env file safely (no errors if missing)
    }

    // ✅ Singleton: Get Main Database Instance
    public static function getInstance()
    {
        if (self::$capsule === null) {
            self::$capsule = new Capsule;
            self::loadEnv();

            try {
                self::$capsule->addConnection([
                    'driver'    => 'mysql',
                    'host'      => $_ENV['DB_HOST'] ?? 'localhost',
                    'port'      => $_ENV['DB_PORT'] ?? '3306',
                    'database'  => $_ENV['DB_DATABASE'] ?? '',
                    'username'  => $_ENV['DB_USERNAME'] ?? '',
                    'password'  => $_ENV['DB_PASSWORD'] ?? '',
                    'charset'   => $_ENV['DB_CHARSET'] ?? 'utf8mb4',
                    'collation' => 'utf8mb4_unicode_ci',
                    'prefix'    => '',
                ]);

                self::$capsule->setEventDispatcher(new Dispatcher(new Container));
                self::$capsule->setAsGlobal();
                self::$capsule->bootEloquent();

                self::logEvent('database', "✅ Main Database connected successfully.");
            } catch (Exception $e) {
                self::logEvent('errors', "❌ Database connection failed: " . $e->getMessage());
                die(json_encode(["error" => "Database connection failed"]));
            }
        }

        return self::$capsule;
    }

    // ✅ Singleton: Get Secure Database Instance
    public static function getSecureInstance()
    {
        if (self::$secureCapsule === null) {
            self::$secureCapsule = new Capsule;
            self::loadEnv();

            try {
                self::$secureCapsule->addConnection([
                    'driver'    => 'mysql',
                    'host'      => $_ENV['SECURE_DB_HOST'] ?? 'localhost',
                    'port'      => $_ENV['SECURE_DB_PORT'] ?? '3306',
                    'database'  => $_ENV['SECURE_DB_DATABASE'] ?? '',
                    'username'  => $_ENV['SECURE_DB_USERNAME'] ?? '',
                    'password'  => $_ENV['SECURE_DB_PASSWORD'] ?? '',
                    'charset'   => $_ENV['SECURE_DB_CHARSET'] ?? 'utf8mb4',
                    'collation' => 'utf8mb4_unicode_ci',
                    'prefix'    => '',
                ], 'secure');

                self::$secureCapsule->setEventDispatcher(new Dispatcher(new Container));
                self::$secureCapsule->setAsGlobal();
                self::$secureCapsule->bootEloquent();

                self::logEvent('database', "✅ Secure Database connected successfully.");
            } catch (Exception $e) {
                self::logEvent('errors', "❌ Secure Database connection failed: " . $e->getMessage());
                die(json_encode(["error" => "Secure database connection failed"]));
            }
        }

        return self::$secureCapsule;
    }

    // ✅ Log Events
    private static function logEvent($category, $message)
    {
        $logFilePath = __DIR__ . "/../../logs/{$category}.log";
        $timestamp = date('Y-m-d H:i:s');
        file_put_contents($logFilePath, "[$timestamp] $message\n", FILE_APPEND);
    }
}
