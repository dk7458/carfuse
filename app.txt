=== App/Controllers/UserController.php ===
<?php

namespace App\Controllers;

use App\Models\User;
use ApiHelper;
use Validator;
use TokenService;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use Illuminate\Routing\Controller;
use Illuminate\Support\Str;

/**
 * User Management Controller
 *
 * Handles profile management, password resets, and dashboard access.
 */
class UserController extends Controller
{
    private Validator $validator;
    private TokenService $tokenService;
    private ExceptionHandler $exceptionHandler;
    private LoggerInterface $userLogger;
    private LoggerInterface $authLogger;
    private LoggerInterface $auditLogger;

    public function __construct(
        Validator $validator,
        TokenService $tokenService,
        ExceptionHandler $exceptionHandler,
        LoggerInterface $userLogger,
        LoggerInterface $authLogger,
        LoggerInterface $auditLogger
    ) {
        $this->validator = $validator;
        $this->tokenService = $tokenService;
        $this->exceptionHandler = $exceptionHandler;
        $this->userLogger = $userLogger;
        $this->authLogger = $authLogger;
        $this->auditLogger = $auditLogger;
    }

    /**
     * Register a new user.
     */
    public function registerUser()
    {
        $data = $_POST;
        // Validate input data
        $rules = [
            'email'    => 'required|email',
            'password' => 'required|min:6',
            // ... other rules ...
        ];
        if (!$this->validator->validate($data, $rules)) {
            return ApiHelper::sendJsonResponse('error', 'Validation failed', $this->validator->errors(), 400);
        }
        try {
            $user = User::create($data);
            if (!$user) {
                throw new \Exception("User registration failed");
            }
            $this->userLogger->info("User registered successfully", ['email' => $data['email']]);
            return ApiHelper::sendJsonResponse('success', 'User registered successfully', ['user_id' => $user->id], 201);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    /**
     * Log in an existing user.
     */
    public function login()
    {
        $email = $_POST['email'] ?? null;
        $password = $_POST['password'] ?? null;
        if (!$email || !$password) {
            return ApiHelper::sendJsonResponse('error', 'Email and password required', null, 400);
        }
        try {
            $user = User::where('email', $email)->first();
            if (!$user || !password_verify($password, $user->password_hash)) {
                throw new \Exception("Invalid credentials");
            }
            if (session_status() === PHP_SESSION_NONE) {
                session_start();
            }
            session_regenerate_id(true);
            $_SESSION['user_id']   = $user->id;
            $_SESSION['user_role'] = $user->role ?? 'user';
            $token = $this->tokenService->generateToken($user);
            $refreshToken = $this->tokenService->generateRefreshToken($user);
            $this->authLogger->info("User logged in", ['userId' => $user->id, 'email' => $user->email]);
            return ApiHelper::sendJsonResponse('success', 'User logged in', [
                'token'         => $token,
                'refresh_token' => $refreshToken
            ], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    /**
     * Log out the current user.
     */
    public function logout()
    {
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }
        $_SESSION = [];
        if (ini_get('session.use_cookies')) {
            setcookie(session_name(), '', time() - 42000, '/');
        }
        session_destroy();
        $this->authLogger->info("User logged out");
        return ApiHelper::sendJsonResponse('success', 'Logged out successfully', null, 200);
    }

    /**
     * Retrieve current user profile.
     */
    public function getUserProfile()
    {
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }
        $user = User::find($_SESSION['user_id'] ?? null);
        return ApiHelper::sendJsonResponse('success', 'User profile retrieved', $user, 200);
    }

    /**
     * 🔹 Update user profile
     */
    public function updateProfile()
    {
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }
        $user = $_SESSION['user'] ?? null;
        if (!$user) {
            return ApiHelper::sendJsonResponse('error', 'Unauthorized', null, 401);
        }
        $data = [
            'name'    => $_POST['name'] ?? null,
            'surname' => $_POST['surname'] ?? null,
            'email'   => $_POST['email'] ?? null,
            'phone'   => $_POST['phone'] ?? null,
            'address' => $_POST['address'] ?? null,
        ];
        $rules = [
            'name'    => 'required|string|max:255',
            'surname' => 'required|string|max:255',
            'email'   => 'required|email',
            'phone'   => 'nullable|string|max:15',
            'address' => 'nullable|string|max:255',
        ];
        if (!$this->validator->validate($data, $rules)) {
            return ApiHelper::sendJsonResponse('error', 'Validation failed', $this->validator->errors(), 400);
        }
        try {
            $user->update($data);
            $this->auditLogger->info("User profile updated", ['userId' => $user->id]);
            return ApiHelper::sendJsonResponse('success', 'Profile updated successfully', null, 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    /**
     * 🔹 Get user profile
     */
    public function getProfile()
    {
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }
        $user = $_SESSION['user'] ?? null;
        return ApiHelper::sendJsonResponse('success', 'User profile', $user, 200);
    }

    /**
     * 🔹 Request password reset
     */
    public function requestPasswordReset()
    {
        $email = $_POST['email'] ?? null;
        if (!$email) {
            return ApiHelper::sendJsonResponse('error', 'Invalid input', null, 400);
        }
        try {
            $token = Str::random(60);
            \App\Models\PasswordReset::create([
                'email'      => $email,
                'token'      => $token,
                'expires_at' => now()->addHour(),
            ]);
            return ApiHelper::sendJsonResponse('success', 'Password reset requested', null, 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    /**
     * 🔹 User dashboard access
     */
    public function userDashboard()
    {
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }
        // Rendering HTML for dashboard via ApiHelper response
        $html = "<html><body><h1>User Dashboard</h1><!-- ...existing dashboard HTML... --></body></html>";
        return ApiHelper::sendJsonResponse('success', 'User Dashboard', $html, 200);
    }
}
=== App/Controllers/BookingController.php ===
<?php

namespace App\Controllers;

use App\Models\Booking;
use App\Models\RefundLog;
use Illuminate\Http\Request;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

/**
 * Booking Controller
 *
 * Handles booking operations, including creating, rescheduling,
 * canceling bookings, and fetching booking details or logs.
 */
class BookingController extends Controller
{
    private BookingService $bookingService;
    private PaymentService $paymentService;
    private Validator $validator;
    private AuditService $auditService;
    private NotificationService $notificationService;
    private LoggerInterface $logger;

    public function __construct(
        BookingService $bookingService,
        PaymentService $paymentService,
        Validator $validator,
        AuditService $auditService,
        NotificationService $notificationService,
        LoggerInterface $logger
    ) {
        $this->bookingService = $bookingService;
        $this->paymentService = $paymentService;
        $this->validator = $validator;
        $this->auditService = $auditService;
        $this->notificationService = $notificationService;
        $this->logger = $logger;
    }

    /**
     * View Booking Details
     */
    public function viewBooking(int $id)
    {
        try {
            $booking = Booking::with('logs')->findOrFail($id);
            header('Content-Type: application/json');
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Booking details fetched',
                'data'    => ['booking' => $booking]
            ]);
            exit;
        } catch (\Exception $e) {
            $this->logger->error("BOOKING ERROR: " . $e->getMessage());
            http_response_code(404);
            echo 'Booking not found';
            exit;
        }
    }

    /**
     * Reschedule Booking
     */
    public function rescheduleBooking(int $id): void
    {
        $data = $_POST; // minimal custom validation assumed
        
        try {
            $booking = Booking::findOrFail($id);
            $booking->update([
                'pickup_date'  => $data['pickup_date'],
                'dropoff_date' => $data['dropoff_date'],
            ]);
            error_log("AUDIT: Booking rescheduled, booking_id: {$id}");
            header('Content-Type: application/json');
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Booking rescheduled successfully'
            ]);
            exit;
        } catch (\Exception $e) {
            $this->logger->error("BOOKING ERROR: Failed to reschedule booking: " . $e->getMessage());
            http_response_code(500);
            echo 'Failed to reschedule booking';
            exit;
        }
    }

    /**
     * Cancel Booking
     */
    public function cancelBooking(int $id): void
    {
        try {
            $booking = Booking::findOrFail($id);
            $booking->update(['status' => 'canceled']);

            // Process refund if applicable.
            $refundAmount = $booking->calculateRefund(); // Assumes a calculateRefund() method exists.
            if ($refundAmount > 0) {
                RefundLog::create([
                    'booking_id' => $id,
                    'amount'     => $refundAmount,
                    'status'     => 'processed'
                ]);
            }
            error_log("BOOKING: Booking canceled, booking_id: {$id}");
            header('Content-Type: application/json');
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Booking canceled successfully'
            ]);
            exit;
        } catch (\Exception $e) {
            $this->logger->error("BOOKING ERROR: Failed to cancel booking: " . $e->getMessage());
            http_response_code(500);
            echo 'Failed to cancel booking';
            exit;
        }
    }

    /**
     * Fetch Booking Logs
     */
    public function getBookingLogs(int $bookingId): void
    {
        try {
            $logs = Booking::findOrFail($bookingId)->logs()->latest()->get();
            header('Content-Type: application/json');
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Booking logs fetched successfully',
                'data'    => ['logs' => $logs]
            ]);
            exit;
        } catch (\Exception $e) {
            $this->logger->error("BOOKING ERROR: Failed to fetch booking logs: " . $e->getMessage());
            http_response_code(500);
            echo 'Failed to fetch booking logs';
            exit;
        }
    }

    /**
     * List All Bookings for a User
     */
    public function getUserBookings(): void
    {
        try {
            $userId = $_SESSION['user_id'] ?? null;
            if (!$userId) {
                throw new \Exception('User not authenticated');
            }
            $bookings = Booking::where('user_id', $userId)->latest()->get();
            header('Content-Type: application/json');
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'User bookings fetched successfully',
                'data'    => ['bookings' => $bookings]
            ]);
            exit;
        } catch (\Exception $e) {
            $this->logger->error("BOOKING ERROR: Failed to fetch user bookings: " . $e->getMessage());
            http_response_code(500);
            echo 'Failed to fetch user bookings';
            exit;
        }
    }

    /**
     * Create New Booking
     */
    public function createBooking(): void
    {
        $data = $_POST; // assuming custom validation is performed elsewhere
        
        try {
            // Check vehicle availability using an assumed Booking::isAvailable() scope.
            if (!Booking::isAvailable($data['vehicle_id'], $data['pickup_date'], $data['dropoff_date'])) {
                header('Content-Type: application/json');
                http_response_code(400);
                echo json_encode([
                    'status'  => 'error',
                    'message' => 'Vehicle is not available for the selected dates'
                ]);
                exit;
            }
            $booking = Booking::create($data);
            error_log("BOOKING: Booking created, booking_id: {$booking->id}");
            header('Content-Type: application/json');
            http_response_code(201);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Booking created successfully',
                'data'    => ['booking_id' => $booking->id]
            ]);
            exit;
        } catch (\Exception $e) {
            $this->logger->error("BOOKING ERROR: Failed to create booking: " . $e->getMessage());
            http_response_code(500);
            echo 'Failed to create booking';
            exit;
        }
    }
}
=== App/Controllers/NotificationController.php ===
<?php

namespace App\Controllers;

use App\Models\Notification;
use Illuminate\Support\Facades\Auth;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

/**
 * Notification Controller
 *
 * Handles notification management, including sending notifications,
 * marking notifications as read, deleting notifications, and
 * fetching user notifications for display.
 */
class NotificationController extends Controller
{
    // Removed injected NotificationService, Validator, LoggerInterface, and NotificationQueue

    /**
     * Display user notifications.
     */
    public function viewNotifications()
    {
        try {
            $notifications = Notification::with('user')
                ->where('user_id', $_SESSION['user_id'] ?? null)
                ->latest()
                ->get();
            $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Notifications loaded',
                'data'    => ['notifications' => $notifications]
            ], 200);
        } catch (\Exception $e) {
            $this->jsonResponse([
                'status'  => 'error',
                'message' => 'An error occurred while fetching notifications',
                'data'    => []
            ], 500);
        }
    }

    /**
     * Fetch all notifications for the authenticated user.
     */
    public function getUserNotifications()
    {
        try {
            $notifications = Notification::with('user')
                ->where('user_id', $_SESSION['user_id'] ?? null)
                ->latest()
                ->get();
            $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Notifications fetched',
                'data'    => ['notifications' => $notifications]
            ], 200);
        } catch (\Exception $e) {
            $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to fetch user notifications',
                'data'    => []
            ], 500);
        }
    }

    /**
     * Fetch unread notifications via AJAX.
     */
    public function fetchNotificationsAjax()
    {
        try {
            $notifications = Notification::with('user')
                ->where('user_id', $_SESSION['user_id'] ?? null)
                ->where('is_read', false)
                ->latest()
                ->get();
            $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Notifications fetched',
                'data'    => ['notifications' => $notifications]
            ], 200);
        } catch (\Exception $e) {
            $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to fetch notifications',
                'data'    => []
            ], 500);
        }
    }

    /**
     * Mark a notification as read.
     */
    public function markNotificationAsRead()
    {
        $data = $this->validateRequest($_POST, [
            'notification_id' => 'required|integer'
        ]);

        try {
            $notification = Notification::findOrFail($data['notification_id']);
            $notification->update(['is_read' => true]);
            $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Notification marked as read',
                'data'    => []
            ], 200);
        } catch (\Exception $e) {
            $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to mark notification as read',
                'data'    => []
            ], 500);
        }
    }

    /**
     * Delete a notification.
     */
    public function deleteNotification()
    {
        $data = $this->validateRequest($_POST, [
            'notification_id' => 'required|integer'
        ]);

        try {
            $notification = Notification::findOrFail($data['notification_id']);
            $notification->delete();
            $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Notification deleted',
                'data'    => []
            ], 200);
        } catch (\Exception $e) {
            $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to delete notification',
                'data'    => []
            ], 500);
        }
    }

    /**
     * Send a notification.
     */
    public function sendNotification()
    {
        $data = $this->validateRequest($_POST, [
            'user_id' => 'required|integer',
            'type'    => 'required|in:email,sms,webhook,push',
            'message' => 'required|string|max:1000',
            'options' => 'nullable|array',
        ]);

        try {
            // Store notification via Eloquent
            $notification = Notification::create([
                'user_id' => $data['user_id'],
                'type'    => $data['type'],
                'message' => $data['message'],
                'sent_at' => date('Y-m-d H:i:s'),
                'is_read' => false,
            ]);
            // Optionally dispatch via queue or any external channel here.
            $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Notification sent successfully',
                'data'    => ['notification' => $notification]
            ], 200);
        } catch (\Exception $e) {
            $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to send notification',
                'data'    => []
            ], 500);
        }
    }
}
=== App/Controllers/AdminController.php ===
<?php

namespace App\Controllers;

use App\Models\User;
use App\Models\Admin;
use App\Models\Booking;
use App\Models\Payment;
use App\Models\TransactionLog;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Validator;
use Psr\Log\LoggerInterface;

/**
 * AdminController - Handles admin user management and dashboard operations.
 */
class AdminController extends Controller
{
    private LoggerInterface $logger;

    public function __construct(LoggerInterface $adminLogger)
    {
        parent::__construct($adminLogger);
        $this->logger = $adminLogger;
    }

    /**
     * ✅ Get a paginated list of all users with their roles.
     */
    public function getAllUsers()
    {
        $users = User::with('roles')->latest()->paginate(10);
        header('Content-Type: application/json');
        http_response_code(200);
        echo json_encode(['users' => $users]);
        exit;
    }

    /**
     * ✅ Update a user's role.
     */
    public function updateUserRole($userId)
    {
        // Replace Laravel validation with native checks.
        $role = $_POST['role'] ?? '';
        $allowedRoles = ['user', 'admin', 'manager'];
        if (!$role || !in_array($role, $allowedRoles)) {
            http_response_code(400);
            echo json_encode(['message' => 'Invalid role']);
            exit;
        }
        $user = User::findOrFail($userId);
        $user->update(['role' => $role]);
        $this->logger->info("AUDIT: User role updated: {$user->email} to {$role}");
        header('Content-Type: application/json');
        http_response_code(200);
        echo json_encode(['message' => 'User role updated successfully']);
        exit;
    }

    /**
     * ✅ Delete a user (Soft delete).
     */
    public function deleteUser($userId)
    {
        $user = User::findOrFail($userId);
        $user->delete();
        $this->logger->info("AUDIT: User deleted: {$user->email}");
        header('Content-Type: application/json');
        http_response_code(200);
        echo json_encode(['message' => 'User deleted successfully']);
        exit;
    }

    /**
     * ✅ Fetch admin dashboard statistics.
     */
    public function getDashboardData()
    {
        $dashboardData = Cache::remember('admin_dashboard', 60, function () {
            return [
                'total_users' => User::count(),
                'total_bookings' => Booking::count(),
                'total_revenue' => Payment::sum('amount'),
                'latest_users' => User::with('roles')->latest()->limit(5)->get(),
                'latest_transactions' => TransactionLog::latest()->limit(5)->get(),
            ];
        });
        header('Content-Type: application/json');
        http_response_code(200);
        echo json_encode($dashboardData);
        exit;
    }

    /**
     * ✅ Create a new admin user.
     */
    public function createAdmin()
    {
        // Use native PHP POST handling.
        $data = $_POST;
        // Basic native validation.
        if (!isset($data['name'], $data['email'], $data['password']) ||
            !filter_var($data['email'], FILTER_VALIDATE_EMAIL) ||
            strlen($data['password']) < 8
        ) {
            http_response_code(400);
            echo json_encode(['message' => 'Invalid input']);
            exit;
        }

        $admin = Admin::create([
            'name' => $data['name'],
            'email' => $data['email'],
            'password' => Hash::make($data['password']),
            'role' => 'admin'
        ]);
        $this->logger->info("AUDIT: New admin created: {$admin->email}");
        header('Content-Type: application/json');
        http_response_code(201);
        echo json_encode(['message' => 'Admin created successfully', 'admin' => $admin]);
        exit;
    }
}
=== App/Controllers/AuthController.php ===
<?php

namespace App\Controllers;

use App\Services\Auth\TokenService;
use App\Services\Auth\AuthService;
use Exception;
use App\Helpers\DatabaseHelper;
use App\Services\Validator;
use App\Helpers\SecurityHelper;
use App\Helpers\ApiHelper;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler; // New dependency

class AuthController extends Controller
{
    private AuthService $authService;
    private Validator $validator;
    private TokenService $tokenService;
    private ExceptionHandler $exceptionHandler;
    private LoggerInterface $authLogger;
    private LoggerInterface $auditLogger;

    public function __construct(
        AuthService $authService,
        Validator $validator,
        TokenService $tokenService,
        ExceptionHandler $exceptionHandler,
        LoggerInterface $authLogger,
        LoggerInterface $auditLogger
    ) {
        $this->authService = $authService;
        $this->validator = $validator;
        $this->tokenService = $tokenService;
        $this->exceptionHandler = $exceptionHandler;
        $this->authLogger = $authLogger;
        $this->auditLogger = $auditLogger;

        DatabaseHelper::getInstance();
    }

    public function loginView()
    {
        view('auth/login');
    }

    public function registerView()
    {
        view('auth/register');
    }

    public function login($request = null)
    {
        // ...existing code...
        $data = json_decode(file_get_contents("php://input"), true);
        if (!$data || !is_array($data)) {
            return ApiHelper::sendJsonResponse('error', 'Invalid JSON input', ['errors' => (object)[]], 400);
        }
        
        $email = $data['email'] ?? '';
        $password = $data['password'] ?? '';
        
        $result = $this->authService->login($email, $password);
        setcookie("jwt", $result['token'], [
            "expires"  => time() + 3600,
            "path"     => "/",
            "secure"   => true,
            "httponly" => true,
            "samesite" => "Strict"
        ]);
        setcookie("refresh_token", $result['refresh_token'], [
            "expires"  => time() + 604800,
            "path"     => "/",
            "secure"   => true,
            "httponly" => true,
            "samesite" => "Strict"
        ]);
        // Improved logging with context
        $this->authLogger->info("User logged in", ['email' => $email]);
        return ApiHelper::sendJsonResponse('success', 'User logged in', ['errors' => (object)[]], 200);
    }

    public function register($request = null)
    {
        // ...existing code...
        $data = json_decode(file_get_contents("php://input"), true);
        if (!$data || !is_array($data)) {
            return ApiHelper::sendJsonResponse('error', 'Invalid JSON input', ['errors' => (object)[]], 400);
        }
        
        $rules = [
            'name'             => 'required',
            'email'            => 'required|email',
            'password'         => 'required',
            'confirm_password' => 'required'
        ];
        if (!$this->validator->validate($data, $rules)) {
            return ApiHelper::sendJsonResponse('error', 'Validation failed', ['errors' => $this->validator->errors()], 400);
        }
        if ($data['password'] !== $data['confirm_password']) {
            return ApiHelper::sendJsonResponse('error', 'Password and confirm password do not match', ['errors' => (object)[]], 400);
        }
        
        $registrationData = [
            'name'     => $data['name'],
            'surname'  => $data['surname']  ?? '',
            'email'    => $data['email'],
            'password' => $data['password'],
            'phone'    => $data['phone']    ?? null,
            'address'  => $data['address']  ?? null
        ];

        try {
            $result = $this->authService->registerUser($registrationData);
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            // Additional audit logging if needed
            $this->auditLogger->error("User registration failed", [
                'error' => $e->getMessage(),
                'email' => $data['email']
            ]);
            return; // ExceptionHandler is assumed to handle the response
        }
        $this->auditLogger->info("User registered", ['email' => $data['email']]);
        return ApiHelper::sendJsonResponse('success', 'User registered', $result, 201);
    }

    public function resetPasswordRequest($request = null)
    {
        $data = json_decode(file_get_contents("php://input"), true);
        if (!$data || !is_array($data)) {
            ApiHelper::sendJsonResponse('error', 'Invalid JSON input', ['errors' => (object)[]], 400);
        }
        $email = $data['email'] ?? '';
        $result = $this->authService->resetPasswordRequest($email);
        ApiHelper::sendJsonResponse('success', 'Password reset request processed', $result, 200);
    }

    public function refresh()
    {
        if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
            ApiHelper::sendJsonResponse('error', 'Method Not Allowed', ['errors' => (object)[]], 405);
        }
        $refreshToken = $_COOKIE['refresh_token'] ?? null;
        if (!$refreshToken) {
            ApiHelper::sendJsonResponse('error', 'Refresh token is required', ['errors' => (object)[]], 400);
        }
        $newToken = $this->tokenService->refreshToken($refreshToken);
        if ($newToken) {
            setcookie("jwt", $newToken, [
                "expires" => time() + 3600,
                "path" => "/",
                "secure" => true,
                "httponly" => true,
                "samesite" => "Strict"
            ]);
            ApiHelper::sendJsonResponse('success', 'Token refreshed', ['errors' => (object)[]], 200);
        } else {
            ApiHelper::sendJsonResponse('error', 'Invalid refresh token', ['errors' => (object)[]], 401);
        }
    }

    public function logout($request = null)
    {
        $this->authService->logout();
        setcookie("jwt", "", [
            "expires" => time() - 3600,
            "path" => "/",
            "secure" => true,
            "httponly" => true,
            "samesite" => "Strict"
        ]);
        setcookie("refresh_token", "", [
            "expires" => time() - 3600,
            "path" => "/",
            "secure" => true,
            "httponly" => true,
            "samesite" => "Strict"
        ]);
        ApiHelper::sendJsonResponse('success', 'User logged out', ['errors' => (object)[]], 200);
    }

    public function userDetails($request = null)
    {
        $token = $_COOKIE['jwt'] ?? '';
        if (!$this->authService->validateToken($token)) {
            ApiHelper::sendJsonResponse('error', 'Invalid token', ['errors' => (object)[]], 400);
        }
        $userData = $this->authService->getUserFromToken($token);
        ApiHelper::sendJsonResponse('success', 'User details fetched', $userData, 200);
    }

    private function refreshToken()
    {
        // ...existing code...
    }

    private function updateSessionActivity()
    {
        $_SESSION['last_activity'] = time();
    }

    // Updated logging method with context details
    private function logAuthAttempt($status, $message)
    {
        $context = ['ip' => $_SERVER['REMOTE_ADDR'], 'time' => date('Y-m-d H:i:s')];
        $logMessage = sprintf("%s: %s", ucfirst($status), $message);
        $this->authLogger->info($logMessage, $context);
    }
}
=== App/Controllers/SignatureController.php ===
<?php

namespace App\Controllers;

use App\Services\SignatureService;
use Psr\Log\LoggerInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

/**
 * Signature Controller
 *
 * Handles the management of user signatures, including uploading,
 * verifying, and retrieving signatures for documents.
 */
class SignatureController extends Controller
{
    private SignatureService $signatureService;
    private LoggerInterface $logger;

    public function __construct(
        SignatureService $signatureService,
        LoggerInterface $signatureLogger
    ) {
        $this->signatureService = $signatureService;
        $this->logger = $signatureLogger;
    }

    /**
     * Upload a signature.
     *
     * @param array $data The uploaded signature file and associated metadata.
     * @return array Response indicating success or failure.
     */
    public function uploadSignature(array $data): array
    {
        $rules = [
            'user_id' => 'required|integer',
            'file' => 'required|file|mimes:png,jpg,jpeg|max:2048', // Max 2MB
        ];

        try {
            custom_validate($data, $rules);
        } catch (\Exception $ex) {
            $this->logger->error("Warning: Signature validation failed. Data: " . json_encode($data));
            return ['status' => 'error', 'message' => 'Validation failed', 'errors' => $ex->getMessage()];
        }

        try {
            $signaturePath = $this->signatureService->uploadSignature($data['user_id'], $data['file']);
            $this->logger->info("Info: Signature uploaded successfully for user_id: " . $data['user_id']);
            return ['status' => 'success', 'message' => 'Signature uploaded successfully', 'signature_path' => $signaturePath];
        } catch (\Exception $e) {
            $this->logger->error("Error: Failed to upload signature, error: " . $e->getMessage());
            return ['status' => 'error', 'message' => 'Failed to upload signature'];
        }
    }

    /**
     * Verify a signature.
     *
     * @param int $userId The ID of the user whose signature is to be verified.
     * @param string $documentHash The hash of the document to verify against the signature.
     * @return array Verification result.
     */
    public function verifySignature(int $userId, string $documentHash): array
    {
        try {
            $isValid = $this->signatureService->verifySignature($userId, $documentHash);

            if ($isValid) {
                $this->logger->info("Info: Signature verified successfully for user_id: {$userId}");
                return ['status' => 'success', 'message' => 'Signature verified successfully'];
            }

            return ['status' => 'error', 'message' => 'Signature verification failed'];
        } catch (\Exception $e) {
            $this->logger->error("Error: Failed to verify signature, error: " . $e->getMessage());
            return ['status' => 'error', 'message' => 'Failed to verify signature'];
        }
    }

    /**
     * Retrieve a user's signature.
     *
     * @param int $userId The ID of the user.
     * @return array Response containing the signature path or error message.
     */
    public function getSignature(int $userId): array
    {
        try {
            $signaturePath = $this->signatureService->getSignature($userId);

            if ($signaturePath) {
                $this->logger->info("Info: Signature retrieved successfully for user_id: {$userId}");
                return ['status' => 'success', 'signature_path' => $signaturePath];
            }

            return ['status' => 'error', 'message' => 'Signature not found'];
        } catch (\Exception $e) {
            $this->logger->error("Error: Failed to retrieve signature, error: " . $e->getMessage());
            return ['status' => 'error', 'message' => 'Failed to retrieve signature'];
        }
    }
}
=== App/Controllers/DashboardController.php ===
<?php

namespace App\Controllers;

use App\Models\Booking;
use App\Models\Payment;
use App\Models\Notification;
use App\Models\User;
use Illuminate\Support\Facades\Cache;
use Psr\Log\LoggerInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

class DashboardController extends Controller
{
    private BookingService $bookingService;
    private StatisticsService $statisticsService;
    private NotificationService $notificationService;
    private UserService $userService;
    private LoggerInterface $logger;

    public function __construct(
        BookingService $bookingService,
        StatisticsService $statisticsService,
        NotificationService $notificationService,
        UserService $userService,
        LoggerInterface $userLogger
    ) {
        $this->bookingService = $bookingService;
        $this->statisticsService = $statisticsService;
        $this->notificationService = $notificationService;
        $this->userService = $userService;
        $this->logger = $userLogger;
    }

    /**
     * Render user dashboard view.
     */
    public function userDashboard()
    {
        try {
            // Assume session_start() is already called.
            $user = (object)['id' => $_SESSION['user_id'] ?? null]; // Replace with native session retrieval
            // ...existing code for eager loading if needed...
            $statistics = Cache::remember('user_dashboard_' . $user->id, 60, function () use ($user) {
                return [
                    'total_bookings'     => Booking::where('user_id', $user->id)->count(),
                    'completed_bookings' => Booking::where('user_id', $user->id)->where('status', 'completed')->count(),
                    'total_payments'     => Payment::where('user_id', $user->id)->sum('amount'),
                ];
            });
            view('dashboard/user_dashboard', ['user' => $user, 'statistics' => $statistics]);
        } catch (\Exception $e) {
            $this->logger->error('Failed to load user dashboard: ' . $e->getMessage());
            abort(500, 'Error loading dashboard');
        }
    }

    /**
     * Fetch user bookings.
     */
    public function getUserBookings(): void
    {
        try {
            $bookings = Booking::where('user_id', $_SESSION['user_id'] ?? null)->get();
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Bookings fetched',
                'data'    => ['bookings' => $bookings]
            ]);
        } catch (\Exception $e) {
            $this->logger->error('Failed to fetch bookings: ' . $e->getMessage());
            abort(500, 'Failed to fetch bookings');
        }
    }

    /**
     * Fetch dashboard statistics.
     */
    public function fetchStatistics(): void
    {
        try {
            $stats = Cache::remember('dashboard_statistics', 60, function () {
                return [
                    'total_bookings'     => Booking::count(),
                    'completed_bookings' => Booking::where('status', 'completed')->count(),
                    'total_revenue'      => Payment::sum('amount')
                ];
            });
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Statistics fetched',
                'data'    => $stats
            ]);
        } catch (\Exception $e) {
            $this->logger->error('Failed to fetch statistics: ' . $e->getMessage());
            abort(500, 'Failed to fetch statistics');
        }
    }

    /**
     * Fetch user notifications.
     */
    public function fetchNotifications(): void
    {
        try {
            $notifications = Notification::where('user_id', $_SESSION['user_id'] ?? null)
                ->latest()
                ->get();
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Notifications fetched',
                'data'    => ['notifications' => $notifications]
            ]);
        } catch (\Exception $e) {
            $this->logger->error('Failed to fetch notifications: ' . $e->getMessage());
            abort(500, 'Failed to fetch notifications');
        }
    }

    /**
     * Fetch user profile.
     */
    public function fetchUserProfile(): void
    {
        try {
            $profile = User::findOrFail($_SESSION['user_id'] ?? null);
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'User profile fetched',
                'data'    => ['profile' => $profile]
            ]);
        } catch (\Exception $e) {
            $this->logger->error('Failed to fetch user profile: ' . $e->getMessage());
            abort(500, 'Failed to fetch user profile');
        }
    }
}
=== App/Controllers/AdminDashboardController.php ===
<?php

namespace App\Controllers;

use App\Models\User;
use App\Models\Booking;
use App\Models\Payment;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;
use Psr\Log\LoggerInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

class AdminDashboardController
{
    private LoggerInterface $logger;

    public function __construct(LoggerInterface $adminLogger)
    {
        $this->logger = $adminLogger;
    }

    public function index(): void
    {
        try {
            $metrics = Cache::remember('dashboard_metrics', 60, function () {
                $totalRevenue = Payment::where('status', 'completed')->sum('amount');
                $totalRefunds = Payment::where('status', 'completed')->where('type', 'refund')->sum('amount');
                return [
                    'total_users'        => User::count(),
                    'active_users'       => User::where('active', true)->count(),
                    'total_bookings'     => Booking::count(),
                    'completed_bookings' => Booking::where('status', 'completed')->count(),
                    'canceled_bookings'  => Booking::where('status', 'canceled')->count(),
                    'total_revenue'      => $totalRevenue,
                    'total_refunds'      => $totalRefunds,
                    'net_revenue'        => $totalRevenue - $totalRefunds,
                ];
            });
            $recentBookings = Booking::with('user')->latest()->limit(5)->get();

            extract(compact('metrics', 'recentBookings'));
            include BASE_PATH . '/public/views/admin/dashboard.php';
        } catch (\Exception $e) {
            $this->logger->error("DASHBOARD ERROR: " . $e->getMessage());
            http_response_code(500);
            echo 'Error loading the dashboard. Please try again later.';
        }
    }

    public function getDashboardData(): void
    {
        requireAuth(); // ensure admin authentication is in place
        try {
            $metrics = Cache::remember('dashboard_metrics', 60, function () {
                $totalRevenue = Payment::where('status', 'completed')->sum('amount');
                $totalRefunds = Payment::where('status', 'completed')->where('type', 'refund')->sum('amount');
                return [
                    'total_users'        => User::count(),
                    'active_users'       => User::where('active', true)->count(),
                    'total_bookings'     => Booking::count(),
                    'completed_bookings' => Booking::where('status', 'completed')->count(),
                    'canceled_bookings'  => Booking::where('status', 'canceled')->count(),
                    'total_revenue'      => $totalRevenue,
                    'total_refunds'      => $totalRefunds,
                    'net_revenue'        => $totalRevenue - $totalRefunds,
                ];
            });
            $recentBookings = Booking::with('user')->latest()->limit(5)->get();

            header('Content-Type: application/json');
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Dashboard data fetched',
                'data'    => [
                    'metrics'         => $metrics,
                    'recent_bookings' => $recentBookings,
                ]
            ]);
            exit;
        } catch (\Exception $e) {
            $this->logger->error("DASHBOARD ERROR: " . $e->getMessage());
            http_response_code(500);
            echo json_encode([
                'status'  => 'error',
                'message' => 'Failed to fetch dashboard data',
                'data'    => []
            ]);
            exit;
        }
    }
}
=== App/Controllers/PaymentController.php ===
<?php

namespace App\Controllers;

use App\Models\Payment;
use App\Models\RefundLog;
use App\Models\TransactionLog;
use App\Models\InstallmentPlan;
use Illuminate\Support\Facades\Auth;

/**
 * Payment Controller
 *
 * Handles payment processing, refunds, installment payments, and user transactions.
 */
class PaymentController extends Controller
{
    private PaymentService $paymentService;
    private Validator $validator;
    private NotificationService $notificationService;
    private AuditService $auditService;
    private PDO $db;
    private LoggerInterface $logger;

    public function __construct(
        PaymentService $paymentService,
        Validator $validator,
        NotificationService $notificationService,
        AuditService $auditService,
        PDO $db,
        LoggerInterface $logger
    ) {
        $this->paymentService = $paymentService;
        $this->validator = $validator;
        $this->notificationService = $notificationService;
        $this->auditService = $auditService;
        $this->db = $db;
        $this->logger = $logger;
    }

    /**
     * Process a payment.
     */
    public function processPayment(): void
    {
        $data = $this->validateRequest($_POST, [
            'user_id'          => 'required|integer',
            'booking_id'       => 'required|integer',
            'amount'           => 'required|numeric|min:0.01',
            'payment_method_id' => 'required|integer',
        ]);
        try {
            $payment = Payment::create([
                'booking_id'     => $data['booking_id'],
                'user_id'        => $data['user_id'],
                'amount'         => $data['amount'],
                'payment_method' => $data['payment_method_id'],
                'status'         => 'completed'
            ]);
            // Update related booking status via Eloquent relationship
            $payment->booking()->update(['status' => 'paid']);
            $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Payment processed',
                'data'    => ['payment' => $payment]
            ], 200);
        } catch (\Exception $e) {
            $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Payment processing failed',
                'data'    => []
            ], 500);
        }
    }

    /**
     * Refund a payment.
     */
    public function refundPayment(): void
    {
        $data = $this->validateRequest($_POST, [
            'transaction_id' => 'required|integer',
            'amount'         => 'required|numeric|min:0.01',
        ]);
        try {
            $refund = RefundLog::create([
                'transaction_id' => $data['transaction_id'],
                'amount'         => $data['amount'],
                'status'         => 'processed'
            ]);
            $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Refund processed',
                'data'    => ['refund' => $refund]
            ], 200);
        } catch (\Exception $e) {
            $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Refund processing failed',
                'data'    => []
            ], 500);
        }
    }

    /**
     * Set up installment payments.
     */
    public function setupInstallment(): void
    {
        $data = $this->validateRequest($_POST, [
            'user_id'           => 'required|integer',
            'total_amount'      => 'required|numeric|min:0.01',
            'installments'      => 'required|integer|min:2',
            'payment_method_id' => 'required|integer',
        ]);
        try {
            $plan = InstallmentPlan::create([
                'user_id'        => $data['user_id'],
                'total_amount'   => $data['total_amount'],
                'installments'   => $data['installments'],
                'payment_method' => $data['payment_method_id'],
            ]);
            $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Installment plan created',
                'data'    => ['installment_plan' => $plan]
            ], 200);
        } catch (\Exception $e) {
            $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Installment plan setup failed',
                'data'    => []
            ], 500);
        }
    }

    /**
     * Fetch all user transactions.
     */
    public function getUserTransactions(): void
    {
        try {
            $transactions = TransactionLog::with(['payment', 'booking'])
                ->where('user_id', $_SESSION['user_id'] ?? null)
                ->latest()
                ->get();
            $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Transactions fetched',
                'data'    => ['transactions' => $transactions]
            ], 200);
        } catch (\Exception $e) {
            $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to fetch user transactions',
                'data'    => []
            ], 500);
        }
    }

    /**
     * Fetch payment details.
     */
    public function getPaymentDetails(int $transactionId): void
    {
        try {
            $details = TransactionLog::findOrFail($transactionId);
            $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Payment details fetched',
                'data'    => ['details' => $details]
            ], 200);
        } catch (\Exception $e) {
            $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to fetch payment details',
                'data'    => []
            ], 500);
        }
    }
}
=== App/Controllers/Controller.php ===
<?php

namespace App\Controllers;

use Exception;
use Psr\Log\LoggerInterface;

/**
 * Base Controller - Provides shared methods for all controllers.
 */
class Controller
{
    protected LoggerInterface $logger;

    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
        // Ensure session has started
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }
    }

    /**
     * ✅ Standard JSON Response
     */
    protected function jsonResponse(array $data, int $statusCode = 200): void
    {
        header('Content-Type: application/json');
        http_response_code($statusCode);
        echo json_encode($data);
        exit;
    }

    /**
     * ✅ Handle Exceptions & Log Errors
     */
    protected function handleException(Exception $e, string $context = 'General Error'): void
    {
        $this->logger->error("{$context}: " . $e->getMessage());
        $this->jsonResponse(['status' => 'error', 'message' => 'An error occurred.'], 500);
    }

    /**
     * ✅ Authorization Check (Example: Admin Access)
     */
    protected function checkAuth(): void
    {
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }
        if (!isset($_SESSION['user_id']) || ($_SESSION['role'] ?? null) !== 'admin') {
            $this->jsonResponse(['status' => 'error', 'message' => 'Unauthorized'], 403);
        }
    }

    /**
     * ✅ Input Validation Helper
     */
    protected function validateRequest(array $data, array $rules): array
    {
        $errors = [];

        foreach ($rules as $field => $rule) {
            $value = $data[$field] ?? null;

            if (strpos($rule, 'required') !== false && empty($value)) {
                $errors[$field] = "{$field} is required.";
            }

            if (strpos($rule, 'integer') !== false && !filter_var($value, FILTER_VALIDATE_INT)) {
                $errors[$field] = "{$field} must be an integer.";
            }

            if (strpos($rule, 'email') !== false && !filter_var($value, FILTER_VALIDATE_EMAIL)) {
                $errors[$field] = "{$field} must be a valid email.";
            }
        }

        if (!empty($errors)) {
            $this->jsonResponse(['status' => 'error', 'message' => 'Validation failed', 'errors' => $errors], 422);
        }

        return $data;
    }
}
=== App/Controllers/DocumentController.php ===
<?php

namespace App\Controllers;

use App\Services\DocumentService;
use App\Services\EncryptionService;
use App\Services\FileStorage;
use App\Services\Validator;
use App\Services\AuditService;
use Psr\Log\LoggerInterface;
use App\Models\DocumentTemplate;
use App\Models\AuditLog;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

class DocumentController extends Controller
{
    private DocumentService $documentService;
    private Validator $validator;
    private AuditService $auditService;
    private LoggerInterface $logger;

    public function __construct(
        DocumentService $documentService,
        Validator $validator,
        AuditService $auditService,
        LoggerInterface $documentLogger
    ) {
        $this->documentService = $documentService;
        $this->validator = $validator;
        $this->auditService = $auditService;
        $this->logger = $documentLogger;
    }
    
    /**
     * Upload a document template.
     */
    public function uploadTemplate(array $data): array
    {
        $rules = [
            'name' => 'required|string|max:255',
            'file' => 'required|file|mimes:pdf,docx|max:10240', // Max 10MB
        ];

        if (!$this->validator->validate($data, $rules)) {
            return $this->jsonResponse(['status' => 'error', 'message' => 'Validation failed', 'errors' => $this->validator->errors()]);
        }

        try {
            // Store file using FileStorage service
            $filePath = FileStorage::store($data['file']);
            // Create a new template using Eloquent ORM
            $template = DocumentTemplate::create([
                'name' => $data['name'],
                'file_path' => $filePath,
            ]);
            // Log document creation using AuditLog model
            AuditLog::create([
                'action' => 'template_uploaded',
                'message' => 'Template uploaded successfully.',
                'ip_address' => $_SERVER['REMOTE_ADDR'] ?? null,
            ]);
            return $this->jsonResponse(['status' => 'success', 'message' => 'Template uploaded successfully', 'template_id' => $template->id]);
        } catch (\Exception $e) {
            $this->logger->error('Failed to upload template: ' . $e->getMessage());
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to upload template']);
        }
    }

    /**
     * Generate a contract for a booking.
     */
    public function generateContract(int $bookingId, int $userId): array
    {
        try {
            // Use a secure contract generation method ensuring encryption is applied
            $contractPath = $this->documentService->generateContractSecure($bookingId, $userId);
            // Log the contract generation using AuditLog model
            AuditLog::create([
                'action' => 'contract_generated',
                'message' => 'Contract generated successfully.',
                'ip_address' => $_SERVER['REMOTE_ADDR'] ?? null,
            ]);
            return $this->jsonResponse(['status' => 'success', 'message' => 'Contract generated successfully', 'contract_path' => $contractPath]);
        } catch (\Exception $e) {
            $this->logger->error('Failed to generate contract: ' . $e->getMessage());
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to generate contract']);
        }
    }

    /**
     * Upload and manage the Terms & Conditions document.
     */
    public function uploadTerms(array $data): array
    {
        $rules = [
            'file' => 'required|file|mimes:pdf|max:5120', // Max 5MB
        ];

        if (!$this->validator->validate($data, $rules)) {
            return ['status' => 'error', 'message' => 'Validation failed', 'errors' => $this->validator->errors()];
        }

        try {
            $path = $this->documentService->uploadTerms($data['file']);
            $this->auditService->log(
                'terms_uploaded',
                'Terms and Conditions document uploaded.',
                null,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            return $this->jsonResponse(['status' => 'success', 'message' => 'T&C document uploaded successfully']);
        } catch (\Exception $e) {
            $this->logger->error('Failed to upload T&C document: ' . $e->getMessage());
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to upload T&C document']);
        }
    }

    /**
     * Generate an invoice for a booking.
     */
    public function generateInvoice(int $bookingId): array
    {
        try {
            $invoicePath = $this->documentService->generateInvoice($bookingId);
            $this->auditService->log(
                'invoice_generated',
                'Invoice generated successfully.',
                null,
                $bookingId,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            return ['status' => 'success', 'message' => 'Invoice generated successfully', 'invoice_path' => $invoicePath];
        } catch (\Exception $e) {
            $this->logger->error('Failed to generate invoice: ' . $e->getMessage());
            return ['status' => 'error', 'message' => 'Failed to generate invoice'];
        }
    }

    /**
     * Delete a document (template or user-specific).
     */
    public function deleteDocument(int $documentId): array
    {
        try {
            $this->documentService->deleteDocument($documentId);
            $this->auditService->log(
                'document_deleted',
                'Document deleted successfully.',
                null,
                null,
                $_SERVER['REMOTE_ADDR'] ?? null
            );

            return ['status' => 'success', 'message' => 'Document deleted successfully'];
        } catch (\Exception $e) {
            $this->logger->error('Failed to delete document: ' . $e->getMessage());
            return ['status' => 'error', 'message' => 'Failed to delete document'];
        }
    }
}
=== App/Controllers/ReportController.php ===
<?php

namespace App\Controllers;

use App\Models\Booking;
use App\Models\Payment;
use App\Models\User;
use Maatwebsite\Excel\Facades\Excel;
use PDF;
use Psr\Log\LoggerInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

class ReportController extends Controller
{
    private ReportService $reportService;
    private NotificationService $notificationService;
    private LoggerInterface $logger;

    public function __construct(
        ReportService $reportService,
        /* Removed Validator */ $validator,
        NotificationService $notificationService,
        LoggerInterface $reportLogger
    ) {
        $this->reportService = $reportService;
        $this->notificationService = $notificationService;
        $this->logger = $reportLogger;
    }

    /**
     * Admin Report Dashboard View
     */
    public function index()
    {
        try {
            $data = ['view' => 'admin/reports'];
            http_response_code(200);
            echo json_encode(['status' => 'success', 'message' => 'Report dashboard loaded', 'data' => $data]);
        } catch (\Exception $e) {
            $this->logger->error(date('Y-m-d H:i:s') . ' ' . $e->getMessage());
            $this->logger->error("Error: Failed to load admin report dashboard, error: " . $e->getMessage());
            http_response_code(500);
            echo json_encode(['status' => 'error', 'message' => 'Failed to load report dashboard', 'data' => []]);
        }
        exit;
    }

    /**
     * Generate Report for Admin using Eloquent ORM.
     */
    public function generateReport()
    {
        // Replace Request validation with native PHP validation
        $validated = $_POST; // Assumes JSON-decoded input or form data

        $start      = $validated['date_range']['start'] ?? null;
        $end        = $validated['date_range']['end'] ?? null;
        $format     = $validated['format'] ?? null;
        $reportType = $validated['report_type'] ?? null;

        if (!$start || !$end || !$format || !$reportType) {
            http_response_code(400);
            echo json_encode(['status' => 'error', 'message' => 'Missing required parameters']);
            exit;
        }

        switch ($reportType) {
            case 'bookings':
                $data = Booking::with(['user', 'vehicle'])
                    ->whereBetween('created_at', [$start, $end])
                    ->get()
                    ->toArray();
                break;
            case 'payments':
                $data = Payment::whereBetween('created_at', [$start, $end])
                    ->get()
                    ->toArray();
                break;
            case 'users':
                $data = User::whereBetween('created_at', [$start, $end])
                    ->get()
                    ->toArray();
                break;
            default:
                http_response_code(400);
                echo json_encode(['status' => 'error', 'message' => 'Invalid report type']);
                exit;
        }

        $filename = "{$reportType}_report_" . date('YmdHis');
        if ($format === 'csv') {
            // Assuming Excel::download now returns file content in native PHP
            return Excel::download(new \App\Exports\ReportExport($data), $filename . ".csv");
        } elseif ($format === 'pdf') {
            $pdf = PDF::loadView('reports.template', ['data' => $data]);
            return $pdf->download($filename . ".pdf");
        } else {
            http_response_code(400);
            echo json_encode(['status' => 'error', 'message' => 'Unsupported format']);
            exit;
        }
    }

    /**
     * User Report Dashboard View
     */
    public function userReports()
    {
        try {
            $data = ['view' => 'user/reports'];
            http_response_code(200);
            echo json_encode(['status' => 'success', 'message' => 'User report dashboard loaded', 'data' => $data]);
        } catch (\Exception $e) {
            $this->logger->error(date('Y-m-d H:i:s') . ' ' . $e->getMessage());
            $this->logger->error("Error: Failed to load user report dashboard, error: " . $e->getMessage());
            http_response_code(500);
            echo json_encode(['status' => 'error', 'message' => 'Failed to load report dashboard', 'data' => []]);
        }
        exit;
    }

    /**
     * Generate Report for a User using Eloquent ORM.
     */
    public function generateUserReport()
    {
        $validated = $_POST;
        $userId     = $validated['user_id'] ?? null;
        $start      = $validated['date_range']['start'] ?? null;
        $end        = $validated['date_range']['end'] ?? null;
        $format     = $validated['format'] ?? null;
        $reportType = $validated['report_type'] ?? null;

        if (!$userId || !$start || !$end || !$format || !$reportType) {
            http_response_code(400);
            echo json_encode(['status' => 'error', 'message' => 'Missing required parameters']);
            exit;
        }

        switch ($reportType) {
            case 'bookings':
                $data = Booking::with(['user', 'vehicle'])
                    ->where('user_reference', $userId)
                    ->whereBetween('created_at', [$start, $end])
                    ->get()
                    ->toArray();
                break;
            case 'payments':
                $data = Payment::where('user_id', $userId)
                    ->whereBetween('created_at', [$start, $end])
                    ->get()
                    ->toArray();
                break;
            default:
                http_response_code(400);
                echo json_encode(['status' => 'error', 'message' => 'Invalid report type']);
                exit;
        }

        $filename = "user_{$userId}_{$reportType}_report_" . date('YmdHis');
        if ($format === 'csv') {
            return Excel::download(new \App\Exports\ReportExport($data), $filename . ".csv");
        } elseif ($format === 'pdf') {
            $pdf = PDF::loadView('reports.template', ['data' => $data]);
            return $pdf->download($filename . ".pdf");
        } else {
            http_response_code(400);
            echo json_encode(['status' => 'error', 'message' => 'Unsupported format']);
            exit;
        }
    }

    /**
     * Download a Report
     */
    public function downloadReport(string $filePath): void
    {
        try {
            if (!file_exists($filePath)) {
                http_response_code(404);
                echo json_encode(['status' => 'error', 'message' => 'Report not found', 'data' => []]);
                return;
            }

            header('Content-Description: File Transfer');
            header('Content-Type: application/octet-stream');
            header('Content-Disposition: attachment; filename=' . basename($filePath));
            header('Expires: 0');
            header('Cache-Control: must-revalidate');
            header('Pragma: public');
            header('Content-Length: ' . filesize($filePath));
            readfile($filePath);
            exit;
        } catch (\Exception $e) {
            $this->logger->error(date('Y-m-d H:i:s') . ' ' . $e->getMessage());
            $this->logger->error("Error: Failed to download report, error: " . $e->getMessage());
            http_response_code(500);
            echo json_encode(['status' => 'error', 'message' => 'Failed to download report', 'data' => []]);
        }
    }
}
=== App/Controllers/AuditController.php ===
<?php

namespace App\Controllers;

use App\Models\AuditLog;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Response;
use App\Services\AuditService;
/**
 * AuditController - Handles viewing and retrieving audit logs.
 */
class AuditController extends Controller
{
    /**
     * ✅ Render the audit log view for the admin.
     */
    public function index()
    {
        try {
            // Replace request->validate(...) with native PHP filters (assuming $_POST).
            $filters = $_POST; // custom validation can be performed as needed
            $logs = AuditLog::where($filters)->latest()->paginate(10);
            extract(compact('logs'));
            include BASE_PATH . '/public/views/admin/audit_logs.php';
        } catch (\Exception $e) {
            // Centralized error handling
            return $this->handleException($e);
        }
    }

    /**
     * ✅ API Endpoint: Fetch logs based on filters.
     */
    public function fetchLogs()
    {
        try {
            $filters = $_POST; // custom validation as needed
            $logs = AuditLog::where($filters)->latest()->paginate(10);
            header('Content-Type: application/json');
            http_response_code(200);
            echo json_encode(['status' => 'success', 'logs' => $logs]);
            exit;
        } catch (\Exception $e) {
            return $this->handleException($e);
        }
    }
}
=== App/Models/Booking.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasOne;

/**
 * Booking Model
 *
 * Represents a booking and handles database interactions.
 */
class Booking extends BaseModel
{
    use SoftDeletes;

    /**
     * Attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'user_id',
        'vehicle_id',
        'pickup_date',
        'dropoff_date',
        'status'
    ];

    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'user_id' => 'required|exists:users,id',
        'vehicle_id' => 'required|exists:vehicles,id',
        'pickup_date' => 'required|date',
        'dropoff_date' => 'required|date|after_or_equal:pickup_date',
        'status' => 'required|string|in:pending,confirmed,cancelled,completed',
    ];

    /**
     * Relationships
     */

    /**
     * Get the user who made the booking.
     *
     * @return BelongsTo
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Get the vehicle associated with the booking.
     *
     * @return BelongsTo
     */
    public function vehicle(): BelongsTo
    {
        return $this->belongsTo(Vehicle::class);
    }

    /**
     * Get the payment associated with the booking.
     *
     * @return HasOne
     */
    public function payment(): HasOne
    {
        return $this->hasOne(Payment::class);
    }

    /**
     * Scopes
     */

    /**
     * Scope a query to filter active bookings.
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopeActive($query)
    {
        return $query->where('status', 'confirmed');
    }

    /**
     * Scope a query to filter bookings by user.
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     * @param int $userId
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopeByUser($query, int $userId)
    {
        return $query->where('user_id', $userId);
    }
}
=== App/Models/TransactionLog.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use App\Services\EncryptionService;

/**
 * TransactionLog Model
 *
 * Represents a financial transaction and handles interactions with the `transaction_logs` table.
 */
class TransactionLog extends BaseModel
{
    // Define relationships
    public function user()
    {
        return $this->belongsTo(User::class);
    }

    // Define query scopes
    public function scopeRecent($query)
    {
        return $query->orderBy('created_at', 'desc');
    }

    public function scopeByUser($query, $userId)
    {
        return $query->where('user_id', $userId);
    }

    // Prevent modification of log entries after creation
    public static function boot()
    {
        parent::boot();

        static::updating(function ($model) {
            return false;
        });
    }

    private PDO $db;

    public function __construct(PDO $db)
    {
        $this->db = $db;
    }

    /**
     * Get all transactions for a user.
     */
    public function getByUserId(int $userId): array
    {
        $stmt = $this->db->prepare("SELECT * FROM transaction_logs WHERE user_id = :user_id ORDER BY created_at DESC");
        $stmt->execute([':user_id' => $userId]);
        $transactions = $stmt->fetchAll(PDO::FETCH_ASSOC) ?: [];

        // Decrypt transaction details
        foreach ($transactions as &$transaction) {
            $transaction['amount'] = EncryptionService::decrypt($transaction['amount']);
        }

        return $transactions;
    }

    /**
     * Get transaction by ID.
     */
    public function getById(int $id): ?array
    {
        $stmt = $this->db->prepare("SELECT * FROM transaction_logs WHERE id = :id");
        $stmt->execute([':id' => $id]);
        $transaction = $stmt->fetch(PDO::FETCH_ASSOC) ?: null;

        if ($transaction) {
            // Decrypt transaction details
            $transaction['amount'] = EncryptionService::decrypt($transaction['amount']);
        }

        return $transaction;
    }

    /**
     * Log a new transaction.
     */
    public function create(array $data): int
    {
        // Encrypt transaction details
        $data['amount'] = EncryptionService::encrypt($data['amount']);

        $stmt = $this->db->prepare("
            INSERT INTO transaction_logs (user_id, booking_id, amount, type, status, created_at)
            VALUES (:user_id, :booking_id, :amount, :type, :status, NOW())
        ");
        $stmt->execute([
            ':user_id' => $data['user_id'],
            ':booking_id' => $data['booking_id'],
            ':amount' => $data['amount'],
            ':type' => $data['type'],
            ':status' => $data['status'] ?? 'pending',
        ]);
        return $this->db->lastInsertId();
    }

    /**
     * Update transaction status.
     */
    public function updateStatus(int $id, string $status): bool
    {
        $stmt = $this->db->prepare("UPDATE transaction_logs SET status = :status WHERE id = :id");
        return $stmt->execute([':status' => $status, ':id' => $id]);
    }
}
=== App/Models/Payment.php ===
<?php

namespace App\Models;

use App\Models\BaseModel;
use App\Models\User;
use App\Models\Booking;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo; // Ensure this is included

/**
 * Payment Model
 *
 * Represents a payment transaction in the system.
 *
 * @property int $id Primary key
 * @property int $user_id ID of the user who made the payment
 * @property int $booking_id ID of the associated booking
 * @property float $amount Transaction amount
 * @property string $method Payment method (credit_card, PayPal, etc.)
 * @property string $status Status of the payment (pending, completed, failed)
 * @property string|null $transaction_id Unique external transaction identifier
 * @property \DateTime $created_at Timestamp when the record was created
 * @property \DateTime $updated_at Timestamp when the record was last updated
 * @property \DateTime|null $deleted_at Soft delete timestamp
 */
class Payment extends BaseModel
{
    use SoftDeletes;

    /**
     * Attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'user_id',
        'booking_id',
        'amount',
        'method',
        'status',
        'transaction_id'
    ];

    /**
     * Attributes that should be hidden for arrays.
     *
     * @var array
     */
    protected $hidden = [
        'deleted_at'
    ];

    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'user_id' => 'required|exists:users,id',
        'booking_id' => 'required|exists:bookings,id',
        'amount' => 'required|numeric|min:0',
        'method' => 'required|string|in:credit_card,paypal,bank_transfer',
        'status' => 'required|string|in:pending,completed,failed',
        'transaction_id' => 'nullable|string|max:255',
    ];

    /**
     * Relationships
     */

    /**
     * Get the user who made the payment.
     *
     * @return BelongsTo
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Get the booking associated with the payment.
     *
     * @return BelongsTo
     */
    public function booking(): BelongsTo
    {
        return $this->belongsTo(Booking::class);
    }

    /**
     * Scopes
     */

    /**
     * Scope a query to filter payments by user.
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     * @param int $userId
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopeByUser($query, int $userId)
    {
        return $query->where('user_id', $userId);
    }

    /**
     * Scope a query to fetch completed payments.
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopeCompleted($query)
    {
        return $query->where('status', 'completed');
    }

    /**
     * Scope a query to filter payments by status.
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     * @param string $status
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopeByStatus($query, string $status)
    {
        return $query->where('status', $status);
    }

    /**
     * Scope a query to filter payments by a date range.
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     * @param string $startDate
     * @param string $endDate
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopeByDateRange($query, string $startDate, string $endDate)
    {
        return $query->whereBetween('created_at', [$startDate, $endDate]);
    }
}
=== App/Models/Admin.php ===
<?php

namespace App\Models;

use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Notifications\Notifiable;
use Illuminate\Support\Facades\Hash;

/**
 * Admin Model - Manages system administrators.
 * 
 * Features:
 * - Extends Laravel's Authenticatable for authentication.
 * - Implements SoftDeletes to allow admin recovery.
 * - Provides relationships for managing users and audit logs.
 */
class Admin extends Authenticatable
{
    use HasFactory, Notifiable, SoftDeletes;

    /**
     * ✅ Table name.
     */
    protected $table = 'admins';

    /**
     * ✅ Mass assignable attributes.
     */
    protected $fillable = [
        'name',
        'email',
        'password',
        'role'
    ];

    /**
     * ✅ Hidden attributes for security.
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * ✅ Attribute casting.
     */
    protected $casts = [
        'email_verified_at' => 'datetime',
    ];

    /**
     * ✅ Mutator: Automatically hash password before saving.
     */
    public function setPasswordAttribute($value)
    {
        $this->attributes['password'] = Hash::make($value);
    }

    /**
     * ✅ Relationship: Admin can have multiple audit logs.
     */
    public function logs()
    {
        return $this->hasMany(AuditLog::class, 'admin_id');
    }

    /**
     * ✅ Relationship: Admin manages multiple users.
     */
    public function managedUsers()
    {
        return $this->hasMany(User::class, 'managed_by');
    }
}
=== App/Models/Notification.php ===
<?php

namespace App\Models;

use DateTime;
use PDO;
use PDOException;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

/**
 * Notification Model
 *
 * Represents a notification in the system.
 *
 * @property int $id
 * @property int $user_id
 * @property string $type
 * @property string $message
 * @property DateTime $sent_at
 * @property bool $is_read
 */
class Notification extends BaseModel
{
    use SoftDeletes;

    private int $id;
    private int $user_id;
    private string $type;
    private string $message;
    private DateTime $sent_at;
    private bool $is_read;

    /**
     * Attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'user_id',
        'type',
        'message',
        'sent_at',
        'is_read'
    ];

    /**
     * Validation rules for the model.
     *
     * @var array
     */
    public static $rules = [
        'user_id' => 'required|exists:users,id',
        'type' => 'required|string|max:255',
        'message' => 'required|string',
        'sent_at' => 'required|date',
        'is_read' => 'boolean',
    ];

    public function __construct(
        int $user_id,
        string $type,
        string $message,
        DateTime $sent_at = null,
        bool $is_read = false
    ) {
        $this->user_id = $user_id;
        $this->type = $type;
        $this->message = $message;
        $this->sent_at = $sent_at ?? new DateTime();
        $this->is_read = $is_read;
    }

    /**
     * Save the notification to the database.
     */
    public function save(PDO $db): bool
    {
        try {
            $stmt = $db->prepare("
                INSERT INTO notifications (user_id, type, message, sent_at, is_read)
                VALUES (:user_id, :type, :message, :sent_at, :is_read)
            ");
            $success = $stmt->execute([
                ':user_id' => $this->user_id,
                ':type' => $this->type,
                ':message' => $this->message,
                ':sent_at' => $this->sent_at->format('Y-m-d H:i:s'),
                ':is_read' => (int)$this->is_read,
            ]);

            if ($success) {
                $this->id = (int)$db->lastInsertId();
            }

            return $success;
        } catch (PDOException $e) {
            return false;
        }
    }

    /**
     * Mark the notification as read.
     */
    public function markAsRead(PDO $db): bool
    {
        try {
            $stmt = $db->prepare("
                UPDATE notifications
                SET is_read = 1
                WHERE id = :id
            ");
            return $stmt->execute([':id' => $this->id]);
        } catch (PDOException $e) {
            return false;
        }
    }

    /**
     * Delete the notification from the database.
     */
    public function delete(PDO $db): bool
    {
        try {
            $stmt = $db->prepare("
                DELETE FROM notifications
                WHERE id = :id
            ");
            return $stmt->execute([':id' => $this->id]);
        } catch (PDOException $e) {
            return false;
        }
    }

    /**
     * Fetch all notifications for a specific user.
     */
    public static function getByUserId(PDO $db, int $user_id): array
    {
        try {
            $stmt = $db->prepare("
                SELECT * FROM notifications
                WHERE user_id = :user_id
                ORDER BY sent_at DESC
            ");
            $stmt->execute([':user_id' => $user_id]);
            $results = $stmt->fetchAll(PDO::FETCH_ASSOC);

            return array_map(function ($data) {
                return new self(
                    $data['user_id'],
                    $data['type'],
                    $data['message'],
                    new DateTime($data['sent_at']),
                    (bool)$data['is_read']
                );
            }, $results);
        } catch (PDOException $e) {
            return [];
        }
    }

    /**
     * Fetch a single notification by its ID.
     */
    public static function getById(PDO $db, int $id): ?self
    {
        try {
            $stmt = $db->prepare("
                SELECT * FROM notifications
                WHERE id = :id
            ");
            $stmt->execute([':id' => $id]);
            $data = $stmt->fetch(PDO::FETCH_ASSOC);

            if ($data) {
                return new self(
                    $data['user_id'],
                    $data['type'],
                    $data['message'],
                    new DateTime($data['sent_at']),
                    (bool)$data['is_read']
                );
            }

            return null;
        } catch (PDOException $e) {
            return null;
        }
    }

    /**
     * Mark all notifications as read for a user.
     */
    public static function markAllAsRead(PDO $db, int $user_id): bool
    {
        try {
            $stmt = $db->prepare("
                UPDATE notifications
                SET is_read = 1
                WHERE user_id = :user_id
            ");
            return $stmt->execute([':user_id' => $user_id]);
        } catch (PDOException $e) {
            return false;
        }
    }

    /**
     * Relationships
     */

    /**
     * Get the user associated with the notification.
     *
     * @return BelongsTo
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Scopes
     */

    /**
     * Scope a query to filter unread notifications.
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopeUnread($query)
    {
        return $query->where('is_read', false);
    }
}
=== App/Models/PaymentMethod.php ===
<?php

namespace App\Models;

use PDO;
use App\Models\BaseModel;
use App\Models\User;

/**
 * PaymentMethod Model
 *
 * Represents a payment method and handles interactions with the `payment_methods` table.
 */
class PaymentMethod extends BaseModel
{
    protected $fillable = ['name', 'description', 'is_active', 'user_id', 'payment_type'];
    private PDO $db;

    public function __construct(PDO $db)
    {
        $this->db = $db;
    }

    /**
     * Get all available payment methods.
     */
    public function getAll(): array
    {
        $stmt = $this->db->query("SELECT * FROM payment_methods WHERE is_active = 1");
        return $stmt->fetchAll(PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Get payment method by ID.
     */
    public function getById(int $id): ?array
    {
        $stmt = $this->db->prepare("SELECT * FROM payment_methods WHERE id = :id");
        $stmt->execute([':id' => $id]);
        return $stmt->fetch(PDO::FETCH_ASSOC) ?: null;
    }

    /**
     * Add a new payment method.
     */
    public function create(array $data): int
    {
        $validPaymentTypes = ['credit_card', 'paypal', 'bank_transfer'];
        if (!in_array($data['payment_type'], $validPaymentTypes)) {
            throw new \InvalidArgumentException("Invalid payment type.");
        }

        $stmt = $this->db->prepare("
            INSERT INTO payment_methods (name, description, is_active, created_at, user_id, payment_type)
            VALUES (:name, :description, :is_active, NOW(), :user_id, :payment_type)
        ");
        $stmt->execute([
            ':name' => $data['name'],
            ':description' => $data['description'] ?? '',
            ':is_active' => $data['is_active'] ?? 1,
            ':user_id' => $data['user_id'],
            ':payment_type' => $data['payment_type'],
        ]);
        return $this->db->lastInsertId();
    }

    /**
     * Define relationship with User.
     */
    public function user()
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Scope to filter by user.
     */
    public function scopeByUser($query, $userId)
    {
        return $query->where('user_id', $userId);
    }
}
=== App/Models/Document.php ===
<?php

namespace DocumentManager\Models;

use PDO;
use Exception;

/**
 * Document Model
 *
 * Represents documents stored in the system and provides methods
 * for managing and querying them.
 */
class Document
{
    private PDO $db;

    public function __construct(PDO $db)
    {
        $this->db = $db;
    }

    /**
     * Create a new document record.
     *
     * @param string $name The name of the document.
     * @param string $filePath The file path of the stored document.
     * @param int|null $userId The ID of the user associated with the document (if applicable).
     * @param string|null $type The type of document (e.g., 'contract', 'terms').
     * @return int The ID of the newly created document.
     * @throws Exception If the document creation fails.
     */
    public function create(string $name, string $filePath, ?int $userId = null, ?string $type = null): int
    {
        $query = "
            INSERT INTO documents (name, file_path, user_id, type, created_at)
            VALUES (:name, :file_path, :user_id, :type, NOW())
        ";

        $stmt = $this->db->prepare($query);

        if (!$stmt->execute([
            ':name' => $name,
            ':file_path' => $filePath,
            ':user_id' => $userId,
            ':type' => $type,
        ])) {
            throw new Exception('Failed to create document.');
        }

        return (int)$this->db->lastInsertId();
    }

    /**
     * Retrieve a document by its ID.
     *
     * @param int $id The ID of the document.
     * @return array|null The document record or null if not found.
     */
    public function getById(int $id): ?array
    {
        $query = "SELECT * FROM documents WHERE id = :id";
        $stmt = $this->db->prepare($query);
        $stmt->execute([':id' => $id]);

        $document = $stmt->fetch(PDO::FETCH_ASSOC);
        return $document ?: null;
    }

    /**
     * Retrieve documents associated with a user.
     *
     * @param int $userId The ID of the user.
     * @return array A list of documents associated with the user.
     */
    public function getByUserId(int $userId): array
    {
        $query = "SELECT * FROM documents WHERE user_id = :user_id ORDER BY created_at DESC";
        $stmt = $this->db->prepare($query);
        $stmt->execute([':user_id' => $userId]);

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Retrieve documents by type.
     *
     * @param string $type The type of document (e.g., 'contract', 'terms').
     * @return array A list of documents matching the specified type.
     */
    public function getByType(string $type): array
    {
        $query = "SELECT * FROM documents WHERE type = :type ORDER BY created_at DESC";
        $stmt = $this->db->prepare($query);
        $stmt->execute([':type' => $type]);

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Delete a document by its ID.
     *
     * @param int $id The ID of the document to delete.
     * @return bool True on success, false otherwise.
     */
    public function deleteById(int $id): bool
    {
        $query = "DELETE FROM documents WHERE id = :id";
        $stmt = $this->db->prepare($query);

        return $stmt->execute([':id' => $id]);
    }
}
=== App/Models/Vehicle.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Vehicle extends BaseModel
{
    protected string $table = 'vehicles';

    protected array $fillable = [
        'registration_number',
        'type',
        'status',
        'make',
        'model',
        'year',
    ];

    public static array $rules = [
        'registration_number' => 'required|string|unique:vehicles,registration_number',
        'type' => 'required|string',
        'status' => 'required|in:available,unavailable,maintenance',
        'make' => 'required|string|max:255',
        'model' => 'required|string|max:255',
        'year' => 'required|integer|min:1886|max:' . date('Y'),
    ];

    /**
     * Relationships
     */

    // Get vehicle's bookings
    public function bookings()
    {
        return $this->hasMany(Booking::class, 'vehicle_id', 'id');
    }

    /**
     * Scopes
     */

    // Scope a query to only include available vehicles
    public function scopeAvailable($query)
    {
        return $query->where('status', 'available');
    }

    // Scope a query to only include vehicles of a specific type
    public function scopeByType($query, $type)
    {
        return $query->where('type', $type);
    }

    /**
     * Events
     */

    // Actions to take after vehicle creation
    protected static function boot()
    {
        parent::boot();

        static::creating(function ($vehicle) {
            // Ensure vehicle status is properly managed
            if (empty($vehicle->status)) {
                $vehicle->status = 'available';
            }
        });
    }
}
=== App/Models/DocumentTemplate.php ===
<?php

namespace DocumentManager\Models;

use PDO;
use Exception;

/**
 * DocumentTemplate Model
 *
 * Manages templates for documents such as contracts, invoices, and Terms & Conditions.
 */
class DocumentTemplate
{
    private PDO $db;

    public function __construct(PDO $db)
    {
        $this->db = $db;
    }

    /**
     * Create a new document template.
     *
     * @param string $name The name of the template.
     * @param string $filePath The file path of the template.
     * @return int The ID of the newly created template.
     * @throws Exception If the template creation fails.
     */
    public function create(string $name, string $filePath): int
    {
        $query = "
            INSERT INTO document_templates (name, file_path, created_at)
            VALUES (:name, :file_path, NOW())
        ";

        $stmt = $this->db->prepare($query);

        if (!$stmt->execute([
            ':name' => $name,
            ':file_path' => $filePath,
        ])) {
            throw new Exception('Failed to create document template.');
        }

        return (int)$this->db->lastInsertId();
    }

    /**
     * Retrieve a template by its ID.
     *
     * @param int $id The ID of the template.
     * @return array|null The template record or null if not found.
     */
    public function getById(int $id): ?array
    {
        $query = "SELECT * FROM document_templates WHERE id = :id";
        $stmt = $this->db->prepare($query);
        $stmt->execute([':id' => $id]);

        $template = $stmt->fetch(PDO::FETCH_ASSOC);
        return $template ?: null;
    }

    /**
     * Retrieve a template by its name.
     *
     * @param string $name The name of the template.
     * @return array|null The template record or null if not found.
     */
    public function getByName(string $name): ?array
    {
        $query = "SELECT * FROM document_templates WHERE name = :name";
        $stmt = $this->db->prepare($query);
        $stmt->execute([':name' => $name]);

        $template = $stmt->fetch(PDO::FETCH_ASSOC);
        return $template ?: null;
    }

    /**
     * Retrieve all templates.
     *
     * @return array A list of all document templates.
     */
    public function getAll(): array
    {
        $query = "SELECT * FROM document_templates ORDER BY created_at DESC";
        $stmt = $this->db->query($query);

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Delete a template by its ID.
     *
     * @param int $id The ID of the template to delete.
     * @return bool True on success, false otherwise.
     */
    public function deleteById(int $id): bool
    {
        $query = "DELETE FROM document_templates WHERE id = :id";
        $stmt = $this->db->prepare($query);

        return $stmt->execute([':id' => $id]);
    }
}
=== App/Models/User.php ===
<?php

namespace App\Models;

use App\Models\BaseModel; // updated base model
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Support\Facades\Hash;
use Ramsey\Uuid\Uuid;
use App\Models\Booking;
use App\Models\Notification;
use App\Models\Payment;
use App\Models\AuditTrail;
use App\Models\Log;
use App\Models\Contract;

/**
 * User Model
 * 
 * Represents a user in the system with their associated data and relationships.
 * 
 * @property string $id UUID of the user
 * @property string $name User's first name
 * @property string $surname User's last name
 * @property string $email User's email address
 * @property string $password_hash Hashed password
 * @property string $role User role (user, admin, super_admin)
 * @property string $phone Phone number
 * @property string $address Physical address
 * @property \DateTime $created_at
 * @property \DateTime $updated_at
 * @property \DateTime $deleted_at
 */
class User extends BaseModel
{
    use SoftDeletes;

    protected $table = 'users';
    protected $primaryKey = 'id';
    public $incrementing = false;
    protected $keyType = 'string';

    protected $fillable = [
        'name',
        'surname',
        'email',
        'password_hash',
        'role',
        'phone',
        'address',
    ];

    protected $hidden = [
        'password_hash',
        'remember_token',
        'deleted_at',
    ];

    protected $dates = [
        'created_at',
        'updated_at',
        'deleted_at',
        'email_verified_at',
    ];

    public static array $rules = [
        'name' => 'required|string|max:255',
        'surname' => 'required|string|max:255',
        'email' => 'required|email|unique:users,email',
        'password' => 'required|min:8|regex:/^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/',
        'role' => 'required|in:user,admin,super_admin',
        'phone' => 'nullable|string|max:20',
        'address' => 'nullable|string|max:255',
    ];

    /**
     * Relationships
     */

    public function bookings()
    {
        return $this->hasMany(Booking::class, 'user_id', 'id');
    }

    public function payments()
    {
        return $this->hasMany(Payment::class, 'user_id', 'id');
    }

    public function notifications()
    {
        return $this->hasMany(Notification::class, 'user_id', 'id');
    }

    public function logs()
    {
        return $this->hasMany(Log::class, 'user_reference', 'id');
    }

    public function auditTrails()
    {
        return $this->hasMany(AuditTrail::class, 'user_reference', 'id');
    }

    public function contracts()
    {
        return $this->hasMany(Contract::class, 'user_reference', 'id');
    }

    /**
     * Accessors
     */
    public function getFullNameAttribute(): string
    {
        return "{$this->name} {$this->surname}";
    }

    /**
     * Mutators
     */
    public function setPasswordAttribute(string $value): void
    {
        $this->attributes['password_hash'] = Hash::make($value);
    }

    /**
     * Helpers
     */
    public function isAdmin(): bool
    {
        return in_array($this->role, ['admin', 'super_admin']);
    }

    public function isSuperAdmin(): bool
    {
        return $this->role === 'super_admin';
    }

    public function hasPermission(string $permission): bool
    {
        $rolePermissions = [
            'user' => ['read_own'],
            'admin' => ['read_own', 'read_all', 'write_all'],
            'super_admin' => ['read_own', 'read_all', 'write_all', 'delete_all'],
        ];

        return in_array($permission, $rolePermissions[$this->role] ?? []);
    }

    /**
     * Scopes
     */
    public function scopeActive($query)
    {
        return $query->whereNull('deleted_at');
    }

    public function scopeWithRole($query, string $role)
    {
        return $query->where('role', $role);
    }

    /**
     * Events
     */
    protected static function boot()
    {
        parent::boot();

        static::creating(function ($user) {
            if (empty($user->id)) {
                $user->id = (string) Uuid::uuid4();
            }
        });

        static::updating(function ($user) {
            if ($user->isDirty('email')) {
                error_log("[SECURITY] User {$user->id} updated email to {$user->email}");
            }
        });

        static::deleting(function ($user) {
            error_log("[SECURITY] User {$user->id} was deleted.");
        });
    }
}
=== App/Models/BaseModel.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Support\Str;


class BaseModel extends Model
{
    use SoftDeletes;

    /**
     * The "booting" method of the model.
     *
     * @return void
     */
    protected static function boot()
    {
        parent::boot();

        // Automatically generate UUID for primary key
        static::creating(function ($model) {
            if (empty($model->{$model->getKeyName()})) {
                $model->{$model->getKeyName()} = (string) Str::uuid();
            }
        });

        // Apply global scope for soft deletes
        static::addGlobalScope('softDeletes', function (Builder $builder) {
            $builder->whereNull('deleted_at');
        });

        // Apply global scope for default ordering
        static::addGlobalScope('order', function (Builder $builder) {
            $builder->orderBy('created_at', 'desc');
        });
    }

    /**
     * Indicates if the IDs are auto-incrementing.
     *
     * @var bool
     */
    public $incrementing = false;

    /**
     * The data type of the primary key.
     *
     * @var string
     */
    protected $keyType = 'string';

    /**
     * Attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [];

    /**
     * Log changes made to the model.
     *
     * @return void
     */
    protected static function bootLogging()
    {
        static::updated(function ($model) {
            // Log changes
        });
    }
}
=== App/Models/Report.php ===
<?php

namespace App\Models;

use App\Models\BaseModel;
use App\Models\Admin;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

/**
 * Report Model
 *
 * Represents an admin report in the system.
 */
class Report extends BaseModel
{
    use SoftDeletes;

    /**
     * Attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'admin_id',
        'title',
        'content',
        'status',
        'created_at',
        'updated_at'
    ];

    /**
     * Relationships
     */

    /**
     * Get the admin who created the report.
     *
     * @return BelongsTo
     */
    public function admin(): BelongsTo
    {
        return $this->belongsTo(Admin::class);
    }

    /**
     * Scopes
     */

    /**
     * Scope a query to filter reports by a date range.
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     * @param string $start
     * @param string $end
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopeByDateRange($query, string $start, string $end)
    {
        return $query->whereBetween('created_at', [$start, $end]);
    }
}
=== App/Models/AuditTrail.php ===
<?php

namespace App\Models;

use PDO;

/**
 * AuditTrail Model
 *
 * Represents the audit trails stored in the database and provides methods
 * for accessing and filtering the logs.
 */
class AuditTrail
{
    private PDO $db;

    public function __construct(PDO $db)
    {
        $this->db = $db;
    }

    /**
     * Create a new audit trail record.
     *
     * @param string $action The action performed (e.g., 'user_registered').
     * @param string $details Additional details about the action.
     * @param int|null $userId The ID of the user performing the action.
     * @param int|null $bookingId The ID of the related booking (if applicable).
     * @param string|null $ipAddress The IP address of the user.
     * @return bool True on success, false otherwise.
     */
    public function create(
        string $action,
        string $details,
        ?int $userId = null,
        ?int $bookingId = null,
        ?string $ipAddress = null
    ): bool {
        $query = "
            INSERT INTO audit_trails (action, details, user_id, booking_id, ip_address, created_at)
            VALUES (:action, :details, :user_id, :booking_id, :ip_address, NOW())
        ";

        $stmt = $this->db->prepare($query);

        return $stmt->execute([
            ':action' => $action,
            ':details' => $details,
            ':user_id' => $userId,
            ':booking_id' => $bookingId,
            ':ip_address' => $ipAddress,
        ]);
    }

    /**
     * Retrieve audit trail records based on filters.
     *
     * @param array $filters An associative array of filters:
     *                       - 'user_id' (int): Filter by user ID.
     *                       - 'booking_id' (int): Filter by booking ID.
     *                       - 'action' (string): Filter by action type.
     *                       - 'start_date' (string): Filter by start date (YYYY-MM-DD).
     *                       - 'end_date' (string): Filter by end date (YYYY-MM-DD).
     * @return array An array of matching audit trail records.
     */
    public function getLogs(array $filters = []): array
    {
        $query = "SELECT * FROM audit_trails WHERE 1=1";
        $params = [];

        if (!empty($filters['user_id'])) {
            $query .= " AND user_id = :user_id";
            $params[':user_id'] = $filters['user_id'];
        }

        if (!empty($filters['booking_id'])) {
            $query .= " AND booking_id = :booking_id";
            $params[':booking_id'] = $filters['booking_id'];
        }

        if (!empty($filters['action'])) {
            $query .= " AND action = :action";
            $params[':action'] = $filters['action'];
        }

        if (!empty($filters['start_date'])) {
            $query .= " AND created_at >= :start_date";
            $params[':start_date'] = $filters['start_date'];
        }

        if (!empty($filters['end_date'])) {
            $query .= " AND created_at <= :end_date";
            $params[':end_date'] = $filters['end_date'];
        }

        $query .= " ORDER BY created_at DESC";

        $stmt = $this->db->prepare($query);
        $stmt->execute($params);

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Delete an audit trail record by ID.
     *
     * @param int $id The ID of the audit trail record to delete.
     * @return bool True on success, false otherwise.
     */
    public function deleteById(int $id): bool
    {
        $query = "DELETE FROM audit_trails WHERE id = :id";
        $stmt = $this->db->prepare($query);

        return $stmt->execute([':id' => $id]);
    }
}
=== App/Models/RefundLog.php ===
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

/**
 * RefundLog Model
 *
 * Represents a refund and handles interactions with the `refund_logs` table.
 */
class RefundLog extends Model  // Directly extend Eloquent's Model for testing
{
    use SoftDeletes;

    protected $fillable = ['booking_id', 'amount', 'reason', 'status', 'user_id', 'payment_id'];

    /**
     * Validation rules for the model.
     */
    public static $rules = [
        'booking_id' => 'required|exists:bookings,id',
        'amount' => 'required|numeric|min:0',
        'reason' => 'nullable|string',
        'status' => 'required|string|in:pending,approved,denied',
        'user_id' => 'required|exists:users,id',
        'payment_id' => 'required|exists:payments,id',
    ];

    /**
     * Relationship with User.
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Relationship with Payment.
     */
    public function payment(): BelongsTo
    {
        return $this->belongsTo(Payment::class);
    }
}=== App/Models/Signature.php ===
namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use App\Services\EncryptionService;

class Signature extends BaseModel
{
    // Define relationships
    public function user()
    {
        return $this->belongsTo(User::class);
    }

    // Ensure secure storage handling using encryption
    public function setSignatureAttribute($value)
    {
        $this->attributes['signature'] = EncryptionService::encrypt($value);
    }

    public function getSignatureAttribute($value)
    {
        return EncryptionService::decrypt($value);
    }

    // Implement validation rules to only allow specific file types
    public static function rules()
    {
        return [
            'signature' => 'required|mimes:png,jpg,svg|max:2048',
        ];
    }
}
=== App/Models/PasswordReset.php ===
<?php

namespace App\Models;

use App\Models\BaseModel; // updated base model

class PasswordReset extends BaseModel
{
    protected $table = 'password_resets';
    
    protected $fillable = ['email', 'token', 'expires_at'];
    
    public $timestamps = true;
}
=== App/Queues/DocumentQueue.php ===
<?php

namespace App\Queues;

use DocumentManager\Services\FileStorage;
use Psr\Log\LoggerInterface;

class DocumentQueue
{
    private FileStorage $fileStorage;
    private string $queueFile;
    private LoggerInterface $logger;
    private const MAX_RETRY_ATTEMPTS = 3;

    public function __construct(LoggerInterface $logger, FileStorage $fileStorage, string $queueFile)
    {
        $this->logger = $logger;
        $this->fileStorage = $fileStorage;
        $this->queueFile = $queueFile;
    }

    public function push(array $document): void
    {
        $queue = $this->getQueue();
        $document['attempts'] = 0;
        $queue[] = $document;
        $this->saveQueue($queue);
        $this->logger->info('Document added to queue', $document);
    }

    public function process(): void
    {
        $queue = $this->getQueue();
        foreach ($queue as $index => $document) {
            try {
                $success = $this->fileStorage->storeFile($document['file_path'], $document['destination']);

                if ($success) {
                    unset($queue[$index]);
                    $this->logger->info('Document processed successfully', $document);
                } else {
                    $queue[$index]['attempts']++;
                    $this->logger->warning('Document processing failed, retrying...', [
                        'document' => $document,
                        'attempts' => $queue[$index]['attempts'],
                    ]);
                }

                if ($queue[$index]['attempts'] >= self::MAX_RETRY_ATTEMPTS) {
                    $this->logger->error('Max retry attempts reached for document', $document);
                    unset($queue[$index]);
                }
            } catch (\Exception $e) {
                $this->logger->error('Error processing document', [
                    'document' => $document,
                    'error' => $e->getMessage(),
                ]);
            }
        }

        $this->saveQueue(array_values($queue));
    }

    private function getQueue(): array
    {
        if (!file_exists($this->queueFile)) {
            return [];
        }
        return json_decode(file_get_contents($this->queueFile), true) ?? [];
    }

    private function saveQueue(array $queue): void
    {
        file_put_contents($this->queueFile, json_encode($queue, JSON_PRETTY_PRINT));
    }
}
=== App/Queues/NotificationQueue.php ===
<?php

namespace App\Queues;

use App\Services\NotificationService;
use Psr\Log\LoggerInterface;

class NotificationQueue
{
    private string $queueFile;
    private NotificationService $notificationService;
    private LoggerInterface $logger;
    private const MAX_RETRY_ATTEMPTS = 3;

    public function __construct(
        LoggerInterface $logger,
        NotificationService $notificationService,
        string $queueFile
    ) {
        $this->logger = $logger;
        $this->notificationService = $notificationService;
        $this->queueFile = $queueFile;
    }

    /**
     * Push a notification onto the queue
     */
    public function push(array $notification): void
    {
        $queue = $this->getQueue();
        $notification['attempts'] = 0; // Initialize retry attempts
        $queue[] = $notification;
        $this->saveQueue($queue);
        $this->logger->info('Notification added to queue', $notification);
    }

    /**
     * Process the notification queue
     */
    public function process(): void
    {
        $queue = $this->getQueue();
        foreach ($queue as $index => $notification) {
            try {
                $success = $this->notificationService->sendNotification(
                    $notification['user_id'],
                    $notification['type'],
                    $notification['message'],
                    $notification['options']
                );

                if ($success) {
                    unset($queue[$index]); // Remove notification on success
                    $this->logger->info('Notification processed successfully', $notification);
                } else {
                    $queue[$index]['attempts']++;
                    $this->logger->warning('Notification failed, retrying...', [
                        'notification' => $notification,
                        'attempts' => $queue[$index]['attempts'],
                    ]);
                }

                // Remove notifications that exceed retry attempts
                if ($queue[$index]['attempts'] >= self::MAX_RETRY_ATTEMPTS) {
                    $this->logger->error('Max retry attempts reached for notification', $notification);
                    unset($queue[$index]);
                }
            } catch (\Exception $e) {
                $this->logger->error('Error processing notification', [
                    'notification' => $notification,
                    'error' => $e->getMessage(),
                ]);
            }
        }

        $this->saveQueue(array_values($queue)); // Reindex and save the queue
    }

    /**
     * Retrieve the current queue
     */
    private function getQueue(): array
    {
        if (!file_exists($this->queueFile)) {
            return [];
        }
        return json_decode(file_get_contents($this->queueFile), true) ?? [];
    }

    /**
     * Save the current queue to the file
     */
    private function saveQueue(array $queue): void
    {
        file_put_contents($this->queueFile, json_encode($queue, JSON_PRETTY_PRINT));
    }
}
=== App/Services/TemplateService.php ===
<?php

namespace App\Services;

use Exception;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

/**
 * Template Service
 *
 * Provides functionality for managing and rendering document templates.
 * Templates support placeholders for dynamic data injection.
 */
class TemplateService
{
    public const DEBUG_MODE = true;
    private string $templateDirectory;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    /**
     * Constructor
     *
     * @param LoggerInterface $logger The logger instance.
     * @param string $templateDirectory The directory where templates are stored.
     * @param ExceptionHandler $exceptionHandler The exception handler instance.
     * @throws Exception If the directory is invalid or not readable.
     */
    public function __construct(LoggerInterface $logger, string $templateDirectory, ExceptionHandler $exceptionHandler)
    {
        if (!is_dir($templateDirectory) || !is_readable($templateDirectory)) {
            throw new \InvalidArgumentException("Invalid template directory: $templateDirectory");
        }

        $this->logger = $logger;
        $this->templateDirectory = $templateDirectory;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * List all available templates in the directory.
     *
     * @return array List of template filenames with '.html' extension.
     */
    public function listTemplates(): array
    {
        $files = scandir($this->templateDirectory);
        return array_values(array_filter($files, fn($file) => pathinfo($file, PATHINFO_EXTENSION) === 'html'));
    }

    /**
     * Load the content of a template.
     *
     * @param string $templateName The name of the template file.
     * @return string The template content.
     * @throws Exception If the template cannot be found or read.
     */
    public function loadTemplate(string $templateName): string
    {
        try {
            $filePath = $this->getTemplatePath($templateName);

            if (!file_exists($filePath) || !is_readable($filePath)) {
                throw new Exception("Template not found or unreadable: $templateName");
            }

            $content = file_get_contents($filePath);
            if (self::DEBUG_MODE) {
                $this->logger->info("[system] Loaded template", ['template' => $templateName]);
            }
            return $content;
        } catch (\Exception $e) {
            $this->logger->error("[system] ❌ Error loading template: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Render a template by replacing placeholders with data.
     *
     * @param string $templateName The name of the template file.
     * @param array $data Key-value pairs to replace placeholders.
     * @return string Rendered template with placeholders replaced.
     * @throws Exception If the template cannot be loaded.
     */
    public function renderTemplate(string $templateName, array $data): string
    {
        $template = $this->loadTemplate($templateName);

        foreach ($data as $key => $value) {
            $placeholder = '{{' . $key . '}}';
            $template = str_replace($placeholder, htmlspecialchars((string)$value, ENT_QUOTES, 'UTF-8'), $template);
        }

        $this->logger->info("Rendered template", ['template' => $templateName]);
        return $template;
    }

    /**
     * Save a new or updated template file.
     *
     * @param string $templateName The name of the template file.
     * @param string $content The template content to save.
     * @return bool True if saved successfully, false otherwise.
     * @throws Exception If saving fails.
     */
    public function saveTemplate(string $templateName, string $content): bool
    {
        try {
            $filePath = $this->getTemplatePath($templateName);

            if (file_put_contents($filePath, $content) === false) {
                throw new Exception("Failed to save template: $templateName");
            }

            $this->logger->info("Saved template", ['template' => $templateName]);
            return true;
        } catch (\Exception $e) {
            $this->logger->error("Error saving template", ['template' => $templateName, 'error' => $e->getMessage()]);
            throw $e;
        }
    }

    /**
     * Delete a template file.
     *
     * @param string $templateName The name of the template file to delete.
     * @return bool True if deleted successfully, false otherwise.
     * @throws Exception If the template cannot be found or deleted.
     */
    public function deleteTemplate(string $templateName): bool
    {
        try {
            $filePath = $this->getTemplatePath($templateName);

            if (!file_exists($filePath)) {
                throw new Exception("Template not found: $templateName");
            }

            if (!unlink($filePath)) {
                throw new Exception("Failed to delete template: $templateName");
            }

            $this->logger->info("Deleted template", ['template' => $templateName]);
            return true;
        } catch (\Exception $e) {
            $this->logger->error("Error deleting template", ['template' => $templateName, 'error' => $e->getMessage()]);
            throw $e;
        }
    }

    /**
     * Validate and sanitize template filename.
     *
     * @param string $templateName The name of the template file.
     * @return string Sanitized template file path.
     */
    private function getTemplatePath(string $templateName): string
    {
        $sanitizedFileName = preg_replace('/[^a-zA-Z0-9_\.-]/', '_', $templateName);

        if (pathinfo($sanitizedFileName, PATHINFO_EXTENSION) !== 'html') {
            $sanitizedFileName .= '.html';
        }

        return $this->templateDirectory . DIRECTORY_SEPARATOR . $sanitizedFileName;
    }
}
=== App/Services/MetricsService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use Exception;

class MetricsService
{
    public const DEBUG_MODE = true;
    private $db;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    public function __construct(LoggerInterface $logger, ExceptionHandler $exceptionHandler, DatabaseHelper $db)
    {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->db = $db;
    }

    public function getDashboardMetrics(): array
    {
        try {
            $totalUsers        = $this->db->table('users')->count();
            $activeUsers       = $this->db->table('users')->where('active', true)->count();
            $totalBookings     = $this->db->table('bookings')->count();
            $completedBookings = $this->db->table('bookings')->where('status', 'completed')->count();
            $canceledBookings  = $this->db->table('bookings')->where('status', 'canceled')->count();
            $totalRevenue      = $this->db->table('payments')->where('status', 'completed')->sum('amount');
            $totalRefunds      = $this->db->table('payments')
                                          ->where('status', 'completed')
                                          ->where('type', 'refund')
                                          ->sum('amount');
            
            $metrics = [
                'total_users'         => $totalUsers,
                'active_users'        => $activeUsers,
                'total_bookings'      => $totalBookings,
                'completed_bookings'  => $completedBookings,
                'canceled_bookings'   => $canceledBookings,
                'total_revenue'       => $totalRevenue,
                'total_refunds'       => $totalRefunds,
            ];
            $metrics['net_revenue'] = $totalRevenue - $totalRefunds;
            if (self::DEBUG_MODE) {
                $this->logger->info("[Metrics] Dashboard metrics retrieved successfully");
            }
            return $metrics;
        } catch (Exception $e) {
            $this->logger->error("[DB] ❌ MetricsService error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return [];
        }
    }
}
=== App/Services/UserService.php ===
<?php

namespace App\Services;

use Psr\Log\LoggerInterface;
use Firebase\JWT\JWT;
use Illuminate\Database\Eloquent\ModelNotFoundException;
use Exception;
use App\Helpers\DatabaseHelper;
use App\Helpers\ApiHelper;
use App\Helpers\ExceptionHandler;

class UserService
{
    public const DEBUG_MODE = true;

    private DatabaseHelper $db;
    private LoggerInterface $authLogger;
    private LoggerInterface $auditLogger;
    private ExceptionHandler $exceptionHandler;

    public function __construct(
        DatabaseHelper $db,
        LoggerInterface $authLogger,
        LoggerInterface $auditLogger,
        ExceptionHandler $exceptionHandler
    ) {
        $this->db = $db;
        $this->authLogger = $authLogger;
        $this->auditLogger = $auditLogger;
        $this->exceptionHandler = $exceptionHandler;
        if (self::DEBUG_MODE) {
            $this->authLogger->info("[auth] UserService initialized", ['service' => 'UserService']);
        }
    }

    public function createUser(array $data): array
    {
        $rules = [
            'name' => 'required|string|max:255',
            'email' => 'required|email|unique:users',
            'password' => 'required|string|min:8|regex:/^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/',
            'phone' => 'required|string|max:20',
            'address' => 'required|string|max:255',
        ];

        try {
            Validator::validate($data, $rules);
        } catch (Exception $e) {
            return ['status' => 'error', 'message' => $e->getMessage()];
        }

        try {
            $userId = $this->db->table('users')->insertGetId($data);
            if (self::DEBUG_MODE) {
                $this->authLogger->info("[auth] ✅ User registered.", ['userId' => $userId]);
            }
            $this->logAction($userId, 'user_created', ['email' => $data['email']]);
            return ApiHelper::sendJsonResponse('success', 'User created successfully', ['user_id' => $userId], 201);
        } catch (Exception $e) {
            $this->authLogger->error("[auth] ❌ User creation failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return ApiHelper::sendJsonResponse('error', 'User creation failed', [], 500);
        }
    }

    public function updateUser(int $id, array $data): array
    {
        try {
            $user = $this->db->table('users')->where('id', $id)->first();
            if (!$user) {
                $this->authLogger->error("User not found", ['userId' => $id]);
                throw new ModelNotFoundException();
            }
            $this->db->table('users')->where('id', $id)->update($data);
            $this->authLogger->info("✅ User updated.", ['userId' => $id]);
            $this->logAction($id, 'user_updated', $data);
            return ApiHelper::sendJsonResponse('success', 'User updated successfully', ['user_id' => $id], 200);
        } catch (ModelNotFoundException $e) {
            $this->exceptionHandler->handleException($e);
            return ApiHelper::sendJsonResponse('error', 'User not found', [], 404);
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ApiHelper::sendJsonResponse('error', 'User update failed', [], 500);
        }
    }

    public function authenticate(string $email, string $password): array
    {
        try {
            $user = $this->db->table('users')->where('email', $email)->first();
            if (!$user || !Hash::check($password, $user->password_hash)) {
                $this->authLogger->error("Authentication failed", ['email' => $email]);
                $this->logAction(null, 'authentication_failed', ['email' => $email]);
                return ApiHelper::sendJsonResponse('error', 'Authentication failed', [], 401);
            }
            $this->authLogger->info("✅ Authentication successful.", ['userId' => $user->id]);
            $this->logAction($user->id, 'authentication_successful');
            $jwt = $this->generateJWT($user);
            return ApiHelper::sendJsonResponse('success', 'Authentication successful', ['token' => $jwt], 200);
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ApiHelper::sendJsonResponse('error', 'Authentication error', [], 500);
        }
    }

    private function generateJWT($user): string
    {
        $payload = [
            'sub' => $user->id,
            'email' => $user->email,
            'role' => $user->role,
            'iat' => time(),
            'exp' => time() + 3600,
        ];

        return JWT::encode($payload, $this->jwtSecret, 'HS256');
    }

    public function requestPasswordReset(string $email): array
    {
        try {
            $user = $this->db->table('users')->where('email', $email)->first();
            if (!$user) {
                $this->authLogger->error("Password reset request failed", ['email' => $email]);
                return ApiHelper::sendJsonResponse('error', 'User not found', [], 404);
            }
            $token = bin2hex(random_bytes(32));
            $expiresAt = now()->addHour();
            $this->db->table('password_resets')->insert([
                'email' => $email,
                'token' => $token,
                'expires_at' => $expiresAt
            ]);
            $this->authLogger->info("✅ Password reset requested.", ['userId' => $user->id]);
            $this->logAction($user->id, 'password_reset_requested', ['email' => $email]);
            return ApiHelper::sendJsonResponse('success', 'Password reset requested', ['reset_token' => $token], 200);
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ApiHelper::sendJsonResponse('error', 'Password reset request error', [], 500);
        }
    }

    private function logAction(?int $userId, string $action, array $details = []): void
    {
        try {
            $this->db->table('audit_logs')->insert([
                'user_id' => $userId,
                'action'  => $action,
                'details' => json_encode($details)
            ]);
            $this->auditLogger->info("✅ Logged action.", ['userId' => $userId, 'action' => $action]);
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }
}
=== App/Services/Validator.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

/**
 * Validator Service
 *
 * Validates input data against defined rules.
 */
class Validator
{
    public const DEBUG_MODE = true;
    private array $errors = [];
    private LoggerInterface $logger;
    private DatabaseHelper $db;
    private ExceptionHandler $exceptionHandler;

    // Updated constructor for Dependency Injection
    public function __construct(LoggerInterface $logger, DatabaseHelper $db, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->db = $db;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Validate data against rules.
     */
    public function validate(array $data, array $rules): bool
    {
        $this->errors = [];
        foreach ($rules as $field => $ruleSet) {
            $rulesArray = explode('|', $ruleSet);
            foreach ($rulesArray as $rule) {
                $this->applyRule($field, $data[$field] ?? null, $rule, $data);
            }
        }

        if (!empty($this->errors)) {
            if (self::DEBUG_MODE) {
                $this->logger->warning("[Validation] Validation failed", ['errors' => $this->errors]);
            }

            // **Throw an exception to prevent further execution**
            throw new \InvalidArgumentException(json_encode(['errors' => $this->errors]));
        }

        return true;
    }

    /**
     * Get validation errors.
     */
    public function errors(): array
    {
        return $this->errors;
    }

    /**
     * Apply a validation rule to a field.
     */
    private function applyRule(string $field, $value, string $rule, array $data): void
    {
        try {
            if ($rule === 'required' && empty($value)) {
                $this->errors[$field][] = 'This field is required.';
            } elseif (strpos($rule, 'max:') === 0) {
                $maxLength = (int)explode(':', $rule)[1];
                if (!empty($value) && strlen($value) > $maxLength) {
                    $this->errors[$field][] = "Maximum length is $maxLength characters.";
                }
            } elseif (strpos($rule, 'min:') === 0) {
                $minLength = (int)explode(':', $rule)[1];
                if (empty($value) || strlen($value) < $minLength) {
                    $this->errors[$field][] = "Minimum length is $minLength characters.";
                }
            } elseif ($rule === 'email' && !filter_var($value, FILTER_VALIDATE_EMAIL)) {
                $this->errors[$field][] = 'Invalid email address.';
            } elseif (strpos($rule, 'regex:') === 0) {
                $pattern = substr($rule, 6);
                if (!empty($value) && !preg_match($pattern, $value)) {
                    $this->errors[$field][] = 'Invalid format.';
                }
            } elseif (strpos($rule, 'same:') === 0) {
                $otherField = substr($rule, 5);
                if (isset($data[$otherField]) && ($value ?? '') !== $data[$otherField]) {
                    $this->errors[$field][] = "This field must match {$otherField}.";
                }
            } elseif (strpos($rule, 'unique:') === 0) {
                [$table, $column] = explode(',', substr($rule, 7));
                if ($this->db->getCapsule()->table($table)->where($column, $value)->exists()) {
                    $this->errors[$field][] = "The {$field} must be unique.";
                }
            }
        } catch (\Exception $e) {
            $this->logger->error("[Validation] ❌ Validation error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
        }
    }
}=== App/Services/BookingService.php ===
<?php

namespace App\Services;

use App\Models\Booking;
use Exception;
use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class BookingService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private DatabaseHelper $db;

    public function __construct(LoggerInterface $logger, ExceptionHandler $exceptionHandler, DatabaseHelper $db)
    {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->db = $db;
    }

    /**
     * Get booking details by ID
     */
    public function getBookingById(int $id): array
    {
        try {
            $booking = $this->db->table('bookings')->where('id', $id)->first();
            if (!$booking) {
                throw new Exception("Booking not found.");
            }
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved booking id: {$id}");
            }
            return (array)$booking;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getBookingById error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Reschedule a booking
     */
    public function rescheduleBooking(int $id, string $pickupDate, string $dropoffDate): void
    {
        try {
            $updated = $this->db->table('bookings')->where('id', $id)->update([
                'pickup_date'  => $pickupDate,
                'dropoff_date' => $dropoffDate,
                'status'       => 'rescheduled'
            ]);
            if (!$updated) {
                throw new Exception("Failed to update booking.");
            }
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Rescheduled booking id: {$id}");
            }
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ rescheduleBooking error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Cancel a booking and calculate refund amount
     */
    public function cancelBooking(int $id): float
    {
        try {
            $booking = $this->db->table('bookings')->where('id', $id)->first();
            if (!$booking) {
                throw new Exception("Booking not found.");
            }
            $updated = $this->db->table('bookings')->where('id', $id)->update(['status' => 'canceled']);
            if (!$updated) {
                throw new Exception("Failed to update booking status.");
            }
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Canceled booking id: {$id}");
            }
            return isset($booking->refund_amount) ? $booking->refund_amount : 0.0;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ cancelBooking error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get user ID associated with a booking
     */
    public function getUserIdByBooking(int $id): int
    {
        try {
            $record = $this->db->table('bookings')->where('id', $id)->first();
            if (!$record || !isset($record->user_id)) {
                throw new Exception("User not found for booking.");
            }
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved user id for booking id: {$id}");
            }
            return $record->user_id;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getUserIdByBooking error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get monthly booking trends for the current year
     */
    public function getMonthlyBookingTrends(): array
    {
        try {
            $trends = $this->db->table('bookings')
                               ->selectRaw('MONTH(created_at) AS month, COUNT(*) AS total')
                               ->groupBy('month')
                               ->get();
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved monthly booking trends.");
            }
            return $trends;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getMonthlyBookingTrends error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get total number of bookings
     */
    public function getTotalBookings(): int
    {
        try {
            $total = $this->db->table('bookings')->count();
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved total bookings.");
            }
            return $total;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getTotalBookings error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get the number of completed bookings
     */
    public function getCompletedBookings(): int
    {
        try {
            $completed = $this->db->table('bookings')->where('status', 'completed')->count();
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved completed bookings.");
            }
            return $completed;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getCompletedBookings error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get the number of canceled bookings
     */
    public function getCanceledBookings(): int
    {
        try {
            $canceled = $this->db->table('bookings')->where('status', 'canceled')->count();
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved canceled bookings.");
            }
            return $canceled;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getCanceledBookings error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Get booking logs for a specific booking ID
     */
    public function getBookingLogs(int $bookingId): array
    {
        try {
            $logs = $this->db->table('booking_logs')
                             ->where('booking_id', $bookingId)
                             ->orderBy('created_at', 'desc')
                             ->get();
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Retrieved logs for booking id: {$bookingId}");
            }
            return $logs;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ getBookingLogs error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Check booking availability
     */
    private function isBookingAvailable(int $vehicleId, string $pickupDate, string $dropoffDate): bool
    {
        try {
            // Assuming DatabaseHelper provides a method isAvailable() or equivalent query.
            $available = $this->db->table('bookings')
                                  ->where('vehicle_id', $vehicleId)
                                  ->whereBetween('pickup_date', [$pickupDate, $dropoffDate])
                                  ->count() === 0;
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Checked availability for vehicle id: {$vehicleId}");
            }
            return $available;
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ isBookingAvailable error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Create a new booking
     */
    public function createBooking(int $userId, int $vehicleId, string $pickupDate, string $dropoffDate): array
    {
        if (!$this->isBookingAvailable($vehicleId, $pickupDate, $dropoffDate)) {
            $this->logger->error("[Booking] ❌ Vehicle not available for booking (vehicle id: {$vehicleId})");
            return ['status' => 'error', 'message' => 'Vehicle not available for the selected dates'];
        }

        try {
            $booking = $this->db->table('bookings')->insertGetId([
                'user_id'     => $userId,
                'vehicle_id'  => $vehicleId,
                'pickup_date' => $pickupDate,
                'dropoff_date'=> $dropoffDate,
                'status'      => 'booked',
                'created_at'  => now(),
                'updated_at'  => now()
            ]);
            if (self::DEBUG_MODE) {
                $this->logger->info("[Booking] Booking created for user {$userId}");
            }

            return ['status' => 'success', 'message' => 'Booking created successfully'];
        } catch (Exception $e) {
            $this->logger->error("[Booking] ❌ createBooking error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'Failed to create booking'];
        }
    }
}
=== App/Services/Auth/TokenService.php ===
<?php

namespace App\Services\Auth;

use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use App\Helpers\ApiHelper;

class TokenService
{
    public const DEBUG_MODE = true;

    private string $secretKey;
    private string $refreshSecretKey;
    private LoggerInterface $tokenLogger;
    private ExceptionHandler $exceptionHandler;

    public function __construct(
        string $secretKey,
        string $refreshSecretKey,
        LoggerInterface $tokenLogger,
        ExceptionHandler $exceptionHandler
    ) {
        if (empty($secretKey) || empty($refreshSecretKey)) {
            throw new \RuntimeException('❌ JWT secrets are missing.');
        }
        $this->secretKey = $secretKey;
        $this->refreshSecretKey = $refreshSecretKey;
        $this->tokenLogger = $tokenLogger;
        $this->exceptionHandler = $exceptionHandler;
        if (self::DEBUG_MODE) {
            $this->tokenLogger->info("[auth] TokenService initialized.");
        }
    }

    public function generateToken($user)
    {
        $payload = [
            'iss' => "your-issuer",
            'sub' => $user->id,
            'iat' => time(),
            'exp' => time() + 3600
        ];
        try {
            $token = JWT::encode($payload, $this->secretKey, 'HS256');
            if (self::DEBUG_MODE) {
                $this->tokenLogger->info("[auth] ✅ Token generated.", ['userId' => $user->id]);
            }
            return ApiHelper::sendJsonResponse('success', 'Token generated', ['token' => $token]);
        } catch (\Exception $e) {
            $this->tokenLogger->error("[auth] ❌ Token generation failed: " . $e->getMessage());
            return $this->exceptionHandler->handleException($e);
        }
    }

    public function verifyToken(string $token): ?array
    {
        try {
            $decoded = JWT::decode($token, new Key($this->secretKey, 'HS256'));
            $this->tokenLogger->info("✅ Token verified.", ['userId' => $decoded->sub]);
            return (array)$decoded;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }

    public function validateToken(string $token): ?array
    {
        try {
            $decoded = JWT::decode($token, new Key($this->secretKey, 'HS256'));
            if ($decoded->exp < time()) {
                $this->tokenLogger->error("❌ [TokenService] Expired token.", ['userId' => $decoded->sub ?? 'unknown']);
                return null;
            }
            return (array)$decoded;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }

    public function generateRefreshToken($user): string
    {
        $payload = [
            'iss' => "your-issuer",
            'sub' => $user->id,
            'iat' => time(),
            'exp' => time() + 604800
        ];
        try {
            return JWT::encode($payload, $this->refreshSecretKey, 'HS256');
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return '';
        }
    }

    public function refreshAccessToken(string $refreshToken): ?string
    {
        $decoded = $this->verifyToken($refreshToken);
        if ($decoded) {
            $userId = $decoded['sub'];
            if (apcu_exists("revoked_refresh_token_$refreshToken")) {
                return null;
            }
            return $this->generateToken((object)['id' => $userId]);
        }
        return null;
    }

    public function refreshToken(string $refreshToken): ?string
    {
        try {
            $decoded = JWT::decode($refreshToken, new Key($this->refreshSecretKey, 'HS256'));
            if ($decoded->exp < time()) {
                $this->tokenLogger->error("❌ [TokenService] Expired refresh token.", ['userId' => $decoded->sub ?? 'unknown']);
                return null;
            }
            if (apcu_exists("revoked_refresh_token_$refreshToken")) {
                $this->tokenLogger->error("❌ [TokenService] Revoked refresh token attempted.", ['userId' => $decoded->sub ?? 'unknown']);
                return null;
            }
            return $this->generateToken((object)['id' => $decoded->sub]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }

    public function revokeToken(string $token): void
    {
        apcu_store("revoked_refresh_token_$token", true, 604800);
        $this->tokenLogger->info("✅ [TokenService] Revoked refresh token.");
    }
}
=== App/Services/Auth/AuthService.php ===
<?php

namespace App\Services\Auth;

use App\Models\User;
use App\Helpers\DatabaseHelper;
use Firebase\JWT\JWT;
use App\Helpers\ExceptionHandler;
use Firebase\JWT\Key;
use Exception;
use App\Helpers\SecurityHelper;
use Psr\Log\LoggerInterface;
use App\Helpers\ApiHelper;
use App\Services\Validator;

class AuthService
{
    private $db;
    private TokenService $tokenService;
    private ExceptionHandler $exceptionHandler;
    private LoggerInterface $authLogger;
    private LoggerInterface $auditLogger;
    private array $encryptionConfig;
    private Validator $validator;

    public function __construct(
        DatabaseHelper $dbHelper,  // Ensure DatabaseHelper is injected
        TokenService $tokenService,
        ExceptionHandler $exceptionHandler,
        LoggerInterface $authLogger,
        LoggerInterface $auditLogger,
        array $encryptionConfig,
        Validator $validator // Inject Validator
    ) {
        $this->db = $dbHelper->getCapsule();  // Get the Capsule instance
        $this->tokenService = $tokenService;
        $this->exceptionHandler = $exceptionHandler;
        $this->authLogger = $authLogger;
        $this->auditLogger = $auditLogger;
        $this->encryptionConfig = $encryptionConfig;
        $this->validator = $validator; // Initialize Validator
    }

    public function login($email, $password)
    {
        try {
            // Use injected DatabaseHelper to query the user
            $user = $this->db->table('users')->where('email', $email)->first();
            if (!$user || !password_verify($password, $user->password_hash)) {
                $this->authLogger->warning("Authentication failed", ['email' => $email]);
                throw new Exception("Invalid credentials");
            }
            if (self::DEBUG_MODE) {
                $this->authLogger->info("[auth] User authenticated", ['userId' => $user->id, 'email' => $user->email]);
            }

            if (session_status() === PHP_SESSION_NONE) {
                session_start();
            }
            session_regenerate_id(true);
            $_SESSION['user_id']   = $user->id;
            $_SESSION['user_role'] = $user->role ?? 'user';

            $token = $this->tokenService->generateToken($user);
            $refreshToken = $this->tokenService->generateRefreshToken($user);

            return [
                'token'         => $token,
                'refresh_token' => $refreshToken
            ];
        } catch (Exception $e) {
            $this->authLogger->error("[auth] ❌ Credential error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            // Optionally use ApiHelper to send an error response
            ApiHelper::sendJsonResponse('error', $e->getMessage(), [], 401);
        }
    }

    public function registerUser(array $data)
    {
        $rules = [
            'email'    => 'required|email|unique:users,email',
            'password' => 'required|min:6',
            'name'     => 'required|string',
        ];

        try {
            // Validate the input data
            $this->validator->validate($data, $rules);

            // Hash the password before storing it
            $data['password'] = password_hash($data['password'], PASSWORD_BCRYPT);

            // Insert the user into the database
            $userId = $this->db->table('users')->insertGetId($data);
            return ApiHelper::sendJsonResponse('success', 'User registered', ['user_id' => $userId], 201);
        } catch (\InvalidArgumentException $e) {
            return ApiHelper::sendJsonResponse('error', 'Validation failed', json_decode($e->getMessage(), true), 400);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    public function resetPasswordRequest($email)
    {
        $user = User::where('email', $email)->first();
        if (!$user) {
            $this->authLogger->error("Password reset failed: email not found", ['email' => $email]);
            throw new Exception("Email not found.");
        }

        $token = bin2hex(random_bytes(32));
        $hashedToken = password_hash($token, PASSWORD_BCRYPT);
        $expiresAt = now()->addHour();

        try {
            $this->db->table('password_resets')->insert([
                'email'      => $email,
                'token'      => $hashedToken,
                'expires_at' => $expiresAt,
            ]);
            getLogger('auth')->info("[Auth] Password reset requested for {$email}");
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
        }

        // Send email (mock implementation)
        // ...existing code...

        return ['token' => $token];
    }

    public function validateToken($token)
    {
        try {
            $decoded = JWT::decode($token, new Key($this->tokenService->jwtSecret, 'HS256'));
            return (array)$decoded;
        } catch (Exception $e) {
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    public function getUserFromToken($token)
    {
        $decoded = $this->tokenService->validateToken($token);
        if (!$decoded) {
            throw new Exception("Invalid token.");
        }

        return User::find($decoded['sub']);
    }

    public function logout()
    {
        // Clear session data and session cookie for secure logout
        $_SESSION = [];
        if (ini_get('session.use_cookies')) {
            setcookie(session_name(), '', time() - 42000, '/');
        }
        session_destroy();
        $this->auditLogger->info("User logged out", ['session_id' => session_id()]);
    }
}
?>
=== App/Services/DocumentService.php ===
<?php

namespace DocumentManager\Services;

use Exception;
use App\Helpers\DatabaseHelper; // added for database operations
use AuditManager\Services\AuditService;
use DocumentManager\Services\FileStorage;
use DocumentManager\Services\TemplateService;
use App\Services\EncryptionService;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

/**
 * Document Service
 *
 * Manages documents including templates, contracts, and Terms & Conditions (T&C).
 * Supports encryption, secure storage, logging, and dynamic document generation.
 */
class DocumentService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private $db;
    private AuditService $auditService;
    private FileStorage $fileStorage;
    private EncryptionService $encryptionService;
    private TemplateService $templateService;

    public function __construct(
        AuditService $auditService,
        FileStorage $fileStorage,
        EncryptionService $encryptionService,
        TemplateService $templateService,
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler
    ) {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->db = DatabaseHelper::getInstance();
        $this->auditService = $auditService;
        $this->fileStorage = $fileStorage;
        $this->encryptionService = $encryptionService;
        $this->templateService = $templateService;
    }

    /**
     * Upload a document template.
     */
    public function uploadTemplate(string $name, string $content): void
    {
        $this->processTemplate($name, $content, 'template_uploaded');
    }

    /**
     * Upload the Terms & Conditions document.
     */
    public function uploadTerms(string $content): void
    {
        $this->processTemplate('terms_and_conditions', $content, 'terms_uploaded');
    }

    /**
     * Process template storage and logging.
     */
    private function processTemplate(string $name, string $content, string $logAction): void
    {
        try {
            if (self::DEBUG_MODE) {
                $this->logger->info("[Document] Uploading template: {$name}");
            }
            $encryptedContent = $this->encryptionService->encrypt($content);
            $this->templateService->saveTemplate("{$name}.html", $encryptedContent);
            $this->auditService->log($logAction, ['template' => $name]);
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Upload template exception: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to upload template: {$name} " . $e->getMessage());
        }
    }

    /**
     * Generate a rental contract document dynamically.
     */
    public function generateContract(int $bookingId, int $userId): string
    {
        try {
            if (self::DEBUG_MODE) {
                $this->logger->info("[Document] Generating contract for booking {$bookingId}");
            }

            $templateContent = $this->templateService->loadTemplate('rental_contract.html');
            $data = array_merge($this->fetchUserData($userId), $this->fetchBookingData($bookingId));
            $renderedContent = $this->templateService->renderTemplate('rental_contract.html', $data);

            $encryptedContract = $this->encryptionService->encrypt($renderedContent);
            $filePath = $this->fileStorage->storeFile("contracts", "contract_{$bookingId}.pdf", $encryptedContract);

            // Replace raw SQL insert/prepare with DatabaseHelper query
            $this->db->table('contracts')->insert([
                'booking_id'  => $bookingId,
                'user_id'     => $userId,
                'contract_pdf'=> $filePath,
                'created_at'  => now()
            ]);

            $this->auditService->log('contract_generated', ['booking_id' => $bookingId, 'user_id' => $userId]);

            return $filePath;
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Contract generation error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Retrieve and decrypt a document.
     */
    public function retrieveDocument(string $filePath): string
    {
        try {
            if (self::DEBUG_MODE) {
                $this->logger->info("[Document] Retrieving document from {$filePath}");
            }

            $encryptedContent = $this->fileStorage->retrieveFile($filePath);
            $decryptedContent = $this->encryptionService->decrypt($encryptedContent);

            $this->auditService->log('document_retrieved', ['file_path' => $filePath]);

            return $decryptedContent;
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Retrieve document error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to retrieve document " . $e->getMessage());
        }
    }

    /**
     * Delete a document.
     */
    public function deleteDocument(int $documentId): void
    {
        try {
            if (self::DEBUG_MODE) {
                $this->logger->info("[Document] Deleting document ID {$documentId}");
            }

            // Replace raw PDO prepare with DatabaseHelper query
            $document = $this->db->table('documents')->where('id', $documentId)->first();

            if (!$document) {
                throw new Exception("Document not found.");
            }

            $this->fileStorage->deleteFile($document->file_path);
            $this->db->table('documents')->where('id', $documentId)->delete();

            $this->auditService->log('document_deleted', ['document_id' => $documentId]);
        } catch (Exception $e) {
            $this->logger->error("[Document] ❌ Delete document error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to delete document " . $e->getMessage());
        }
    }

    /**
     * Fetch user data.
     */
    private function fetchUserData(int $userId): array
    {
        return $this->fetchRecord("SELECT * FROM users WHERE id = :id", ['id' => $userId], "User not found.");
    }

    /**
     * Fetch booking data.
     */
    private function fetchBookingData(int $bookingId): array
    {
        return $this->fetchRecord("SELECT * FROM bookings WHERE id = :id", ['id' => $bookingId], "Booking not found.");
    }

    /**
     * Fetch a record from the database.
     */
    private function fetchRecord(string $query, array $params, string $errorMessage): array
    {
        try {
            // Replace raw PDO query with DatabaseHelper call (assuming a helper method exists)
            $record = $this->db->table(explode(' ', $query)[3])
                               ->where(key($params), current($params))
                               ->first();
            if (!$record) {
                throw new Exception($errorMessage);
            }
            return (array)$record;
        } catch (Exception $e) {
            $this->logger->error("[DocumentService] Database error: " . $e->getMessage(), ['category' => 'database']);
            throw $e;
        }
    }

    /**
     * Handle exceptions and log errors.
     */
    private function handleException(string $message, Exception $e): void
    {
        $this->logger->error($message, ['error' => $e->getMessage(), 'category' => 'document']);
        throw new Exception($message . " " . $e->getMessage());
    }
}
=== App/Services/NotificationService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper; // new import
use Psr\Log\LoggerInterface;
use PHPMailer\PHPMailer\PHPMailer;
use PHPMailer\PHPMailer\Exception;
use App\Helpers\ExceptionHandler; // assume this exists

/**
 * NotificationService
 *
 * Handles various notification types (email, SMS, webhook, push notifications).
 */
class NotificationService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private array $config;
    private DatabaseHelper $db;

    public function __construct(LoggerInterface $logger, ExceptionHandler $exceptionHandler, DatabaseHelper $db, array $config)
    {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->db = $db;
        $this->config = $config;
    }

    /**
     * Send a notification
     */
    public function sendNotification(int $userId, string $type, string $message, array $options = []): bool
    {
        try {
            $this->storeNotification($userId, $type, $message);
            return $this->dispatchNotification($userId, $type, $message, $options);
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ Notification failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Store notification in the database
     */
    private function storeNotification(int $userId, string $type, string $message): void
    {
        try {
            // Instead of Eloquent relationship, we use direct DB insert.
            $this->db->table('notifications')->insert([
                'user_id' => $userId,
                'type'    => $type,
                'message' => $message,
                'sent_at' => date('Y-m-d H:i:s'),
                'is_read' => false,
            ]);
            if (self::DEBUG_MODE) {
                $this->logger->info("[Notification] Stored notification for user {$userId}");
            }
        } catch (\Exception $e) {
            $this->logger->error("[DB] ❌ storeNotification error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function getUserNotifications(int $userId)
    {
        try {
            $notifications = $this->db->table('notifications')
                                 ->where('user_id', $userId)
                                 ->orderBy('created_at', 'desc')
                                 ->get();
            if (self::DEBUG_MODE) {
                $this->logger->info("[Notification] Retrieved notifications for user {$userId}");
            }
            return $notifications;
        } catch (\Exception $e) {
            $this->logger->error("[DB] ❌ getUserNotifications error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function markAsRead(int $notificationId): void
    {
        try {
            $this->db->table('notifications')
                     ->where('id', $notificationId)
                     ->update(['is_read' => true]);
            if (self::DEBUG_MODE) {
                $this->logger->info("[Notification] Marked notification {$notificationId} as read");
            }
        } catch (\Exception $e) {
            $this->logger->error("[DB] ❌ markAsRead error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function deleteNotification(int $notificationId): void
    {
        try {
            $this->db->table('notifications')
                     ->where('id', $notificationId)
                     ->delete();
            if (self::DEBUG_MODE) {
                $this->logger->info("[Notification] Deleted notification {$notificationId}");
            }
        } catch (\Exception $e) {
            $this->logger->error("[DB] ❌ deleteNotification error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function markAllAsRead(int $userId): void
    {
        try {
            $this->db->table('notifications')
                     ->where('user_id', $userId)
                     ->update(['is_read' => true]);
            if (self::DEBUG_MODE) {
                $this->logger->info("[Notification] Marked all notifications as read for user {$userId}");
            }
        } catch (\Exception $e) {
            $this->logger->error("[DB] ❌ markAllAsRead error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Dispatch the appropriate notification method
     */
    private function dispatchNotification(int $userId, string $type, string $message, array $options): bool
    {
        return match ($type) {
            'email' => $this->sendEmail($options['email'] ?? '', $message, $options['subject'] ?? 'Notification'),
            'sms' => $this->sendSMS($options['phone'] ?? '', $message),
            'webhook' => $this->sendWebhook($options['url'] ?? '', $message),
            'push' => $this->sendPushNotification($options['device_token'] ?? '', $message),
            default => throw new \InvalidArgumentException("Unsupported notification type: $type"),
        };
    }

    /**
     * Send an email using PHPMailer
     */
    private function sendEmail(string $to, string $message, string $subject): bool
    {
        if (empty($to)) return false;

        try {
            $mail = new PHPMailer(true);
            $mail->isSMTP();
            $mail->Host = $this->config['smtp_host'];
            $mail->SMTPAuth = true;
            $mail->Username = $this->config['smtp_user'];
            $mail->Password = $this->config['smtp_password'];
            $mail->SMTPSecure = $this->config['smtp_secure'] ?? 'tls';
            $mail->Port = $this->config['smtp_port'];
            $mail->setFrom($this->config['from_email'], $this->config['from_name']);
            $mail->addAddress($to);
            $mail->Subject = $subject;
            $mail->isHTML(true);
            $mail->Body = "<p>$message</p>";
            $mail->send();
            if (self::DEBUG_MODE) {
                $this->logger->info("[Notification] Email sent to {$to}");
            }

            return true;
        } catch (Exception $e) {
            $this->logger->error("[Notification] ❌ Email error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Send an SMS
     */
    private function sendSMS(string $phone, string $message): bool
    {
        if (empty($phone)) return false;

        try {
            if (self::DEBUG_MODE) {
                $this->logger->info("[Notification] SMS sent to {$phone}");
            }
            return true;
        } catch (\Exception $e) {
            $this->logger->error("[Notification] ❌ SMS error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Send a webhook notification
     */
    private function sendWebhook(string $url, string $message): bool
    {
        if (empty($url)) return false;

        try {
            $ch = curl_init($url);
            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
            curl_setopt($ch, CURLOPT_POST, true);
            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode(['message' => $message]));
            curl_setopt($ch, CURLOPT_HTTPHEADER, ['Content-Type: application/json']);
            $response = curl_exec($ch);
            curl_close($ch);

            return $response !== false;
        } catch (\Exception $e) {
            $this->logger->error('Webhook failed', ['error' => $e->getMessage()]);
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Send a push notification
     */
    private function sendPushNotification(string $deviceToken, string $message): bool
    {
        if (empty($deviceToken)) return false;

        try {
            $payload = [
                'to' => $deviceToken,
                'notification' => ['title' => 'Notification', 'body' => $message],
            ];
            return $this->sendFCMRequest($payload);
        } catch (\Exception $e) {
            $this->logger->error('Push notification failed', ['error' => $e->getMessage()]);
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    /**
     * Send Firebase Cloud Messaging (FCM) request
     */
    private function sendFCMRequest(array $payload): bool
    {
        $ch = curl_init('https://fcm.googleapis.com/fcm/send');
        curl_setopt($ch, CURLOPT_HTTPHEADER, [
            'Content-Type: application/json',
            'Authorization: key=' . $this->config['fcm_api_key'],
        ]);
        curl_setopt($ch, CURLOPT_POST, true);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($payload));
        $response = curl_exec($ch);

        curl_close($ch);
        return $response !== false;
    }
}
=== App/Services/AuditService.php ===
<?php

namespace App\Services;

use App\Models\AuditLog;
use Exception;
use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class AuditService
{
    public const DEBUG_MODE = true;
    private $db;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    public function __construct(LoggerInterface $logger, ExceptionHandler $exceptionHandler, DatabaseHelper $db)
    {
        $this->db = $db;
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Log an action using AuditLog Eloquent model.
     */
    public function log(
        string $action,
        array $details = [],
        ?int $userId = null,
        ?int $bookingId = null,
        ?string $ipAddress = null
    ): void {
        try {
            $this->db->table('audit_logs')->insert([
                'action'     => $action,
                'details'    => json_encode($details, JSON_UNESCAPED_UNICODE),
                'user_id'    => $userId,
                'booking_id' => $bookingId,
                'ip_address' => $ipAddress,
                'created_at' => now()
            ]);
            if (self::DEBUG_MODE) {
                $this->logger->info("[Audit] Logged action: {$action}");
            }
        } catch (Exception $e) {
            $this->logger->error("[Audit] ❌ log error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception('Failed to log action: ' . $e->getMessage());
        }
    }

    /**
     * Retrieve logs using Eloquent with applied filters.
     */
    public function getLogs(array $filters): \Illuminate\Contracts\Pagination\LengthAwarePaginator
    {
        try {
            $query = $this->db->table('audit_logs');
            if (!empty($filters['user_id'])) {
                $query->where('user_id', $filters['user_id']);
            }
            if (!empty($filters['booking_id'])) {
                $query->where('booking_id', $filters['booking_id']);
            }
            if (!empty($filters['action'])) {
                $query->where('action', $filters['action']);
            }
            if (!empty($filters['start_date'])) {
                $query->where('created_at', '>=', $filters['start_date']);
            }
            if (!empty($filters['end_date'])) {
                $query->where('created_at', '<=', $filters['end_date']);
            }
            return $query->orderBy('created_at', 'desc')->paginate(10);
        } catch (Exception $e) {
            $this->logger->error("[Audit] ❌ getLogs error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Retrieve a single log entry by ID.
     */
    public function getLogById(int $logId)
    {
        try {
            $log = $this->db->table('audit_logs')->where('id', $logId)->first();
            if (!$log) {
                throw new Exception('Log entry not found.');
            }
            return $log;
        } catch (Exception $e) {
            $this->logger->error("[Audit] ❌ getLogById error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    /**
     * Soft delete logs based on specific filters.
     */
    public function deleteLogs(array $filters): int
    {
        try {
            $query = $this->db->table('audit_logs');
            if (!empty($filters['user_id'])) {
                $query->where('user_id', $filters['user_id']);
            }
            if (!empty($filters['booking_id'])) {
                $query->where('booking_id', $filters['booking_id']);
            }
            if (!empty($filters['action'])) {
                $query->where('action', $filters['action']);
            }
            if (!empty($filters['start_date'])) {
                $query->where('created_at', '>=', $filters['start_date']);
            }
            if (!empty($filters['end_date'])) {
                $query->where('created_at', '<=', $filters['end_date']);
            }
            $deleted = $query->delete();
            if (self::DEBUG_MODE) {
                $this->logger->info("[Audit] Deleted logs with filters: " . json_encode($filters));
            }
            return $deleted;
        } catch (Exception $e) {
            $this->logger->error("[Audit] ❌ deleteLogs error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception('Failed to delete logs: ' . $e->getMessage());
        }
    }
}
=== App/Services/TransactionService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class TransactionService
{
    public const DEBUG_MODE = true;
    private $db;
    private LoggerInterface $bookingLogger;
    private ExceptionHandler $exceptionHandler;

    // Constructor for dependency injection
    public function __construct(LoggerInterface $bookingLogger, DatabaseHelper $db, ExceptionHandler $exceptionHandler)
    {
        $this->bookingLogger = $bookingLogger;
        $this->db = $db;
        $this->exceptionHandler = $exceptionHandler;
    }

    public function getByUserId(int $userId): array
    {
        try {
            $transactions = $this->db->table('transaction_logs')
                                     ->where('user_id', $userId)
                                     ->orderBy('created_at', 'desc')
                                     ->get()
                                     ->toArray();
            if (self::DEBUG_MODE) {
                $this->bookingLogger->info("[db] Retrieved transactions", ['userId' => $userId]);
            }
            return $transactions;
        } catch (\Exception $e) {
            $this->bookingLogger->error("[db] ❌ Error retrieving transactions: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return [];
        }
    }

    public function create(array $data): void
    {
        try {
            $this->db->table('transaction_logs')->insert([
                'user_id'    => $data['user_id'],
                'booking_id' => $data['booking_id'],
                'amount'     => $data['amount'],
                'type'       => $data['type'],
                'status'     => $data['status'],
                'created_at' => date('Y-m-d H:i:s'),
            ]);
            $this->bookingLogger->info("Transaction created", ['userId' => $data['user_id']]);
        } catch (\Exception $e) {
            $this->bookingLogger->error("Database error while creating transaction", ['error' => $e->getMessage()]);
            throw $e;
        }
    }

    public function updateStatus(int $transactionId, string $status): void
    {
        try {
            $this->db->table('transaction_logs')
                     ->where('id', $transactionId)
                     ->update(['status' => $status, 'updated_at' => date('Y-m-d H:i:s')]);
            $this->bookingLogger->info("Updated transaction status", ['transactionId' => $transactionId, 'status' => $status]);
        } catch (\Exception $e) {
            $this->bookingLogger->error("Database error while updating transaction status", ['error' => $e->getMessage()]);
            throw $e;
        }
    }
}
=== App/Services/EncryptionService.php ===
<?php

namespace App\Services;

use Illuminate\Support\Facades\Crypt;
use Illuminate\Support\Facades\Storage;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class EncryptionService
{
    public const DEBUG_MODE = true;

    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private string $encryptionKey;

    public function __construct(LoggerInterface $logger, ExceptionHandler $exceptionHandler, string $encryptionKey)
    {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->encryptionKey = $encryptionKey;
    }

    public function encrypt(string $data): string
    {
        try {
            return Crypt::encryptString($data);
        } catch (\Exception $e) {
            $this->logger->error("[Encryption] ❌ Encryption failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function decrypt(string $encryptedData): ?string
    {
        try {
            return Crypt::decryptString($encryptedData);
        } catch (\Exception $e) {
            $this->logger->error("[Encryption] ❌ Decryption failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return null;
        }
    }

    public function encryptFile(string $inputFile, string $outputFile): bool
    {
        try {
            $data = file_get_contents($inputFile);
            if ($data === false) {
                throw new \RuntimeException("Failed to read file: $inputFile");
            }
            $encrypted = Crypt::encryptString($data);
            Storage::put($outputFile, $encrypted);
            return true;
        } catch (\Exception $e) {
            $this->logger->error("File encryption failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    public function decryptFile(string $inputFile, string $outputFile): bool
    {
        try {
            $encryptedData = Storage::get($inputFile);
            $decrypted = Crypt::decryptString($encryptedData);
            Storage::put($outputFile, $decrypted);
            return true;
        } catch (\Exception $e) {
            $this->logger->error("File decryption failed: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    public function sign(string $data): string
    {
        return hash_hmac('sha256', $data, $this->encryptionKey);
    }

    public function verify(string $data, string $signature): bool
    {
        return hash_equals($this->sign($data), $signature);
    }
}
=== App/Services/FileStorage.php ===
<?php

namespace App\Services;

use Exception;
use App\Services\EncryptionService;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class FileStorage
{
    public const DEBUG_MODE = true;
    private string $basePath;
    private array $config;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private EncryptionService $encryptionService;

    public function __construct(array $config, EncryptionService $encryptionService, LoggerInterface $logger, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->config = $config;
        $this->encryptionService = $encryptionService;
        $this->basePath = rtrim($config['base_directory'], DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;

        if (!is_dir($this->basePath) || !is_writable($this->basePath)) {
            throw new Exception("Invalid storage base path or insufficient permissions: {$this->basePath}");
        }
    }

    public function storeFile(string $directory, string $fileName, string $content, bool $encrypt = false): string
    {
        $safeDirectory = $this->getDirectoryPath($directory);
        $safeFileName = $this->sanitizeFileName($fileName);
        $filePath = $safeDirectory . $safeFileName;

        if ($encrypt) {
            $content = $this->encryptionService->encrypt($content);
        }

        try {
            if (file_put_contents($filePath, $content) === false) {
                throw new Exception("Failed to store file: $fileName");
            }

            chmod($filePath, $this->config['security']['permissions']['default']);
            if (self::DEBUG_MODE) {
                $this->logger->info("[FileStorage] File stored: {$fileName}");
            }

            return $filePath;
        } catch (\Exception $e) {
            $this->logger->error("[FileStorage] ❌ Failed to store file: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function retrieveFile(string $filePath, bool $decrypt = false): string
    {
        try {
            if (!file_exists($filePath) || !is_readable($filePath)) {
                throw new Exception("File not found or not readable: $filePath");
            }

            $content = file_get_contents($filePath);
            if ($content === false) {
                throw new Exception("Failed to retrieve file: $filePath");
            }

            if ($decrypt) {
                $content = $this->encryptionService->decrypt($content);
                if ($content === null) {
                    throw new Exception("Failed to decrypt file: $filePath");
                }
            }

            if (self::DEBUG_MODE) {
                $this->logger->info("[FileStorage] File retrieved: {$filePath}");
            }
            return $content;
        } catch (\Exception $e) {
            $this->logger->error("[FileStorage] ❌ Failed to retrieve file: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function deleteFile(string $filePath): void
    {
        try {
            if (!file_exists($filePath)) {
                throw new Exception("File not found: $filePath");
            }

            if (!unlink($filePath)) {
                throw new Exception("Failed to delete file: $filePath");
            }

            if (self::DEBUG_MODE) {
                $this->logger->info("[FileStorage] File deleted: {$filePath}");
            }
        } catch (\Exception $e) {
            $this->logger->error("[FileStorage] ❌ Failed to delete file: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    private function sanitizeFileName(string $fileName): string
    {
        return preg_replace('/[^a-zA-Z0-9_\.-]/', '_', $fileName);
    }

    private function getDirectoryPath(string $directory): string
    {
        $path = $this->basePath . trim($directory, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;

        if (!is_dir($path) && !mkdir($path, 0755, true)) {
            $this->logger->error("❌ Failed to create directory.", ['path' => $path, 'trace' => debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS)]);
            throw new Exception("Failed to create directory: $path");
        }

        if (!is_writable($path)) {
            $this->logger->error("❌ Directory is not writable.", ['path' => $path, 'trace' => debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS)]);
            throw new Exception("Directory is not writable: $path");
        }

        return $path;
    }
}
=== App/Services/RateLimiter.php ===
<?php

namespace App\Services;

use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

/**
 * Rate Limiter Service
 *
 * Implements IP-based rate limiting.
 */
class RateLimiter
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    public function __construct(LoggerInterface $logger, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
    }

    public function isRateLimited(string $ip): bool
    {
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }
        if (!isset($_SESSION['rate_limit'])) {
            $_SESSION['rate_limit'] = [];
        }
        $attempts = $_SESSION['rate_limit'][$ip] ?? 0;
        if ($attempts >= 5) {
            if (self::DEBUG_MODE) {
                $this->logger->warning("[security] Rate limit exceeded for IP: {$ip}", ['category' => 'security']);
            }
            return true;
        }
        return false;
    }

    public function recordFailedAttempt(string $ip): void
    {
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }
        if (!isset($_SESSION['rate_limit'])) {
            $_SESSION['rate_limit'] = [];
        }
        $_SESSION['rate_limit'][$ip] = ($_SESSION['rate_limit'][$ip] ?? 0) + 1;
        if (self::DEBUG_MODE) {
            $this->logger->info("[security] Recorded failed attempt for IP: {$ip}", ['category' => 'security']);
        }
    }
}
=== App/Services/RevenueService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper; // new import
use App\Models\Payment;
use App\Models\TransactionLog;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class RevenueService
{
    public const DEBUG_MODE = true;
    private $db;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    // Assume dependency injection now supplies the logger.
    public function __construct(LoggerInterface $logger, DatabaseHelper $db, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->db = $db;
        $this->exceptionHandler = $exceptionHandler;
    }

    public function getMonthlyRevenueTrends(): array
    {
        try {
            $data = $this->db->table('payments')
                ->where('status', 'completed')
                ->selectRaw('DATE_FORMAT(created_at, "%Y-%m") as month, SUM(amount) as revenue')
                ->groupBy('month')
                ->orderBy('month')
                ->get();
            $labels = array_column($data, 'month');
            $amounts = array_column($data, 'revenue');
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Retrieved monthly revenue trends", ['category' => 'revenue']);
            }
            return [
                'labels' => $labels,
                'data'   => $amounts,
            ];
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function getTotalRevenue(): float
    {
        try {
            $total = $this->db->table('transaction_logs')
                ->where('type', 'payment')
                ->sum('amount');
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Retrieved total revenue", ['category' => 'revenue']);
            }
            return (float) $total;
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function getTotalRefunds(): float
    {
        try {
            $total = $this->db->table('transaction_logs')
                ->where('type', 'refund')
                ->sum('amount');
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Retrieved total refunds", ['category' => 'revenue']);
            }
            return (float) $total;
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    public function getNetRevenue(): float
    {
        return $this->getTotalRevenue() - $this->getTotalRefunds();
    }
}
=== App/Services/Security/KeyManager.php ===
<?php

namespace App\Services\Security;

use Exception;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class KeyManager
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;
    private array $keys;

    public function __construct(array $keys, LoggerInterface $logger, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
        $this->keys = $keys;
    }

    public function getKey(string $identifier): string
    {
        $keyName = 'encryption_key_' . strtolower($identifier);

        if (!isset($this->keys[$keyName]) || empty($this->keys[$keyName])) {
            $this->logger->error("[security] ❌ Encryption key for {$identifier} not found.", ['identifier' => $identifier]);
            throw new Exception("Encryption key for {$identifier} not found.");
        }

        return $this->keys[$keyName];
    }

    public function generateKey(): string
    {
        return base64_encode(random_bytes(32)); // AES-256 key
    }

    public function storeKey(string $identifier, string $key): void
    {
        if (self::DEBUG_MODE) {
            $this->logger->info("[security] Storing key for {$identifier}");
        }
        $this->logger->info("[security] ✅ Storing key for {$identifier}", ['identifier' => $identifier]);
        // Implementation for storing key securely (e.g., database, key vault)
    }

    public function rotateKey(string $identifier): void
    {
        $newKey = $this->generateKey();
        $this->storeKey($identifier, $newKey);
        $this->logger->info("[security] ✅ Rotated key for {$identifier}", ['identifier' => $identifier]);
    }

    public function revokeKey(string $identifier): void
    {
        $this->logger->info("[security] ✅ Revoking key for {$identifier}", ['identifier' => $identifier]);
        // Implementation for revoking key securely
    }
}
=== App/Services/SignatureService.php ===
<?php

namespace App\Services;

use Exception;
use GuzzleHttp\Client;
use Psr\Log\LoggerInterface;
use App\Services\FileStorage;
use App\Services\EncryptionService;
use App\Helpers\DatabaseHelper;
use App\Helpers\ExceptionHandler;

/**
 * Signature Service
 *
 * Manages electronic signatures both locally and via an external AES API.
 */
class SignatureService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private $db;
    private string $apiEndpoint;
    private string $apiKey;
    private FileStorage $fileStorage;
    private EncryptionService $encryptionService;
    private ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        DatabaseHelper $db,
        array $config,
        FileStorage $fileStorage,
        EncryptionService $encryptionService,
        ExceptionHandler $exceptionHandler
    ) {
        if (empty($config['api_endpoint']) || empty($config['api_key'])) {
            throw new Exception('AES API configuration is incomplete.');
        }

        $this->logger = $logger;
        $this->db = $db;
        $this->apiEndpoint = $config['api_endpoint'];
        $this->apiKey = $config['api_key'];
        $this->fileStorage = $fileStorage;
        $this->encryptionService = $encryptionService;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Upload a local signature securely.
     */
    public function uploadSignature(string $filePath, int $userId): string
    {
        $this->validateFileType($filePath);

        $encryptedContent = $this->encryptionService->encrypt(file_get_contents($filePath));
        $fileName = uniqid() . '.' . pathinfo($filePath, PATHINFO_EXTENSION);
        $storagePath = $this->fileStorage->storeFile("signatures/{$userId}", $fileName, $encryptedContent, false);

        try {
            $this->db->table('signatures')->insert([
                'user_id'   => $userId,
                'file_path' => $storagePath,
                'encrypted' => true,
                'created_at'=> date('Y-m-d H:i:s'),
            ]);
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Signature record created", ['userId' => $userId, 'storagePath' => $storagePath]);
            }
        } catch (Exception $e) {
            $this->logger->error("[db] ❌ Database error: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
        if (self::DEBUG_MODE) {
            $this->logger->info("[system] Signature uploaded", ['userId' => $userId, 'storagePath' => $storagePath]);
        }
        return $storagePath;
    }

    /**
     * Send a document for AES signature.
     */
    public function sendForAdvancedSignature(string $filePath, int $userId, string $callbackUrl): array
    {
        try {
            $documentHash = hash_file('sha256', $filePath);

            $client = new Client();
            $response = $client->post("{$this->apiEndpoint}/sign-aes", [
                'headers' => $this->getAuthHeaders(),
                'multipart' => [
                    ['name' => 'file', 'contents' => fopen($filePath, 'r')],
                    ['name' => 'user_id', 'contents' => $userId],
                    ['name' => 'document_hash', 'contents' => $documentHash],
                    ['name' => 'callback_url', 'contents' => $callbackUrl],
                ],
            ]);

            return json_decode($response->getBody()->getContents(), true);
        } catch (Exception $e) {
            $this->logger->error("[api] Failed to send document for AES signing: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to send document for AES signing: " . $e->getMessage());
        }
    }

    /**
     * Verify an AES signature using Laravel HTTP client.
     */
    public function verifySignature(string $signedFilePath, string $originalFilePath): bool
    {
        try {
            $originalHash = hash_file('sha256', $originalFilePath);
            $signedHash = hash_file('sha256', $signedFilePath);
            
            $client = new Client();
            $response = $client->post("{$this->apiEndpoint}/verify-aes", [
                'headers' => $this->getAuthHeaders(),
                'json' => [
                    'original_hash' => $originalHash,
                    'signed_hash'   => $signedHash,
                ],
            ]);

            $result = json_decode($response->getBody()->getContents(), true);
            if (self::DEBUG_MODE) {
                $this->logger->info("[api] Signature verification", ['result' => $result]);
            }
            return $result['verified'] ?? false;
        } catch (Exception $e) {
            $this->logger->error("[api] Failed to verify signature: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to verify signature: " . $e->getMessage());
        }
    }

    /**
     * Retrieve stored local signatures for a user.
     */
    public function getSignatures(int $userId): array
    {
        $storedSignatures = $this->fileStorage->retrieveFiles("signatures/{$userId}");

        if (empty($storedSignatures)) {
            throw new Exception('No signatures found.');
        }

        return array_map(fn($path) => $this->encryptionService->decrypt($this->fileStorage->retrieveFile($path, false)), $storedSignatures);
    }

    /**
     * Check the status of an AES signature request.
     */
    public function checkAdvancedSignatureStatus(string $requestId): array
    {
        try {
            $client = new Client();
            $response = $client->get("{$this->apiEndpoint}/status/{$requestId}", [
                'headers' => $this->getAuthHeaders(),
            ]);

            return json_decode($response->getBody()->getContents(), true);
        } catch (Exception $e) {
            $this->logger->error("[api] Failed to check AES signature status: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to check AES signature status: " . $e->getMessage());
        }
    }

    /**
     * Download a signed AES document.
     */
    public function downloadSignedDocument(string $requestId, string $outputPath): bool
    {
        try {
            $client = new Client();
            $response = $client->get("{$this->apiEndpoint}/download/{$requestId}", [
                'headers' => $this->getAuthHeaders(),
                'sink' => $outputPath,
            ]);

            return $response->getStatusCode() === 200;
        } catch (Exception $e) {
            $this->logger->error("[api] Failed to download AES signed document: " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw new Exception("Failed to download AES signed document: " . $e->getMessage());
        }
    }

    /**
     * Get authentication headers for API requests.
     */
    private function getAuthHeaders(): array
    {
        return [
            'Authorization' => "Bearer {$this->apiKey}",
            'Content-Type'  => 'application/json',
        ];
    }

    /**
     * Validate allowed file types.
     */
    private function validateFileType(string $filePath): void
    {
        $allowedExtensions = ['png', 'jpg', 'svg'];
        if (!in_array(pathinfo($filePath, PATHINFO_EXTENSION), $allowedExtensions)) {
            throw new Exception('Invalid file type.');
        }
    }

    /**
     * Log error and throw exception.
     */
    private function logAndThrow(string $message, Exception $e): void
    {
        $this->logger->error($message, ['error' => $e->getMessage()]);
        throw new Exception("$message: " . $e->getMessage());
    }
}
=== App/Services/ReportService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use App\Models\Booking;
use App\Models\Payment;
use App\Models\User;
use Dompdf\Dompdf;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class ReportService
{
    public const DEBUG_MODE = true;
    private DatabaseHelper $db;
    private LoggerInterface $logger;
    private ExceptionHandler $exceptionHandler;

    public function __construct(LoggerInterface $logger, DatabaseHelper $db, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->db = $db;
        $this->exceptionHandler = $exceptionHandler;
    }    

    public function generateReport(string $reportType, array $dateRange, string $format, array $filters = []): string
    {
        $start = $dateRange['start'];
        $end   = $dateRange['end'];
        $data = match ($reportType) {
            'bookings' => $this->getBookingReportData($dateRange, $filters),
            'payments' => $this->getPaymentReportData($dateRange, $filters),
            'users'    => $this->getUserReportData($dateRange, $filters),
            default    => throw new \InvalidArgumentException("Invalid report type: $reportType"),
        };
        return $this->exportReport($data, "{$reportType}_" . date('YmdHis'), $format);
    }

    public function generateUserReport(int $userId, string $reportType, array $dateRange, string $format): string
    {
        $start = $dateRange['start'];
        $end   = $dateRange['end'];
        $data = match ($reportType) {
            'bookings' => Booking::with('user')
                         ->where('user_id', $userId)
                         ->whereBetween('created_at', [$start, $end])
                         ->get()
                         ->toArray(),
            'payments' => Payment::where('user_id', $userId)
                         ->whereBetween('created_at', [$start, $end])
                         ->get()
                         ->toArray(),
            default    => throw new \InvalidArgumentException("Invalid report type: $reportType"),
        };
        return $this->exportReport($data, "{$reportType}_user_{$userId}", $format);
    }

    private function getBookingReportData(array $dateRange, array $filters): array
    {
        try {
            $query = $this->db->table('bookings')->whereBetween('created_at', [$dateRange['start'], $dateRange['end']]);
            if (!empty($filters['status'])) {
                $query->where('status', $filters['status']);
            }
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Fetched booking report data", ['category' => 'report']);
            }
            return $query->get();
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error (booking): " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    private function getPaymentReportData(array $dateRange, array $filters): array
    {
        try {
            $query = $this->db->table('payments')->whereBetween('created_at', [$dateRange['start'], $dateRange['end']]);
            if (!empty($filters['type'])) {
                $query->where('type', $filters['type']);
            }
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Fetched payment report data", ['category' => 'report']);
            }
            return $query->get();
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error (payments): " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    private function getUserReportData(array $dateRange, array $filters): array
    {
        try {
            $data = $this->db->table('users')
                         ->whereBetween('created_at', [$dateRange['start'], $dateRange['end']])
                         ->get();
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Fetched user report data");
            }
            return $data;
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error (users): " . $e->getMessage());
            $this->exceptionHandler->handleException($e);
            throw $e;
        }
    }

    private function exportReport(array $data, string $reportName, string $format): string
    {
        $filePath = __DIR__ . "/../../storage/reports/{$reportName}_" . date('YmdHis') . ".{$format}";

        if ($format === 'csv') {
            $file = fopen($filePath, 'w');
            if (!empty($data)) {
                fputcsv($file, array_keys($data[0])); // headers
                foreach ($data as $row) {
                    fputcsv($file, $row);
                }
            }
            fclose($file);
        } elseif ($format === 'pdf') {
            $dompdf = new Dompdf();
            $html = '<table border="1"><tr>';
            if (!empty($data)) {
                foreach (array_keys($data[0]) as $header) {
                    $html .= "<th>$header</th>";
                }
                $html .= "</tr>";
                foreach ($data as $row) {
                    $html .= "<tr>";
                    foreach ($row as $cell) {
                        $html .= "<td>$cell</td>";
                    }
                    $html .= "</tr>";
                }
            }
            $html .= "</table>";
            $dompdf->loadHtml($html);
            $dompdf->render();
            file_put_contents($filePath, $dompdf->output());
        } else {
            throw new \InvalidArgumentException("Unsupported format: $format");
        }
        if (self::DEBUG_MODE) {
            $this->logger->info("[system] Exported report: {$filePath}");
        }
        return $filePath;
    }
}
=== App/Services/PaymentService.php ===
<?php

namespace App\Services;

use App\Helpers\DatabaseHelper;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

class PaymentService
{
    public const DEBUG_MODE = true;
    private LoggerInterface $logger;
    private $db;
    private ExceptionHandler $exceptionHandler;

    public function __construct(LoggerInterface $logger, DatabaseHelper $db, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->db = $db;
        $this->exceptionHandler = $exceptionHandler;
    }

    public function processPayment($user, array $paymentData)
    {
        if (empty($user) || empty($user['authenticated']) || !$user['authenticated']) {
            $this->logger->error("[PaymentService] Unauthenticated payment attempt", ['category' => 'auth']);
            return ['status' => 'error', 'message' => 'User not authenticated'];
        }

        if (!empty($paymentData['adminOnly']) && $paymentData['adminOnly'] === true && $user['role'] !== 'admin') {
            $this->logger->error("[PaymentService] Unauthorized admin transaction", ['category' => 'auth']);
            return ['status' => 'error', 'message' => 'Admin privileges required'];
        }

        try {
            $this->db->transaction(function () use ($paymentData) {
                // Insert payment record
                $this->db->table('payments')->insert([
                    'booking_id'     => $paymentData['bookingId'],
                    'amount'         => $paymentData['amount'],
                    'payment_method' => $paymentData['paymentMethod'],
                    'status'         => 'completed',
                    'created_at'     => now()
                ]);

                // Update booking status
                $booking = $this->db->table('bookings')
                                ->where('id', $paymentData['bookingId'])
                                ->first();
                if (!$booking) {
                    throw new \Exception("Booking not found");
                }
                $this->db->table('bookings')
                        ->where('id', $paymentData['bookingId'])
                        ->update(['status' => 'paid']);

                // Log transaction
                $this->db->table('transaction_logs')->insert([
                    'booking_id' => $paymentData['bookingId'],
                    'amount'     => $paymentData['amount'],
                    'type'       => 'payment',
                    'status'     => 'completed',
                    'created_at' => now()
                ]);
            });
            if (self::DEBUG_MODE) {
                $this->logger->info("[payment] Payment processed for booking {$paymentData['bookingId']}", ['category' => 'system']);
            }
            return ['status' => 'success', 'message' => 'Payment processed successfully'];
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error: " . $e->getMessage(), ['category' => 'db']);
            $this->exceptionHandler->handleException($e);
            return ['status' => 'error', 'message' => 'Payment processing failed'];
        }
    }

    public function processRefund(int $bookingId, float $amount): bool
    {
        try {
            $this->db->transaction(function () use ($bookingId, $amount) {
                $this->db->table('refund_logs')->insert([
                    'booking_id' => $bookingId,
                    'amount'     => $amount,
                    'status'     => 'processed',
                    'created_at' => now()
                ]);
                $booking = $this->db->table('bookings')
                                ->where('id', $bookingId)
                                ->first();
                if (!$booking) {
                    throw new \Exception("Booking not found");
                }
                $this->db->table('bookings')
                        ->where('id', $bookingId)
                        ->update(['refund_status' => 'processed']);

                $this->db->table('transaction_logs')->insert([
                    'booking_id' => $bookingId,
                    'amount'     => $amount,
                    'type'       => 'refund',
                    'status'     => 'completed',
                    'created_at' => now()
                ]);
            });
            if (self::DEBUG_MODE) {
                $this->logger->info("[payment] Refund processed for booking {$bookingId}", ['category' => 'system']);
            }
            return true;
        } catch (\Exception $e) {
            $this->logger->error("[db] Database error: " . $e->getMessage(), ['category' => 'db']);
            $this->exceptionHandler->handleException($e);
            return false;
        }
    }

    public function getMonthlyRevenueTrends(): array
    {
        try {
            $data = $this->db->table('payments')
                             ->where('status', 'completed')
                             ->selectRaw('MONTH(created_at) AS month, SUM(amount) AS total')
                             ->groupBy('month')
                             ->orderBy('month')
                             ->get();
            $this->logger->info("[PaymentService] Retrieved monthly revenue trends");
            return $data;
        } catch (\Exception $e) {
            $this->logger->error("[PaymentService] Database error: " . $e->getMessage());
            throw $e;
        }
    }
}
=== App/Services/PayUService.php ===
<?php

namespace App\Services;

use Exception;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use App\Helpers\DatabaseHelper; // new import
use Psr\Log\LoggerInterface; // ensure LoggerInterface is imported
use App\Helpers\ExceptionHandler;
require_once __DIR__ . '/../../config/payu.php';
/**
 * PayUService
 * 
 * Handles PayU API integration, including payment initialization, verification, and refunds.
 */
class PayUService
{
    public const DEBUG_MODE = true;
    private string $merchantKey;
    private string $merchantSalt;
    private string $endpoint;
    private $db; // DatabaseHelper instance
    private LoggerInterface $logger; // injected logger
    private ExceptionHandler $exceptionHandler;

    // Constructor updated to accept LoggerInterface
    public function __construct(array $config, LoggerInterface $logger, ExceptionHandler $exceptionHandler)
    {
        $this->merchantKey = $config['merchant_key'];
        $this->merchantSalt = $config['merchant_salt'];
        $this->endpoint = $config['endpoint'];
        $this->db = DatabaseHelper::getInstance();
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Initialize a payment transaction
     *
     * @param string $transactionId
     * @param float $amount
     * @param string $productInfo
     * @param string $customerEmail
     * @param string $customerPhone
     * @return array
     */
    public function initiatePayment(string $transactionId, float $amount, string $productInfo, string $customerEmail, string $customerPhone): array
    {
        $hash = $this->generateHash($transactionId, $amount, $productInfo, $customerEmail);

        $params = [
            'key' => $this->merchantKey,
            'txnid' => $transactionId,
            'amount' => $amount,
            'productinfo' => $productInfo,
            'firstname' => $customerEmail, // Assuming first name is derived from the email
            'email' => $customerEmail,
            'phone' => $customerPhone,
            'surl' => $this->endpoint . '/success', // Success callback URL
            'furl' => $this->endpoint . '/failure', // Failure callback URL
            'hash' => $hash,
            'service_provider' => 'payu_paisa'
        ];

        if (self::DEBUG_MODE) {
            $this->logger->info("[api] Initiating PayU payment", ['transactionId' => $transactionId, 'category' => 'api']);
        }

        $response = Http::post("{$this->endpoint}/_payment", $params);
        throw_if($response->failed(), Exception::class, 'Payment API error');
        return [
            'status' => 'success',
            'data'   => $response->json()
        ];
    }

    /**
     * Verify a payment transaction
     *
     * @param string $transactionId
     * @return array
     */
    public function verifyPayment(string $transactionId): array
    {
        $params = [
            'key' => $this->merchantKey,
            'command' => 'verify_payment',
            'var1' => $transactionId,
        ];

        if (self::DEBUG_MODE) {
            $this->logger->info("[api] Verifying PayU payment", ['transactionId' => $transactionId, 'category' => 'api']);
        }

        $response = Http::post("{$this->endpoint}/payment/verify", $params);
        throw_if($response->failed(), Exception::class, 'Payment verification error');
        return [
            'status' => 'success',
            'data'   => $response->json()
        ];
    }

    /**
     * Process a refund
     *
     * @param string $transactionId
     * @param float $amount
     * @return array
     */
    public function processRefund(string $transactionId, float $amount): array
    {
        $params = [
            'key' => $this->merchantKey,
            'command' => 'refund_transaction',
            'var1' => $transactionId,
            'var2' => $amount,
        ];

        try {
            $response = Http::post("{$this->endpoint}/refund", $params);
            throw_if($response->failed(), Exception::class, 'Refund processing error');
            $this->db->table('transaction_logs')->insert([
                'booking_id' => $transactionId,
                'amount'     => $amount,
                'type'       => 'refund',
                'status'     => 'completed'
            ]);
            if (self::DEBUG_MODE) {
                $this->logger->info("[db] Refund logged for transaction {$transactionId}", ['category' => 'db']);
            }
            return [
                'status' => 'success',
                'data'   => $response->json()
            ];
        } catch (Exception $e) {
            $this->logger->error("[payment] Refund processing error: " . $e->getMessage(), ['category' => 'system']);
            $this->exceptionHandler->handleException($e);
            return [
                'status' => 'error',
                'message' => 'Refund processing failed'
            ];
        }
    }

    /**
     * Generate hash for PayU API
     *
     * @param string $transactionId
     * @param float $amount
     * @param string $productInfo
     * @param string $customerEmail
     * @return string
     */
    private function generateHash(string $transactionId, float $amount, string $productInfo, string $customerEmail): string
    {
        $hashString = implode('|', [
            $this->merchantKey,
            $transactionId,
            $amount,
            $productInfo,
            $customerEmail,
            $this->merchantSalt
        ]);

        return hash('sha512', $hashString);
    }
}
=== App/Middleware/EncryptionMiddleware.php ===
<?php

namespace App\Middleware;

// Removed: use Illuminate\Http\Request;
// Removed: use Illuminate\Support\Facades\Log;
use Psr\Log\LoggerInterface;
use App\Services\EncryptionService;

class EncryptionMiddleware
{
    private LoggerInterface $logger;
    
    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }
    
    // Modified handle() to use native PHP request handling without Closure
    public function handle(array $request)
    {
        $uri = $_SERVER['REQUEST_URI'] ?? '/';
        if ($this->isSensitiveEndpoint($uri)) {
            $this->encryptRequestData($request);
        }

        // Process request (replace with your actual request processing)
        // ...existing code or processRequest($request)...
        $response = []; // Placeholder for processed response
        
        if ($this->isSensitiveEndpoint($uri)) {
            $response = $this->encryptResponseData(json_encode($response));
        }
        
        echo json_encode($response);
        exit;
    }
    
    // Modified to encrypt response data and return a string
    private function encryptResponseData(string $data): string
    {
        return EncryptionService::encrypt($data);
    }

    // Handle encryption on native request arrays (e.g., $_POST or $_GET)
    private function encryptRequestData(array &$request)
    {
        foreach ($request as $key => $value) {
            if ($this->isSensitiveField($key)) {
                $request[$key] = EncryptionService::encrypt($value);
            }
        }
    }

    // Load sensitive fields dynamically from configuration file
    private function isSensitiveField(string $field): bool
    {
        $configPath = __DIR__ . '/../../config/sensitive_fields.json';
        $config = file_exists($configPath) ? json_decode(file_get_contents($configPath), true) : [];
        $sensitiveFields = $config['sensitive_fields'] ?? ['password', 'email', 'phone'];
        return in_array($field, $sensitiveFields);
    }

    // Load sensitive endpoints dynamically from configuration file
    private function isSensitiveEndpoint(string $endpoint): bool
    {
        $configPath = __DIR__ . '/../../config/sensitive_endpoints.json';
        $config = file_exists($configPath) ? json_decode(file_get_contents($configPath), true) : [];
        $sensitiveEndpoints = $config['sensitive_endpoints'] ?? ['/user/profile-data'];
        return in_array($endpoint, $sensitiveEndpoints);
    }
    
    // Log events using injected LoggerInterface
    private function logEvent(string $message)
    {
        $this->logger->info("[EncryptionMiddleware] $message");
    }
}
=== App/Middleware/AuthMiddleware.php ===
<?php

namespace App\Middleware;

use App\Helpers\ApiHelper;
use App\Services\TokenService;
use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;

/**
 * AuthMiddleware - Handles authentication and authorization for API requests.
 * Ensures valid JWT tokens and role-based access control.
 */
class AuthMiddleware
{
    private TokenService $tokenService;
    private ExceptionHandler $exceptionHandler;
    private LoggerInterface $authLogger;
    private LoggerInterface $securityLogger;

    public function __construct(
        TokenService $tokenService,
        ExceptionHandler $exceptionHandler,
        LoggerInterface $authLogger,
        LoggerInterface $securityLogger
    ) {
        $this->tokenService = $tokenService;
        $this->exceptionHandler = $exceptionHandler;
        $this->authLogger = $authLogger;
        $this->securityLogger = $securityLogger;
    }

    /**
     * Handle authentication and authorization.
     * 
     * @param callable $next The next middleware function.
     * @param array $roles Required roles (e.g., 'admin').
     */
    public function handle(callable $next, ...$roles)
    {
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }

        try {
            // Retrieve and validate Authorization header
            $headers = getallheaders();
            if (!isset($headers['Authorization']) || !str_starts_with($headers['Authorization'], 'Bearer ')) {
                $this->authLogger->warning("Unauthorized access: Missing Authorization header.");
                ApiHelper::sendJsonResponse('error', 'Unauthorized', [], 401);
            }

            $token = substr($headers['Authorization'], 7);
            $decoded = $this->tokenService->validateToken($token);
            if (!$decoded) {
                $this->authLogger->warning("Invalid token detected.");
                ApiHelper::sendJsonResponse('error', 'Invalid token', [], 401);
            }

            // Store user details in session
            $_SESSION['user_id'] = $decoded['sub'] ?? null;
            $_SESSION['user_role'] = $decoded['role'] ?? 'guest';
            
            // Role-based access control
            if (!empty($roles) && !in_array($_SESSION['user_role'], $roles)) {
                $this->securityLogger->warning("Unauthorized role access attempt.", [
                    'userId' => $_SESSION['user_id'],
                    'requiredRoles' => $roles
                ]);
                ApiHelper::sendJsonResponse('error', 'Forbidden', [], 403);
            }

            $this->authLogger->info("✅ User authenticated.", [
                'userId' => $_SESSION['user_id'],
                'role' => $_SESSION['user_role']
            ]);

            return $next();
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }
}
=== App/Middleware/AuditTrailMiddleware.php ===
<?php

namespace App\Middleware;

use AuditManager\Services\AuditService;
use Psr\Log\LoggerInterface;

/**
 * AuditTrailMiddleware - Logs user actions for audit tracking.
 */
class AuditTrailMiddleware
{
    private AuditService $auditService;
    private LoggerInterface $logger;

    public function __construct(AuditService $auditService, LoggerInterface $logger)
    {
        $this->auditService = $auditService;
        $this->logger = $logger;
    }

    /**
     * Handle an incoming request and log relevant details.
     *
     * @param array $request The request data.
     * @param callable $next The next middleware function.
     */
    public function handle(array $request, callable $next)
    {
        try {
            // Extract request details
            $action = $this->determineAction();
            $details = json_encode($this->sanitizeRequestData($request));
            $userId = $_SESSION['user_id'] ?? null;
            $ipAddress = $_SERVER['REMOTE_ADDR'] ?? 'unknown';

            // Log the action
            $this->auditService->log($action, $details, $userId, $ipAddress);

            // Continue to the next middleware/controller
            return $next($request);
        } catch (\Exception $e) {
            $this->logger->error('[AuditTrail] Failed to log action', ['error' => $e->getMessage()]);
            return $next($request); // Allow the request to proceed even if logging fails
        }
    }

    /**
     * Determine the action performed based on the request.
     *
     * @return string
     */
    private function determineAction(): string
    {
        return $_SERVER['REQUEST_METHOD'] . ' ' . ($_SERVER['REQUEST_URI'] ?? 'unknown');
    }

    /**
     * Sanitize request data before logging.
     *
     * @param array $request The raw request data.
     * @return array The sanitized request data.
     */
    private function sanitizeRequestData(array $request): array
    {
        unset($request['password'], $request['token']); // Remove sensitive fields
        return $request;
    }
}
=== App/Helpers/ViewHelper.php ===
<?php

function view($viewName, $data = [])
{
    $viewPath = BASE_PATH . "/App/Views/{$viewName}.php";

    if (!file_exists($viewPath)) {
        die("❌ View not found: {$viewName}");
    }

    extract($data); // Extract data for use inside views
    require $viewPath;
}
=== App/Helpers/SecurityHelper.php ===
<?php

namespace App\Helpers;

use Psr\Log\LoggerInterface;
use Firebase\JWT\JWT;

class SecurityHelper
{
    // Security Configuration
    const SESSION_CONFIG = [
        'use_only_cookies'        => 1,
        'use_strict_mode'         => 1,
        'cookie_httponly'         => 1,
        'cookie_samesite'         => 'Lax',
        'gc_maxlifetime'          => 3600,
        'cookie_lifetime'         => 0,
        'use_trans_sid'           => 0,
        'sid_bits_per_character'  => 6
    ];

    // Standardized Logging Function
    public static function securityLog(LoggerInterface $logger, $message, $level = 'info', $category = 'Security')
    {
        if ($logger && method_exists($logger, 'log')) {
            $logger->log($level, "[$category] $message");
        } else {
            error_log("[$category][$level] $message");
        }
    }

    // Log authentication events
    public static function logAuthEvent($message, $level = 'info')
    {
        self::securityLog(null, $message, $level, 'Auth');
    }

    // Helper to log authentication failures
    public static function logAuthFailure($message)
    {
        self::securityLog(null, $message, 'error', 'Auth');
    }

    // Secure Session Handling using native PHP sessions
    public static function startSecureSession()
    {
        if (session_status() === PHP_SESSION_NONE) {
            ini_set('session.use_only_cookies', 1);
            ini_set('session.use_strict_mode', 1);
            ini_set('session.cookie_httponly', 1);
            ini_set('session.cookie_samesite', 'Lax');
            session_start();
        }
        return true;
    }

    // Refresh session to extend its duration
    public static function refreshSession()
    {
        $logFile = __DIR__ . '/../../logs/security.log';
        $timestamp = date('Y-m-d H:i:s');

        try {
            if (session_status() === PHP_SESSION_ACTIVE) {
                $_SESSION['last_activity'] = time();
                session_regenerate_id(true);
                error_log("[$timestamp][info] Session refreshed\n", 3, $logFile);
            }
        } catch (Exception $e) {
            error_log("[$timestamp][error] Session refresh failed: " . $e->getMessage() . "\n", 3, $logFile);
        }
    }

    // Replace Laravel session calls with native PHP for session expiry enforcement
    public static function enforceSessionExpiry(LoggerInterface $logger)
    {
        if (!isset($_SESSION['last_activity'])) {
            $_SESSION['last_activity'] = time();
            return;
        }
        if (time() - $_SESSION['last_activity'] > 1800) { // 30 min timeout
            self::securityLog($logger, 'Session expired due to inactivity', 'info');
            $_SESSION = [];
            if (ini_get('session.use_cookies')) {
                setcookie(session_name(), '', time() - 42000, '/');
            }
            session_destroy();
        }
    }

    // Fingerprint-Based Session Integrity Check
    public static function validateSessionIntegrity(LoggerInterface $logger)
    {
        $currentIp = hash('sha256', $_SERVER['REMOTE_ADDR']);
        $currentAgent = hash('sha256', $_SERVER['HTTP_USER_AGENT']);

        if (!isset($_SESSION['client_ip'])) {
            $_SESSION['client_ip'] = $currentIp;
            $_SESSION['user_agent'] = $currentAgent;
            return true;
        }
        if ($_SESSION['client_ip'] !== $currentIp || $_SESSION['user_agent'] !== $currentAgent) {
            self::securityLog($logger, 'Session integrity check failed: Mismatch detected', 'warning');
            $_SESSION = [];
            if (ini_get('session.use_cookies')) {
                setcookie(session_name(), '', time() - 42000, '/');
            }
            session_destroy();
            return false;
        }
        return true;
    }

    // Sanitize user input to prevent XSS
    public static function sanitizeInput($data)
    {
        if (!isset($data) || $data === null) {
            $data = ''; // Default to empty string to prevent undefined variable errors
        }
        $cleanedData = trim((string)$data);
        return htmlspecialchars($cleanedData, ENT_QUOTES, 'UTF-8');
    }

    // Generate secure random string (for password resets, API keys, etc.)
    public static function generateSecureToken($length = 64)
    {
        return bin2hex(random_bytes($length / 2));
    }

    // Secure Session Destruction using native PHP
    public static function destroySession(LoggerInterface $logger)
    {
        self::securityLog($logger, 'Destroying session', 'info');
        $_SESSION = [];
        if (ini_get('session.use_cookies')) {
            setcookie(session_name(), '', time() - 42000, '/');
        }
        session_destroy();
        self::securityLog($logger, 'Session destroyed successfully', 'info');
    }

    // Check if a user is logged in
    public static function isUserLoggedIn()
    {
        return isset($_SESSION['user_id']);
    }

    // Get the logged-in user's role
    public static function getUserRole()
    {
        return isset($_SESSION['user_id']) ? ($_SESSION['user_role'] ?? 'guest') : 'guest';
    }

    // Get session data safely
    public static function getSessionData($key)
    {
        return $_SESSION[$key] ?? null;
    }

    // Set session data safely
    public static function setSessionData($key, $value)
    {
        $_SESSION[$key] = $value;
    }

    // Validate JWT token
    public static function validateJWT($token)
    {
        // Replace Laravel's authentication with a native JWT approach or session check.
        // For example, decode using firebase/php-jwt, here we simply check session.
        return $_SESSION['user_id'] ?? null;
    }

    // Enforce authentication for protected pages
    public static function requireUserAuth()
    {
        return self::requireAuth();
    }

    // Custom Authentication Enforcement
    public static function requireAuth($allowGuest = false)
    {
        if (isset($_SESSION['user_id'])) {
            return $_SESSION['user_id'];
        }
        if ($allowGuest) {
            return null;
        }
        header('Content-Type: application/json');
        http_response_code(401);
        echo json_encode(['error' => 'Unauthorized']);
        exit;
    }

    // CSRF Token Generation
    public static function generateCsrfToken()
    {
        if (!isset($_SESSION['csrf_token'])) {
            $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
        }
        return $_SESSION['csrf_token'];
    }

    // Validate CSRF token in POST requests
    public static function validateCsrfToken($token)
    {
        return isset($_SESSION['csrf_token']) && $_SESSION['csrf_token'] === $token;
    }

    // Return structured JSON response
    public static function jsonResponse($data, $statusCode = 200)
    {
        header('Content-Type: application/json');
        http_response_code($statusCode);
        echo json_encode($data);
        exit;
    }
}

// Initialize secure session when the file is included
if (!SecurityHelper::startSecureSession()) {
    SecurityHelper::securityLog(null, 'Critical: Failed to initialize secure session', 'critical');
}
?>
=== App/Helpers/ExceptionHandler.php ===
<?php
namespace App\Helpers;

use Illuminate\Database\QueryException;
use Illuminate\Database\UniqueConstraintViolationException;
use PDOException;
use Exception;
use Psr\Log\LoggerInterface;

class ExceptionHandler
{
    private LoggerInterface $dbLogger;
    private LoggerInterface $authLogger;
    private LoggerInterface $systemLogger;

    public function __construct(
        LoggerInterface $dbLogger,
        LoggerInterface $authLogger,
        LoggerInterface $systemLogger
    ) {
        $this->dbLogger = $dbLogger;
        $this->authLogger = $authLogger;
        $this->systemLogger = $systemLogger;
    }

    /**
     * Handle exceptions centrally.
     */
    public function handleException(Exception $e): void
    {
        // Database-related exceptions
        if ($e instanceof UniqueConstraintViolationException || $e instanceof PDOException) {
            $this->dbLogger->error("❌ Database Error: " . $e->getMessage(), ['trace' => $e->getTraceAsString()]);
            ApiHelper::sendJsonResponse('error', 'Database error', ['error' => $e->getMessage()], 400);
        }
        // Query exceptions
        elseif ($e instanceof QueryException) {
            $this->dbLogger->error("❌ Query Error: " . $e->getMessage(), ['trace' => $e->getTraceAsString()]);
            ApiHelper::sendJsonResponse('error', 'Query error', ['error' => $e->getMessage()], 400);
        }
        // Authentication exceptions (if applicable)
        // elseif ($e instanceof AuthenticationException) {
        //     $this->authLogger->error("❌ Authentication Error: " . $e->getMessage(), ['trace' => $e->getTraceAsString()]);
        //     ApiHelper::sendJsonResponse('error', 'Authentication error', ['error' => $e->getMessage()], 401);
        // }
        // Other exceptions
        else {
            $this->systemLogger->error("❌ System Error: " . $e->getMessage(), ['trace' => $e->getTraceAsString()]);
            ApiHelper::sendJsonResponse('error', 'Unexpected error occurred', ['error' => $e->getMessage()], 500);
        }
        exit();
    }
}
?>=== App/Helpers/ApiHelper.php ===
<?php

namespace App\Helpers;

/**
 * API Helper Functions
 */
class ApiHelper
{
    /**
     * ✅ Log API Events for Debugging
     */
    public static function logApiEvent($message)
    {
        $timestamp = date('Y-m-d H:i:s');
        $logFile = __DIR__ . '/../../logs/api.log';
        file_put_contents($logFile, "{$timestamp} - {$message}\n", FILE_APPEND);
    }

    /**
     * ✅ Standardized JSON Response Function
     */
    public static function sendJsonResponse($status, $message, $data = [], $httpCode = 200)
    {
        http_response_code($httpCode);
        header('Content-Type: application/json');
        echo json_encode(['status' => $status, 'message' => $message, 'data' => $data]);
        exit();
    }

    /**
     * ✅ Extract JWT from Authorization Header or Cookie
     */
    public static function getJWT()
    {
        $headers = getallheaders();
        if (isset($headers['Authorization']) && preg_match('/Bearer\s(\S+)/', $headers['Authorization'], $matches)) {
            return $matches[1];
        }
        return $_COOKIE['jwt'] ?? null;
    }
}
=== App/Helpers/DatabaseHelper.php ===
<?php

namespace App\Helpers;

use Illuminate\Database\Capsule\Manager as Capsule;
use Exception;
use Psr\Log\LoggerInterface;
use App\Helpers\ApiHelper;

class DatabaseHelper
{
    private static ?DatabaseHelper $instance = null;
    private static ?DatabaseHelper $secureInstance = null;
    private Capsule $capsule;
    private static LoggerInterface $logger;

    private function __construct(array $config)
    {
        try {
            $this->capsule = new Capsule();
            $this->capsule->addConnection($config);
            $this->capsule->setAsGlobal();
            $this->capsule->bootEloquent();

            // ✅ Log successful initialization
            self::$logger->info("✅ Database connection initialized successfully.");
        } catch (Exception $e) {
            self::$logger->critical("❌ Database connection failed: " . $e->getMessage());
            die("Database connection failed. Check logs for details.");
        }
    }

    public static function setLogger(LoggerInterface $logger)
    {
        if (!isset(self::$logger)) {
            self::$logger = $logger;
        }
    }

    private static function getDatabaseConfig(array $envConfig, string $type = 'default'): array
    {
        if ($type === 'secure') {
            return [
                'driver'    => $envConfig['SECURE_DB_DRIVER'] ?? 'mysql',
                'host'      => $envConfig['SECURE_DB_HOST'] ?? 'localhost',
                'port'      => $envConfig['SECURE_DB_PORT'] ?? '3306',
                'database'  => $envConfig['SECURE_DB_DATABASE'] ?? '',
                'username'  => $envConfig['SECURE_DB_USERNAME'] ?? '',
                'password'  => $envConfig['SECURE_DB_PASSWORD'] ?? '',
                'charset'   => $envConfig['SECURE_DB_CHARSET'] ?? 'utf8mb4',
                'collation' => $envConfig['SECURE_DB_COLLATION'] ?? 'utf8mb4_unicode_ci',
                'prefix'    => '',
            ];
        }

        return [
            'driver'    => $envConfig['DB_DRIVER'] ?? 'mysql',
            'host'      => $envConfig['DB_HOST'] ?? 'localhost',
            'port'      => $envConfig['DB_PORT'] ?? '3306',
            'database'  => $envConfig['DB_DATABASE'] ?? '',
            'username'  => $envConfig['DB_USERNAME'] ?? '',
            'password'  => $envConfig['DB_PASSWORD'] ?? '',
            'charset'   => $envConfig['DB_CHARSET'] ?? 'utf8mb4',
            'collation' => $envConfig['DB_COLLATION'] ?? 'utf8mb4_unicode_ci',
            'prefix'    => '',
        ];
    }

    public static function getInstance(array $envConfig): DatabaseHelper
    {
        if (self::$instance === null) {
            try {
                self::$instance = new DatabaseHelper(self::getDatabaseConfig($envConfig, 'default'));
            } catch (Exception $e) {
                self::$logger->critical("❌ Database initialization failed: " . $e->getMessage());
                die("Database initialization failed.");
            }
        }

        return self::$instance;
    }

    public static function getSecureInstance(array $envConfig): DatabaseHelper
    {
        if (self::$secureInstance === null) {
            try {
                self::$secureInstance = new DatabaseHelper(self::getDatabaseConfig($envConfig, 'secure'));
            } catch (Exception $e) {
                self::$logger->critical("❌ Secure database initialization failed: " . $e->getMessage());
                die("Secure database initialization failed.");
            }
        }

        return self::$secureInstance;
    }

    public function getCapsule(): Capsule
    {
        return $this->capsule;
    }

    public function getConnection()
    {
        try {
            return $this->capsule->getConnection();
        } catch (Exception $e) {
            self::$logger->error("❌ Failed to get database connection: " . $e->getMessage());
            return null;
        }
    }

    /**
     * ✅ Safe Query Execution with Exception Handling
     */
    public static function safeQuery(callable $query)
    {
        try {
            return $query(self::getInstance()->getCapsule());
        } catch (\PDOException $e) {
            self::$logger->error("❌ Database Query Error: " . $e->getMessage(), ['trace' => $e->getTraceAsString()]);
            if ($e->getCode() == "23000") {
                return ApiHelper::sendJsonResponse('error', 'Duplicate entry error', [], 400);
            }
            return ApiHelper::sendJsonResponse('error', 'Database query error', [], 500);
        } catch (\Exception $e) {
            self::$logger->error("❌ Database Query Error: " . $e->getMessage(), ['trace' => $e->getTraceAsString()]);
            return ApiHelper::sendJsonResponse('error', 'Database query error', [], 500);
        }
    }

    /**
     * ✅ Wrapper for Insert Queries
     */
    public static function insert($table, $data)
    {
        return self::safeQuery(fn ($db) => $db->table($table)->insertGetId($data));
    }

    /**
     * ✅ Wrapper for Update Queries
     */
    public static function update($table, $data, $where)
    {
        return self::safeQuery(fn ($db) => $db->table($table)->where($where)->update($data));
    }

    /**
     * ✅ Wrapper for Delete Queries
     */
    public static function delete($table, $where)
    {
        return self::safeQuery(fn ($db) => $db->table($table)->where($where)->delete());
    }

    /**
     * ✅ Wrapper for Select Queries
     */
    public static function select($query, $params = [])
    {
        return self::safeQuery(fn ($db) => $db->select($query, $params));
    }
}
=== App/api.php ===
<?php

require_once __DIR__ . '/../vendor/autoload.php';
require_once __DIR__ . '/../App/Helpers/SecurityHelper.php';

use Firebase\JWT\JWT;
use Firebase\JWT\Key;

// ✅ Load encryption keys
$config = require __DIR__ . '/encryption.php';
$jwtSecret = $config['jwt_secret'] ?? '';

header('Content-Type: application/json');

// ✅ Log Incoming Headers and Cookies
$tmpHeaders = getallheaders();
if (isset($tmpHeaders['X-Auth-Token'])) {
    $tmpHeaders['X-Auth-Token'] = 'Bearer <redacted>';
}
$tmpCookies = $_COOKIE;
if (isset($tmpCookies['jwt'])) {
    $tmpCookies['jwt'] = '<redacted>';
}
error_log("[API DEBUG] " . date('Y-m-d H:i:s') . " - Headers: " . json_encode($tmpHeaders) . "\n", 3, __DIR__ . '/../logs/debug.log');
error_log("[API DEBUG] " . date('Y-m-d H:i:s') . " - Cookies: " . json_encode($tmpCookies) . "\n", 3, __DIR__ . '/../logs/debug.log');

// ✅ Extract JWT from X-Auth-Token Header or Cookie
function getJWT() {
    $headers = getallheaders();
    if (isset($headers['X-Auth-Token']) && preg_match('/Bearer\s+(\S+)/', $headers['X-Auth-Token'], $matches)) {
        return trim($matches[1]);
    }
    return isset($_COOKIE['jwt']) ? trim($_COOKIE['jwt']) : null;
}

// ✅ Validate JWT and Decode User Info
function validateToken() {
    global $jwtSecret;

    $jwt = getJWT();
    if (!$jwt) {
        logApiError("Missing JWT");
        http_response_code(401);
        echo json_encode(["error" => "Unauthorized: Missing token"]);
        exit;
    }

    try {
        return (array) JWT::decode($jwt, new Key($jwtSecret, 'HS256'));
    } catch (Exception $e) {
        logApiError("Invalid JWT: " . $e->getMessage());
        http_response_code(401);
        echo json_encode(["error" => "Unauthorized: Invalid token"]);
        exit;
    }
}

// ✅ Log API Errors for Debugging
function logApiError($message) {
    error_log("[API] " . date('Y-m-d H:i:s') . " - {$message}\n", 3, __DIR__ . '/../logs/debug.log');
}

// ✅ CORS Handling (Apply to All Requests)
header('Access-Control-Allow-Origin: *');
header('Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, X-Auth-Token');

// ✅ Handle CORS Preflight Requests
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    exit;
}

// ✅ Parse API request
$requestUri = $_SERVER['REQUEST_URI'];
$apiPath = trim(str_replace('/api/', '', parse_url($requestUri, PHP_URL_PATH)), '/');

// ✅ Hardcoded Public API Routes
$publicApiRoutes = [
    'auth/login' => '/../public/api/auth/login.php',
    'auth/logout' => '/../public/api/auth/logout.php',
    'auth/register' => '/../public/api/auth/register.php',
    'auth/reset_request' => '/../public/api/auth/reset_request.php',
    'home' => '/../public/api/home.php',
    'vehicles' => '/../public/api/vehicles.php',
];

// ✅ Hardcoded Protected API Routes (Require Authentication)
$protectedApiRoutes = [
    'user/dashboard' => '/../public/api/user/dashboard.php',
    'user/profile' => '/../public/api/user/profile.php',
    'user/reports' => '/../public/api/user/reports.php',
    'user/notifications' => '/../public/api/user/notifications.php',
    'user/documents' => '/../public/api/user/documents.php',
    'payments/history' => '/../public/api/payments/history.php',
    'payments/make_payment' => '/../public/api/payments/make_payment.php',
    'payments/methods' => '/../public/api/payments/methods.php',
    'payments/refund' => '/../public/api/payments/refund.php',
];

// ✅ Ensure API Route Exists
if (isset($protectedApiRoutes[$apiPath])) {
    validateToken();
    $apiFile = __DIR__ . $protectedApiRoutes[$apiPath];
} elseif (isset($publicApiRoutes[$apiPath])) {
    $apiFile = __DIR__ . $publicApiRoutes[$apiPath];
} else {
    logApiError("API Endpoint Not Found: $apiPath");
    http_response_code(404);
    echo json_encode(['error' => 'API not found']);
    exit;
}

// ✅ Include API File
if (file_exists($apiFile)) {
    logApiError("Processing API endpoint: $apiPath");
    require_once $apiFile;
} else {
    logApiError("API File Not Found: $apiFile");
    http_response_code(404);
    echo json_encode(['error' => 'API file not found']);
}
