=== App/Controllers/UserController.php ===
<?php

namespace App\Controllers;

use App\Helpers\ApiHelper;
use App\Helpers\ExceptionHandler;
use App\Services\Validator;
use App\Services\Auth\TokenService;
use App\Services\AuditService;
use App\Services\Auth\AuthService;
use App\Models\User; // Inject User model
use Psr\Log\LoggerInterface;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;

/**
 * User Management Controller
 *
 * Handles profile management, password resets, and dashboard access.
 */
class UserController extends Controller
{
    private Validator $validator;
    private TokenService $tokenService;
    protected ExceptionHandler $exceptionHandler;
    protected LoggerInterface $logger;
    private AuthService $authService;
    private AuditService $auditService;
    private User $userModel; // Added User model

    public function __construct(
        LoggerInterface $logger,
        Validator $validator,
        TokenService $tokenService,
        ExceptionHandler $exceptionHandler,
        AuthService $authService,
        AuditService $auditService,
        User $userModel // Injected dependency
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->validator     = $validator;
        $this->tokenService  = $tokenService;
        $this->exceptionHandler = $exceptionHandler;
        $this->authService   = $authService;
        $this->auditService  = $auditService;
        $this->userModel     = $userModel;
    }

    /**
     * Register a new user.
     */
    public function registerUser(Request $request, Response $response)
    {
        try {
            $data = json_decode($request->getBody()->getContents(), true);
            $this->logger->info("Processing user registration", ['email' => $data['email'] ?? 'not provided']);

            $rules = [
                'email'    => 'required|email',
                'password' => 'required|min:6',
                'name'     => 'required|string',
            ];
            $this->validator->validate($data, $rules);

            // Check if email is already in use via User model
            if ($this->userModel->findByEmail($data['email'])) {
                return ApiHelper::sendJsonResponse('error', 'Email already in use', [], 400);
            }
            
            // Prepare and create new user (User model handles password hashing and timestamps)
            $data['role'] = 'user';
            $userId = $this->userModel->createWithDefaultRole($data);
            
            // Removed direct audit logging – User model handles logging after creation
            
            $this->logger->info("User registered successfully", [
                'user_id' => $userId,
                'email' => $data['email']
            ]);
            return ApiHelper::sendJsonResponse('success', 'User registered successfully', ['user_id' => $userId], 201);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ApiHelper::sendJsonResponse('error', 'Registration failed', [], 500);
        }
    }

    /**
     * Retrieve current user profile.
     */
    public function getUserProfile(Request $request, Response $response)
    {
        try {
            $user = $this->tokenService->validateRequest($request);
            if (!$user) {
                return ApiHelper::sendJsonResponse('error', 'User not authenticated', [], 401);
            }
            $userId = $user['id'];
            $this->logger->info("Fetching user profile", ['user_id' => $userId]);

            // Fetch user profile using the model
            $userData = $this->userModel->find($userId);
            if (!$userData) {
                return ApiHelper::sendJsonResponse('error', 'User not found', [], 404);
            }
            
            // Log profile view via AuditService if needed
            $this->auditService->logEvent('profile_viewed', 'User viewed their profile', ['user_id' => $userId], $userId, null, 'user');

            return ApiHelper::sendJsonResponse('success', 'User profile retrieved', $userData, 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ApiHelper::sendJsonResponse('error', 'Failed to retrieve profile', [], 500);
        }
    }

    /**
     * Update user profile.
     */
    public function updateProfile(Request $request, Response $response)
    {
        try {
            $user = $this->tokenService->validateRequest($request);
            if (!$user) {
                return ApiHelper::sendJsonResponse('error', 'User not authenticated', [], 401);
            }
            $userId = $user['id'];

            $data = json_decode($request->getBody()->getContents(), true);
            $this->logger->info("Updating user profile", ['user_id' => $userId]);

            $rules = [
                'name'       => 'string|max:100',
                'bio'        => 'string|max:500',
                'location'   => 'string|max:100',
                'avatar_url' => 'url|max:255'
            ];
            $this->validator->validate($data, $rules);

            // Delegate profile update to the User model logic
            $this->userModel->updateProfile($userId, $data);

            $this->auditService->logEvent('profile_updated', 'User updated their profile', ['user_id' => $userId, 'fields_updated' => array_keys($data)], $userId, null, 'user');

            // Retrieve updated profile
            $updatedProfile = $this->userModel->find($userId);
            return ApiHelper::sendJsonResponse('success', 'Profile updated successfully', $updatedProfile, 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ApiHelper::sendJsonResponse('error', 'Failed to update profile', [], 500);
        }
    }

    /**
     * Request password reset.
     */
    public function requestPasswordReset(Request $request, Response $response)
    {
        try {
            $data = json_decode($request->getBody()->getContents(), true);
            if (!isset($data['email']) || !filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
                return ApiHelper::sendJsonResponse('error', 'Valid email is required', [], 400);
            }
            
            $this->logger->info("Processing password reset request", ['email' => $data['email']]);
            $user = $this->userModel->findByEmail($data['email']);
            if (!$user) {
                $this->logger->info("Password reset requested for non-existent email", ['email' => $data['email']]);
                return ApiHelper::sendJsonResponse('success', 'If your email is in our system, you will receive reset instructions shortly', [], 200);
            }
            
            $token    = bin2hex(random_bytes(30));
            $expiresAt = date('Y-m-d H:i:s', strtotime('+1 hour'));
            $ipAddress = $_SERVER['REMOTE_ADDR'] ?? null;

            // Use model method to create reset token
            $this->userModel->createPasswordReset($data['email'], $token, $ipAddress, $expiresAt);
            $this->auditService->logEvent('password_reset_requested', 'Password reset requested', ['email' => $data['email'], 'expires_at' => $expiresAt], $user['id'], null, 'user');
            
            return ApiHelper::sendJsonResponse('success', 'Password reset instructions sent to your email', [], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return ApiHelper::sendJsonResponse('error', 'Failed to process password reset request', [], 500);
        }
    }

    /**
     * Reset password with token.
     */
    public function resetPassword(Request $request, Response $response)
    {
        try {
            $data = json_decode($request->getBody()->getContents(), true);
            if (!isset($data['token']) || !isset($data['password']) || strlen($data['password']) < 6) {
                return ApiHelper::sendJsonResponse('error', 'Token and password (min 6 chars) required', [], 400);
            }
            
            $this->logger->info("Processing password reset with token");
            $tokenData = $this->userModel->verifyResetToken($data['token']);
            if (!$tokenData) {
                $this->logger->warning("Invalid or expired password reset token used");
                return ApiHelper::sendJsonResponse('error', 'Invalid or expired token', [], 400);
            }
            $email = $tokenData['email'];
            $user = $this->userModel->findByEmail($email);
            if (!$user) {
                $this->logger->warning("User not found for password reset", ['email' => $email]);
                return ApiHelper::sendJsonResponse('error', 'User not found', [], 404);
            }
            
            // Update user's password using model method
            $this->userModel->updatePassword($user['id'], $data['password']);
            // Optionally, mark the token as used if desired (User model provides markResetTokenUsed)
            
            $this->logger->info("Password reset successful", [
                'user_id' => $user['id'],
                'email' => $email
            ]);
            return ApiHelper::sendJsonResponse('success', 'Password has been reset successfully', [], 200);
        } catch (\Exception $e) {
            $this->logger->error("Failed to reset password", [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            return ApiHelper::sendJsonResponse('error', 'Failed to reset password', [], 500);
        }
    }

    /**
     * User dashboard access.
     */
    public function userDashboard(Request $request, Response $response)
    {
        try {
            $user = $this->tokenService->validateRequest($request);
            if (!$user) {
                return ApiHelper::sendJsonResponse('error', 'User not authenticated', [], 401);
            }

            $userId = $user['id'];
            $this->logger->info("User accessing dashboard", ['user_id' => $userId]);

            // Replace direct DB calls with model methods
            $userData = $this->userModel->find($userId);
            if (!$userData) {
                return ApiHelper::sendJsonResponse('error', 'User not found', [], 404);
            }

            // Get recent activity from model
            $recentActivity = $this->userModel->getRecentActivity($userId, 5);

            // Log activity via model
            $this->userModel->logActivity($userId, 'dashboard_access', 'User accessed their dashboard', $_SERVER['REMOTE_ADDR'] ?? null);

            $dashboardData = [
                'user' => $userData,
                'recent_activity' => $recentActivity
            ];

            return ApiHelper::sendJsonResponse('success', 'User Dashboard', $dashboardData, 200);
        } catch (\Exception $e) {
            $this->logger->error("Failed to load user dashboard", [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
                'user_id' => $request->getAttribute('user_id') ?? 'unknown'
            ]);
            return ApiHelper::sendJsonResponse('error', 'Failed to load dashboard', [], 500);
        }
    }
}
=== App/Controllers/ViewHelper.php ===
<?php

function view($viewName, $data = [])
{
    $viewPath = BASE_PATH . "/App/Views/{$viewName}.php";

    if (!file_exists($viewPath)) {
        die("❌ View not found: {$viewName}");
    }

    extract($data); // Extract data for use inside views
    require $viewPath;
}
=== App/Controllers/BookingController.php ===
<?php

namespace App\Controllers;

use App\Models\RefundLog;
use App\Services\AuthService;
use App\Services\AuditService;
use App\Services\BookingService;
use App\Services\PaymentService;
use App\Services\NotificationService;
use App\Services\Auth\TokenService;
use App\Helpers\ExceptionHandler;
use App\Services\Validator;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Log\LoggerInterface;

require_once   'ViewHelper.php';

/**
 * Booking Controller
 *
 * Handles booking operations, including creating, rescheduling,
 * canceling bookings, and fetching booking details or logs.
 */
class BookingController extends Controller
{
    private BookingService $bookingService;
    private PaymentService $paymentService;
    private Validator $validator;
    private AuditService $auditService;
    private NotificationService $notificationService;
    private ResponseFactoryInterface $responseFactory;
    protected LoggerInterface $logger;
    private TokenService $tokenService;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        BookingService $bookingService,
        PaymentService $paymentService,
        Validator $validator,
        AuditService $auditService,
        NotificationService $notificationService,
        ResponseFactoryInterface $responseFactory,
        TokenService $tokenService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->bookingService = $bookingService;
        $this->paymentService = $paymentService;
        $this->validator = $validator;
        $this->auditService = $auditService;
        $this->notificationService = $notificationService;
        $this->responseFactory = $responseFactory;
        $this->tokenService = $tokenService;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Create standardized PSR-7 JSON response
     */
    public function jsonResponse(ResponseInterface $response, $data, $status = 200): ResponseInterface
    {
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json')->withStatus($status);
    }

    /**
     * View Booking Details
     */
    public function viewBooking(int $id): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $booking = $this->bookingService->getBookingById($id);
            
            // Audit log for viewing booking
            $this->auditService->logEvent(
                'booking_viewed',
                "Booking #{$id} details viewed",
                ['booking_id' => $id, 'user_id' => $user['id']],
                $user['id'],
                $id,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking details fetched',
                'data' => ['booking' => $booking]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch booking details'
            ], 500);
        }
    }

    /**
     * Reschedule Booking
     */
    public function rescheduleBooking(int $id): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $data = $this->validator->validate($_POST, [
                'pickup_date' => 'required|date',
                'dropoff_date' => 'required|date|after:pickup_date'
            ]);
            
            if ($this->validator->failed()) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Validation error',
                    'errors' => $this->validator->errors()
                ], 400);
            }
            
            // Let the service handle the business logic
            $result = $this->bookingService->rescheduleBooking($id, $data['pickup_date'], $data['dropoff_date'], $user['id']);
            
            if (isset($result['error'])) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => $result['error']
                ], 400);
            }
            
            // Audit the rescheduling action
            $this->auditService->logEvent(
                'booking_rescheduled',
                "Booking #{$id} rescheduled",
                [
                    'booking_id' => $id,
                    'user_id' => $user['id'],
                    'new_pickup' => $data['pickup_date'],
                    'new_dropoff' => $data['dropoff_date']
                ],
                $user['id'],
                $id,
                'booking'
            );
            
            // Send notification about rescheduled booking
            $this->notificationService->sendBookingUpdatedNotification($id, $user['id']);
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking rescheduled successfully'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to reschedule booking'
            ], 500);
        }
    }

    /**
     * Cancel Booking
     */
    public function cancelBooking(int $id): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            // Let the service handle the cancellation and refund calculation
            $result = $this->bookingService->cancelBooking($id, $user['id']);
            
            if (isset($result['error'])) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => $result['error']
                ], 400);
            }

            $refundAmount = $result['refund_amount'] ?? 0;

            // Process refund if applicable through payment service
            if ($refundAmount > 0) {
                $refundResult = $this->paymentService->processRefund([
                    'booking_id' => $id,
                    'amount' => $refundAmount,
                    'user_id' => $user['id'],
                    'reason' => 'Booking cancellation'
                ]);
                
                // Audit the refund processed
                $this->auditService->logEvent(
                    'refund_processed',
                    "Refund processed for booking #{$id}",
                    [
                        'booking_id' => $id,
                        'user_id' => $user['id'],
                        'refund_amount' => $refundAmount,
                        'refund_id' => $refundResult['refund_id'] ?? null
                    ],
                    $user['id'],
                    $id,
                    'payment'
                );
            }
            
            // Audit the cancellation
            $this->auditService->logEvent(
                'booking_canceled',
                "Booking #{$id} canceled",
                [
                    'booking_id' => $id,
                    'user_id' => $user['id'],
                    'refund_amount' => $refundAmount
                ],
                $user['id'],
                $id,
                'booking'
            );
            
            // Send notification about canceled booking
            $this->notificationService->sendBookingCanceledNotification($id, $user['id']);
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking canceled successfully',
                'data' => [
                    'refund_amount' => $refundAmount
                ]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to cancel booking'
            ], 500);
        }
    }

    /**
     * Fetch Booking Logs
     */
    public function getBookingLogs(int $bookingId): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            // Check if user has access to this booking
            $hasAccess = $this->bookingService->validateBookingAccess($bookingId, $user['id']);
            if (!$hasAccess && !isset($user['role']) && $user['role'] !== 'admin') {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'You do not have permission to view this booking'
                ], 403);
            }
            
            // Get logs through the service
            $logs = $this->bookingService->getBookingLogs($bookingId);
            
            // Log this access to audit logs
            $this->auditService->logEvent(
                'booking_logs_viewed',
                "Booking #{$bookingId} logs accessed",
                [
                    'booking_id' => $bookingId,
                    'user_id' => $user['id']
                ],
                $user['id'],
                $bookingId,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking logs fetched successfully',
                'data' => ['logs' => $logs]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch booking logs'
            ], 500);
        }
    }

    /**
     * List All Bookings for a User
     */
    public function getUserBookings(): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            // Get pagination parameters
            $page = (int) ($this->request->getQueryParams()['page'] ?? 1);
            $perPage = (int) ($this->request->getQueryParams()['per_page'] ?? 10);
            $status = $this->request->getQueryParams()['status'] ?? null;
            
            $bookings = $this->bookingService->getUserBookings($user['id'], $page, $perPage, $status);
            
            // Log the fetch operation
            $this->auditService->logEvent(
                'user_bookings_listed',
                "User retrieved their booking list",
                ['user_id' => $user['id']],
                $user['id'],
                null,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'User bookings fetched successfully',
                'data' => $bookings
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch user bookings'
            ], 500);
        }
    }

    /**
     * Create New Booking
     */
    public function createBooking(): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $data = $this->validator->validate($_POST, [
                'vehicle_id' => 'required|integer',
                'pickup_date' => 'required|date',
                'dropoff_date' => 'required|date|after:pickup_date',
                'pickup_location' => 'required|string',
                'dropoff_location' => 'required|string',
                'payment_method_id' => 'required|integer'
            ]);
            
            if ($this->validator->failed()) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Validation error',
                    'errors' => $this->validator->errors()
                ], 400);
            }
            
            $data['user_id'] = $user['id'];
            
            // Let the BookingService handle all booking creation logic
            $result = $this->bookingService->createBooking($data);
            
            if (isset($result['status']) && $result['status'] == 'error') {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => $result['message'] ?? 'Failed to create booking'
                ], 400);
            }

            // Log the booking creation to the audit logs
            $this->auditService->logEvent(
                'booking_created',
                "New booking created",
                [
                    'booking_id' => $result['booking_id'],
                    'user_id' => $user['id'],
                    'vehicle_id' => $data['vehicle_id'],
                    'pickup_date' => $data['pickup_date'], 
                    'dropoff_date' => $data['dropoff_date']
                ],
                $user['id'],
                $result['booking_id'],
                'booking'
            );
            
            // Send notification for new booking
            $this->notificationService->sendBookingConfirmationNotification($result['booking_id'], $user['id']);
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking created successfully',
                'data' => ['booking_id' => $result['booking_id']]
            ], 201);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to create booking'
            ], 500);
        }
    }

    /**
     * Get booking list for HTMX requests
     */
    public function getBookingListHtmx(): void
    {
        try {
            // Get user from session
            $userId = $_SESSION['user_id'] ?? null;
            if (!$userId) {
                echo '<div class="text-red-500 p-4">Nie jesteś zalogowany. Proszę zalogować się ponownie.</div>';
                return;
            }
            
            // Get pagination and filter parameters
            $page = isset($_GET['page']) ? (int)$_GET['page'] : 0;
            $perPage = isset($_GET['per_page']) ? (int)$_GET['per_page'] : 5;
            $status = $_GET['status'] ?? 'all';
            
            // Get bookings using service
            $bookings = $this->bookingService->getUserBookings($userId, $page + 1, $perPage, $status !== 'all' ? $status : null);
            
            // Log access to audit trail
            $this->auditService->logEvent(
                'user_bookings_htmx_fetched',
                "User fetched their bookings via HTMX",
                [
                    'user_id' => $userId,
                    'page' => $page,
                    'per_page' => $perPage,
                    'status' => $status
                ],
                $userId,
                null,
                'booking'
            );
            
            // Check if we have results
            if (empty($bookings['data']) && $page === 0) {
                echo '<script>document.getElementById("no-bookings-message").classList.remove("hidden");</script>';
                return;
            }
            
            // Render each booking
            foreach ($bookings['data'] as $booking) {
                include BASE_PATH . '/public/views/partials/booking-list-item.php';
            }
            
        } catch (\Exception $e) {
            $this->logger->error("Failed to load user bookings for HTMX", [
                'error' => $e->getMessage(),
                'user_id' => $_SESSION['user_id'] ?? 'unknown'
            ]);
            
            echo '<div class="text-red-500 p-4">
                <p class="font-medium">Nie udało się załadować rezerwacji</p>
                <p class="text-sm">Spróbuj odświeżyć stronę lub skontaktuj się z obsługą klienta</p>
            </div>';
        }
    }
}
=== App/Controllers/NotificationController.php ===
<?php

namespace App\Controllers;

use App\Services\NotificationService;
use App\Services\AuthService;
use App\Helpers\JsonResponse;
use App\Services\Auth\TokenService;
use App\Helpers\ExceptionHandler;
use App\Services\AuditService;
use Psr\Log\LoggerInterface;
use Psr\Http\Message\ResponseInterface;

require_once   'ViewHelper.php';

/**
 * Notification Controller
 *
 * Handles notification management, including sending notifications,
 * marking notifications as read, deleting notifications, and
 * fetching user notifications for display.
 */
class NotificationController extends Controller
{
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;
    private AuditService $auditService;
    private TokenService $tokenService;
    private NotificationService $notificationService;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService,
        TokenService $tokenService,
        NotificationService $notificationService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
        $this->tokenService = $tokenService;
        $this->notificationService = $notificationService;
    }

    /**
     * Display user notifications.
     */
    public function viewNotifications(): ResponseInterface
    {
        try {
            // Use TokenService to validate the request and get the user
            $user = $this->tokenService->validateRequest($this->request);
            if (!$user) {
                return $this->jsonResponse([
                    'status'  => 'error',
                    'message' => 'Invalid token or unauthorized access'
                ], 401);
            }
            
            $userId = $user['id'];
            $notifications = $this->notificationService->getUserNotifications($userId);
                
            // Log notification view in audit logs
            $this->auditService->logEvent(
                'notifications_viewed',
                "User viewed their notifications",
                ['user_id' => $userId],
                $userId,
                null,
                'notification'
            );
                
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Notifications loaded',
                'data'    => ['notifications' => $notifications]
            ], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'An error occurred while fetching notifications'
            ], 500);
        }
    }

    /**
     * Fetch all notifications for the authenticated user.
     */
    public function getUserNotifications(): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateRequest($this->request);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $notifications = $this->notificationService->getUserNotifications($user['id']);
                
            // Log in audit logs
            $this->auditService->logEvent(
                'user_notifications_fetched',
                "User fetched their notifications via API",
                ['user_id' => $user['id']],
                $user['id'],
                null,
                'notification'
            );
                
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notifications retrieved successfully',
                'data' => ['notifications' => $notifications]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch user notifications'
            ], 500);
        }
    }

    /**
     * Fetch unread notifications via AJAX.
     */
    public function fetchNotificationsAjax(): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateRequest($this->request);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $notifications = $this->notificationService->getUnreadNotifications($user['id']);
            $notificationCount = count($notifications);
                
            // Log notification fetch in audit logs
            $this->auditService->logEvent(
                'unread_notifications_fetched',
                "User fetched unread notifications",
                ['user_id' => $user['id'], 'count' => $notificationCount],
                $user['id'],
                null,
                'notification'
            );
                
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notifications retrieved successfully',
                'data' => ['notifications' => $notifications]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch notifications'
            ], 500);
        }
    }

    /**
     * Mark a notification as read.
     */
    public function markNotificationAsRead(): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateRequest($this->request);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $data = $this->validateRequest($_POST, [
                'notification_id' => 'required|integer'
            ]);

            // Verify ownership first using notification service
            $notification = $this->notificationService->verifyNotificationOwnership($data['notification_id'], $user['id']);
            if (!$notification) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Notification not found or access denied'
                ], 404);
            }

            $result = $this->notificationService->markAsRead($data['notification_id']);
            
            // Log in audit logs
            $this->auditService->logEvent(
                'notification_marked_as_read',
                "User marked a notification as read",
                ['user_id' => $user['id'], 'notification_id' => $data['notification_id']],
                $user['id'],
                null,
                'notification'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notification marked as read'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to mark notification as read'
            ], 500);
        }
    }

    /**
     * Delete a notification.
     */
    public function deleteNotification(): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateRequest($this->request);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $data = $this->validateRequest($_POST, [
                'notification_id' => 'required|integer'
            ]);

            // Verify ownership first using notification service
            $notification = $this->notificationService->verifyNotificationOwnership($data['notification_id'], $user['id']);
            if (!$notification) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Notification not found or access denied'
                ], 404);
            }

            $this->notificationService->deleteNotification($data['notification_id']);
            
            // Log in audit logs
            $this->auditService->logEvent(
                'notification_deleted',
                "User deleted a notification",
                ['user_id' => $user['id'], 'notification_id' => $data['notification_id']],
                $user['id'],
                null,
                'notification'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notification deleted'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to delete notification'
            ], 500);
        }
    }

    /**
     * Send a notification.
     */
    public function sendNotification(): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateRequest($this->request);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $data = $this->validateRequest($_POST, [
                'user_id' => 'required|integer',
                'type'    => 'required|in:email,sms,webhook,push',
                'message' => 'required|string|max:1000',
                'options' => 'nullable|array',
            ]);

            $options = $data['options'] ?? [];
            
            // Use service to send notification
            $result = $this->notificationService->sendNotification(
                $data['user_id'], 
                $data['type'], 
                $data['message'], 
                $options
            );
            
            if (!$result) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Failed to send notification'
                ], 500);
            }
            
            // Log in audit logs
            $this->auditService->logEvent(
                'notification_sent',
                "User sent a notification",
                ['user_id' => $data['user_id'], 'type' => $data['type']],
                $user['id'],
                null,
                'notification'
            );
            
            // Get the recent notifications to return the newly created one
            $recentNotifications = $this->notificationService->getUserNotifications($data['user_id']);
            $latestNotification = !empty($recentNotifications) ? $recentNotifications[0] : null;
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notification sent successfully',
                'data' => ['notification' => $latestNotification]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to send notification'
            ], 500);
        }
    }
}
=== App/Controllers/AdminController.php ===
<?php

namespace App\Controllers;

use App\Services\AdminService;
use App\Services\AuditService;
use App\Services\Auth\TokenService;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

/**
 * AdminController - Handles admin user management and dashboard operations.
 */
class AdminController extends Controller
{
    private AdminService $adminService;
    private ResponseFactoryInterface $responseFactory;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        AdminService $adminService,
        ResponseFactoryInterface $responseFactory,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->adminService = $adminService;
        $this->responseFactory = $responseFactory;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Create standardized PSR-7 JSON response
     */
    public function jsonResponse(ResponseInterface $response, $data, $status = 200): ResponseInterface
    {
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json')->withStatus($status);
    }

    /**
     * ✅ Get a paginated list of all users with their roles.
     */
    public function getAllUsers(): ResponseInterface
    {
        try {
            $admin = $this->adminService->validateAdmin($this->request);
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }

            // Get pagination parameters
            $page = (int) ($this->request->getQueryParams()['page'] ?? 1);
            $role = $this->request->getQueryParams()['role'] ?? 'all';
            $status = $this->request->getQueryParams()['status'] ?? 'all';
            $search = $this->request->getQueryParams()['search'] ?? '';
            $perPage = (int) ($this->request->getQueryParams()['per_page'] ?? 10);
            
            $userData = $this->adminService->getAllUsers($page, $admin['id'], $perPage, $role, $status, $search);
            
            // Set pagination headers for HTMX
            $response = $this->responseFactory->createResponse(200)
                ->withHeader('Content-Type', 'application/json')
                ->withHeader('X-Pagination', json_encode([
                    'currentPage' => $page,
                    'totalPages' => $userData['meta']['total_pages'] ?? 1,
                    'totalItems' => $userData['meta']['total'] ?? 0,
                    'perPage' => $perPage
                ]));
            
            if ($this->request->getHeaderLine('HX-Request') === 'true') {
                // If this is an HTMX request, return HTML for the table rows
                $rows = '';
                foreach ($userData['data'] as $user) {
                    // Format created_at date
                    $createdAt = date('d.m.Y H:i', strtotime($user['created_at']));
                    
                    // Get user initials for avatar
                    $initials = strtoupper(substr($user['name'], 0, 1) . substr($user['surname'] ?? '', 0, 1));
                    
                    // Set role details
                    $roleLabel = match($user['role']) {
                        'admin' => 'Administrator',
                        'manager' => 'Menedżer',
                        default => 'Użytkownik'
                    };
                    
                    $roleColorClass = match($user['role']) {
                        'admin' => 'bg-red-100 text-red-800',
                        'manager' => 'bg-blue-100 text-blue-800',
                        default => 'bg-green-100 text-green-800'
                    };
                    
                    // Set status details
                    $statusLabel = $user['active'] ? 'Aktywny' : 'Nieaktywny';
                    $statusBgClass = $user['active'] ? 'bg-green-500' : 'bg-gray-300';
                    $statusTextClass = $user['active'] ? 'text-green-600' : 'text-gray-600';
                    
                    // Use the row template and replace placeholders
                    $template = file_get_contents(BASE_PATH . '/public/views/admin/templates/user-row.php');
                    
                    // Replace all placeholders
                    $replacements = [
                        '{{id}}' => $user['id'],
                        '{{name}}' => htmlspecialchars($user['name']),
                        '{{surname}}' => htmlspecialchars($user['surname'] ?? ''),
                        '{{email}}' => htmlspecialchars($user['email']),
                        '{{initials}}' => $initials,
                        '{{roleLabel}}' => $roleLabel,
                        '{{roleColorClass}}' => $roleColorClass,
                        '{{statusLabel}}' => $statusLabel,
                        '{{statusBgClass}}' => $statusBgClass,
                        '{{statusTextClass}}' => $statusTextClass,
                        '{{active}}' => $user['active'] ? 'true' : 'false',
                        '{{created_at}}' => $createdAt
                    ];
                    
                    $rows .= str_replace(array_keys($replacements), array_values($replacements), $template);
                }
                
                $response->getBody()->write($rows ?: '<tr><td colspan="6" class="px-6 py-4 text-center text-gray-500">Brak użytkowników do wyświetlenia</td></tr>');
                return $response;
            }
            
            // Standard JSON response
            return $this->jsonResponse($response, [
                'status' => 'success', 
                'message' => 'User list retrieved successfully', 
                'data' => $userData['data'],
                'meta' => $userData['meta']
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to retrieve users'], 500);
        }
    }

    /**
     * ✅ Get user by ID
     */
    public function getUserById($userId): ResponseInterface
    {
        try {
            $admin = $this->adminService->validateAdmin($this->request);
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }
            
            $user = $this->adminService->getUserById((int)$userId);
            
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'User not found'
                ], 404);
            }
            
            // Log the user view in audit logs
            $this->adminService->logAdminAction(
                $admin['id'], 
                'user_view', 
                "Admin viewed user details",
                ['user_id' => $userId]
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'User retrieved successfully',
                'data' => $user
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to retrieve user'], 500);
        }
    }

    /**
     * ✅ Create a new user
     */
    public function createUser(): ResponseInterface
    {
        try {
            $admin = $this->adminService->validateAdmin($this->request);
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }

            $data = json_decode($this->request->getBody()->getContents(), true) ?? [];
            
            // Validate input
            if (!isset($data['name'], $data['email'], $data['password']) ||
                !filter_var($data['email'], FILTER_VALIDATE_EMAIL) ||
                strlen($data['password']) < 8
            ) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Nieprawidłowe dane. Email musi być prawidłowy, a hasło musi mieć min. 8 znaków.'
                ], 400);
            }
            
            // Ensure role is valid or default to user
            $data['role'] = in_array($data['role'] ?? '', ['user', 'admin', 'manager']) ? $data['role'] : 'user';
            
            // Create user using admin service
            $result = $this->adminService->createUser($data, $admin['id']);
            
            if (!$result) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Email już istnieje w systemie lub nie można utworzyć użytkownika'
                ], 400);
            }
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Użytkownik utworzony pomyślnie',
                'data' => $result
            ], 201);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse(['status' => 'error', 'message' => 'Nie udało się utworzyć użytkownika'], 500);
        }
    }

    /**
     * ✅ Update user details
     */
    public function updateUser($userId): ResponseInterface
    {
        try {
            $admin = $this->adminService->validateAdmin($this->request);
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }

            $data = json_decode($this->request->getBody()->getContents(), true) ?? [];
            
            // Ensure sensitive fields can't be updated this way
            unset($data['email'], $data['password'], $data['id']);
            
            // Ensure role is valid if provided
            if (isset($data['role']) && !in_array($data['role'], ['user', 'admin', 'manager'])) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Nieprawidłowa rola użytkownika'
                ], 400);
            }
            
            // Update the user
            $result = $this->adminService->updateUser((int)$userId, $data, $admin['id']);
            
            if ($result === null) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Użytkownik nie został znaleziony'
                ], 404);
            }
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Użytkownik zaktualizowany pomyślnie',
                'data' => $result
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse(['status' => 'error', 'message' => 'Nie udało się zaktualizować użytkownika'], 500);
        }
    }

    /**
     * ✅ Toggle user active status
     */
    public function toggleUserStatus($userId): ResponseInterface
    {
        try {
            $admin = $this->adminService->validateAdmin($this->request);
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }

            $data = $this->request->getParsedBody();
            $active = isset($data['active']) ? (bool)$data['active'] : null;
            
            if ($active === null) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Nie podano statusu aktywności'
                ], 400);
            }
            
            $result = $this->adminService->toggleUserStatus((int)$userId, $active, $admin['id']);
            
            if ($result === null) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Użytkownik nie został znaleziony'
                ], 404);
            }
            
            // For HTMX requests, return updated status component
            if ($this->request->getHeaderLine('HX-Request') === 'true') {
                $response = $this->responseFactory->createResponse(200);
                
                // Set status details
                $statusLabel = $active ? 'Aktywny' : 'Nieaktywny';
                $statusBgClass = $active ? 'bg-green-500' : 'bg-gray-300';
                $statusTextClass = $active ? 'text-green-600' : 'text-gray-600';
                
                $html = <<<HTML
                <div class="inline-flex items-center">
                    <button @click="toggleUserStatus($userId, $active)" 
                            class="relative inline-flex flex-shrink-0 h-6 w-11 border-2 border-transparent rounded-full cursor-pointer transition-colors ease-in-out duration-200 $statusBgClass">
                        <span class="inline-block h-5 w-5 rounded-full bg-white shadow transform transition ease-in-out duration-200" style="transform: translateX(<?php echo $active ? '20px' : '0px'; ?>)"></span>
                    </button>
                    <span class="ml-2 text-sm $statusTextClass">$statusLabel</span>
                </div>
                HTML;
                
                $response->getBody()->write($html);
                return $response->withHeader('Content-Type', 'text/html');
            }
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Status użytkownika zmieniony pomyślnie',
                'data' => ['active' => $active]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse(['status' => 'error', 'message' => 'Nie udało się zmienić statusu użytkownika'], 500);
        }
    }

    /**
     * ✅ Update a user's role.
     */
    public function updateUserRole($userId): ResponseInterface
    {
        try {
            $admin = $this->adminService->validateAdmin($this->request);
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }

            $data = $this->request->getParsedBody();
            $role = $data['role'] ?? '';
            $allowedRoles = ['user', 'admin', 'manager'];
            if (!$role || !in_array($role, $allowedRoles)) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Nieprawidłowa rola'
                ], 400);
            }
            
            $result = $this->adminService->updateUserRole((int)$userId, $role, $admin['id']);
            
            if (!$result) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Użytkownik nie został znaleziony'
                ], 404);
            }
            
            // For HTMX requests, return updated role component
            if ($this->request->getHeaderLine('HX-Request') === 'true') {
                $response = $this->responseFactory->createResponse(200);
                
                // Set role details
                $roleLabel = match($role) {
                    'admin' => 'Administrator',
                    'manager' => 'Menedżer',
                    default => 'Użytkownik'
                };
                
                $roleColorClass = match($role) {
                    'admin' => 'bg-red-100 text-red-800',
                    'manager' => 'bg-blue-100 text-blue-800',
                    default => 'bg-green-100 text-green-800'
                };
                
                $html = <<<HTML
                <div class="inline-flex items-center">
                    <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full $roleColorClass">
                      $roleLabel
                    </span>
                    <div class="relative ml-2" x-data="{ roleDropdownOpen: false }">
                      <button @click="roleDropdownOpen = !roleDropdownOpen" 
                              type="button" 
                              class="text-gray-400 hover:text-gray-600">
                        <i class="fas fa-edit text-xs"></i>
                      </button>
                      <div x-show="roleDropdownOpen" 
                           @click.away="roleDropdownOpen = false"
                           class="origin-top-right absolute right-0 mt-2 w-36 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none z-20">
                        <div class="py-1">
                          <a href="#" @click.prevent="updateUserRole($userId, 'user'); roleDropdownOpen = false" 
                             class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                             Użytkownik
                          </a>
                          <a href="#" @click.prevent="updateUserRole($userId, 'manager'); roleDropdownOpen = false" 
                             class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                             Menedżer
                          </a>
                          <a href="#" @click.prevent="updateUserRole($userId, 'admin'); roleDropdownOpen = false" 
                             class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                             Administrator
                          </a>
                        </div>
                      </div>
                    </div>
                </div>
                HTML;
                
                $response->getBody()->write($html);
                return $response->withHeader('Content-Type', 'text/html');
            }
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Rola użytkownika zaktualizowana pomyślnie'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse(['status' => 'error', 'message' => 'Nie udało się zaktualizować roli użytkownika'], 500);
        }
    }

    /**
     * ✅ Delete a user (Soft delete).
     */
    public function deleteUser($userId): ResponseInterface
    {
        try {
            $admin = $this->adminService->validateAdmin($this->request);
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }
            
            $result = $this->adminService->deleteUser((int)$userId, $admin['id']);
            
            if ($result === null) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'User not found'
                ], 404);
            }
            
            if (isset($result['error'])) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => $result['error']
                ], 403);
            }
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'User deleted successfully'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to delete user'], 500);
        }
    }

    /**
     * ✅ Fetch admin dashboard statistics.
     */
    public function getDashboardData(): ResponseInterface
    {
        try {
            $admin = $this->adminService->validateAdmin($this->request);
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }
            
            $dashboardData = $this->adminService->getDashboardData($admin['id']);
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Dashboard data retrieved successfully',
                'data' => $dashboardData
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to retrieve dashboard data'], 500);
        }
    }

    /**
     * ✅ Create a new admin user.
     */
    public function createAdmin(): ResponseInterface
    {
        try {
            $admin = $this->adminService->validateAdmin($this->request);
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }

            $data = $this->request->getParsedBody();
            
            // Validate input
            if (!isset($data['name'], $data['email'], $data['password']) ||
                !filter_var($data['email'], FILTER_VALIDATE_EMAIL) ||
                strlen($data['password']) < 8
            ) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid input. Email must be valid and password must be at least 8 characters'
                ], 400);
            }
            
            $newAdmin = $this->adminService->createAdmin($data, $admin['id']);
            
            if (!$newAdmin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Email already in use or failed to create admin'
                ], 400);
            }
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Admin created successfully',
                'data' => $newAdmin
            ], 201);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to create admin user'], 500);
        }
    }

    /**
     * ✅ Create a template for user row display
     */
    public function usersPage(): void
    {
        try {
            // Authentication check should happen at route middleware level
            if (!isset($_SESSION['user_id']) || $_SESSION['user_role'] !== 'admin') {
                header('Location: /auth/login');
                exit;
            }
            
            // Include the users management view
            include BASE_PATH . '/public/views/admin/users.php';
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }
}
=== App/Controllers/AuthController.php ===
<?php

namespace App\Controllers;

use App\Services\Auth\AuthService;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Log\LoggerInterface;
use App\Services\Auth\TokenService;
use App\Services\RateLimiter;
use App\Helpers\ExceptionHandler;

class AuthController extends Controller
{
    protected LoggerInterface $logger;
    private AuthService $authService;
    private TokenService $tokenService;
    private RateLimiter $rateLimiter;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        AuthService $authService,
        TokenService $tokenService,
        RateLimiter $rateLimiter,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->authService = $authService;
        $this->tokenService = $tokenService;
        $this->rateLimiter = $rateLimiter;
        $this->exceptionHandler = $exceptionHandler;
    }    

    public function login(Request $request, Response $response)
    {
        try {
            // Rewind the request body stream in case it was consumed
            $request->getBody()->rewind();
            
            // Use getParsedBody() for consistency with other endpoints
            $data = $request->getParsedBody();
            
            if (!is_array($data)) {
                $this->logger->error("Parsed body is not an array or is null in login.");
                return $this->jsonResponse($response, ["error" => "Invalid JSON input"], 400);
            }

            $this->logger->debug("Parsed request data in login: " . print_r($data, true));

            if (!isset($data['email']) || !isset($data['password'])) {
                $this->logger->warning("Missing required fields in login");
                return $this->jsonResponse($response, ["error" => "Email and password are required"], 400);
            }

            // Rate Limiting Logic
            $email = $data['email'];
            $ipAddress = $request->getServerParams()['REMOTE_ADDR'] ?? 'UNKNOWN';

        
            if ($this->rateLimiter->isRateLimited($email, $ipAddress, 'login')) {
                $this->logger->warning("Rate limit exceeded for login", ['email' => $email, 'ip' => $ipAddress]);
                return $this->jsonResponse($response, ["error" => "Too many login attempts. Please try again later."], 429);
            }

            $result = $this->authService->login($data);
            $this->logger->info('User login successful', ['email' => $data['email']]);
            
            // Set JWT token as a secure HttpOnly cookie
            setcookie('jwt', $result['token'], [
                'expires'  => time() + 3600,
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            // Set refresh token as a secure HttpOnly cookie with longer expiration
            setcookie('refresh_token', $result['refresh_token'], [
                'expires'  => time() + 604800,
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            // Return success message without exposing tokens in the response body
            return $this->jsonResponse($response, [
                "message" => "Login successful",
                "user_id" => $result['user_id'] ?? null,
                "name" => $result['name'] ?? null
            ]);
            
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Authentication failed"], 401);
        }
    }

    public function register(Request $request, Response $response)
    {
        try {
            // Use getParsedBody() since the parsed body was set in index.php
            $data = $request->getParsedBody();
            
            if (!is_array($data)) {
                $this->logger->error("Parsed body is not an array or is null.");
                return $this->jsonResponse($response, ["error" => "Invalid JSON input"], 400);
            }

            $this->logger->debug("Parsed request data in register: " . print_r($data, true));

            $requiredFields = ['name', 'surname', 'email', 'password'];
            $missingFields = array_diff($requiredFields, array_keys($data));

            if (!empty($missingFields)) {
                $this->logger->warning("Missing required fields in register: " . implode(', ', $missingFields));
                return $this->jsonResponse($response, ["error" => "Missing fields: " . implode(', ', $missingFields)], 400);
            }

            $result = $this->authService->register($data);
            $this->logger->info('User registration attempt', ['data' => $data]);

            return $this->jsonResponse($response, $result);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Registration failed"], 500);
        }
    }

    public function refresh(Request $request, Response $response)
    {
        try {
            // Try to get refresh token from cookie first
            $refreshToken = $_COOKIE['refresh_token'] ?? null;
            
            // If not in cookie, try to get from request body
            if (!$refreshToken) {
                $request->getBody()->rewind();
                $data = $request->getParsedBody();
                $refreshToken = $data['refresh_token'] ?? null;
            }
            
            if (!$refreshToken) {
                $this->logger->warning('Refresh token missing');
                return $this->jsonResponse($response, ["error" => "Refresh token is required"], 400);
            }
            
            $result = $this->authService->refresh(['refresh_token' => $refreshToken]);
            $this->logger->info('Token refreshed successfully');
            
            // Set the new JWT token as a cookie
            setcookie('jwt', $result['token'], [
                'expires'  => time() + 3600,
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            return $this->jsonResponse($response, ["message" => "Token refreshed successfully"]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Token refresh failed"], 401);
        }
    }

    public function logout(Request $request, Response $response)
    {
        try {
            // Clear both JWT and refresh token cookies
            setcookie('jwt', '', [
                'expires'  => time() - 3600, // Expire in the past
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            setcookie('refresh_token', '', [
                'expires'  => time() - 3600, // Expire in the past
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            // Log the logout action
            $this->logger->info('User logged out successfully');
            
            // Call the service logout method if needed (e.g., to revoke tokens server-side)
            $this->authService->logout([]);
            
            return $this->jsonResponse($response, ["message" => "Logout successful"]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Logout failed"], 500);
        }
    }

    /**
     * Get authenticated user details
     * 
     * This endpoint assumes AuthMiddleware is applied to the route.
     * For protected routes, use AuthMiddleware with required=true.
     */
    public function userDetails(Request $request, Response $response): Response
    {
        try {
            $user = $request->getAttribute('user');
            
            if (!$user) {
                $this->logger->error("User not authenticated");
                return $this->jsonResponse($response->withStatus(401), ['error' => 'Authentication required']);
            }
            
            // Remove sensitive fields
            $userDetails = array_diff_key($user, array_flip(['password_hash']));
            
            $this->logger->info("User details retrieved successfully", ['user_id' => $user['id']]);
            return $this->jsonResponse($response, ['user' => $userDetails]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Failed to get user details"], 500);
        }
    }

    public function resetPasswordRequest(Request $request, Response $response)
    {
        try {
            $request->getBody()->rewind();
            $data = $request->getParsedBody();
            
            if (!is_array($data)) {
                $this->logger->error("Invalid JSON input for password reset request");
                return $this->jsonResponse($response, ["error" => "Invalid JSON input"], 400);
            }
            
            if (!isset($data['email'])) {
                $this->logger->warning("Missing email in password reset request");
                return $this->jsonResponse($response, ["error" => "Email is required"], 400);
            }
            
            $result = $this->authService->resetPasswordRequest($data);
            $this->logger->info("Password reset requested", ['email' => $data['email']]);
            return $this->jsonResponse($response, ["message" => "Password reset email sent"]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Password reset request failed"], 500);
        }
    }

    public function resetPassword(Request $request, Response $response)
    {
        try {
            $request->getBody()->rewind();
            $data = $request->getParsedBody();
            
            if (!is_array($data)) {
                $this->logger->error("Invalid JSON input for password reset");
                return $this->jsonResponse($response, ["error" => "Invalid JSON input"], 400);
            }
            
            // Validate required fields
            $requiredFields = ['token', 'password', 'confirm_password'];
            $missingFields = array_diff($requiredFields, array_keys($data));
            
            if (!empty($missingFields)) {
                $this->logger->warning("Missing fields in password reset", ['missing' => $missingFields]);
                return $this->jsonResponse($response, [
                    "error" => "Missing required fields: " . implode(', ', $missingFields)
                ], 400);
            }
            
            // Check if passwords match
            if ($data['password'] !== $data['confirm_password']) {
                $this->logger->warning("Password mismatch in reset");
                return $this->jsonResponse($response, ["error" => "Passwords do not match"], 400);
            }
            
            $result = $this->authService->resetPassword($data);
            $this->logger->info("Password reset completed successfully");
            return $this->jsonResponse($response, ["message" => "Password has been reset successfully"]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Password reset failed"], 500);
        }
    }
}
=== App/Controllers/SignatureController.php ===
<?php

namespace App\Controllers;

use App\Services\SignatureService;
use App\Services\AuditService;
use App\Services\Auth\TokenService;
use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;

require_once   'ViewHelper.php';

/**
 * Signature Controller
 *
 * Handles the management of user signatures, including uploading,
 * verifying, and retrieving signatures for documents.
 */
class SignatureController extends Controller
{
    private SignatureService $signatureService;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;
    private AuditService $auditService;
    private TokenService $tokenService;

    public function __construct(
        LoggerInterface $logger,
        SignatureService $signatureService,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService,
        TokenService $tokenService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->signatureService = $signatureService;
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
        $this->tokenService = $tokenService;
    }

    /**
     * Upload a signature.
     *
     * @param array $data The uploaded signature file and associated metadata.
     * @return array Response containing upload status
     */
    public function uploadSignature(array $data): array
    {
        try {
            $user = $this->tokenService->validateRequest($this->request->getHeader('Authorization'));
            if (!$user) {
                return ['status' => 'error', 'message' => 'Unauthorized access', 'code' => 401];
            }

            $rules = [
                'user_id' => 'required|integer',
                'file' => 'required|file|mimes:png,jpg,jpeg|max:2048', // Max 2MB
            ];

            $this->validator->validate($data, $rules);

            $signaturePath = $this->signatureService->uploadSignature($data['file'], $data['user_id']);
            
            // Log the signature upload event
            $this->auditService->logEvent(
                'signature_uploaded',
                "Signature uploaded successfully",
                ['user_id' => $data['user_id']],
                $user['id'],
                null,
                'document'
            );
            
            return ['status' => 'success', 'message' => 'Signature uploaded successfully', 'data' => $signaturePath];
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ['status' => 'error', 'message' => 'Failed to upload signature', 'code' => 500];
        }
    }

    /**
     * Verify a signature.
     *
     * @param int $userId The ID of the user whose signature is to be verified.
     * @param string $documentHash The hash of the document to verify against the signature.
     * @return array Verification result.
     */
    public function verifySignature(int $userId, string $documentHash): array
    {
        try {
            $user = $this->tokenService->validateRequest($this->request->getHeader('Authorization'));
            if (!$user) {
                return ['status' => 'error', 'message' => 'Unauthorized access', 'code' => 401];
            }
            
            $isValid = $this->signatureService->verifySignature($userId, $documentHash);
            
            // Log the signature verification attempt
            $this->auditService->logEvent(
                'signature_verified',
                "Signature verification " . ($isValid ? "successful" : "failed"),
                [
                    'user_id' => $userId,
                    'document_hash' => substr($documentHash, 0, 10) . '...',
                    'result' => $isValid ? 'valid' : 'invalid'
                ],
                $user['id'],
                null,
                'document'
            );

            if ($isValid) {
                return ['status' => 'success', 'message' => 'Signature verified successfully'];
            }

            return ['status' => 'error', 'message' => 'Signature verification failed', 'code' => 400];
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ['status' => 'error', 'message' => 'Failed to verify signature', 'code' => 500];
        }
    }

    /**
     * Retrieve a user's signature.
     *
     * @param int $userId The ID of the user.
     * @return array Response containing the signature path or error message.
     */
    public function getSignature(int $userId): array
    {
        try {
            $requestingUser = $this->tokenService->validateRequest($this->request->getHeader('Authorization'));
            if (!$requestingUser) {
                return ['status' => 'error', 'message' => 'Unauthorized access', 'code' => 401];
            }
            
            $signaturePath = $this->signatureService->getSignature($userId);
            
            // Log the signature retrieval
            $this->auditService->logEvent(
                'signature_retrieved',
                "Signature retrieved " . ($signaturePath ? "successfully" : "failed - not found"),
                [
                    'user_id' => $userId,
                    'requested_by' => $requestingUser['id']
                ],
                $requestingUser['id'],
                null,
                'document'
            );

            if ($signaturePath) {
                return ['status' => 'success', 'message' => 'Signature retrieved successfully', 'data' => $signaturePath];
            }

            return ['status' => 'error', 'message' => 'Signature not found', 'code' => 404];
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ['status' => 'error', 'message' => 'Failed to retrieve signature', 'code' => 500];
        }
    }
}
=== App/Controllers/DashboardController.php ===
<?php

namespace App\Controllers;

use App\Models\Booking;
use App\Models\Payment;
use App\Models\Notification;
use App\Models\User;
use App\Services\AuditService;
use App\Helpers\ExceptionHandler;
use Illuminate\Support\Facades\Cache;
use Psr\Log\LoggerInterface;
use App\Services\BookingService;
use App\Services\MetricsService;
use App\Services\NotificationService;
use App\Services\UserService;
use App\Helpers\ViewHelper;

require_once   'ViewHelper.php';

class DashboardController extends Controller
{
    private BookingService $bookingService;
    private MetricsService $metricsService;
    private NotificationService $notificationService;
    private UserService $userService;
    private AuditService $auditService;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        BookingService $bookingService,
        MetricsService $metricsService,
        NotificationService $notificationService,
        UserService $userService,
        AuditService $auditService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->bookingService = $bookingService;
        $this->metricsService = $metricsService;
        $this->notificationService = $notificationService;
        $this->userService = $userService;
        $this->auditService = $auditService;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Render user dashboard view.
     */
    public function userDashboard()
    {
        try {
            // Assume session_start() is already called.
            $user = (object)['id' => $_SESSION['user_id'] ?? null]; // Replace with native session retrieval
            
            // Log dashboard access
            $this->auditService->logEvent(
                'dashboard_accessed',
                "User accessed their dashboard",
                ['user_id' => $user->id],
                $user->id,
                null,
                'user'
            );
            
            // Render the main dashboard view - the components will load via HTMX
            include BASE_PATH . '/public/views/dashboard.php';
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    /**
     * Get user statistics (for HTMX).
     */
    public function getUserStatistics(): void
    {
        try {
            $userId = $_SESSION['user_id'] ?? null;
            
            $statistics = Cache::remember('user_dashboard_' . $userId, 60, function () use ($userId) {
                return [
                    'total_bookings'     => Booking::where('user_id', $userId)->count(),
                    'completed_bookings' => Booking::where('user_id', $userId)->where('status', 'completed')->count(),
                    'total_payments'     => Payment::where('user_id', $userId)->sum('amount'),
                ];
            });
            
            // Include the statistics partial
            include BASE_PATH . '/public/views/partials/user-statistics.php';
        } catch (\Exception $e) {
            echo '<div class="text-red-500 p-4">Nie udało się załadować statystyk.</div>';
            $this->logger->error("Failed to load user statistics", [
                'error' => $e->getMessage(),
                'user_id' => $_SESSION['user_id'] ?? 'unknown'
            ]);
        }
    }

    /**
     * Fetch user bookings (for HTMX).
     */
    public function getUserBookings(): void
    {
        try {
            $userId = $_SESSION['user_id'] ?? null;
            $page = isset($_GET['page']) ? (int)$_GET['page'] : 0;
            $limit = 5;
            $offset = $page * $limit;
            
            $bookings = Booking::where('user_id', $userId)
                ->orderBy('created_at', 'desc')
                ->limit($limit)
                ->offset($offset)
                ->get();
            
            // Log bookings fetch
            $this->auditService->logEvent(
                'bookings_fetched',
                "User fetched their bookings",
                ['user_id' => $userId],
                $userId,
                null,
                'booking'
            );
            
            // Include the bookings partial
            include BASE_PATH . '/public/views/partials/user-bookings.php';
        } catch (\Exception $e) {
            echo '<div class="text-red-500 p-4">Nie udało się załadować rezerwacji.</div>';
            $this->logger->error("Failed to load user bookings", [
                'error' => $e->getMessage(),
                'user_id' => $_SESSION['user_id'] ?? 'unknown'
            ]);
        }
    }

    /**
     * Fetch user profile (for HTMX).
     */
    public function getUserProfile(): void
    {
        try {
            $userId = $_SESSION['user_id'] ?? null;
            if (!$userId) {
                echo '<div class="text-red-500 p-4">Nie jesteś zalogowany. Proszę zalogować się ponownie.</div>';
                return;
            }
            
            $profile = User::findOrFail($userId);
            
            // Prepare additional profile data if needed
            $profileData = [
                'id' => $profile->id,
                'name' => $profile->name,
                'email' => $profile->email,
                'avatar_url' => $profile->avatar_url ?? '/assets/images/default-avatar.png',
                'bio' => $profile->bio ?? '',
                'location' => $profile->location ?? '',
                'joined_date' => (new \DateTime($profile->created_at))->format('d.m.Y'),
            ];
            
            // Log profile fetch
            $this->auditService->logEvent(
                'profile_fetched',
                "User fetched their profile",
                ['user_id' => $userId],
                $userId,
                null,
                'user'
            );
            
            // Include the updated profile partial
            include BASE_PATH . '/public/views/partials/user-profile.php';
        } catch (\Exception $e) {
            echo '<div class="text-red-500 p-4">Nie udało się załadować profilu.</div>';
            $this->logger->error("Failed to load user profile", [
                'error' => $e->getMessage(),
                'user_id' => $_SESSION['user_id'] ?? 'unknown'
            ]);
        }
    }

    /**
     * Fetch user notifications (for HTMX).
     */
    public function getUserNotifications(): void
    {
        try {
            $userId = $_SESSION['user_id'] ?? null;
            $page = isset($_GET['page']) ? (int)$_GET['page'] : 0;
            $limit = 5;
            $offset = $page * $limit;
            
            $notifications = Notification::where('user_id', $userId)
                ->orderBy('created_at', 'desc')
                ->limit($limit)
                ->offset($offset)
                ->get();
                
            // Log notifications fetch
            $this->auditService->logEvent(
                'notifications_fetched',
                "User fetched their notifications",
                ['user_id' => $userId],
                $userId,
                null,
                'notification'
            );
            
            // Include the notifications partial
            include BASE_PATH . '/public/views/partials/user-notifications.php';
        } catch (\Exception $e) {
            echo '<div class="text-red-500 p-4">Nie udało się załadować powiadomień.</div>';
            $this->logger->error("Failed to load user notifications", [
                'error' => $e->getMessage(),
                'user_id' => $_SESSION['user_id'] ?? 'unknown'
            ]);
        }
    }
}
=== App/Controllers/update_catch.sh ===
#!/bin/bash

# Define the ExceptionHandler include statement
EXCEPTION_HANDLER_INCLUDE="require_once '/../Helpers/ExceptionHandler.php';"

# Define the output file for constructor exports
CONSTRUCTS_EXPORT="constructs_export.txt"

# Clear the export file before starting
> "$CONSTRUCTS_EXPORT"

# Find all PHP files and process them
find . -type f -name "*.php" | while read -r file; do
    echo "Processing: $file"

    # Check if the file contains a try-catch block
    if grep -q "try\s*{" "$file"; then
        # Replace all try-catch blocks with ExceptionHandler usage
        sed -i -E 's|try\s*\{([^}]*)\}\s*catch\s*\((Exception\s+\$\w+)\)\s*\{([^}]*)\}|try {\1} catch (\2) {\n    ExceptionHandler::handle(\2);\n}|g' "$file"
        
        echo "Updated try-catch blocks in: $file"
    fi

    # Check if the ExceptionHandler is already included
    if ! grep -q "require_once 'path/to/ExceptionHandler.php';" "$file"; then
        # Add ExceptionHandler inclusion at the top of the file
        sed -i "1s|^|$EXCEPTION_HANDLER_INCLUDE\n|" "$file"
        echo "Added ExceptionHandler inclusion to: $file"
    fi

    # Extract and export all constructor methods
    if grep -q "function __construct" "$file"; then
        echo "Extracting constructor from: $file"
        echo -e "\n--- Constructor from $file ---" >> "$CONSTRUCTS_EXPORT"
        awk '/function __construct/,/}/{print}' "$file" >> "$CONSTRUCTS_EXPORT"
    fi
done

echo "✅ All files processed. Constructor exports saved to $CONSTRUCTS_EXPORT."
=== App/Controllers/AdminDashboardController.php ===
<?php

namespace App\Controllers;

use App\Models\User;
use App\Models\Booking;
use App\Models\Payment;
use Illuminate\Support\Facades\Cache;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use App\Services\AuditService;

require_once   'ViewHelper.php';

class AdminDashboardController extends Controller
{
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;
    private AuditService $auditService;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    public function index(): void
    {
        try {
            $metrics = Cache::remember('dashboard_metrics', 60, function () {
                $totalRevenue = Payment::where('status', 'completed')->sum('amount');
                $totalRefunds = Payment::where('status', 'completed')->where('type', 'refund')->sum('amount');
                return [
                    'total_users'        => User::count(),
                    'active_users'       => User::where('active', true)->count(),
                    'total_bookings'     => Booking::count(),
                    'completed_bookings' => Booking::where('status', 'completed')->count(),
                    'canceled_bookings'  => Booking::where('status', 'canceled')->count(),
                    'total_revenue'      => $totalRevenue,
                    'total_refunds'      => $totalRefunds,
                    'net_revenue'        => $totalRevenue - $totalRefunds,
                ];
            });
            $recentBookings = Booking::with('user')->latest()->limit(5)->get();

            // Log this dashboard view in audit logs
            $this->auditService->logEvent(
                'admin_dashboard_viewed',
                'Admin dashboard viewed',
                ['admin_id' => $_SESSION['user_id'] ?? 'unknown'],
                $_SESSION['user_id'] ?? null,
                null,
                'admin'
            );

            extract(compact('metrics', 'recentBookings'));
            include BASE_PATH . '/public/views/admin/dashboard.php';
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    public function getDashboardData(): void
    {
        try {
            requireAuth(); // ensure admin authentication is in place
            
            $metrics = Cache::remember('dashboard_metrics', 60, function () {
                $totalRevenue = Payment::where('status', 'completed')->sum('amount');
                $totalRefunds = Payment::where('status', 'completed')->where('type', 'refund')->sum('amount');
                return [
                    'total_users'        => User::count(),
                    'active_users'       => User::where('active', true)->count(),
                    'total_bookings'     => Booking::count(),
                    'completed_bookings' => Booking::where('status', 'completed')->count(),
                    'canceled_bookings'  => Booking::where('status', 'canceled')->count(),
                    'total_revenue'      => $totalRevenue,
                    'total_refunds'      => $totalRefunds,
                    'net_revenue'        => $totalRevenue - $totalRefunds,
                ];
            });
            $recentBookings = Booking::with('user')->latest()->limit(5)->get();

            // Log this API request in audit logs
            $this->auditService->logEvent(
                'admin_dashboard_data_api',
                'Admin dashboard data API requested',
                ['admin_id' => $_SESSION['user_id'] ?? 'unknown'],
                $_SESSION['user_id'] ?? null,
                null,
                'admin'
            );

            header('Content-Type: application/json');
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Dashboard data fetched',
                'data'    => [
                    'metrics'         => $metrics,
                    'recent_bookings' => $recentBookings,
                ]
            ]);
            exit;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }
}
=== App/Controllers/PaymentController.php ===
<?php

namespace App\Controllers;

use App\Services\PaymentService;
use App\Helpers\TokenValidator;
use App\Helpers\ExceptionHandler;
use Psr\Http\Message\ResponseInterface;
use Psr\Log\LoggerInterface;
use App\Services\NotificationService;
use App\Services\Validator;

/**
 * Payment Controller
 *
 * Handles payment processing, refunds, and user transactions.
 */
class PaymentController extends Controller
{
    private PaymentService $paymentService;
    private Validator $validator;
    private NotificationService $notificationService;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        PaymentService $paymentService,
        Validator $validator,
        NotificationService $notificationService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->paymentService = $paymentService;
        $this->validator = $validator;
        $this->notificationService = $notificationService;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Process a payment.
     */
    public function processPayment(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $data = $this->validator->validate($_POST, [
                'booking_id'       => 'required|integer',
                'amount'           => 'required|numeric|min:0.01',
                'payment_method_id' => 'required|integer',
                'currency'         => 'nullable|string|size:3',
            ]);
            
            if ($this->validator->failed()) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Validation error',
                    'errors' => $this->validator->errors()
                ], 400);
            }
            
            // Add user_id to payment data
            $paymentData = array_merge($data, ['user_id' => $user->id]);
            
            // Delegate all payment processing to the service
            $result = $this->paymentService->processPayment($paymentData);
            
            // Notify user about successful payment
            $this->notificationService->sendPaymentConfirmation($user->id, $paymentData['booking_id'], $paymentData['amount']);
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Payment processed',
                'data'    => ['payment' => $result]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Payment processing failed'
            ], 500);
        }
    }

    /**
     * Refund a payment.
     */
    public function refundPayment(): ResponseInterface
    {
        try {
            $admin = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$admin || !$admin->isAdmin()) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized - admin rights required'
                ], 401);
            }
            
            $data = $this->validator->validate($_POST, [
                'payment_id'    => 'required|integer',
                'amount'        => 'required|numeric|min:0.01',
                'reason'        => 'required|string',
            ]);

            if ($this->validator->failed()) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Validation error',
                    'errors' => $this->validator->errors()
                ], 400);
            }
            
            // Add admin_id to refund data
            $refundData = array_merge($data, ['admin_id' => $admin->id]);
            
            // Delegate all refund processing to the service
            $result = $this->paymentService->refundPayment($refundData);
            
            // Notify user about refund
            if (isset($result['user_id']) && isset($result['booking_id'])) {
                $this->notificationService->sendRefundNotification(
                    $result['user_id'],
                    $result['booking_id'],
                    $refundData['amount'],
                    $refundData['reason']
                );
            }
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Refund processed',
                'data'    => ['refund' => $result]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Refund processing failed'
            ], 500);
        }
    }

    /**
     * Fetch all user transactions.
     */
    public function getUserTransactions(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            // Get pagination parameters
            $page = (int)($this->request->getQueryParams()['page'] ?? 1);
            $limit = (int)($this->request->getQueryParams()['limit'] ?? 20);
            
            // Get transactions from service
            $transactions = $this->paymentService->getTransactionHistory($user->id, $page, $limit);
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Transactions fetched',
                'data'    => $transactions
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to fetch user transactions'
            ], 500);
        }
    }

    /**
     * Fetch payment details.
     */
    public function getPaymentDetails(int $transactionId): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            // Delegate to service which handles permission checking
            $details = $this->paymentService->getTransactionDetails($transactionId, $user->id, $user->isAdmin());
            
            // If details are null, user doesn't have permission
            if ($details === null) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'You do not have permission to view this transaction'
                ], 403);
            }
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Payment details fetched',
                'data'    => ['details' => $details]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to fetch payment details'
            ], 500);
        }
    }

    /**
     * Add a payment method.
     */
    public function addPaymentMethod(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $data = $this->validator->validate($_POST, [
                'type'        => 'required|string',
                'card_last4'  => 'required_if:type,credit_card|numeric',
                'card_brand'  => 'required_if:type,credit_card|string',
                'expiry_date' => 'required_if:type,credit_card|string',
                'is_default'  => 'nullable|boolean',
            ]);

            if ($this->validator->failed()) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Validation error',
                    'errors' => $this->validator->errors()
                ], 400);
            }
            
            // Add user_id to payment method data
            $methodData = array_merge($data, ['user_id' => $user->id]);
            
            // Delegate to service
            $paymentMethod = $this->paymentService->addPaymentMethod($methodData);
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Payment method added successfully',
                'data'    => ['payment_method' => $paymentMethod]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to add payment method'
            ], 500);
        }
    }
    
    /**
     * Get all payment methods for a user.
     */
    public function getUserPaymentMethods(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            // Delegate to service
            $paymentMethods = $this->paymentService->getUserPaymentMethods($user->id);
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Payment methods retrieved successfully',
                'data'    => ['payment_methods' => $paymentMethods]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to retrieve payment methods'
            ], 500);
        }
    }

    /**
     * Process a payment using a specific gateway.
     */
    public function processGatewayPayment(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $data = $this->validator->validate($_POST, [
                'gateway'          => 'required|string|in:stripe,paypal,payu',
                'booking_id'       => 'required|integer',
                'amount'           => 'required|numeric|min:0.01',
                'currency'         => 'required|string|size:3',
                'return_url'       => 'required|url',
                'cancel_url'       => 'required|url',
            ]);

            if ($this->validator->failed()) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Validation error',
                    'errors' => $this->validator->errors()
                ], 400);
            }
            
            // Add user_id to payment data
            $paymentData = array_merge($data, [
                'user_id' => $user->id,
                'ip_address' => $this->request->getServerParams()['REMOTE_ADDR'] ?? null,
                'user_agent' => $this->request->getHeaderLine('User-Agent')
            ]);
            
            // Delegate to gateway service
            $result = $this->paymentService->processPaymentGateway(
                $paymentData['gateway'],
                $paymentData
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Gateway payment initiated',
                'data'    => $result
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Gateway payment processing failed'
            ], 500);
        }
    }

    /**
     * Handle gateway callback.
     */
    public function handleGatewayCallback(string $gateway): ResponseInterface
    {
        try {
            // No authentication for callbacks - they come from payment providers
            
            // Get payload data (could be POST, GET, or JSON)
            $callbackData = [];
            
            if ($_SERVER['REQUEST_METHOD'] === 'POST') {
                $callbackData = $_POST;
            } else if ($_SERVER['REQUEST_METHOD'] === 'GET') {
                $callbackData = $_GET;
            } else {
                $callbackData = json_decode(file_get_contents('php://input'), true) ?? [];
            }
            
            // Add request metadata for verification
            $callbackData['_meta'] = [
                'ip_address' => $_SERVER['REMOTE_ADDR'] ?? null,
                'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? null,
                'timestamp' => time(),
                'request_method' => $_SERVER['REQUEST_METHOD']
            ];
            
            // Delegate to service
            $result = $this->paymentService->handlePaymentCallback($gateway, $callbackData);
            
            // If successful and we have user data, send notification
            if (isset($result['success']) && $result['success'] && isset($result['user_id'])) {
                $this->notificationService->sendPaymentConfirmation(
                    $result['user_id'],
                    $result['booking_id'] ?? null,
                    $result['amount'] ?? 0
                );
            }
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Callback processed',
                'data'    => $result
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to process gateway callback'
            ], 500);
        }
    }

    /**
     * Delete a payment method
     */
    public function deletePaymentMethod(int $methodId): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            // Delegate to service
            $result = $this->paymentService->deletePaymentMethod($methodId, $user->id);
            
            if (!$result) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Payment method not found or you do not have permission to delete it'
                ], 404);
            }
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Payment method deleted successfully'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to delete payment method'
            ], 500);
        }
    }

    /**
     * Get user transactions for HTMX requests
     */
    public function getUserTransactionsHtmx(): void
    {
        try {
            // Get user from session
            $userId = $_SESSION['user_id'] ?? null;
            if (!$userId) {
                echo '<div class="text-red-500 p-4">Nie jesteś zalogowany. Proszę zalogować się ponownie.</div>';
                return;
            }
            
            // Get pagination and filter parameters
            $page = isset($_GET['page']) ? (int)$_GET['page'] : 1;
            $limit = isset($_GET['limit']) ? (int)$_GET['limit'] : 10;
            $type = $_GET['type'] ?? 'all';
            $sortBy = $_GET['sort_by'] ?? 'date';
            $sortDir = $_GET['sort_dir'] ?? 'desc';
            
            // Map frontend sort fields to backend fields
            $sortMapping = [
                'date' => 'created_at',
                'amount' => 'amount',
                'status' => 'status'
            ];
            
            $backendSortField = $sortMapping[$sortBy] ?? 'created_at';
            
            // Get transactions through the service
            $transactions = $this->paymentService->getTransactionHistory(
                $userId, 
                $page, 
                $limit, 
                $type !== 'all' ? $type : null,
                $backendSortField,
                $sortDir
            );
            
            // Check if we have results
            if (empty($transactions['data'])) {
                echo '<script>document.getElementById("no-transactions").classList.remove("hidden");</script>';
                return;
            }
            
            // Render each transaction
            foreach ($transactions['data'] as $transaction) {
                include BASE_PATH . '/public/views/partials/payment-item.php';
            }
            
        } catch (\Exception $e) {
            $this->logger->error("Failed to load user transactions for HTMX", [
                'error' => $e->getMessage(),
                'user_id' => $_SESSION['user_id'] ?? 'unknown'
            ]);
            
            echo '<div class="text-red-500 p-4">
                <p class="font-medium">Nie udało się załadować historii transakcji</p>
                <p class="text-sm">Spróbuj odświeżyć stronę lub skontaktuj się z obsługą klienta</p>
            </div>';
        }
    }
}
=== App/Controllers/Controller.php ===
<?php

namespace App\Controllers;

use Exception;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use Psr\Http\Message\ResponseInterface as Response;

/**
 * Base Controller - Provides shared methods for all controllers.
 */
class Controller
{
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(LoggerInterface $logger, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * ✅ Standard JSON Response
     */
    protected function jsonResponse(Response $response, $data, $status = 200)
    {
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json')->withStatus($status);
    }

    /**
     * ✅ Error Response
     */
    protected function errorResponse(Response $response, $message, $status = 400)
    {
        return $this->jsonResponse($response, ['error' => $message], $status);
    }

    /**
     * ✅ Handle Exceptions & Log Errors
     * This method is for backward compatibility, new controllers should use ExceptionHandler
     */
    protected function handleException(Exception $e, string $context = 'General Error'): void
    {
        if ($this->exceptionHandler) {
            $this->exceptionHandler->handleException($e);
        } else {
            // Legacy fallback behavior
            $this->logger->error("{$context}: " . $e->getMessage());
            $this->jsonResponse(['status' => 'error', 'message' => 'An error occurred.'], 500);
        }
    }

    /**
     * ✅ Input Validation Helper
     */
    protected function validateRequest(array $data, array $rules): array
    {
        $errors = [];

        foreach ($rules as $field => $rule) {
            $value = $data[$field] ?? null;

            if (strpos($rule, 'required') !== false && empty($value)) {
                $errors[$field] = "{$field} is required.";
            }

            if (strpos($rule, 'integer') !== false && !filter_var($value, FILTER_VALIDATE_INT)) {
                $errors[$field] = "{$field} must be an integer.";
            }

            if (strpos($rule, 'email') !== false && !filter_var($value, FILTER_VALIDATE_EMAIL)) {
                $errors[$field] = "{$field} must be a valid email.";
            }
        }

        if (!empty($errors)) {
            if ($this->exceptionHandler) {
                throw new \InvalidArgumentException(json_encode(['validation' => $errors]));
            } else {
                // Legacy fallback behavior
                $this->jsonResponse(['status' => 'error', 'message' => 'Validation failed', 'errors' => $errors], 422);
            }
        }

        return $data;
    }
}
=== App/Controllers/DocumentController.php ===
<?php

namespace App\Controllers;

use App\Services\DocumentService;
use App\Services\Validator;
use App\Services\AuditService;
use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;

require_once   'ViewHelper.php';

class DocumentController extends Controller
{
    private DocumentService $documentService;
    private Validator $validator;
    private AuditService $auditService;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        DocumentService $documentService,
        Validator $validator,
        AuditService $auditService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->documentService = $documentService;
        $this->validator = $validator;
        $this->auditService = $auditService;
        $this->exceptionHandler = $exceptionHandler;
    }
    
    /**
     * Upload a document template.
     */
    public function uploadTemplate(array $data): array
    {
        try {
            $rules = [
                'name' => 'required|string|max:255',
                'content' => 'required|string',
            ];

            if (!$this->validator->validate($data, $rules)) {
                return $this->jsonResponse('error', ['message' => 'Validation failed', 'errors' => $this->validator->errors()], 400);
            }

            // Delegate template upload to service
            $this->documentService->uploadTemplate($data['name'], $data['content']);
            
            return $this->jsonResponse('success', ['message' => 'Template uploaded successfully'], 201);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse('error', ['message' => 'Failed to upload template'], 500);
        }
    }

    /**
     * Generate a contract for a booking.
     */
    public function generateContract(int $bookingId, int $userId): array
    {
        try {
            // Delegate contract generation to service
            $contractPath = $this->documentService->generateContractSecure($bookingId, $userId);
            
            return $this->jsonResponse('success', ['message' => 'Contract generated successfully', 'contract_path' => $contractPath], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse('error', ['message' => 'Failed to generate contract'], 500);
        }
    }

    /**
     * Upload and manage the Terms & Conditions document.
     */
    public function uploadTerms(array $data): array
    {
        try {
            $rules = [
                'content' => 'required|string',
            ];

            if (!$this->validator->validate($data, $rules)) {
                return $this->jsonResponse('error', ['message' => 'Validation failed', 'errors' => $this->validator->errors()], 400);
            }

            // Delegate T&C upload to service
            $this->documentService->uploadTerms($data['content']);

            return $this->jsonResponse('success', ['message' => 'T&C document uploaded successfully'], 201);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse('error', ['message' => 'Failed to upload T&C document'], 500);
        }
    }

    /**
     * Generate an invoice for a booking.
     */
    public function generateInvoice(int $bookingId): array
    {
        try {
            // Delegate invoice generation to service
            $invoicePath = $this->documentService->generateInvoice($bookingId);

            return $this->jsonResponse('success', ['message' => 'Invoice generated successfully', 'invoice_path' => $invoicePath], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse('error', ['message' => 'Failed to generate invoice'], 500);
        }
    }

    /**
     * Delete a document (template or user-specific).
     */
    public function deleteDocument(int $documentId): array
    {
        try {
            // Delegate document deletion to service
            $this->documentService->deleteDocument($documentId);

            return $this->jsonResponse('success', ['message' => 'Document deleted successfully'], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse('error', ['message' => 'Failed to delete document'], 500);
        }
    }
    
    /**
     * Get all templates
     */
    public function getTemplates(): array
    {
        try {
            // Delegate to service
            $templates = $this->documentService->getTemplates();
            
            return $this->jsonResponse('success', ['templates' => $templates], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse('error', ['message' => 'Failed to retrieve templates'], 500);
        }
    }
    
    /**
     * Get a specific template
     */
    public function getTemplate(int $templateId): array
    {
        try {
            // Delegate to service
            $template = $this->documentService->getTemplateById($templateId);
            
            return $this->jsonResponse('success', ['template' => $template], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse('error', ['message' => 'Failed to retrieve template'], 500);
        }
    }
}
=== App/Controllers/ReportController.php ===
<?php

namespace App\Controllers;

use App\Services\ReportService;
use App\Services\NotificationService;
use App\Services\AuditService;
use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;

class ReportController extends Controller
{
    private ReportService $reportService;
    private NotificationService $notificationService;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;
    private AuditService $auditService;

    public function __construct(
        LoggerInterface $logger,
        ReportService $reportService,
        NotificationService $notificationService,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->reportService = $reportService;
        $this->notificationService = $notificationService;
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    /**
     * Admin Report Dashboard View
     */
    public function index()
    {
        try {
            // Log the dashboard access in audit logs
            $this->auditService->logEvent(
                'report_dashboard_accessed',
                'Admin report dashboard accessed',
                ['user_id' => $_SESSION['user_id'] ?? 'unknown'],
                $_SESSION['user_id'] ?? null,
                null,
                'report'
            );
            
            $data = ['view' => 'admin/reports'];
            http_response_code(200);
            echo json_encode(['status' => 'success', 'message' => 'Report dashboard loaded', 'data' => $data]);
            exit;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
        }
    }

    /**
     * Generate Report for Admin
     */
    public function generateReport()
    {
        try {
            // Parse request data
            $validated = $_POST;
            
            $dateRange = [
                'start' => $validated['date_range']['start'] ?? null,
                'end' => $validated['date_range']['end'] ?? null
            ];
            $format = $validated['format'] ?? null;
            $reportType = $validated['report_type'] ?? null;
            $filters = $validated['filters'] ?? [];
            $userId = $_SESSION['user_id'] ?? null;
            
            if (!$dateRange['start'] || !$dateRange['end'] || !$format || !$reportType) {
                http_response_code(400);
                echo json_encode(['status' => 'error', 'message' => 'Missing required parameters']);
                exit;
            }
            
            // Log report generation in audit logs
            $this->auditService->logEvent(
                'report_generated',
                "Admin generated {$reportType} report",
                [
                    'report_type' => $reportType,
                    'format' => $format,
                    'date_range' => $dateRange
                ],
                $userId,
                null,
                'report'
            );
            
            // Generate report using service
            $reportPath = $this->reportService->generateReport($reportType, $dateRange, $format, $filters);
            
            // Return the report
            return $this->downloadReport($reportPath);
            
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    /**
     * User Report Dashboard View
     */
    public function userReports()
    {
        try {
            $data = ['view' => 'user/reports'];
            http_response_code(200);
            echo json_encode(['status' => 'success', 'message' => 'User report dashboard loaded', 'data' => $data]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
        }
    }

    /**
     * Generate Report for a User
     */
    public function generateUserReport()
    {
        try {
            $validated = $_POST;
            $userId = $validated['user_id'] ?? null;
            $dateRange = [
                'start' => $validated['date_range']['start'] ?? null,
                'end' => $validated['date_range']['end'] ?? null
            ];
            $format = $validated['format'] ?? null;
            $reportType = $validated['report_type'] ?? null;

            if (!$userId || !$dateRange['start'] || !$dateRange['end'] || !$format || !$reportType) {
                http_response_code(400);
                echo json_encode(['status' => 'error', 'message' => 'Missing required parameters']);
                exit;
            }
            
            // Generate user-specific report
            $reportPath = $this->reportService->generateUserReport($userId, $reportType, $dateRange, $format);
            
            // Return the report
            return $this->downloadReport($reportPath);
            
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    /**
     * Download a Report
     */
    public function downloadReport(string $filePath): void
    {
        try {
            if (!file_exists($filePath)) {
                http_response_code(404);
                echo json_encode(['status' => 'error', 'message' => 'Report not found', 'data' => []]);
                return;
            }

            header('Content-Description: File Transfer');
            header('Content-Type: application/octet-stream');
            header('Content-Disposition: attachment; filename=' . basename($filePath));
            header('Expires: 0');
            header('Cache-Control: must-revalidate');
            header('Pragma: public');
            header('Content-Length: ' . filesize($filePath));
            readfile($filePath);
            exit;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
        }
    }
}
=== App/Controllers/ApiController.php ===
<?php

namespace App\Controllers;

use App\Helpers\ExceptionHandler;
use Psr\Http\Message\ResponseInterface;
use Psr\Log\LoggerInterface;
use App\Services\AuditService;

/**
 * Base API Controller
 * 
 * Provides common functionality for all API controllers including
 * standardized JSON responses, error handling, and shared utilities.
 */
class ApiController extends Controller
{
    protected ExceptionHandler $exceptionHandler;
    protected AuditService $auditService;
    
    /**
     * Constructor
     */
    public function __construct(
        LoggerInterface $logger,
        AuditService $auditService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    /**
     * Create a success response
     */
    protected function success($message, $data = [], $status = 200): ResponseInterface
    {
        return $this->jsonResponse([
            'status' => 'success',
            'message' => $message,
            'data' => $data
        ], $status);
    }

    /**
     * Create an error response
     */
    protected function error($message, $errors = [], $status = 400): ResponseInterface
    {
        return $this->jsonResponse([
            'status' => 'error',
            'message' => $message,
            'errors' => $errors
        ], $status);
    }

    /**
     * Safe handling of exceptions in API controllers
     */
    protected function safeExecute(callable $action): ResponseInterface
    {
        try {
            return $action();
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // This line won't be reached if the exception handler exits
            return $this->error('An unexpected error occurred', [], 500);
        }
    }

    /**
     * Log audit event with proper context
     */
    protected function logAuditEvent(
        string $eventType,
        string $message,
        array $context = [],
        ?int $userId = null,
        ?int $resourceId = null,
        string $category = 'api'
    ): void {
        $this->auditService->logEvent(
            $eventType,
            $message,
            $context,
            $userId,
            $resourceId,
            $category
        );
    }
}
=== App/Controllers/AuditController.php ===
<?php

namespace App\Controllers;

use App\Services\AuditService;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

/**
 * AuditController - Handles viewing and retrieving audit logs.
 * Follows the clean controller pattern by delegating all DB operations
 * to the AuditService.
 */
class AuditController extends Controller
{
    protected LoggerInterface $logger;
    private AuditService $auditService;
    protected ExceptionHandler $exceptionHandler;
    
    /**
     * Constructor with dependency injection
     */
    public function __construct(
        LoggerInterface $logger, 
        AuditService $auditService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->auditService = $auditService;
        $this->exceptionHandler = $exceptionHandler;
    }
    
    /**
     * Admin dashboard view for audit logs
     */
    public function index()
    {
        try {
            // Check if user has admin role
            if (!$this->hasAdminAccess()) {
                return $this->jsonResponse('error', 'Admin access required', 403);
            }
            
            // Process filters from request
            $filters = $this->processFilters($_GET);
            
            // Get logs using the audit service
            $logs = $this->auditService->getLogs($filters);
            
            return $this->jsonResponse('success', $logs, 200);
        } catch (\Exception $e) {
            $this->logger->error('Error in audit log retrieval: ' . $e->getMessage(), [
                'controller' => 'AuditController',
                'method' => 'index'
            ]);
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse('error', 'Failed to retrieve audit logs', 500);
        }
    }

    /**
     * API Endpoint: Fetch logs based on filters
     */
    public function fetchLogs()
    {
        try {
            // Check if user has admin role
            if (!$this->hasAdminAccess()) {
                return $this->jsonResponse('error', 'Admin access required', 403);
            }
            
            // Process filters from request
            $filters = $this->processFilters($_POST);
            
            // Get logs using the audit service
            $logs = $this->auditService->getLogs($filters);
            
            return $this->jsonResponse('success', $logs, 200);
        } catch (\Exception $e) {
            $this->logger->error('Error in API log retrieval: ' . $e->getMessage(), [
                'controller' => 'AuditController',
                'method' => 'fetchLogs'
            ]);
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse('error', 'Failed to fetch logs', 500);
        }
    }
    
    /**
     * API Endpoint: Get log details by ID
     */
    public function getLog($id)
    {
        try {
            // Check if user has admin role
            if (!$this->hasAdminAccess()) {
                return $this->jsonResponse('error', 'Admin access required', 403);
            }
            
            $log = $this->auditService->getLogById((int)$id);
            
            if (!$log) {
                return $this->jsonResponse('error', 'Log not found', 404);
            }
            
            return $this->jsonResponse('success', ['log' => $log], 200);
        } catch (\Exception $e) {
            $this->logger->error('Error retrieving log details: ' . $e->getMessage(), [
                'controller' => 'AuditController',
                'method' => 'getLog',
                'id' => $id
            ]);
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse('error', 'Failed to retrieve log', 500);
        }
    }
    
    /**
     * API Endpoint: Export logs based on filters
     */
    public function exportLogs()
    {
        try {
            // Check if user has admin role
            if (!$this->hasAdminAccess()) {
                return $this->jsonResponse('error', 'Admin access required', 403);
            }
            
            // Process filters from request
            $filters = $this->processFilters($_POST);
            
            // Get export info from audit service
            $exportInfo = $this->auditService->exportLogs($filters);
            
            return $this->jsonResponse('success', [
                'export' => $exportInfo
            ], 200);
        } catch (\Exception $e) {
            $this->logger->error('Error exporting logs: ' . $e->getMessage(), [
                'controller' => 'AuditController',
                'method' => 'exportLogs'
            ]);
            $this->exceptionHandler->handleException($e);
            return $this->jsonResponse('error', 'Failed to export logs', 500);
        }
    }
    
    /**
     * Process and validate incoming filters
     */
    private function processFilters(array $rawFilters): array
    {
        $filters = [];
        
        // Category filter
        if (!empty($rawFilters['category'])) {
            $filters['category'] = $rawFilters['category'];
        }
        
        // Action filter
        if (!empty($rawFilters['action'])) {
            $filters['action'] = $rawFilters['action'];
        }
        
        // User ID filter
        if (!empty($rawFilters['user_id'])) {
            $filters['user_id'] = (int)$rawFilters['user_id'];
        }
        
        // Booking ID filter
        if (!empty($rawFilters['booking_id'])) {
            $filters['booking_id'] = (int)$rawFilters['booking_id'];
        }
        
        // Date range filters
        if (!empty($rawFilters['start_date'])) {
            $filters['start_date'] = $rawFilters['start_date'];
        }
        
        if (!empty($rawFilters['end_date'])) {
            $filters['end_date'] = $rawFilters['end_date'];
        }
        
        // Pagination
        if (isset($rawFilters['page'])) {
            $filters['page'] = max(1, (int)$rawFilters['page']);
        }
        
        if (isset($rawFilters['per_page'])) {
            $filters['per_page'] = min(100, max(10, (int)$rawFilters['per_page']));
        }
        
        // Log level
        if (!empty($rawFilters['log_level'])) {
            $filters['log_level'] = $rawFilters['log_level'];
        }
        
        return $filters;
    }
    
    /**
     * Check if current user has admin access
     */
    private function hasAdminAccess(): bool
    {
        // Get configuration for allowed roles
        $config = require __DIR__ . '/../../config/audit.php';
        $allowedRoles = $config['access']['allowed_roles'] ?? ['admin'];
        
        // Check if user role is in allowed roles
        $userRole = $_SESSION['user_role'] ?? '';
        return in_array($userRole, $allowedRoles, true);
    }
}
