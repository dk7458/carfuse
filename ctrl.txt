=== App/Controllers/UserController.php ===
<?php

namespace App\Controllers;

use App\Helpers\ApiHelper;
use App\Helpers\DatabaseHelper;
use App\Services\Validator;
use App\Services\Auth\TokenService;
use App\Services\AuditService;
use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;
use App\Services\Auth\AuthService;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;

/**
 * User Management Controller
 *
 * Handles profile management, password resets, and dashboard access.
 */
class UserController extends Controller
{
    private Validator $validator;
    private TokenService $tokenService;
    protected ExceptionHandler $exceptionHandler;
    protected LoggerInterface $logger;
    private AuthService $authService;
    private AuditService $auditService;

    public function __construct(
        LoggerInterface $logger,
        Validator $validator,
        TokenService $tokenService,
        ExceptionHandler $exceptionHandler,
        AuthService $authService,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->validator = $validator;
        $this->tokenService = $tokenService;
        $this->exceptionHandler = $exceptionHandler;
        $this->authService = $authService;
        $this->auditService = $auditService;
    }

    /**
     * Register a new user.
     */
    public function registerUser(Request $request, Response $response)
    {
        try {
            $data = json_decode($request->getBody()->getContents(), true);
            $this->logger->info("Processing user registration", ['email' => $data['email'] ?? 'not provided']);
            
            // Validate input data
            $rules = [
                'email'    => 'required|email',
                'password' => 'required|min:6',
                'name'     => 'required|string',
            ];
            
            $this->validator->validate($data, $rules);
            
            // Check if email is already in use
            $existingUser = DatabaseHelper::select(
                "SELECT id FROM users WHERE email = ?",
                [$data['email']],
                false // Using application database
            );
            
            if (!empty($existingUser)) {
                return ApiHelper::sendJsonResponse('error', 'Email already in use', [], 400);
            }
            
            // Hash password and prepare user data
            $userData = [
                'email' => $data['email'],
                'name' => $data['name'],
                'password' => password_hash($data['password'], PASSWORD_BCRYPT),
                'created_at' => date('Y-m-d H:i:s'),
                'role' => 'user',
                'status' => 'active'
            ];
            
            // Insert new user using application database
            $userId = DatabaseHelper::insert(
                'users',
                $userData,
                false, // Use application database
                ['operation' => 'user_registration']
            );
            
            // Log the registration in audit logs
            $this->auditService->logEvent(
                'user_registered',
                'User registered successfully',
                ['email' => $data['email']],
                $userId,
                null,
                'user'
            );
            
            $this->logger->info("User registered successfully", [
                'user_id' => $userId,
                'email' => $data['email']
            ]);
            
            return ApiHelper::sendJsonResponse('success', 'User registered successfully', ['user_id' => $userId], 201);
            
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ApiHelper::sendJsonResponse('error', 'Registration failed', [], 500);
        }
    }

    /**
     * Retrieve current user profile.
     */
    public function getUserProfile(Request $request, Response $response)
    {
        try {
            // Get user from TokenService validation
            $user = $this->tokenService->validateRequest($request);
            if (!$user) {
                return ApiHelper::sendJsonResponse('error', 'User not authenticated', [], 401);
            }
            
            $userId = $user['id'];
            $this->logger->info("Fetching user profile", ['user_id' => $userId]);
            
            // Fetch user data with a single optimized query
            $userData = DatabaseHelper::select(
                "SELECT u.id, u.name, u.email, u.created_at, u.role, 
                        u.status, u.last_login, p.bio, p.avatar_url, p.location
                 FROM users u
                 LEFT JOIN user_profiles p ON u.id = p.user_id
                 WHERE u.id = ? AND u.deleted_at IS NULL",
                [$userId],
                false // Using application database
            );
            
            if (empty($userData)) {
                return ApiHelper::sendJsonResponse('error', 'User not found', [], 404);
            }
            
            // Log profile view in audit logs
            $this->auditService->logEvent(
                'profile_viewed',
                'User viewed their profile',
                ['user_id' => $userId],
                $userId,
                null,
                'user'
            );
            
            return ApiHelper::sendJsonResponse('success', 'User profile retrieved', $userData[0], 200);
            
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ApiHelper::sendJsonResponse('error', 'Failed to retrieve profile', [], 500);
        }
    }

    /**
     * Update user profile.
     */
    public function updateProfile(Request $request, Response $response)
    {
        try {
            // Get user from TokenService validation
            $user = $this->tokenService->validateRequest($request);
            if (!$user) {
                return ApiHelper::sendJsonResponse('error', 'User not authenticated', [], 401);
            }
            
            $userId = $user['id'];
            
            $data = json_decode($request->getBody()->getContents(), true);
            $this->logger->info("Updating user profile", ['user_id' => $userId]);
            
            // Validate input data
            $rules = [
                'name'     => 'string|max:100',
                'bio'      => 'string|max:500',
                'location' => 'string|max:100',
                'avatar_url' => 'url|max:255'
            ];
            
            $this->validator->validate($data, $rules);
            
            // Separate user table fields from profile fields
            $userData = array_intersect_key($data, array_flip(['name']));
            $profileData = array_intersect_key($data, array_flip(['bio', 'location', 'avatar_url']));
            
            // Start transaction for updating both tables
            DatabaseHelper::rawQuery(
                "START TRANSACTION",
                [],
                false // Using application database
            );
            
            // Update user main data if needed
            if (!empty($userData)) {
                DatabaseHelper::update(
                    'users',
                    $userData,
                    ['id' => $userId],
                    false, // Using application database
                    ['operation' => 'profile_update', 'user_id' => $userId]
                );
            }
            
            // Update or insert profile data if needed
            if (!empty($profileData)) {
                // Check if profile exists
                $existingProfile = DatabaseHelper::select(
                    "SELECT user_id FROM user_profiles WHERE user_id = ?",
                    [$userId],
                    false // Using application database
                );
                
                if (empty($existingProfile)) {
                    // Create new profile entry
                    $profileData['user_id'] = $userId;
                    $profileData['created_at'] = date('Y-m-d H:i:s');
                    
                    DatabaseHelper::insert(
                        'user_profiles',
                        $profileData,
                        false, // Using application database
                        ['operation' => 'profile_create', 'user_id' => $userId]
                    );
                } else {
                    // Update existing profile
                    $profileData['updated_at'] = date('Y-m-d H:i:s');
                    
                    DatabaseHelper::update(
                        'user_profiles',
                        $profileData,
                        ['user_id' => $userId],
                        false, // Using application database
                        ['operation' => 'profile_update', 'user_id' => $userId]
                    );
                }
            }
            
            // Commit the transaction
            DatabaseHelper::rawQuery(
                "COMMIT",
                [],
                false // Using application database
            );
            
            // Log profile update in audit logs
            $this->auditService->logEvent(
                'profile_updated',
                'User updated their profile',
                [
                    'user_id' => $userId, 
                    'fields_updated' => array_merge(array_keys($userData), array_keys($profileData))
                ],
                $userId,
                null,
                'user'
            );
            
            // Get updated profile
            $updatedProfile = DatabaseHelper::select(
                "SELECT u.id, u.name, u.email, u.role, u.created_at, 
                        p.bio, p.location, p.avatar_url
                 FROM users u
                 LEFT JOIN user_profiles p ON u.id = p.user_id
                 WHERE u.id = ?",
                [$userId],
                false // Using application database
            );
            
            return ApiHelper::sendJsonResponse('success', 'Profile updated successfully', $updatedProfile[0], 200);
            
        } catch (\Exception $e) {
            // Rollback transaction on error
            DatabaseHelper::rawQuery(
                "ROLLBACK",
                [],
                false // Using application database
            );
            
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ApiHelper::sendJsonResponse('error', 'Failed to update profile', [], 500);
        }
    }

    /**
     * Request password reset.
     */
    public function requestPasswordReset(Request $request, Response $response)
    {
        try {
            $data = json_decode($request->getBody()->getContents(), true);
            
            if (!isset($data['email']) || !filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
                return ApiHelper::sendJsonResponse('error', 'Valid email is required', [], 400);
            }
            
            $this->logger->info("Processing password reset request", ['email' => $data['email']]);
            
            // Check if user exists
            $user = DatabaseHelper::select(
                "SELECT id, email FROM users WHERE email = ? AND deleted_at IS NULL",
                [$data['email']],
                false // Using application database
            );
            
            if (empty($user)) {
                // Don't reveal that the email doesn't exist, but log it
                $this->logger->info("Password reset requested for non-existent email", [
                    'email' => $data['email']
                ]);
                return ApiHelper::sendJsonResponse('success', 'If your email is in our system, you will receive reset instructions shortly', [], 200);
            }
            
            // Generate a secure token
            $token = bin2hex(random_bytes(30));
            $expiresAt = date('Y-m-d H:i:s', strtotime('+1 hour'));
            
            // Store token in secure database
            DatabaseHelper::insert(
                'password_resets',
                [
                    'email' => $data['email'],
                    'token' => $token,
                    'expires_at' => $expiresAt,
                    'created_at' => date('Y-m-d H:i:s')
                ],
                true, // Use secure database
                ['operation' => 'password_reset_request', 'user_id' => $user[0]['id']]
            );
            
            // Log password reset request in audit logs
            $this->auditService->logEvent(
                'password_reset_requested',
                'Password reset requested',
                ['email' => $data['email'], 'expires_at' => $expiresAt],
                $user[0]['id'],
                null,
                'user'
            );
            
            return ApiHelper::sendJsonResponse('success', 'Password reset instructions sent to your email', [], 200);
            
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ApiHelper::sendJsonResponse('error', 'Failed to process password reset request', [], 500);
        }
    }

    /**
     * Reset password with token.
     */
    public function resetPassword(Request $request, Response $response)
    {
        try {
            $data = json_decode($request->getBody()->getContents(), true);
            
            // Validate input
            if (!isset($data['token']) || !isset($data['password']) || strlen($data['password']) < 6) {
                return ApiHelper::sendJsonResponse('error', 'Token and password (min 6 chars) required', [], 400);
            }
            
            $this->logger->info("Processing password reset with token");
            
            // Check if token is valid and not expired using secure database
            $resetRequest = DatabaseHelper::select(
                "SELECT email, token, expires_at FROM password_resets 
                 WHERE token = ? AND expires_at > NOW()",
                [$data['token']],
                true // Use secure database
            );
            
            if (empty($resetRequest)) {
                $this->logger->warning("Invalid or expired password reset token used");
                return ApiHelper::sendJsonResponse('error', 'Invalid or expired token', [], 400);
            }
            
            $email = $resetRequest[0]['email'];
            
            // Get user ID
            $user = DatabaseHelper::select(
                "SELECT id FROM users WHERE email = ?",
                [$email]
            );
            
            if (empty($user)) {
                $this->logger->warning("User not found for password reset", ['email' => $email]);
                return ApiHelper::sendJsonResponse('error', 'User not found', [], 404);
            }
            
            $userId = $user[0]['id'];
            
            // Update the password
            $hashedPassword = password_hash($data['password'], PASSWORD_BCRYPT);
            
            DatabaseHelper::update(
                'users',
                [
                    'password' => $hashedPassword,
                    'updated_at' => date('Y-m-d H:i:s')
                ],
                ['id' => $userId],
                false,
                ['operation' => 'password_reset', 'user_id' => $userId]
            );
            
            // Delete the used token using secure database
            DatabaseHelper::delete(
                'password_resets',
                ['token' => $data['token']],
                false,
                true // Use secure database
            );
            
            $this->logger->info("Password reset successful", [
                'user_id' => $userId,
                'email' => $email
            ]);
            
            return ApiHelper::sendJsonResponse('success', 'Password has been reset successfully', [], 200);
            
        } catch (\Exception $e) {
            $this->logger->error("Failed to reset password", [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            return ApiHelper::sendJsonResponse('error', 'Failed to reset password', [], 500);
        }
    }

    /**
     * User dashboard access.
     */
    public function userDashboard(Request $request, Response $response)
    {
        try {
            // Get user from TokenService validation
            $user = $this->tokenService->validateRequest($request);
            if (!$user) {
                return ApiHelper::sendJsonResponse('error', 'User not authenticated', [], 401);
            }
            
            $userId = $user['id'];
            
            $this->logger->info("User accessing dashboard", ['user_id' => $userId]);
            
            // Get user data
            $user = DatabaseHelper::select(
                "SELECT id, name, email, role FROM users WHERE id = ? AND deleted_at IS NULL",
                [$userId]
            );
            
            if (empty($user)) {
                return ApiHelper::sendJsonResponse('error', 'User not found', [], 404);
            }
            
            // Get user's recent activity in a single query
            $userActivity = DatabaseHelper::select(
                "SELECT activity_type, description, created_at 
                 FROM user_activities 
                 WHERE user_id = ? 
                 ORDER BY created_at DESC LIMIT 5",
                [$userId]
            );
            
            // Build dashboard data
            $dashboardData = [
                'user' => $user[0],
                'recent_activity' => $userActivity,
                'account_age_days' => $this->calculateAccountAge($userId)
            ];
            
            // Log dashboard access
            DatabaseHelper::insert(
                'user_activities',
                [
                    'user_id' => $userId,
                    'activity_type' => 'dashboard_access',
                    'description' => 'User accessed their dashboard',
                    'created_at' => date('Y-m-d H:i:s'),
                    'ip_address' => $_SERVER['REMOTE_ADDR'] ?? null
                ]
            );
            
            return ApiHelper::sendJsonResponse('success', 'User Dashboard', $dashboardData, 200);
            
        } catch (\Exception $e) {
            $this->logger->error("Failed to load user dashboard", [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
                'user_id' => $request->getAttribute('user_id') ?? 'unknown'
            ]);
            return ApiHelper::sendJsonResponse('error', 'Failed to load dashboard', [], 500);
        }
    }
    
    /**
     * Calculate user account age in days
     */
    private function calculateAccountAge(int $userId): int
    {
        $creationDate = DatabaseHelper::select(
            "SELECT created_at FROM users WHERE id = ?",
            [$userId]
        );
        
        if (empty($creationDate)) {
            return 0;
        }
        
        $createdTimestamp = strtotime($creationDate[0]['created_at']);
        $currentTimestamp = time();
        return floor(($currentTimestamp - $createdTimestamp) / (60 * 60 * 24));
    }
}
=== App/Controllers/BookingController.php ===
<?php

namespace App\Controllers;

use App\Models\Booking;
use App\Models\RefundLog;
use App\Services\AuthService;
use App\Services\AuditService;
use App\Services\Auth\TokenService;
use App\Helpers\DatabaseHelper;
use App\Helpers\ExceptionHandler;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Log\LoggerInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

/**
 * Booking Controller
 *
 * Handles booking operations, including creating, rescheduling,
 * canceling bookings, and fetching booking details or logs.
 */
class BookingController extends Controller
{
    private BookingService $bookingService;
    private PaymentService $paymentService;
    private Validator $validator;
    private AuditService $auditService;
    private NotificationService $notificationService;
    private ResponseFactoryInterface $responseFactory;
    protected LoggerInterface $logger;
    private TokenService $tokenService;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        BookingService $bookingService,
        PaymentService $paymentService,
        Validator $validator,
        AuditService $auditService,
        NotificationService $notificationService,
        ResponseFactoryInterface $responseFactory,
        TokenService $tokenService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->bookingService = $bookingService;
        $this->paymentService = $paymentService;
        $this->validator = $validator;
        $this->auditService = $auditService;
        $this->notificationService = $notificationService;
        $this->responseFactory = $responseFactory;
        $this->tokenService = $tokenService;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Create standardized PSR-7 JSON response
     */
    protected function jsonResponse(array $data, int $status = 200): ResponseInterface
    {
        $response = $this->responseFactory->createResponse($status);
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    /**
     * View Booking Details
     */
    public function viewBooking(int $id): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $booking = Booking::with('logs')->findOrFail($id);
            
            // Audit log for viewing booking
            $this->auditService->logEvent(
                'booking_viewed',
                "Booking #{$id} details viewed",
                ['booking_id' => $id, 'user_id' => $user['id']],
                $user['id'],
                $id,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking details fetched',
                'data' => ['booking' => $booking]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch booking details'
            ], 500);
        }
    }

    /**
     * Reschedule Booking
     */
    public function rescheduleBooking(int $id): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $data = $_POST; // minimal custom validation assumed
            
            $booking = Booking::findOrFail($id);
            $oldPickup = $booking->pickup_date;
            $oldDropoff = $booking->dropoff_date;
            
            $booking->update([
                'pickup_date'  => $data['pickup_date'],
                'dropoff_date' => $data['dropoff_date'],
            ]);
            
            // Audit the rescheduling action
            $this->auditService->logEvent(
                'booking_rescheduled',
                "Booking #{$id} rescheduled",
                [
                    'booking_id' => $id,
                    'user_id' => $user['id'],
                    'old_pickup' => $oldPickup,
                    'new_pickup' => $data['pickup_date'],
                    'old_dropoff' => $oldDropoff,
                    'new_dropoff' => $data['dropoff_date']
                ],
                $user['id'],
                $id,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking rescheduled successfully'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to reschedule booking'
            ], 500);
        }
    }

    /**
     * Cancel Booking
     */
    public function cancelBooking(int $id): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $booking = Booking::findOrFail($id);
            $oldStatus = $booking->status;
            $booking->update(['status' => 'canceled']);

            // Process refund if applicable.
            $refundAmount = $booking->calculateRefund(); // Assumes a calculateRefund() method exists.
            if ($refundAmount > 0) {
                $refund = RefundLog::create([
                    'booking_id' => $id,
                    'amount'     => $refundAmount,
                    'status'     => 'processed'
                ]);
                
                // Audit the refund processed
                $this->auditService->logEvent(
                    'refund_processed',
                    "Refund processed for booking #{$id}",
                    [
                        'booking_id' => $id,
                        'user_id' => $user['id'],
                        'refund_amount' => $refundAmount,
                        'refund_id' => $refund->id
                    ],
                    $user['id'],
                    $id,
                    'payment'
                );
            }
            
            // Audit the cancellation
            $this->auditService->logEvent(
                'booking_canceled',
                "Booking #{$id} canceled",
                [
                    'booking_id' => $id,
                    'user_id' => $user['id'],
                    'old_status' => $oldStatus,
                    'refund_amount' => $refundAmount ?? 0
                ],
                $user['id'],
                $id,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking canceled successfully'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to cancel booking'
            ], 500);
        }
    }

    /**
     * Fetch Booking Logs
     */
    public function getBookingLogs(int $bookingId): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            // Instead of getting booking logs directly from a logs table,
            // fetch audit events related to this booking from the audit service
            $logs = $this->auditService->getEventsByReference('booking_reference', $bookingId);
            
            // Log this access to audit logs
            $this->auditService->logEvent(
                'booking_logs_viewed',
                "Booking #{$bookingId} logs accessed",
                [
                    'booking_id' => $bookingId,
                    'user_id' => $user['id']
                ],
                $user['id'],
                $bookingId,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking logs fetched successfully',
                'data' => ['logs' => $logs]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch booking logs'
            ], 500);
        }
    }

    /**
     * List All Bookings for a User
     */
    public function getUserBookings(): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $bookings = Booking::where('user_id', $user['id'])->latest()->get();
            
            // Log the fetch operation
            $this->auditService->logEvent(
                'user_bookings_listed',
                "User retrieved their booking list",
                ['user_id' => $user['id']],
                $user['id'],
                null,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'User bookings fetched successfully',
                'data' => ['bookings' => $bookings]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch user bookings'
            ], 500);
        }
    }

    /**
     * Create New Booking
     */
    public function createBooking(): ResponseInterface
    {
        try {
            $user = $this->tokenService->validateTokenFromHeader($this->request->getHeader('Authorization')[0] ?? null);
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $data = $_POST; // assuming custom validation is performed elsewhere
            
            // Check vehicle availability using an assumed Booking::isAvailable() scope.
            if (!Booking::isAvailable($data['vehicle_id'], $data['pickup_date'], $data['dropoff_date'])) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Vehicle is not available for the selected dates'
                ], 400);
            }
            
            $booking = Booking::create($data);
            
            // Log the booking creation to the audit logs
            $this->auditService->logEvent(
                'booking_created',
                "New booking #{$booking->id} created",
                [
                    'booking_id' => $booking->id,
                    'user_id' => $user['id'],
                    'vehicle_id' => $data['vehicle_id'],
                    'pickup_date' => $data['pickup_date'], 
                    'dropoff_date' => $data['dropoff_date']
                ],
                $user['id'],
                $booking->id,
                'booking'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Booking created successfully',
                'data' => ['booking_id' => $booking->id]
            ], 201);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to create booking'
            ], 500);
        }
    }
}
=== App/Controllers/NotificationController.php ===
<?php

namespace App\Controllers;

use App\Models\Notification;
use App\Services\AuthService;
use App\Helpers\JsonResponse;
use App\Helpers\TokenValidator;
use App\Helpers\ExceptionHandler;
use App\Services\AuditService;
use Psr\Log\LoggerInterface;
use Psr\Http\Message\ResponseInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

/**
 * Notification Controller
 *
 * Handles notification management, including sending notifications,
 * marking notifications as read, deleting notifications, and
 * fetching user notifications for display.
 */
class NotificationController extends Controller
{
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;
    private AuditService $auditService;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    /**
     * Display user notifications.
     */
    public function viewNotifications(): ResponseInterface
    {
        try {
            $userId = AuthService::getUserIdFromToken();
            
            $notifications = Notification::with('user')
                ->where('user_id', $userId)
                ->latest()
                ->get();
                
            // Log notification view in audit logs
            $this->auditService->logEvent(
                'notifications_viewed',
                "User viewed their notifications",
                ['user_id' => $userId],
                $userId,
                null,
                'notification'
            );
                
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Notifications loaded',
                'data'    => ['notifications' => $notifications]
            ], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'An error occurred while fetching notifications'
            ], 500);
        }
    }

    /**
     * Fetch all notifications for the authenticated user.
     */
    public function getUserNotifications(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $notifications = Notification::with('user')
                ->where('user_id', $user->id)
                ->latest()
                ->get();
                
            // Log in audit logs
            $this->auditService->logEvent(
                'user_notifications_fetched',
                "User fetched their notifications via API",
                ['user_id' => $user->id],
                $user->id,
                null,
                'notification'
            );
                
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notifications retrieved successfully',
                'data' => ['notifications' => $notifications]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch user notifications'
            ], 500);
        }
    }

    /**
     * Fetch unread notifications via AJAX.
     */
    public function fetchNotificationsAjax(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $notifications = Notification::with('user')
                ->where('user_id', $user->id)
                ->where('is_read', false)
                ->latest()
                ->get();
                
            // Log notification fetch in audit logs
            $this->auditService->logEvent(
                'unread_notifications_fetched',
                "User fetched unread notifications",
                ['user_id' => $user->id, 'count' => $notifications->count()],
                $user->id,
                null,
                'notification'
            );
                
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notifications retrieved successfully',
                'data' => ['notifications' => $notifications]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to fetch notifications'
            ], 500);
        }
    }

    /**
     * Mark a notification as read.
     */
    public function markNotificationAsRead(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $data = $this->validateRequest($_POST, [
                'notification_id' => 'required|integer'
            ]);

            $notification = Notification::findOrFail($data['notification_id']);
            
            // Ensure user owns this notification
            if ($notification->user_id != $user->id) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized'
                ], 403);
            }

            $notification->update(['is_read' => true]);
            
            // Log in audit logs
            $this->auditService->logEvent(
                'notification_marked_as_read',
                "User marked a notification as read",
                ['user_id' => $user->id, 'notification_id' => $data['notification_id']],
                $user->id,
                null,
                'notification'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notification marked as read'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to mark notification as read'
            ], 500);
        }
    }

    /**
     * Delete a notification.
     */
    public function deleteNotification(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $data = $this->validateRequest($_POST, [
                'notification_id' => 'required|integer'
            ]);

            $notification = Notification::findOrFail($data['notification_id']);
            
            // Ensure user owns this notification
            if ($notification->user_id != $user->id) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized'
                ], 403);
            }

            $notification->delete();
            
            // Log in audit logs
            $this->auditService->logEvent(
                'notification_deleted',
                "User deleted a notification",
                ['user_id' => $user->id, 'notification_id' => $data['notification_id']],
                $user->id,
                null,
                'notification'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notification deleted'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to delete notification'
            ], 500);
        }
    }

    /**
     * Send a notification.
     */
    public function sendNotification(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token'
                ], 401);
            }

            $data = $this->validateRequest($_POST, [
                'user_id' => 'required|integer',
                'type'    => 'required|in:email,sms,webhook,push',
                'message' => 'required|string|max:1000',
                'options' => 'nullable|array',
            ]);

            // Store notification via Eloquent
            $notification = Notification::create([
                'user_id' => $data['user_id'],
                'type'    => $data['type'],
                'message' => $data['message'],
                'sent_at' => date('Y-m-d H:i:s'),
                'is_read' => false,
            ]);
            
            // Log in audit logs
            $this->auditService->logEvent(
                'notification_sent',
                "User sent a notification",
                ['user_id' => $data['user_id'], 'notification_id' => $notification->id],
                $user->id,
                null,
                'notification'
            );
            
            // Optionally dispatch via queue or any external channel here.
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Notification sent successfully',
                'data' => ['notification' => $notification]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status' => 'error',
                'message' => 'Failed to send notification'
            ], 500);
        }
    }
}
=== App/Controllers/AdminController.php ===
<?php

namespace App\Controllers;

use App\Helpers\DatabaseHelper;
use App\Services\AuditService;
use App\Services\Auth\TokenService;
use App\Helpers\JsonResponse;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

/**
 * AdminController - Handles admin user management and dashboard operations.
 */
class AdminController extends Controller
{
    private AuditService $auditService;
    private ResponseFactoryInterface $responseFactory;
    protected LoggerInterface $logger;
    private TokenService $tokenService;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        AuditService $auditService,
        ResponseFactoryInterface $responseFactory,
        TokenService $tokenService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->auditService = $auditService;
        $this->responseFactory = $responseFactory;
        $this->tokenService = $tokenService;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Create standardized PSR-7 JSON response
     */
    protected function jsonResponse(array $data, int $status = 200): ResponseInterface
    {
        $response = $this->responseFactory->createResponse($status);
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }
    
    /**
     * Validate admin token and return admin data
     */
    protected function validateAdmin(): ?array
    {
        $this->logger->debug("Validating admin token using secure database");
        
        // Use TokenService to extract the token
        $token = $this->tokenService->extractToken($this->request);
        
        if (empty($token)) {
            $this->logger->info("No authorization token provided");
            return null;
        }
        
        // Validate token and fetch admin details - using secure database
        $adminData = DatabaseHelper::select(
            "SELECT id, email, role FROM admins WHERE token = ? AND token_expiry > NOW()", 
            [$token],
            true // Explicitly using secure database
        );
            
        if (empty($adminData) || $adminData[0]['role'] !== 'admin') {
            $this->logger->info("Invalid admin token or insufficient permissions");
            return null;
        }
        
        $this->logger->info("Admin validated successfully", ['admin_id' => $adminData[0]['id']]);
        return $adminData[0];
    }

    /**
     * ✅ Get a paginated list of all users with their roles.
     */
    public function getAllUsers(): ResponseInterface
    {
        try {
            $admin = $this->validateAdmin();
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }

            $this->logger->debug("Fetching users with pagination using application database");
            
            // Get pagination parameters
            $page = (int) ($this->request->getQueryParams()['page'] ?? 1);
            $perPage = 10;
            $offset = ($page - 1) * $perPage;
            
            // Get users with pagination - using application database
            $users = DatabaseHelper::select(
                "SELECT u.*, r.name as role_name 
                 FROM users u 
                 LEFT JOIN roles r ON u.role_id = r.id 
                 ORDER BY u.created_at DESC 
                 LIMIT ? OFFSET ?",
                [$perPage, $offset],
                false // Explicitly using application database
            );
            
            // Get total count for pagination
            $totalUsers = DatabaseHelper::select(
                "SELECT COUNT(*) as count FROM users", 
                [],
                false // Explicitly using application database
            )[0]['count'];
            
            $this->auditService->logEvent(
                'user_list_viewed',
                'Admin viewed user list',
                ['admin_id' => $admin['id'], 'page' => $page],
                $admin['id'],
                null,
                'admin'
            );
            
            return $this->jsonResponse([
                'status' => 'success', 
                'message' => 'User list retrieved successfully', 
                'data' => [
                    'users' => $users,
                    'pagination' => [
                        'total' => $totalUsers,
                        'per_page' => $perPage,
                        'current_page' => $page,
                        'last_page' => ceil($totalUsers / $perPage)
                    ]
                ]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to retrieve users'], 500);
        }
    }

    /**
     * ✅ Update a user's role.
     */
    public function updateUserRole($userId): ResponseInterface
    {
        try {
            $admin = $this->validateAdmin();
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }

            $data = $this->request->getParsedBody();
            $role = $data['role'] ?? '';
            $allowedRoles = ['user', 'admin', 'manager'];
            if (!$role || !in_array($role, $allowedRoles)) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid role'
                ], 400);
            }
            
            $this->logger->debug("Fetching user data for role update using application database", [
                'user_id' => $userId
            ]);
            
            // Get user and their current role - using application database
            $user = DatabaseHelper::select(
                "SELECT id, role FROM users WHERE id = ?", 
                [(int)$userId],
                false // Explicitly using application database
            );
            
            if (empty($user)) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'User not found'
                ], 404);
            }
            
            $oldRole = $user[0]['role'];
            
            $this->logger->debug("Updating user role using application database", [
                'user_id' => $userId,
                'old_role' => $oldRole,
                'new_role' => $role
            ]);
            
            // Update role - using application database
            DatabaseHelper::update(
                "users", 
                ["role" => $role], 
                ["id" => (int)$userId],
                false // Explicitly using application database
            );
            
            $this->auditService->logEvent(
                'user_role_updated',
                "User role updated from {$oldRole} to {$role}",
                [
                    'user_id' => $userId,
                    'old_role' => $oldRole,
                    'new_role' => $role,
                    'admin_id' => $admin['id']
                ],
                $admin['id'],
                null,
                'admin'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'User role updated successfully'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to update user role'], 500);
        }
    }

    /**
     * ✅ Delete a user (Soft delete).
     */
    public function deleteUser($userId): ResponseInterface
    {
        try {
            $admin = $this->validateAdmin();
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }

            $this->logger->debug("Fetching user data for deletion using application database", [
                'user_id' => $userId
            ]);
            
            // Get user data for audit log - using application database
            $user = DatabaseHelper::select(
                "SELECT id, email, role FROM users WHERE id = ?", 
                [(int)$userId],
                false // Explicitly using application database
            );
            
            if (empty($user)) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'User not found'
                ], 404);
            }
            
            $userEmail = $user[0]['email'];
            $userRole = $user[0]['role'];
            
            // Check if user is a super admin
            if ($userRole === 'super_admin') {
                $this->logger->info("Attempted to delete a super_admin account", [
                    'user_id' => $userId,
                    'admin_id' => $admin['id']
                ]);
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Super admins cannot be deleted'
                ], 403);
            }
            
            $this->logger->debug("Soft deleting user using application database", [
                'user_id' => $userId,
                'user_email' => $userEmail
            ]);
            
            // Soft delete by setting deleted_at timestamp - using application database
            DatabaseHelper::update(
                "users", 
                ["deleted_at" => date('Y-m-d H:i:s')], 
                ["id" => (int)$userId],
                false // Explicitly using application database
            );
            
            $this->auditService->logEvent(
                'user_deleted',
                "User {$userEmail} was deleted",
                [
                    'user_id' => $userId,
                    'user_email' => $userEmail,
                    'admin_id' => $admin['id']
                ],
                $admin['id'],
                null,
                'admin'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'User deleted successfully'
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to delete user'], 500);
        }
    }

    /**
     * ✅ Fetch admin dashboard statistics.
     */
    public function getDashboardData(): ResponseInterface
    {
        try {
            $admin = $this->validateAdmin();
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }

            $this->logger->debug("Fetching dashboard statistics using application database");
            
            // Get total users count - using application database
            $totalUsers = DatabaseHelper::select(
                "SELECT COUNT(*) as count FROM users WHERE deleted_at IS NULL", 
                [],
                false // Explicitly using application database
            )[0]['count'];
            
            // Get total bookings count - using application database
            $totalBookings = DatabaseHelper::select(
                "SELECT COUNT(*) as count FROM bookings", 
                [],
                false // Explicitly using application database
            )[0]['count'];
            
            // Get total revenue - using application database
            $totalRevenue = DatabaseHelper::select(
                "SELECT SUM(amount) as total FROM payments WHERE status = 'completed'", 
                [],
                false // Explicitly using application database
            )[0]['total'] ?? 0;
            
            // Get latest 5 users - using application database
            $latestUsers = DatabaseHelper::select(
                "SELECT u.*, r.name as role_name 
                 FROM users u 
                 LEFT JOIN roles r ON u.role_id = r.id 
                 WHERE u.deleted_at IS NULL 
                 ORDER BY u.created_at DESC 
                 LIMIT 5",
                [],
                false // Explicitly using application database
            );
            
            // Get latest 5 transactions - using application database
            $latestTransactions = DatabaseHelper::select(
                "SELECT * FROM transaction_logs ORDER BY created_at DESC LIMIT 5",
                [],
                false // Explicitly using application database
            );
            
            $dashboardData = [
                'total_users' => $totalUsers,
                'total_bookings' => $totalBookings,
                'total_revenue' => $totalRevenue,
                'latest_users' => $latestUsers,
                'latest_transactions' => $latestTransactions,
            ];
            
            $this->auditService->logEvent(
                'dashboard_viewed',
                'Admin viewed dashboard',
                ['admin_id' => $admin['id']],
                $admin['id'],
                null,
                'admin'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Dashboard data retrieved successfully',
                'data' => $dashboardData
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to retrieve dashboard data'], 500);
        }
    }

    /**
     * ✅ Create a new admin user.
     */
    public function createAdmin(): ResponseInterface
    {
        try {
            $admin = $this->validateAdmin();
            if (!$admin) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid token or insufficient permissions'
                ], 401);
            }

            $data = $this->request->getParsedBody();
            
            // Validate input
            if (!isset($data['name'], $data['email'], $data['password']) ||
                !filter_var($data['email'], FILTER_VALIDATE_EMAIL) ||
                strlen($data['password']) < 8
            ) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Invalid input. Email must be valid and password must be at least 8 characters'
                ], 400);
            }
            
            $this->logger->debug("Checking for existing admin email using secure database", [
                'email' => $data['email']
            ]);
            
            // Check if email already exists - using secure database
            $existingAdmin = DatabaseHelper::select(
                "SELECT id FROM admins WHERE email = ?", 
                [$data['email']],
                true // Explicitly using secure database
            );
            
            if (!empty($existingAdmin)) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Email already in use'
                ], 400);
            }
            
            // Create new admin - using secure database
            $hashedPassword = password_hash($data['password'], PASSWORD_DEFAULT);
            
            $this->logger->debug("Creating new admin user in secure database");
            
            // Insert new admin record - using secure database
            $newAdminId = DatabaseHelper::insert(
                "admins", 
                [
                    "name" => $data['name'],
                    "email" => $data['email'],
                    "password" => $hashedPassword,
                    "role" => 'admin',
                    "created_at" => date('Y-m-d H:i:s')
                ],
                true // Explicitly using secure database
            );
            
            if (!$newAdminId) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Failed to create admin user'
                ], 500);
            }
            
            $this->logger->debug("Fetching created admin details from secure database", [
                'new_admin_id' => $newAdminId
            ]);
            
            // Get created admin details for response - using secure database
            $newAdmin = DatabaseHelper::select(
                "SELECT id, name, email, role, created_at FROM admins WHERE id = ?", 
                [$newAdminId],
                true // Explicitly using secure database
            )[0];
            
            $this->auditService->logEvent(
                'admin_created',
                "New admin user created: {$data['email']}",
                [
                    'created_by' => $admin['id'],
                    'new_admin_id' => $newAdminId,
                    'new_admin_email' => $data['email']
                ],
                $admin['id'],
                null,
                'admin'
            );
            
            return $this->jsonResponse([
                'status' => 'success',
                'message' => 'Admin created successfully',
                'data' => $newAdmin
            ], 201);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse(['status' => 'error', 'message' => 'Failed to create admin user'], 500);
        }
    }
}
=== App/Controllers/AuthController.php ===
<?php

namespace App\Controllers;

use App\Services\Auth\AuthService;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Log\LoggerInterface;
use App\Services\Auth\TokenService;
use App\Helpers\DatabaseHelper;
use App\Services\RateLimiter;
use App\Helpers\ExceptionHandler;

class AuthController extends Controller
{
    protected LoggerInterface $logger;
    private AuthService $authService;
    private TokenService $tokenService;
    private $pdo;
    private RateLimiter $rateLimiter;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        AuthService $authService,
        TokenService $tokenService,
        DatabaseHelper $dbHelper,
        RateLimiter $rateLimiter,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->authService = $authService;
        $this->tokenService = $tokenService;
        $this->pdo = $dbHelper->getPdo();
        $this->rateLimiter = $rateLimiter;
        $this->exceptionHandler = $exceptionHandler;
    }    

    public function login(Request $request, Response $response)
    {
        try {
            // Rewind the request body stream in case it was consumed
            $request->getBody()->rewind();
            
            // Use getParsedBody() for consistency with other endpoints
            $data = $request->getParsedBody();
            
            if (!is_array($data)) {
                $this->logger->error("Parsed body is not an array or is null in login.");
                return $this->jsonResponse($response, ["error" => "Invalid JSON input"], 400);
            }

            $this->logger->debug("Parsed request data in login: " . print_r($data, true));

            if (!isset($data['email']) || !isset($data['password'])) {
                $this->logger->warning("Missing required fields in login");
                return $this->jsonResponse($response, ["error" => "Email and password are required"], 400);
            }

            // Rate Limiting Logic
            $email = $data['email'];
            $ipAddress = $request->getServerParams()['REMOTE_ADDR'] ?? 'UNKNOWN';

        
            if ($this->rateLimiter->isRateLimited($email, $ipAddress, 'login')) {
                $this->logger->warning("Rate limit exceeded for login", ['email' => $email, 'ip' => $ipAddress]);
                return $this->jsonResponse($response, ["error" => "Too many login attempts. Please try again later."], 429);
            }

            $result = $this->authService->login($data);
            $this->logger->info('User login successful', ['email' => $data['email']]);
            
            // Set JWT token as a secure HttpOnly cookie
            setcookie('jwt', $result['token'], [
                'expires'  => time() + 3600,
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            // Set refresh token as a secure HttpOnly cookie with longer expiration
            setcookie('refresh_token', $result['refresh_token'], [
                'expires'  => time() + 604800,
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            // Return success message without exposing tokens in the response body
            return $this->jsonResponse($response, [
                "message" => "Login successful",
                "user_id" => $result['user_id'] ?? null,
                "name" => $result['name'] ?? null
            ]);
            
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Authentication failed"], 401);
        }
    }

    public function register(Request $request, Response $response)
    {
        try {
            // Use getParsedBody() since the parsed body was set in index.php
            $data = $request->getParsedBody();
            
            if (!is_array($data)) {
                $this->logger->error("Parsed body is not an array or is null.");
                return $this->jsonResponse($response, ["error" => "Invalid JSON input"], 400);
            }

            $this->logger->debug("Parsed request data in register: " . print_r($data, true));

            $requiredFields = ['name', 'surname', 'email', 'password'];
            $missingFields = array_diff($requiredFields, array_keys($data));

            if (!empty($missingFields)) {
                $this->logger->warning("Missing required fields in register: " . implode(', ', $missingFields));
                return $this->jsonResponse($response, ["error" => "Missing fields: " . implode(', ', $missingFields)], 400);
            }

            $result = $this->authService->register($data);
            $this->logger->info('User registration attempt', ['data' => $data]);

            return $this->jsonResponse($response, $result);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Registration failed"], 500);
        }
    }

    public function refresh(Request $request, Response $response)
    {
        try {
            // Try to get refresh token from cookie first
            $refreshToken = $_COOKIE['refresh_token'] ?? null;
            
            // If not in cookie, try to get from request body
            if (!$refreshToken) {
                $request->getBody()->rewind();
                $data = $request->getParsedBody();
                $refreshToken = $data['refresh_token'] ?? null;
            }
            
            if (!$refreshToken) {
                $this->logger->warning('Refresh token missing');
                return $this->jsonResponse($response, ["error" => "Refresh token is required"], 400);
            }
            
            $result = $this->authService->refresh(['refresh_token' => $refreshToken]);
            $this->logger->info('Token refreshed successfully');
            
            // Set the new JWT token as a cookie
            setcookie('jwt', $result['token'], [
                'expires'  => time() + 3600,
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            return $this->jsonResponse($response, ["message" => "Token refreshed successfully"]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Token refresh failed"], 401);
        }
    }

    public function logout(Request $request, Response $response)
    {
        try {
            // Clear both JWT and refresh token cookies
            setcookie('jwt', '', [
                'expires'  => time() - 3600, // Expire in the past
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            setcookie('refresh_token', '', [
                'expires'  => time() - 3600, // Expire in the past
                'path'     => '/',
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]);
            
            // Log the logout action
            $this->logger->info('User logged out successfully');
            
            // Call the service logout method if needed (e.g., to revoke tokens server-side)
            $this->authService->logout([]);
            
            return $this->jsonResponse($response, ["message" => "Logout successful"]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Logout failed"], 500);
        }
    }

    /**
     * Get authenticated user details
     * 
     * This endpoint assumes AuthMiddleware is applied to the route.
     * For protected routes, use AuthMiddleware with required=true.
     */
    public function userDetails(Request $request, Response $response): Response
    {
        try {
            $user = $request->getAttribute('user');
            
            if (!$user) {
                $this->logger->error("User not authenticated");
                return $this->jsonResponse($response->withStatus(401), ['error' => 'Authentication required']);
            }
            
            // Remove sensitive fields
            $userDetails = array_diff_key($user, array_flip(['password_hash']));
            
            $this->logger->info("User details retrieved successfully", ['user_id' => $user['id']]);
            return $this->jsonResponse($response, ['user' => $userDetails]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Failed to get user details"], 500);
        }
    }

    public function resetPasswordRequest(Request $request, Response $response)
    {
        try {
            $request->getBody()->rewind();
            $data = $request->getParsedBody();
            
            if (!is_array($data)) {
                $this->logger->error("Invalid JSON input for password reset request");
                return $this->jsonResponse($response, ["error" => "Invalid JSON input"], 400);
            }
            
            if (!isset($data['email'])) {
                $this->logger->warning("Missing email in password reset request");
                return $this->jsonResponse($response, ["error" => "Email is required"], 400);
            }
            
            $result = $this->authService->resetPasswordRequest($data);
            $this->logger->info("Password reset requested", ['email' => $data['email']]);
            return $this->jsonResponse($response, ["message" => "Password reset email sent"]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Password reset request failed"], 500);
        }
    }

    public function resetPassword(Request $request, Response $response)
    {
        try {
            $request->getBody()->rewind();
            $data = $request->getParsedBody();
            
            if (!is_array($data)) {
                $this->logger->error("Invalid JSON input for password reset");
                return $this->jsonResponse($response, ["error" => "Invalid JSON input"], 400);
            }
            
            // Validate required fields
            $requiredFields = ['token', 'password', 'confirm_password'];
            $missingFields = array_diff($requiredFields, array_keys($data));
            
            if (!empty($missingFields)) {
                $this->logger->warning("Missing fields in password reset", ['missing' => $missingFields]);
                return $this->jsonResponse($response, [
                    "error" => "Missing required fields: " . implode(', ', $missingFields)
                ], 400);
            }
            
            // Check if passwords match
            if ($data['password'] !== $data['confirm_password']) {
                $this->logger->warning("Password mismatch in reset");
                return $this->jsonResponse($response, ["error" => "Passwords do not match"], 400);
            }
            
            $result = $this->authService->resetPassword($data);
            $this->logger->info("Password reset completed successfully");
            return $this->jsonResponse($response, ["message" => "Password has been reset successfully"]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse($response, ["error" => "Password reset failed"], 500);
        }
    }
}
=== App/Controllers/README.md ===
# Controller Audit Logging Guide

## Overview
This guide explains how to properly log audit events directly from controllers using the `AuditService`. The `AuditTrailMiddleware` is now deprecated and controllers should handle their own audit logging.

## Basic Usage

```php
// Inject AuditService in your controller
private AuditService $auditService;

public function __construct(AuditService $auditService) 
{
    $this->auditService = $auditService;
}

// Example usage in a controller method
public function login(Request $request)
{
    // Process login
    $success = $this->authService->authenticate($request->email, $request->password);
    
    if ($success) {
        // Log successful login
        $this->auditService->logAuthEvent(
            $user->id,
            'login',
            ['device' => $request->userAgent()]
        );
        
        return $this->response->json(['success' => true]);
    } else {
        // Log failed login attempt
        $this->auditService->logAuthEvent(
            0,  // No user ID for failed login
            'failed_login',
            ['email' => $request->email]
        );
        
        return $this->response->json(['error' => 'Invalid credentials'], 401);
    }
}
```

## Common Audit Scenarios

### Authentication Events
```php
// Login
$this->auditService->logAuthEvent($userId, 'login', $context);

// Logout
$this->auditService->logAuthEvent($userId, 'logout', $context);

// Password reset
$this->auditService->logAuthEvent($userId, 'password_reset', $context);
```

### User Actions
```php
// Create user
$this->auditService->logUserAction(
    $adminId,
    'create',
    'user',
    $newUserId,
    ['user_data' => $userData]
);

// Update user
$this->auditService->logUserAction(
    $userId,
    'update',
    'user',
    $userId,
    [
        'before' => $oldData,
        'after' => $newData
    ]
);

// Delete user
$this->auditService->logUserAction($adminId, 'delete', 'user', $deletedUserId);
```

### Booking Events
```php
// Create booking
$this->auditService->logBookingEvent(
    $bookingId,
    'created',
    $userId,
    ['amount' => $amount, 'details' => $bookingDetails]
);

// Update booking
$this->auditService->logBookingEvent(
    $bookingId,
    'updated',
    $userId,
    ['changes' => $changes]
);

// Cancel booking
$this->auditService->logBookingEvent(
    $bookingId,
    'cancelled',
    $userId,
    ['reason' => $reason]
);
```

### API Requests
```php
// In API controllers, after processing
$this->auditService->logApiRequest(
    '/api/v1/resource',
    'POST',
    $request->all(),
    $responseData,
    $statusCode,
    $userId
);
```

### Security Events
```php
// Failed login attempts
$this->auditService->logSecurityEvent(
    'failed_login',
    'Multiple failed login attempts',
    ['attempts' => $attempts, 'email' => $email],
    null
);

// Permission denied
$this->auditService->logSecurityEvent(
    'permission_denied',
    'User attempted to access restricted resource',
    ['resource' => $resource],
    $userId
);
```

## Best Practices

1. Always log at the outcome of an operation, not before it happens
2. Include relevant context but avoid sensitive information
3. Use the appropriate helper method for the type of action
4. For custom events, use the generic `logEvent()` method
5. Keep log messages concise and action-oriented
=== App/Controllers/SignatureController.php ===
<?php

namespace App\Controllers;

use App\Services\SignatureService;
use App\Services\AuditService;
use App\Helpers\TokenValidator;
use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

/**
 * Signature Controller
 *
 * Handles the management of user signatures, including uploading,
 * verifying, and retrieving signatures for documents.
 */
class SignatureController extends Controller
{
    private SignatureService $signatureService;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;
    private AuditService $auditService;

    public function __construct(
        LoggerInterface $logger,
        SignatureService $signatureService,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->signatureService = $signatureService;
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    /**
     * Upload a signature.
     *
     * @param array $data The uploaded signature file and associated metadata.
     * @return array Response indicating success or failure.
     */
    public function uploadSignature(array $data): array
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return ['status' => 'error', 'message' => 'Unauthorized access', 'code' => 401];
            }

            $rules = [
                'user_id' => 'required|integer',
                'file' => 'required|file|mimes:png,jpg,jpeg|max:2048', // Max 2MB
            ];

            $this->validator->validate($data, $rules);

            $signaturePath = $this->signatureService->uploadSignature($data['user_id'], $data['file']);
            
            // Log the signature upload event
            $this->auditService->logEvent(
                'signature_uploaded',
                "Signature uploaded successfully",
                ['user_id' => $data['user_id']],
                $user->id,
                null,
                'document'
            );
            
            return ['status' => 'success', 'message' => 'Signature uploaded successfully', 'data' => $signaturePath];
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ['status' => 'error', 'message' => 'Failed to upload signature', 'code' => 500];
        }
    }

    /**
     * Verify a signature.
     *
     * @param int $userId The ID of the user whose signature is to be verified.
     * @param string $documentHash The hash of the document to verify against the signature.
     * @return array Verification result.
     */
    public function verifySignature(int $userId, string $documentHash): array
    {
        try {
            $isValid = $this->signatureService->verifySignature($userId, $documentHash);
            
            // Log the signature verification attempt
            $this->auditService->logEvent(
                'signature_verified',
                "Signature verification " . ($isValid ? "successful" : "failed"),
                [
                    'user_id' => $userId,
                    'document_hash' => substr($documentHash, 0, 10) . '...',
                    'result' => $isValid ? 'valid' : 'invalid'
                ],
                null, // No authenticated user (system action)
                null,
                'document'
            );

            if ($isValid) {
                return ['status' => 'success', 'message' => 'Signature verified successfully'];
            }

            return ['status' => 'error', 'message' => 'Signature verification failed', 'code' => 400];
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ['status' => 'error', 'message' => 'Failed to verify signature', 'code' => 500];
        }
    }

    /**
     * Retrieve a user's signature.
     *
     * @param int $userId The ID of the user.
     * @return array Response containing the signature path or error message.
     */
    public function getSignature(int $userId): array
    {
        try {
            $requestingUser = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$requestingUser) {
                return ['status' => 'error', 'message' => 'Unauthorized access', 'code' => 401];
            }
            
            $signaturePath = $this->signatureService->getSignature($userId);
            
            // Log the signature retrieval
            $this->auditService->logEvent(
                'signature_retrieved',
                "Signature retrieved " . ($signaturePath ? "successfully" : "failed - not found"),
                [
                    'user_id' => $userId,
                    'requested_by' => $requestingUser->id
                ],
                $requestingUser->id,
                null,
                'document'
            );

            if ($signaturePath) {
                return ['status' => 'success', 'message' => 'Signature retrieved successfully', 'data' => $signaturePath];
            }

            return ['status' => 'error', 'message' => 'Signature not found', 'code' => 404];
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return ['status' => 'error', 'message' => 'Failed to retrieve signature', 'code' => 500];
        }
    }
}
=== App/Controllers/DashboardController.php ===
<?php

namespace App\Controllers;

use App\Models\Booking;
use App\Models\Payment;
use App\Models\Notification;
use App\Models\User;
use App\Services\AuditService;
use App\Helpers\ExceptionHandler;
use Illuminate\Support\Facades\Cache;
use Psr\Log\LoggerInterface;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

class DashboardController extends Controller
{
    private BookingService $bookingService;
    private StatisticsService $statisticsService;
    private NotificationService $notificationService;
    private UserService $userService;
    private AuditService $auditService;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        BookingService $bookingService,
        StatisticsService $statisticsService,
        NotificationService $notificationService,
        UserService $userService,
        AuditService $auditService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->bookingService = $bookingService;
        $this->statisticsService = $statisticsService;
        $this->notificationService = $notificationService;
        $this->userService = $userService;
        $this->auditService = $auditService;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Render user dashboard view.
     */
    public function userDashboard()
    {
        try {
            // Assume session_start() is already called.
            $user = (object)['id' => $_SESSION['user_id'] ?? null]; // Replace with native session retrieval
            // ...existing code for eager loading if needed...
            $statistics = Cache::remember('user_dashboard_' . $user->id, 60, function () use ($user) {
                return [
                    'total_bookings'     => Booking::where('user_id', $user->id)->count(),
                    'completed_bookings' => Booking::where('user_id', $user->id)->where('status', 'completed')->count(),
                    'total_payments'     => Payment::where('user_id', $user->id)->sum('amount'),
                ];
            });
            
            // Log dashboard access
            $this->auditService->logEvent(
                'dashboard_accessed',
                "User accessed their dashboard",
                ['user_id' => $user->id],
                $user->id,
                null,
                'user'
            );
            
            view('dashboard/user_dashboard', ['user' => $user, 'statistics' => $statistics]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    /**
     * Fetch user bookings.
     */
    public function getUserBookings(): void
    {
        try {
            $userId = $_SESSION['user_id'] ?? null;
            $bookings = Booking::where('user_id', $userId)->get();
            
            // Log bookings fetch
            $this->auditService->logEvent(
                'bookings_fetched',
                "User fetched their bookings",
                ['user_id' => $userId],
                $userId,
                null,
                'booking'
            );
            
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Bookings fetched',
                'data'    => ['bookings' => $bookings]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    /**
     * Fetch dashboard statistics.
     */
    public function fetchStatistics(): void
    {
        try {
            $userId = $_SESSION['user_id'] ?? null;
            
            $stats = Cache::remember('dashboard_statistics', 60, function () {
                return [
                    'total_bookings'     => Booking::count(),
                    'completed_bookings' => Booking::where('status', 'completed')->count(),
                    'total_revenue'      => Payment::sum('amount')
                ];
            });
            
            // Log statistics fetch
            $this->auditService->logEvent(
                'statistics_fetched',
                "User fetched dashboard statistics",
                ['user_id' => $userId],
                $userId,
                null,
                'user'
            );
            
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Statistics fetched',
                'data'    => $stats
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    /**
     * Fetch user notifications.
     */
    public function fetchNotifications(): void
    {
        try {
            $userId = $_SESSION['user_id'] ?? null;
            
            $notifications = Notification::where('user_id', $userId)
                ->latest()
                ->get();
                
            // Log notifications fetch
            $this->auditService->logEvent(
                'notifications_fetched',
                "User fetched their notifications",
                ['user_id' => $userId],
                $userId,
                null,
                'notification'
            );
            
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Notifications fetched',
                'data'    => ['notifications' => $notifications]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    /**
     * Fetch user profile.
     */
    public function fetchUserProfile(): void
    {
        try {
            $userId = $_SESSION['user_id'] ?? null;
            $profile = User::findOrFail($userId);
            
            // Log profile fetch
            $this->auditService->logEvent(
                'profile_fetched',
                "User fetched their profile",
                ['user_id' => $userId],
                $userId,
                null,
                'user'
            );
            
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'User profile fetched',
                'data'    => ['profile' => $profile]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }
}
=== App/Controllers/update_catch.sh ===
#!/bin/bash

# Define the ExceptionHandler include statement
EXCEPTION_HANDLER_INCLUDE="require_once '/../Helpers/ExceptionHandler.php';"

# Define the output file for constructor exports
CONSTRUCTS_EXPORT="constructs_export.txt"

# Clear the export file before starting
> "$CONSTRUCTS_EXPORT"

# Find all PHP files and process them
find . -type f -name "*.php" | while read -r file; do
    echo "Processing: $file"

    # Check if the file contains a try-catch block
    if grep -q "try\s*{" "$file"; then
        # Replace all try-catch blocks with ExceptionHandler usage
        sed -i -E 's|try\s*\{([^}]*)\}\s*catch\s*\((Exception\s+\$\w+)\)\s*\{([^}]*)\}|try {\1} catch (\2) {\n    ExceptionHandler::handle(\2);\n}|g' "$file"
        
        echo "Updated try-catch blocks in: $file"
    fi

    # Check if the ExceptionHandler is already included
    if ! grep -q "require_once 'path/to/ExceptionHandler.php';" "$file"; then
        # Add ExceptionHandler inclusion at the top of the file
        sed -i "1s|^|$EXCEPTION_HANDLER_INCLUDE\n|" "$file"
        echo "Added ExceptionHandler inclusion to: $file"
    fi

    # Extract and export all constructor methods
    if grep -q "function __construct" "$file"; then
        echo "Extracting constructor from: $file"
        echo -e "\n--- Constructor from $file ---" >> "$CONSTRUCTS_EXPORT"
        awk '/function __construct/,/}/{print}' "$file" >> "$CONSTRUCTS_EXPORT"
    fi
done

echo "✅ All files processed. Constructor exports saved to $CONSTRUCTS_EXPORT."
=== App/Controllers/AdminDashboardController.php ===
<?php

namespace App\Controllers;

use App\Models\User;
use App\Models\Booking;
use App\Models\Payment;
use Illuminate\Support\Facades\Cache;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use App\Services\AuditService;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

class AdminDashboardController extends Controller
{
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;
    private AuditService $auditService;

    public function __construct(
        LoggerInterface $logger,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    public function index(): void
    {
        try {
            $metrics = Cache::remember('dashboard_metrics', 60, function () {
                $totalRevenue = Payment::where('status', 'completed')->sum('amount');
                $totalRefunds = Payment::where('status', 'completed')->where('type', 'refund')->sum('amount');
                return [
                    'total_users'        => User::count(),
                    'active_users'       => User::where('active', true)->count(),
                    'total_bookings'     => Booking::count(),
                    'completed_bookings' => Booking::where('status', 'completed')->count(),
                    'canceled_bookings'  => Booking::where('status', 'canceled')->count(),
                    'total_revenue'      => $totalRevenue,
                    'total_refunds'      => $totalRefunds,
                    'net_revenue'        => $totalRevenue - $totalRefunds,
                ];
            });
            $recentBookings = Booking::with('user')->latest()->limit(5)->get();

            // Log this dashboard view in audit logs
            $this->auditService->logEvent(
                'admin_dashboard_viewed',
                'Admin dashboard viewed',
                ['admin_id' => $_SESSION['user_id'] ?? 'unknown'],
                $_SESSION['user_id'] ?? null,
                null,
                'admin'
            );

            extract(compact('metrics', 'recentBookings'));
            include BASE_PATH . '/public/views/admin/dashboard.php';
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }

    public function getDashboardData(): void
    {
        try {
            requireAuth(); // ensure admin authentication is in place
            
            $metrics = Cache::remember('dashboard_metrics', 60, function () {
                $totalRevenue = Payment::where('status', 'completed')->sum('amount');
                $totalRefunds = Payment::where('status', 'completed')->where('type', 'refund')->sum('amount');
                return [
                    'total_users'        => User::count(),
                    'active_users'       => User::where('active', true)->count(),
                    'total_bookings'     => Booking::count(),
                    'completed_bookings' => Booking::where('status', 'completed')->count(),
                    'canceled_bookings'  => Booking::where('status', 'canceled')->count(),
                    'total_revenue'      => $totalRevenue,
                    'total_refunds'      => $totalRefunds,
                    'net_revenue'        => $totalRevenue - $totalRefunds,
                ];
            });
            $recentBookings = Booking::with('user')->latest()->limit(5)->get();

            // Log this API request in audit logs
            $this->auditService->logEvent(
                'admin_dashboard_data_api',
                'Admin dashboard data API requested',
                ['admin_id' => $_SESSION['user_id'] ?? 'unknown'],
                $_SESSION['user_id'] ?? null,
                null,
                'admin'
            );

            header('Content-Type: application/json');
            http_response_code(200);
            echo json_encode([
                'status'  => 'success',
                'message' => 'Dashboard data fetched',
                'data'    => [
                    'metrics'         => $metrics,
                    'recent_bookings' => $recentBookings,
                ]
            ]);
            exit;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
        }
    }
}
=== App/Controllers/PaymentController.php ===
<?php

namespace App\Controllers;

use App\Models\Payment;
use App\Models\RefundLog;
use App\Models\TransactionLog;
use App\Models\InstallmentPlan;
use App\Services\AuditService;
use App\Helpers\TokenValidator;
use App\Helpers\ExceptionHandler;
use App\Helpers\DatabaseHelper;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Log\LoggerInterface;

/**
 * Payment Controller
 *
 * Handles payment processing, refunds, installment payments, and user transactions.
 */
class PaymentController extends Controller
{
    private PaymentService $paymentService;
    private Validator $validator;
    private NotificationService $notificationService;
    private AuditService $auditService;
    private ResponseFactoryInterface $responseFactory;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        PaymentService $paymentService,
        Validator $validator,
        NotificationService $notificationService,
        AuditService $auditService,
        ResponseFactoryInterface $responseFactory,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->paymentService = $paymentService;
        $this->validator = $validator;
        $this->notificationService = $notificationService;
        $this->auditService = $auditService;
        $this->responseFactory = $responseFactory;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * Create standardized PSR-7 JSON response
     */
    protected function jsonResponse(array $data, int $status = 200): ResponseInterface
    {
        $response = $this->responseFactory->createResponse($status);
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    /**
     * Process a payment.
     */
    public function processPayment(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $data = $this->validateRequest($_POST, [
                'booking_id'       => 'required|integer',
                'amount'           => 'required|numeric|min:0.01',
                'payment_method_id' => 'required|integer',
            ]);
            
            $payment = Payment::create([
                'booking_id'     => $data['booking_id'],
                'user_id'        => $user->id,
                'amount'         => $data['amount'],
                'payment_method' => $data['payment_method_id'],
                'status'         => 'completed'
            ]);
            
            // Update related booking status via Eloquent relationship
            $payment->booking()->update(['status' => 'paid']);
            
            // Log the payment in the secure audit logs
            $this->auditService->logEvent(
                'payment_processed',
                "Payment of {$data['amount']} processed for booking #{$data['booking_id']}",
                [
                    'payment_id' => $payment->id,
                    'booking_id' => $data['booking_id'],
                    'user_id' => $user->id,
                    'amount' => $data['amount'],
                    'payment_method' => $data['payment_method_id']
                ],
                $user->id,
                $data['booking_id'],
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Payment processed',
                'data'    => ['payment' => $payment]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Payment processing failed'
            ], 500);
        }
    }

    /**
     * Refund a payment.
     */
    public function refundPayment(): ResponseInterface
    {
        try {
            $admin = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$admin || !$admin->isAdmin()) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized - admin rights required'
                ], 401);
            }
            
            $data = $this->validateRequest($_POST, [
                'transaction_id' => 'required|integer',
                'amount'         => 'required|numeric|min:0.01',
            ]);
            
            // Get the original transaction
            $transaction = TransactionLog::findOrFail($data['transaction_id']);
            
            $refund = RefundLog::create([
                'transaction_id' => $data['transaction_id'],
                'amount'         => $data['amount'],
                'status'         => 'processed'
            ]);
            
            // Log the refund in the secure audit logs
            $this->auditService->logEvent(
                'refund_processed',
                "Refund of {$data['amount']} processed for transaction #{$data['transaction_id']}",
                [
                    'refund_id' => $refund->id,
                    'transaction_id' => $data['transaction_id'],
                    'booking_id' => $transaction->booking_id,
                    'user_id' => $transaction->user_id,
                    'admin_id' => $admin->id,
                    'amount' => $data['amount']
                ],
                $admin->id,
                $transaction->booking_id,
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Refund processed',
                'data'    => ['refund' => $refund]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Refund processing failed'
            ], 500);
        }
    }

    /**
     * Set up installment payments.
     */
    public function setupInstallment(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $data = $this->validateRequest($_POST, [
                'total_amount'      => 'required|numeric|min:0.01',
                'installments'      => 'required|integer|min:2',
                'payment_method_id' => 'required|integer',
                'booking_id'        => 'required|integer',
            ]);
            
            $plan = InstallmentPlan::create([
                'user_id'        => $user->id,
                'booking_id'     => $data['booking_id'],
                'total_amount'   => $data['total_amount'],
                'installments'   => $data['installments'],
                'payment_method' => $data['payment_method_id'],
            ]);
            
            // Log the installment plan creation
            $this->auditService->logEvent(
                'installment_plan_created',
                "Installment plan created for user #{$user->id} with {$data['installments']} installments",
                [
                    'plan_id' => $plan->id,
                    'user_id' => $user->id,
                    'booking_id' => $data['booking_id'],
                    'total_amount' => $data['total_amount'],
                    'installments' => $data['installments']
                ],
                $user->id,
                $data['booking_id'],
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Installment plan created',
                'data'    => ['installment_plan' => $plan]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Installment plan setup failed'
            ], 500);
        }
    }

    /**
     * Fetch all user transactions.
     */
    public function getUserTransactions(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $transactions = TransactionLog::with(['payment', 'booking'])
                ->where('user_id', $user->id)
                ->latest()
                ->get();
            
            // Log the transaction view activity
            $this->auditService->logEvent(
                'transactions_viewed',
                "User viewed their transaction history",
                ['user_id' => $user->id],
                $user->id,
                null,
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Transactions fetched',
                'data'    => ['transactions' => $transactions]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to fetch user transactions'
            ], 500);
        }
    }

    /**
     * Fetch payment details.
     */
    public function getPaymentDetails(int $transactionId): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $details = TransactionLog::findOrFail($transactionId);
            
            // Verify the user owns this transaction or is an admin
            if ($details->user_id != $user->id && !$user->isAdmin()) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'You do not have permission to view this transaction'
                ], 403);
            }
            
            // Log the access to payment details
            $this->auditService->logEvent(
                'payment_details_viewed',
                "Payment details accessed for transaction #{$transactionId}",
                [
                    'transaction_id' => $transactionId,
                    'user_id' => $user->id,
                    'is_admin' => $user->isAdmin() ? 'yes' : 'no'
                ],
                $user->id,
                $details->booking_id ?? null,
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Payment details fetched',
                'data'    => ['details' => $details]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to fetch payment details'
            ], 500);
        }
    }

    /**
     * Process payment for an installment.
     */
    public function processInstallmentPayment(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $data = $this->validateRequest($_POST, [
                'installment_id'    => 'required|integer',
                'payment_method_id' => 'required|integer',
            ]);
            
            // Get the installment details using DatabaseHelper
            $installment = DatabaseHelper::select(
                "SELECT * FROM installments WHERE id = ? AND user_id = ?",
                [(int)$data['installment_id'], $user->id],
                false // Using application database
            );
            
            if (empty($installment)) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Installment not found or does not belong to you'
                ], 404);
            }
            
            $installmentData = $installment[0];
            
            // Process payment for this specific installment
            $payment = Payment::create([
                'user_id'        => $user->id,
                'booking_id'     => $installmentData['booking_id'],
                'installment_id' => $data['installment_id'],
                'amount'         => $installmentData['amount'],
                'payment_method' => $data['payment_method_id'],
                'status'         => 'completed',
            ]);
            
            // Update installment status
            DatabaseHelper::update(
                "installments",
                ["status" => "paid", "paid_at" => date('Y-m-d H:i:s')],
                ["id" => (int)$data['installment_id']],
                false // Using application database
            );
            
            // Log the payment in audit logs
            $this->auditService->logEvent(
                'installment_payment_processed',
                "Installment payment processed",
                [
                    'user_id' => $user->id,
                    'installment_id' => $data['installment_id'],
                    'payment_id' => $payment->id,
                    'amount' => $installmentData['amount']
                ],
                $user->id,
                $installmentData['booking_id'],
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Installment payment processed successfully',
                'data'    => ['payment' => $payment]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to process installment payment'
            ], 500);
        }
    }

    /**
     * Add a payment method.
     */
    public function addPaymentMethod(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            $data = $this->validateRequest($_POST, [
                'type'        => 'required|string',
                'card_last4'  => 'required_if:type,credit_card|numeric',
                'card_brand'  => 'required_if:type,credit_card|string',
                'expiry_date' => 'required_if:type,credit_card|string',
                'is_default'  => 'nullable|boolean',
            ]);
            
            // Add payment method using DatabaseHelper for secure storage
            $paymentMethodId = DatabaseHelper::insert(
                "payment_methods",
                [
                    "user_id" => $user->id,
                    "type" => $data['type'],
                    "card_last4" => $data['card_last4'] ?? null,
                    "card_brand" => $data['card_brand'] ?? null,
                    "expiry_date" => $data['expiry_date'] ?? null,
                    "is_default" => $data['is_default'] ?? false,
                    "created_at" => date('Y-m-d H:i:s')
                ],
                true // Using secure database for payment details
            );
            
            if (!$paymentMethodId) {
                throw new \RuntimeException("Failed to add payment method");
            }
            
            // If this is set as default, update other methods to non-default
            if (!empty($data['is_default']) && $data['is_default']) {
                DatabaseHelper::execute(
                    "UPDATE payment_methods SET is_default = 0 WHERE user_id = ? AND id != ?",
                    [$user->id, $paymentMethodId],
                    true // Using secure database
                );
            }
            
            // Get the newly created payment method
            $paymentMethod = DatabaseHelper::select(
                "SELECT id, type, card_brand, card_last4, expiry_date, is_default 
                 FROM payment_methods 
                 WHERE id = ?",
                [$paymentMethodId],
                true // Using secure database
            )[0];
            
            // Log in audit logs
            $this->auditService->logEvent(
                'payment_method_added',
                "User added a payment method",
                [
                    'user_id' => $user->id,
                    'payment_method_id' => $paymentMethodId,
                    'type' => $data['type']
                ],
                $user->id,
                null,
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Payment method added successfully',
                'data'    => ['payment_method' => $paymentMethod]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to add payment method'
            ], 500);
        }
    }
    
    /**
     * Get all payment methods for a user.
     */
    public function getUserPaymentMethods(): ResponseInterface
    {
        try {
            $user = TokenValidator::validateToken($this->request->getHeader('Authorization'));
            if (!$user) {
                return $this->jsonResponse([
                    'status' => 'error',
                    'message' => 'Unauthorized access'
                ], 401);
            }
            
            // Fetch payment methods using DatabaseHelper from secure database
            $paymentMethods = DatabaseHelper::select(
                "SELECT id, type, card_brand, card_last4, expiry_date, is_default 
                 FROM payment_methods 
                 WHERE user_id = ? AND deleted_at IS NULL",
                [$user->id],
                true // Using secure database
            );
            
            // Log in audit logs
            $this->auditService->logEvent(
                'payment_methods_viewed',
                "User viewed their payment methods",
                ['user_id' => $user->id],
                $user->id,
                null,
                'payment'
            );
            
            return $this->jsonResponse([
                'status'  => 'success',
                'message' => 'Payment methods retrieved successfully',
                'data'    => ['payment_methods' => $paymentMethods]
            ]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse([
                'status'  => 'error',
                'message' => 'Failed to retrieve payment methods'
            ], 500);
        }
    }
}
=== App/Controllers/Controller.php ===
<?php

namespace App\Controllers;

use Exception;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;
use Psr\Http\Message\ResponseInterface as Response;

/**
 * Base Controller - Provides shared methods for all controllers.
 */
class Controller
{
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(LoggerInterface $logger, ExceptionHandler $exceptionHandler)
    {
        $this->logger = $logger;
        $this->exceptionHandler = $exceptionHandler;
    }

    /**
     * ✅ Standard JSON Response
     */
    protected function jsonResponse(Response $response, $data, $status = 200)
    {
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json')->withStatus($status);
    }

    /**
     * ✅ Error Response
     */
    protected function errorResponse(Response $response, $message, $status = 400)
    {
        return $this->jsonResponse($response, ['error' => $message], $status);
    }

    /**
     * ✅ Handle Exceptions & Log Errors
     * This method is for backward compatibility, new controllers should use ExceptionHandler
     */
    protected function handleException(Exception $e, string $context = 'General Error'): void
    {
        if ($this->exceptionHandler) {
            $this->exceptionHandler->handleException($e);
        } else {
            // Legacy fallback behavior
            $this->logger->error("{$context}: " . $e->getMessage());
            $this->jsonResponse(['status' => 'error', 'message' => 'An error occurred.'], 500);
        }
    }

    /**
     * ✅ Input Validation Helper
     */
    protected function validateRequest(array $data, array $rules): array
    {
        $errors = [];

        foreach ($rules as $field => $rule) {
            $value = $data[$field] ?? null;

            if (strpos($rule, 'required') !== false && empty($value)) {
                $errors[$field] = "{$field} is required.";
            }

            if (strpos($rule, 'integer') !== false && !filter_var($value, FILTER_VALIDATE_INT)) {
                $errors[$field] = "{$field} must be an integer.";
            }

            if (strpos($rule, 'email') !== false && !filter_var($value, FILTER_VALIDATE_EMAIL)) {
                $errors[$field] = "{$field} must be a valid email.";
            }
        }

        if (!empty($errors)) {
            if ($this->exceptionHandler) {
                throw new \InvalidArgumentException(json_encode(['validation' => $errors]));
            } else {
                // Legacy fallback behavior
                $this->jsonResponse(['status' => 'error', 'message' => 'Validation failed', 'errors' => $errors], 422);
            }
        }

        return $data;
    }
}
=== App/Controllers/DocumentController.php ===
<?php

namespace App\Controllers;

use App\Services\DocumentService;
use App\Services\EncryptionService;
use App\Services\FileStorage;
use App\Services\Validator;
use App\Services\AuditService;
use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;
use App\Models\DocumentTemplate;

require_once BASE_PATH . '/App/Helpers/ViewHelper.php';

class DocumentController extends Controller
{
    private DocumentService $documentService;
    private Validator $validator;
    private AuditService $auditService;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;

    public function __construct(
        LoggerInterface $logger,
        DocumentService $documentService,
        Validator $validator,
        AuditService $auditService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->documentService = $documentService;
        $this->validator = $validator;
        $this->auditService = $auditService;
        $this->exceptionHandler = $exceptionHandler;
    }
    
    /**
     * Upload a document template.
     */
    public function uploadTemplate(array $data): array
    {
        try {
            $rules = [
                'name' => 'required|string|max:255',
                'file' => 'required|file|mimes:pdf,docx|max:10240', // Max 10MB
            ];

            if (!$this->validator->validate($data, $rules)) {
                return $this->jsonResponse('error', ['message' => 'Validation failed', 'errors' => $this->validator->errors()], 400);
            }

            // Store file using FileStorage service
            $filePath = FileStorage::store($data['file']);
            // Create a new template using Eloquent ORM
            $template = DocumentTemplate::create([
                'name' => $data['name'],
                'file_path' => $filePath,
            ]);
            
            // Log document creation using unified audit service
            $this->auditService->logEvent(
                'document_template_uploaded', 
                "Template uploaded successfully", 
                ['template_id' => $template->id, 'template_name' => $data['name']],
                $_SESSION['user_id'] ?? null,
                null,
                'document'
            );
            
            return $this->jsonResponse('success', ['message' => 'Template uploaded successfully', 'template_id' => $template->id], 201);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', ['message' => 'Failed to upload template'], 500);
        }
    }

    /**
     * Generate a contract for a booking.
     */
    public function generateContract(int $bookingId, int $userId): array
    {
        try {
            // Use a secure contract generation method ensuring encryption is applied
            $contractPath = $this->documentService->generateContractSecure($bookingId, $userId);
            
            // Log the contract generation using unified audit service
            $this->auditService->logEvent(
                'contract_generated',
                "Contract generated successfully",
                ['contract_type' => 'booking', 'booking_id' => $bookingId], 
                $userId,
                $bookingId,
                'document'
            );
            
            return $this->jsonResponse('success', ['message' => 'Contract generated successfully', 'contract_path' => $contractPath], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', ['message' => 'Failed to generate contract'], 500);
        }
    }

    /**
     * Upload and manage the Terms & Conditions document.
     */
    public function uploadTerms(array $data): array
    {
        try {
            $rules = [
                'file' => 'required|file|mimes:pdf|max:5120', // Max 5MB
            ];

            if (!$this->validator->validate($data, $rules)) {
                return $this->jsonResponse('error', ['message' => 'Validation failed', 'errors' => $this->validator->errors()], 400);
            }

            $path = $this->documentService->uploadTerms($data['file']);
            
            // Log using the unified audit service
            $this->auditService->logEvent(
                'terms_uploaded',
                "Terms and Conditions document uploaded",
                ['document_type' => 'terms_conditions', 'path' => $path],
                $_SESSION['user_id'] ?? null,
                null,
                'document'
            );

            return $this->jsonResponse('success', ['message' => 'T&C document uploaded successfully'], 201);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', ['message' => 'Failed to upload T&C document'], 500);
        }
    }

    /**
     * Generate an invoice for a booking.
     */
    public function generateInvoice(int $bookingId): array
    {
        try {
            $invoicePath = $this->documentService->generateInvoice($bookingId);
            
            // Log using the unified audit service
            $this->auditService->logEvent(
                'invoice_generated',
                "Invoice generated successfully",
                ['document_type' => 'invoice', 'booking_id' => $bookingId],
                $_SESSION['user_id'] ?? null,
                $bookingId,
                'document'
            );

            return $this->jsonResponse('success', ['message' => 'Invoice generated successfully', 'invoice_path' => $invoicePath], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', ['message' => 'Failed to generate invoice'], 500);
        }
    }

    /**
     * Delete a document (template or user-specific).
     */
    public function deleteDocument(int $documentId): array
    {
        try {
            $this->documentService->deleteDocument($documentId);
            
            // Log using the unified audit service
            $this->auditService->logEvent(
                'document_deleted',
                "Document deleted successfully",
                ['document_id' => $documentId],
                $_SESSION['user_id'] ?? null,
                null,
                'document'
            );

            return $this->jsonResponse('success', ['message' => 'Document deleted successfully'], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', ['message' => 'Failed to delete document'], 500);
        }
    }
}
=== App/Controllers/ReportController.php ===
<?php

namespace App\Controllers;

use App\Models\Booking;
use App\Models\Payment;
use App\Models\User;
use App\Services\AuditService;
use App\Helpers\ExceptionHandler;
use Psr\Log\LoggerInterface;

class ReportController extends Controller
{
    private ReportService $reportService;
    private NotificationService $notificationService;
    protected LoggerInterface $logger;
    protected ExceptionHandler $exceptionHandler;
    private AuditService $auditService;

    public function __construct(
        LoggerInterface $logger,
        ReportService $reportService,
        NotificationService $notificationService,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->reportService = $reportService;
        $this->notificationService = $notificationService;
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    /**
     * Admin Report Dashboard View
     */
    public function index()
    {
        try {
            // Log the dashboard access in audit logs
            $this->auditService->logEvent(
                'report_dashboard_accessed',
                'Admin report dashboard accessed',
                ['user_id' => $_SESSION['user_id'] ?? 'unknown'],
                $_SESSION['user_id'] ?? null,
                null,
                'report'
            );
            
            $data = ['view' => 'admin/reports'];
            http_response_code(200);
            echo json_encode(['status' => 'success', 'message' => 'Report dashboard loaded', 'data' => $data]);
            exit;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
        }
    }

    /**
     * Generate Report for Admin using Eloquent ORM.
     */
    public function generateReport()
    {
        try {
            // Replace Request validation with native PHP validation
            $validated = $_POST; // Assumes JSON-decoded input or form data

            $start      = $validated['date_range']['start'] ?? null;
            $end        = $validated['date_range']['end'] ?? null;
            $format     = $validated['format'] ?? null;
            $reportType = $validated['report_type'] ?? null;
            $userId     = $_SESSION['user_id'] ?? null;

            if (!$start || !$end || !$format || !$reportType) {
                http_response_code(400);
                echo json_encode(['status' => 'error', 'message' => 'Missing required parameters']);
                exit;
            }

            switch ($reportType) {
                case 'bookings':
                    $data = Booking::with(['user', 'vehicle'])
                        ->whereBetween('created_at', [$start, $end])
                        ->get()
                        ->toArray();
                    break;
                case 'payments':
                    $data = Payment::whereBetween('created_at', [$start, $end])
                        ->get()
                        ->toArray();
                    break;
                case 'users':
                    $data = User::whereBetween('created_at', [$start, $end])
                        ->get()
                        ->toArray();
                    break;
                default:
                    http_response_code(400);
                    echo json_encode(['status' => 'error', 'message' => 'Invalid report type']);
                    exit;
            }
            
            // Log report generation in audit logs
            $this->auditService->logEvent(
                'report_generated',
                "Admin generated {$reportType} report",
                [
                    'report_type' => $reportType,
                    'format' => $format,
                    'date_range' => ['start' => $start, 'end' => $end]
                ],
                $userId,
                null,
                'report'
            );

            $filename = "{$reportType}_report_" . date('YmdHis');
            if ($format === 'csv') {
                // Assuming Excel::download now returns file content in native PHP
                return Excel::download(new \App\Exports\ReportExport($data), $filename . ".csv");
            } elseif ($format === 'pdf') {
                $pdf = PDF::loadView('reports.template', ['data' => $data]);
                return $pdf->download($filename . ".pdf");
            } else {
                http_response_code(400);
                echo json_encode(['status' => 'error', 'message' => 'Unsupported format']);
                exit;
            }
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
        }
    }

    /**
     * User Report Dashboard View
     */
    public function userReports()
    {
        try {
            $data = ['view' => 'user/reports'];
            http_response_code(200);
            echo json_encode(['status' => 'success', 'message' => 'User report dashboard loaded', 'data' => $data]);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
        }
    }

    /**
     * Generate Report for a User using Eloquent ORM.
     */
    public function generateUserReport()
    {
        try {
            $validated = $_POST;
            $userId     = $validated['user_id'] ?? null;
            $start      = $validated['date_range']['start'] ?? null;
            $end        = $validated['date_range']['end'] ?? null;
            $format     = $validated['format'] ?? null;
            $reportType = $validated['report_type'] ?? null;

            if (!$userId || !$start || !$end || !$format || !$reportType) {
                http_response_code(400);
                echo json_encode(['status' => 'error', 'message' => 'Missing required parameters']);
                exit;
            }

            switch ($reportType) {
                case 'bookings':
                    $data = Booking::with(['user', 'vehicle'])
                        ->where('user_reference', $userId)
                        ->whereBetween('created_at', [$start, $end])
                        ->get()
                        ->toArray();
                    break;
                case 'payments':
                    $data = Payment::where('user_id', $userId)
                        ->whereBetween('created_at', [$start, $end])
                        ->get()
                        ->toArray();
                    break;
                default:
                    http_response_code(400);
                    echo json_encode(['status' => 'error', 'message' => 'Invalid report type']);
                    exit;
            }

            $filename = "user_{$userId}_{$reportType}_report_" . date('YmdHis');
            if ($format === 'csv') {
                return Excel::download(new \App\Exports\ReportExport($data), $filename . ".csv");
            } elseif ($format === 'pdf') {
                $pdf = PDF::loadView('reports.template', ['data' => $data]);
                return $pdf->download($filename . ".pdf");
            } else {
                http_response_code(400);
                echo json_encode(['status' => 'error', 'message' => 'Unsupported format']);
                exit;
            }
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
        }
    }

    /**
     * Download a Report
     */
    public function downloadReport(string $filePath): void
    {
        try {
            if (!file_exists($filePath)) {
                http_response_code(404);
                echo json_encode(['status' => 'error', 'message' => 'Report not found', 'data' => []]);
                return;
            }

            header('Content-Description: File Transfer');
            header('Content-Type: application/octet-stream');
            header('Content-Disposition: attachment; filename=' . basename($filePath));
            header('Expires: 0');
            header('Cache-Control: must-revalidate');
            header('Pragma: public');
            header('Content-Length: ' . filesize($filePath));
            readfile($filePath);
            exit;
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
        }
    }
}
=== App/Controllers/ApiController.php ===
<?php

namespace App\Controllers;

use App\Helpers\ExceptionHandler;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Log\LoggerInterface;
use App\Services\AuditService;

/**
 * Base API Controller
 * 
 * Provides common functionality for all API controllers including
 * standardized JSON responses, error handling, and shared utilities.
 */
class ApiController extends Controller
{
    protected ResponseFactoryInterface $responseFactory;
    protected ExceptionHandler $exceptionHandler;
    protected AuditService $auditService;
    
    /**
     * Constructor
     */
    public function __construct(
        LoggerInterface $logger,
        ResponseFactoryInterface $responseFactory,
        ExceptionHandler $exceptionHandler,
        AuditService $auditService
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->responseFactory = $responseFactory;
        $this->exceptionHandler = $exceptionHandler;
        $this->auditService = $auditService;
    }

    /**
     * Create standardized PSR-7 JSON response
     */
    protected function jsonResponse(array $data, int $status = 200): ResponseInterface
    {
        $response = $this->responseFactory->createResponse($status);
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    /**
     * Create a success response
     */
    protected function success($message, $data = [], int $status = 200): ResponseInterface
    {
        return $this->jsonResponse([
            'status' => 'success',
            'message' => $message,
            'data' => $data
        ], $status);
    }

    /**
     * Create an error response
     */
    protected function error($message, $errors = [], int $status = 400): ResponseInterface
    {
        return $this->jsonResponse([
            'status' => 'error',
            'message' => $message,
            'errors' => $errors
        ], $status);
    }

    /**
     * Safe handling of exceptions in API controllers
     */
    protected function safeExecute(callable $action): ResponseInterface
    {
        try {
            return $action();
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // This line won't be reached if the exception handler exits
            return $this->error('An unexpected error occurred', [], 500);
        }
    }

    /**
     * Log audit event with proper context
     */
    protected function logAuditEvent(
        string $eventType,
        string $message,
        array $context = [],
        ?int $userId = null,
        ?int $resourceId = null,
        string $category = 'api'
    ): void {
        $this->auditService->logEvent(
            $eventType,
            $message,
            $context,
            $userId,
            $resourceId,
            $category
        );
    }
}
=== App/Controllers/AuditController.php ===
<?php

namespace App\Controllers;

use App\Services\AuditService;
use Psr\Log\LoggerInterface;
use App\Helpers\ExceptionHandler;

/**
 * AuditController - Handles viewing and retrieving audit logs.
 */
class AuditController extends Controller
{
    protected LoggerInterface $logger;
    private AuditService $auditService;
    protected ExceptionHandler $exceptionHandler;
    
    /**
     * Constructor with dependency injection
     */
    public function __construct(
        LoggerInterface $logger, 
        AuditService $auditService,
        ExceptionHandler $exceptionHandler
    ) {
        parent::__construct($logger, $exceptionHandler);
        $this->auditService = $auditService;
        $this->exceptionHandler = $exceptionHandler;
    }
    
    /**
     * ✅ Get audit logs data for admin dashboard
     */
    public function index()
    {
        try {
            // Check if user has admin role
            if (!$this->hasAdminAccess()) {
                return $this->jsonResponse('error', 'Admin access required', 403);
            }
            
            // Process filters from request
            $filters = $this->processFilters($_POST);
            
            // Get logs using the audit service
            $logs = $this->auditService->getLogs($filters);
            
            return $this->jsonResponse('success', ['logs' => $logs], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', 'Failed to retrieve audit logs', 500);
        }
    }

    /**
     * ✅ API Endpoint: Fetch logs based on filters.
     */
    public function fetchLogs()
    {
        try {
            // Check if user has admin role
            if (!$this->hasAdminAccess()) {
                return $this->jsonResponse('error', 'Admin access required', 403);
            }
            
            // Process filters from request
            $filters = $this->processFilters($_POST);
            
            // Get logs using the audit service
            $logs = $this->auditService->getLogs($filters);
            
            return $this->jsonResponse('success', ['logs' => $logs], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', 'Failed to fetch logs', 500);
        }
    }
    
    /**
     * API Endpoint: Get log details by ID
     */
    public function getLog($id)
    {
        try {
            // Check if user has admin role
            if (!$this->hasAdminAccess()) {
                return $this->jsonResponse('error', 'Admin access required', 403);
            }
            
            $log = $this->auditService->getLogById((int)$id);
            
            return $this->jsonResponse('success', ['log' => $log], 200);
        } catch (\Exception $e) {
            $this->exceptionHandler->handleException($e);
            // The following won't execute if handleException exits as expected
            return $this->jsonResponse('error', 'Failed to retrieve log', 500);
        }
    }
    
    /**
     * Process and validate incoming filters
     */
    private function processFilters(array $rawFilters): array
    {
        $filters = [];
        
        // Category filter (unified log type)
        if (!empty($rawFilters['category'])) {
            $filters['category'] = $rawFilters['category'];
        }
        
        // Action filter (for backward compatibility)
        if (!empty($rawFilters['action'])) {
            $filters['action'] = $rawFilters['action'];
        }
        
        // User ID filter
        if (!empty($rawFilters['user_id'])) {
            $filters['user_id'] = (int)$rawFilters['user_id'];
        }
        
        // Booking ID filter
        if (!empty($rawFilters['booking_id'])) {
            $filters['booking_id'] = (int)$rawFilters['booking_id'];
        }
        
        // Date range filters
        if (!empty($rawFilters['start_date'])) {
            $filters['start_date'] = $rawFilters['start_date'];
        }
        
        if (!empty($rawFilters['end_date'])) {
            $filters['end_date'] = $rawFilters['end_date'];
        }
        
        return $filters;
    }
    
    /**
     * Check if current user has admin access
     */
    private function hasAdminAccess(): bool
    {
        // Replace with your actual authentication logic
        return isset($_SESSION['user_role']) && $_SESSION['user_role'] === 'admin';
    }
}
